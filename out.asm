
build2/bin/ns_app.elf:	file format elf32-littlearm

Disassembly of section .privileged_functions:

08055200 <xTaskCreateRestricted>:
;     {
 8055200: f848 eb2c    	str	lr, [r8], #44
 8055204: eb08 0809    	add.w	r8, r8, r9
 8055208: b480         	push	{r7}
 805520a: 466f         	mov	r7, sp
 805520c: b084         	sub	sp, #0x10
 805520e: 9003         	str	r0, [sp, #0xc]
 8055210: 9102         	str	r1, [sp, #0x8]
;         pxNewTCB = prvCreateRestrictedTask( pxTaskDefinition, pxCreatedTask );
 8055212: 9803         	ldr	r0, [sp, #0xc]
 8055214: 9902         	ldr	r1, [sp, #0x8]
 8055216: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8055244 <xTaskCreateRestricted+0x44>
 8055218: 4790         	blx	r2
 805521a: 9001         	str	r0, [sp, #0x4]
;         if( pxNewTCB != NULL )
 805521c: 9801         	ldr	r0, [sp, #0x4]
 805521e: b130         	cbz	r0, 0x805522e <xTaskCreateRestricted+0x2e> @ imm = #0xc
 8055220: e7ff         	b	0x8055222 <xTaskCreateRestricted+0x22> @ imm = #-0x2
;             prvAddNewTaskToReadyList( pxNewTCB );
 8055222: 9801         	ldr	r0, [sp, #0x4]
 8055224: 4908         	ldr	r1, [pc, #0x20]         @ 0x8055248 <xTaskCreateRestricted+0x48>
 8055226: 4788         	blx	r1
 8055228: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
 805522a: 9000         	str	r0, [sp]
;         }
 805522c: e003         	b	0x8055236 <xTaskCreateRestricted+0x36> @ imm = #0x6
 805522e: f04f 30ff    	mov.w	r0, #0xffffffff
;             xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8055232: 9000         	str	r0, [sp]
 8055234: e7ff         	b	0x8055236 <xTaskCreateRestricted+0x36> @ imm = #-0x2
;         return xReturn;
 8055236: 9800         	ldr	r0, [sp]
 8055238: b004         	add	sp, #0x10
 805523a: bc80         	pop	{r7}
 805523c: eba8 0809    	sub.w	r8, r8, r9
 8055240: f858 fd2c    	ldr	pc, [r8, #-44]!

08055244 <$d.1>:
 8055244: 4d 52 05 08  	.word	0x0805524d
 8055248: 09 53 05 08  	.word	0x08055309

0805524c <prvCreateRestrictedTask>:
;     {
 805524c: f848 eb1c    	str	lr, [r8], #28
 8055250: eb08 0809    	add.w	r8, r8, r9
 8055254: b4f0         	push	{r4, r5, r6, r7}
 8055256: af03         	add	r7, sp, #0xc
 8055258: f84d bd04    	str	r11, [sp, #-4]!
 805525c: b088         	sub	sp, #0x20
 805525e: 9007         	str	r0, [sp, #0x1c]
 8055260: 9106         	str	r1, [sp, #0x18]
;         configASSERT( pxTaskDefinition->puxStackBuffer );
 8055262: 9807         	ldr	r0, [sp, #0x1c]
 8055264: 6940         	ldr	r0, [r0, #0x14]
 8055266: b920         	cbnz	r0, 0x8055272 <prvCreateRestrictedTask+0x26> @ imm = #0x8
 8055268: e7ff         	b	0x805526a <prvCreateRestrictedTask+0x1e> @ imm = #-0x2
 805526a: 4826         	ldr	r0, [pc, #0x98]         @ 0x8055304 <prvCreateRestrictedTask+0xb8>
 805526c: 4780         	blx	r0
 805526e: e7ff         	b	0x8055270 <prvCreateRestrictedTask+0x24> @ imm = #-0x2
 8055270: e7fe         	b	0x8055270 <prvCreateRestrictedTask+0x24> @ imm = #-0x4
;         if( pxTaskDefinition->puxStackBuffer != NULL )
 8055272: 9807         	ldr	r0, [sp, #0x1c]
 8055274: 6940         	ldr	r0, [r0, #0x14]
 8055276: b398         	cbz	r0, 0x80552e0 <prvCreateRestrictedTask+0x94> @ imm = #0x66
 8055278: e7ff         	b	0x805527a <prvCreateRestrictedTask+0x2e> @ imm = #-0x2
;             pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 805527a: 491f         	ldr	r1, [pc, #0x7c]         @ 0x80552f8 <prvCreateRestrictedTask+0xac>
 805527c: 20d8         	movs	r0, #0xd8
 805527e: 4788         	blx	r1
 8055280: 9005         	str	r0, [sp, #0x14]
;             if( pxNewTCB != NULL )
 8055282: 9805         	ldr	r0, [sp, #0x14]
 8055284: b358         	cbz	r0, 0x80552de <prvCreateRestrictedTask+0x92> @ imm = #0x56
 8055286: e7ff         	b	0x8055288 <prvCreateRestrictedTask+0x3c> @ imm = #-0x2
;                 ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 8055288: 9805         	ldr	r0, [sp, #0x14]
 805528a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80552fc <prvCreateRestrictedTask+0xb0>
 805528c: 2100         	movs	r1, #0x0
 805528e: 22d8         	movs	r2, #0xd8
 8055290: 4798         	blx	r3
;                 pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 8055292: 9807         	ldr	r0, [sp, #0x1c]
 8055294: 6940         	ldr	r0, [r0, #0x14]
 8055296: 9905         	ldr	r1, [sp, #0x14]
 8055298: f8c1 00ac    	str.w	r0, [r1, #0xac]
;                     pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 805529c: 9905         	ldr	r1, [sp, #0x14]
 805529e: 2001         	movs	r0, #0x1
 80552a0: f881 00d5    	strb.w	r0, [r1, #0xd5]
;                 prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 80552a4: f8dd e01c    	ldr.w	lr, [sp, #0x1c]
;                                       ( uint32_t ) pxTaskDefinition->usStackDepth,
 80552a8: f8be 2008    	ldrh.w	r2, [lr, #0x8]
;                 prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 80552ac: f8de 0000    	ldr.w	r0, [lr]
;                                       pxTaskDefinition->pcName,
 80552b0: f8de 1004    	ldr.w	r1, [lr, #0x4]
;                                       pxTaskDefinition->pvParameters,
 80552b4: f8de 300c    	ldr.w	r3, [lr, #0xc]
;                                       pxTaskDefinition->uxPriority,
 80552b8: f8de c010    	ldr.w	r12, [lr, #0x10]
;                                       pxCreatedTask, pxNewTCB,
 80552bc: 9c06         	ldr	r4, [sp, #0x18]
 80552be: 9d05         	ldr	r5, [sp, #0x14]
;                                       pxTaskDefinition->xRegions );
 80552c0: f10e 0618    	add.w	r6, lr, #0x18
;                 prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 80552c4: 46ee         	mov	lr, sp
 80552c6: f8ce 600c    	str.w	r6, [lr, #0xc]
 80552ca: f8ce 5008    	str.w	r5, [lr, #0x8]
 80552ce: f8ce 4004    	str.w	r4, [lr, #0x4]
 80552d2: f8ce c000    	str.w	r12, [lr]
 80552d6: f8df c028    	ldr.w	r12, [pc, #0x28]        @ 0x8055300 <prvCreateRestrictedTask+0xb4>
 80552da: 47e0         	blx	r12
;             }
 80552dc: e7ff         	b	0x80552de <prvCreateRestrictedTask+0x92> @ imm = #-0x2
;         }
 80552de: e002         	b	0x80552e6 <prvCreateRestrictedTask+0x9a> @ imm = #0x4
 80552e0: 2000         	movs	r0, #0x0
;             pxNewTCB = NULL;
 80552e2: 9005         	str	r0, [sp, #0x14]
 80552e4: e7ff         	b	0x80552e6 <prvCreateRestrictedTask+0x9a> @ imm = #-0x2
;         return pxNewTCB;
 80552e6: 9805         	ldr	r0, [sp, #0x14]
 80552e8: b008         	add	sp, #0x20
 80552ea: f85d bb04    	ldr	r11, [sp], #4
 80552ee: bcf0         	pop	{r4, r5, r6, r7}
 80552f0: eba8 0809    	sub.w	r8, r8, r9
 80552f4: f858 fd1c    	ldr	pc, [r8, #-28]!

080552f8 <$d.3>:
 80552f8: cd 96 05 08  	.word	0x080596cd
 80552fc: ad f9 05 08  	.word	0x0805f9ad
 8055300: 91 87 05 08  	.word	0x08058791
 8055304: 15 d7 05 08  	.word	0x0805d715

08055308 <prvAddNewTaskToReadyList>:
;     {
 8055308: f848 eb3c    	str	lr, [r8], #60
 805530c: eb08 0809    	add.w	r8, r8, r9
 8055310: b480         	push	{r7}
 8055312: 466f         	mov	r7, sp
 8055314: b082         	sub	sp, #0x8
 8055316: 9001         	str	r0, [sp, #0x4]
;         taskENTER_CRITICAL();
 8055318: 485e         	ldr	r0, [pc, #0x178]        @ 0x8055494 <prvAddNewTaskToReadyList+0x18c>
 805531a: 4780         	blx	r0
;             uxCurrentNumberOfTasks++;
 805531c: f240 1120    	movw	r1, #0x120
 8055320: f2c2 0100    	movt	r1, #0x2000
 8055324: 6808         	ldr	r0, [r1]
 8055326: 3001         	adds	r0, #0x1
 8055328: 6008         	str	r0, [r1]
;             if( pxCurrentTCB == NULL )
 805532a: f240 1000    	movw	r0, #0x100
 805532e: f2c2 0000    	movt	r0, #0x2000
 8055332: 6800         	ldr	r0, [r0]
 8055334: b998         	cbnz	r0, 0x805535e <prvAddNewTaskToReadyList+0x56> @ imm = #0x26
 8055336: e7ff         	b	0x8055338 <prvAddNewTaskToReadyList+0x30> @ imm = #-0x2
;                 pxCurrentTCB = pxNewTCB;
 8055338: 9801         	ldr	r0, [sp, #0x4]
 805533a: f240 1100    	movw	r1, #0x100
 805533e: f2c2 0100    	movt	r1, #0x2000
 8055342: 6008         	str	r0, [r1]
;                 if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8055344: f240 1020    	movw	r0, #0x120
 8055348: f2c2 0000    	movt	r0, #0x2000
 805534c: 6800         	ldr	r0, [r0]
 805534e: 2801         	cmp	r0, #0x1
 8055350: d103         	bne	0x805535a <prvAddNewTaskToReadyList+0x52> @ imm = #0x6
 8055352: e7ff         	b	0x8055354 <prvAddNewTaskToReadyList+0x4c> @ imm = #-0x2
;                     prvInitialiseTaskLists();
 8055354: 4850         	ldr	r0, [pc, #0x140]        @ 0x8055498 <prvAddNewTaskToReadyList+0x190>
 8055356: 4780         	blx	r0
;                 }
 8055358: e000         	b	0x805535c <prvAddNewTaskToReadyList+0x54> @ imm = #0x0
 805535a: e7ff         	b	0x805535c <prvAddNewTaskToReadyList+0x54> @ imm = #-0x2
;             }
 805535c: e01e         	b	0x805539c <prvAddNewTaskToReadyList+0x94> @ imm = #0x3c
;                 if( xSchedulerRunning == pdFALSE )
 805535e: f240 1024    	movw	r0, #0x124
 8055362: f2c2 0000    	movt	r0, #0x2000
 8055366: 6800         	ldr	r0, [r0]
 8055368: b9b0         	cbnz	r0, 0x8055398 <prvAddNewTaskToReadyList+0x90> @ imm = #0x2c
 805536a: e7ff         	b	0x805536c <prvAddNewTaskToReadyList+0x64> @ imm = #-0x2
;                     if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 805536c: f240 1000    	movw	r0, #0x100
 8055370: f2c2 0000    	movt	r0, #0x2000
 8055374: 6800         	ldr	r0, [r0]
 8055376: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805537a: 9901         	ldr	r1, [sp, #0x4]
 805537c: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 8055380: 4288         	cmp	r0, r1
 8055382: d807         	bhi	0x8055394 <prvAddNewTaskToReadyList+0x8c> @ imm = #0xe
 8055384: e7ff         	b	0x8055386 <prvAddNewTaskToReadyList+0x7e> @ imm = #-0x2
;                         pxCurrentTCB = pxNewTCB;
 8055386: 9801         	ldr	r0, [sp, #0x4]
 8055388: f240 1100    	movw	r1, #0x100
 805538c: f2c2 0100    	movt	r1, #0x2000
 8055390: 6008         	str	r0, [r1]
;                     }
 8055392: e000         	b	0x8055396 <prvAddNewTaskToReadyList+0x8e> @ imm = #0x0
 8055394: e7ff         	b	0x8055396 <prvAddNewTaskToReadyList+0x8e> @ imm = #-0x2
;                 }
 8055396: e000         	b	0x805539a <prvAddNewTaskToReadyList+0x92> @ imm = #0x0
 8055398: e7ff         	b	0x805539a <prvAddNewTaskToReadyList+0x92> @ imm = #-0x2
 805539a: e7ff         	b	0x805539c <prvAddNewTaskToReadyList+0x94> @ imm = #-0x2
;             uxTaskNumber++;
 805539c: f240 1004    	movw	r0, #0x104
 80553a0: f2c2 0000    	movt	r0, #0x2000
 80553a4: 6801         	ldr	r1, [r0]
 80553a6: 3101         	adds	r1, #0x1
 80553a8: 6001         	str	r1, [r0]
;                 pxNewTCB->uxTCBNumber = uxTaskNumber;
 80553aa: 6800         	ldr	r0, [r0]
 80553ac: 9901         	ldr	r1, [sp, #0x4]
 80553ae: f8c1 00c0    	str.w	r0, [r1, #0xc0]
;             prvAddTaskToReadyList( pxNewTCB );
 80553b2: e7ff         	b	0x80553b4 <prvAddNewTaskToReadyList+0xac> @ imm = #-0x2
 80553b4: e7ff         	b	0x80553b6 <prvAddNewTaskToReadyList+0xae> @ imm = #-0x2
 80553b6: 9801         	ldr	r0, [sp, #0x4]
 80553b8: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80553bc: f240 21a0    	movw	r1, #0x2a0
 80553c0: f2c2 0100    	movt	r1, #0x2000
 80553c4: 6809         	ldr	r1, [r1]
 80553c6: 4288         	cmp	r0, r1
 80553c8: d909         	bls	0x80553de <prvAddNewTaskToReadyList+0xd6> @ imm = #0x12
 80553ca: e7ff         	b	0x80553cc <prvAddNewTaskToReadyList+0xc4> @ imm = #-0x2
 80553cc: 9801         	ldr	r0, [sp, #0x4]
 80553ce: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80553d2: f240 21a0    	movw	r1, #0x2a0
 80553d6: f2c2 0100    	movt	r1, #0x2000
 80553da: 6008         	str	r0, [r1]
 80553dc: e7ff         	b	0x80553de <prvAddNewTaskToReadyList+0xd6> @ imm = #-0x2
 80553de: e7ff         	b	0x80553e0 <prvAddNewTaskToReadyList+0xd8> @ imm = #-0x2
 80553e0: e7ff         	b	0x80553e2 <prvAddNewTaskToReadyList+0xda> @ imm = #-0x2
 80553e2: 9801         	ldr	r0, [sp, #0x4]
 80553e4: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80553e8: eb00 0080    	add.w	r0, r0, r0, lsl #2
 80553ec: f240 1160    	movw	r1, #0x160
 80553f0: f2c2 0100    	movt	r1, #0x2000
 80553f4: eb01 0080    	add.w	r0, r1, r0, lsl #2
 80553f8: 6840         	ldr	r0, [r0, #0x4]
 80553fa: 9000         	str	r0, [sp]
 80553fc: 9800         	ldr	r0, [sp]
 80553fe: 9a01         	ldr	r2, [sp, #0x4]
 8055400: f8c2 0084    	str.w	r0, [r2, #0x84]
 8055404: 9800         	ldr	r0, [sp]
 8055406: 6880         	ldr	r0, [r0, #0x8]
 8055408: 9a01         	ldr	r2, [sp, #0x4]
 805540a: f8c2 0088    	str.w	r0, [r2, #0x88]
 805540e: 9801         	ldr	r0, [sp, #0x4]
 8055410: 3080         	adds	r0, #0x80
 8055412: 9a00         	ldr	r2, [sp]
 8055414: 6892         	ldr	r2, [r2, #0x8]
 8055416: 6050         	str	r0, [r2, #0x4]
 8055418: 9801         	ldr	r0, [sp, #0x4]
 805541a: 3080         	adds	r0, #0x80
 805541c: 9a00         	ldr	r2, [sp]
 805541e: 6090         	str	r0, [r2, #0x8]
 8055420: 9a01         	ldr	r2, [sp, #0x4]
 8055422: f8d2 00a8    	ldr.w	r0, [r2, #0xa8]
 8055426: eb00 0080    	add.w	r0, r0, r0, lsl #2
 805542a: eb01 0080    	add.w	r0, r1, r0, lsl #2
 805542e: f8c2 0090    	str.w	r0, [r2, #0x90]
 8055432: 9801         	ldr	r0, [sp, #0x4]
 8055434: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8055438: eb00 0280    	add.w	r2, r0, r0, lsl #2
 805543c: f851 0022    	ldr.w	r0, [r1, r2, lsl #2]
 8055440: 3001         	adds	r0, #0x1
 8055442: f841 0022    	str.w	r0, [r1, r2, lsl #2]
 8055446: e7ff         	b	0x8055448 <prvAddNewTaskToReadyList+0x140> @ imm = #-0x2
 8055448: e7ff         	b	0x805544a <prvAddNewTaskToReadyList+0x142> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 805544a: 4814         	ldr	r0, [pc, #0x50]         @ 0x805549c <prvAddNewTaskToReadyList+0x194>
 805544c: 4780         	blx	r0
;         if( xSchedulerRunning != pdFALSE )
 805544e: f240 1024    	movw	r0, #0x124
 8055452: f2c2 0000    	movt	r0, #0x2000
 8055456: 6800         	ldr	r0, [r0]
 8055458: b1a0         	cbz	r0, 0x8055484 <prvAddNewTaskToReadyList+0x17c> @ imm = #0x28
 805545a: e7ff         	b	0x805545c <prvAddNewTaskToReadyList+0x154> @ imm = #-0x2
;             taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
 805545c: e7ff         	b	0x805545e <prvAddNewTaskToReadyList+0x156> @ imm = #-0x2
 805545e: f240 1000    	movw	r0, #0x100
 8055462: f2c2 0000    	movt	r0, #0x2000
 8055466: 6800         	ldr	r0, [r0]
 8055468: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805546c: 9901         	ldr	r1, [sp, #0x4]
 805546e: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 8055472: 4288         	cmp	r0, r1
 8055474: d203         	bhs	0x805547e <prvAddNewTaskToReadyList+0x176> @ imm = #0x6
 8055476: e7ff         	b	0x8055478 <prvAddNewTaskToReadyList+0x170> @ imm = #-0x2
 8055478: 4809         	ldr	r0, [pc, #0x24]         @ 0x80554a0 <prvAddNewTaskToReadyList+0x198>
 805547a: 4780         	blx	r0
 805547c: e000         	b	0x8055480 <prvAddNewTaskToReadyList+0x178> @ imm = #0x0
 805547e: e7ff         	b	0x8055480 <prvAddNewTaskToReadyList+0x178> @ imm = #-0x2
;             taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
 8055480: e7ff         	b	0x8055482 <prvAddNewTaskToReadyList+0x17a> @ imm = #-0x2
;         }
 8055482: e000         	b	0x8055486 <prvAddNewTaskToReadyList+0x17e> @ imm = #0x0
 8055484: e7ff         	b	0x8055486 <prvAddNewTaskToReadyList+0x17e> @ imm = #-0x2
;     }
 8055486: b002         	add	sp, #0x8
 8055488: bc80         	pop	{r7}
 805548a: eba8 0809    	sub.w	r8, r8, r9
 805548e: f858 fd3c    	ldr	pc, [r8, #-60]!
 8055492: bf00         	nop

08055494 <$d.5>:
 8055494: 49 cd 05 08  	.word	0x0805cd49
 8055498: 21 89 05 08  	.word	0x08058921
 805549c: 7d cd 05 08  	.word	0x0805cd7d
 80554a0: 2f cd 05 08  	.word	0x0805cd2f

080554a4 <xTaskCreate>:
;     {
 80554a4: f848 eb78    	str	lr, [r8], #120
 80554a8: eb08 0809    	add.w	r8, r8, r9
 80554ac: b4d0         	push	{r4, r6, r7}
 80554ae: af02         	add	r7, sp, #0x8
 80554b0: b088         	sub	sp, #0x20
 80554b2: f8d7 c00c    	ldr.w	r12, [r7, #0xc]
 80554b6: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 80554ba: 9007         	str	r0, [sp, #0x1c]
 80554bc: 9106         	str	r1, [sp, #0x18]
 80554be: f827 2c12    	strh	r2, [r7, #-18]
 80554c2: 9304         	str	r3, [sp, #0x10]
;         pxNewTCB = prvCreateTask( pxTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pxCreatedTask );
 80554c4: 9807         	ldr	r0, [sp, #0x1c]
 80554c6: 9906         	ldr	r1, [sp, #0x18]
 80554c8: f837 2c12    	ldrh	r2, [r7, #-18]
 80554cc: 9b04         	ldr	r3, [sp, #0x10]
 80554ce: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 80554d2: 68fc         	ldr	r4, [r7, #0xc]
 80554d4: 46ee         	mov	lr, sp
 80554d6: f8ce 4004    	str.w	r4, [lr, #0x4]
 80554da: f8ce c000    	str.w	r12, [lr]
 80554de: f8df c030    	ldr.w	r12, [pc, #0x30]        @ 0x8055510 <xTaskCreate+0x6c>
 80554e2: 47e0         	blx	r12
 80554e4: 9003         	str	r0, [sp, #0xc]
;         if( pxNewTCB != NULL )
 80554e6: 9803         	ldr	r0, [sp, #0xc]
 80554e8: b130         	cbz	r0, 0x80554f8 <xTaskCreate+0x54> @ imm = #0xc
 80554ea: e7ff         	b	0x80554ec <xTaskCreate+0x48> @ imm = #-0x2
;             prvAddNewTaskToReadyList( pxNewTCB );
 80554ec: 9803         	ldr	r0, [sp, #0xc]
 80554ee: 4909         	ldr	r1, [pc, #0x24]         @ 0x8055514 <xTaskCreate+0x70>
 80554f0: 4788         	blx	r1
 80554f2: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
 80554f4: 9002         	str	r0, [sp, #0x8]
;         }
 80554f6: e003         	b	0x8055500 <xTaskCreate+0x5c> @ imm = #0x6
 80554f8: f04f 30ff    	mov.w	r0, #0xffffffff
;             xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80554fc: 9002         	str	r0, [sp, #0x8]
 80554fe: e7ff         	b	0x8055500 <xTaskCreate+0x5c> @ imm = #-0x2
;         return xReturn;
 8055500: 9802         	ldr	r0, [sp, #0x8]
 8055502: b008         	add	sp, #0x20
 8055504: bcd0         	pop	{r4, r6, r7}
 8055506: eba8 0809    	sub.w	r8, r8, r9
 805550a: f858 fd78    	ldr	pc, [r8, #-120]!
 805550e: bf00         	nop

08055510 <$d.7>:
 8055510: 19 55 05 08  	.word	0x08055519
 8055514: 09 53 05 08  	.word	0x08055309

08055518 <prvCreateTask>:
;     {
 8055518: f848 eb48    	str	lr, [r8], #72
 805551c: eb08 0809    	add.w	r8, r8, r9
 8055520: b4f0         	push	{r4, r5, r6, r7}
 8055522: af03         	add	r7, sp, #0xc
 8055524: f84d bd04    	str	r11, [sp, #-4]!
 8055528: b08a         	sub	sp, #0x28
 805552a: f8d7 c00c    	ldr.w	r12, [r7, #0xc]
 805552e: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 8055532: 9009         	str	r0, [sp, #0x24]
 8055534: 9108         	str	r1, [sp, #0x20]
 8055536: f827 2c1a    	strh	r2, [r7, #-26]
 805553a: 9306         	str	r3, [sp, #0x18]
;             pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 805553c: f837 0c1a    	ldrh	r0, [r7, #-26]
 8055540: 0080         	lsls	r0, r0, #0x2
 8055542: 4922         	ldr	r1, [pc, #0x88]         @ 0x80555cc <prvCreateTask+0xb4>
 8055544: 4788         	blx	r1
 8055546: 9004         	str	r0, [sp, #0x10]
;             if( pxStack != NULL )
 8055548: 9804         	ldr	r0, [sp, #0x10]
 805554a: b1b0         	cbz	r0, 0x805557a <prvCreateTask+0x62> @ imm = #0x2c
 805554c: e7ff         	b	0x805554e <prvCreateTask+0x36> @ imm = #-0x2
;                 pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 805554e: 4920         	ldr	r1, [pc, #0x80]         @ 0x80555d0 <prvCreateTask+0xb8>
 8055550: 20d8         	movs	r0, #0xd8
 8055552: 4788         	blx	r1
 8055554: 9005         	str	r0, [sp, #0x14]
;                 if( pxNewTCB != NULL )
 8055556: 9805         	ldr	r0, [sp, #0x14]
 8055558: b150         	cbz	r0, 0x8055570 <prvCreateTask+0x58> @ imm = #0x14
 805555a: e7ff         	b	0x805555c <prvCreateTask+0x44> @ imm = #-0x2
;                     ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 805555c: 9805         	ldr	r0, [sp, #0x14]
 805555e: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x80555d8 <prvCreateTask+0xc0>
 8055560: 2100         	movs	r1, #0x0
 8055562: 22d8         	movs	r2, #0xd8
 8055564: 4798         	blx	r3
;                     pxNewTCB->pxStack = pxStack;
 8055566: 9804         	ldr	r0, [sp, #0x10]
 8055568: 9905         	ldr	r1, [sp, #0x14]
 805556a: f8c1 00ac    	str.w	r0, [r1, #0xac]
;                 }
 805556e: e003         	b	0x8055578 <prvCreateTask+0x60> @ imm = #0x6
;                     vPortFreeStack( pxStack );
 8055570: 9804         	ldr	r0, [sp, #0x10]
 8055572: 4918         	ldr	r1, [pc, #0x60]         @ 0x80555d4 <prvCreateTask+0xbc>
 8055574: 4788         	blx	r1
 8055576: e7ff         	b	0x8055578 <prvCreateTask+0x60> @ imm = #-0x2
;             }
 8055578: e002         	b	0x8055580 <prvCreateTask+0x68> @ imm = #0x4
 805557a: 2000         	movs	r0, #0x0
;                 pxNewTCB = NULL;
 805557c: 9005         	str	r0, [sp, #0x14]
 805557e: e7ff         	b	0x8055580 <prvCreateTask+0x68> @ imm = #-0x2
;         if( pxNewTCB != NULL )
 8055580: 9805         	ldr	r0, [sp, #0x14]
 8055582: b1d0         	cbz	r0, 0x80555ba <prvCreateTask+0xa2> @ imm = #0x34
 8055584: e7ff         	b	0x8055586 <prvCreateTask+0x6e> @ imm = #-0x2
;                 pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8055586: 9805         	ldr	r0, [sp, #0x14]
 8055588: 2600         	movs	r6, #0x0
 805558a: f880 60d5    	strb.w	r6, [r0, #0xd5]
;             prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 805558e: 9809         	ldr	r0, [sp, #0x24]
 8055590: 9908         	ldr	r1, [sp, #0x20]
 8055592: f837 2c1a    	ldrh	r2, [r7, #-26]
 8055596: 9b06         	ldr	r3, [sp, #0x18]
 8055598: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805559c: 68fc         	ldr	r4, [r7, #0xc]
 805559e: 9d05         	ldr	r5, [sp, #0x14]
 80555a0: 46ee         	mov	lr, sp
 80555a2: f8ce 600c    	str.w	r6, [lr, #0xc]
 80555a6: f8ce 5008    	str.w	r5, [lr, #0x8]
 80555aa: f8ce 4004    	str.w	r4, [lr, #0x4]
 80555ae: f8ce c000    	str.w	r12, [lr]
 80555b2: f8df c028    	ldr.w	r12, [pc, #0x28]        @ 0x80555dc <prvCreateTask+0xc4>
 80555b6: 47e0         	blx	r12
;         }
 80555b8: e7ff         	b	0x80555ba <prvCreateTask+0xa2> @ imm = #-0x2
;         return pxNewTCB;
 80555ba: 9805         	ldr	r0, [sp, #0x14]
 80555bc: b00a         	add	sp, #0x28
 80555be: f85d bb04    	ldr	r11, [sp], #4
 80555c2: bcf0         	pop	{r4, r5, r6, r7}
 80555c4: eba8 0809    	sub.w	r8, r8, r9
 80555c8: f858 fd48    	ldr	pc, [r8, #-72]!

080555cc <$d.9>:
 80555cc: cd 96 05 08  	.word	0x080596cd
 80555d0: cd 96 05 08  	.word	0x080596cd
 80555d4: 61 9a 05 08  	.word	0x08059a61
 80555d8: ad f9 05 08  	.word	0x0805f9ad
 80555dc: 91 87 05 08  	.word	0x08058791

080555e0 <vTaskDelete>:
;     {
 80555e0: f848 eb50    	str	lr, [r8], #80
 80555e4: eb08 0809    	add.w	r8, r8, r9
 80555e8: b480         	push	{r7}
 80555ea: 466f         	mov	r7, sp
 80555ec: b084         	sub	sp, #0x10
 80555ee: 9003         	str	r0, [sp, #0xc]
;         taskENTER_CRITICAL();
 80555f0: 4841         	ldr	r0, [pc, #0x104]        @ 0x80556f8 <vTaskDelete+0x118>
 80555f2: 4780         	blx	r0
;             pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 80555f4: 9803         	ldr	r0, [sp, #0xc]
 80555f6: b938         	cbnz	r0, 0x8055608 <vTaskDelete+0x28> @ imm = #0xe
 80555f8: e7ff         	b	0x80555fa <vTaskDelete+0x1a> @ imm = #-0x2
 80555fa: f240 1000    	movw	r0, #0x100
 80555fe: f2c2 0000    	movt	r0, #0x2000
 8055602: 6800         	ldr	r0, [r0]
 8055604: 9001         	str	r0, [sp, #0x4]
 8055606: e002         	b	0x805560e <vTaskDelete+0x2e> @ imm = #0x4
 8055608: 9803         	ldr	r0, [sp, #0xc]
 805560a: 9001         	str	r0, [sp, #0x4]
 805560c: e7ff         	b	0x805560e <vTaskDelete+0x2e> @ imm = #-0x2
 805560e: 9801         	ldr	r0, [sp, #0x4]
 8055610: 9002         	str	r0, [sp, #0x8]
;             if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8055612: 9802         	ldr	r0, [sp, #0x8]
 8055614: 3080         	adds	r0, #0x80
 8055616: 4939         	ldr	r1, [pc, #0xe4]         @ 0x80556fc <vTaskDelete+0x11c>
 8055618: 4788         	blx	r1
 805561a: b908         	cbnz	r0, 0x8055620 <vTaskDelete+0x40> @ imm = #0x2
 805561c: e7ff         	b	0x805561e <vTaskDelete+0x3e> @ imm = #-0x2
;             }
 805561e: e000         	b	0x8055622 <vTaskDelete+0x42> @ imm = #0x0
 8055620: e7ff         	b	0x8055622 <vTaskDelete+0x42> @ imm = #-0x2
;             if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8055622: 9802         	ldr	r0, [sp, #0x8]
 8055624: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
 8055628: b128         	cbz	r0, 0x8055636 <vTaskDelete+0x56> @ imm = #0xa
 805562a: e7ff         	b	0x805562c <vTaskDelete+0x4c> @ imm = #-0x2
;                 ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 805562c: 9802         	ldr	r0, [sp, #0x8]
 805562e: 3094         	adds	r0, #0x94
 8055630: 4933         	ldr	r1, [pc, #0xcc]         @ 0x8055700 <vTaskDelete+0x120>
 8055632: 4788         	blx	r1
;             }
 8055634: e000         	b	0x8055638 <vTaskDelete+0x58> @ imm = #0x0
 8055636: e7ff         	b	0x8055638 <vTaskDelete+0x58> @ imm = #-0x2
;             uxTaskNumber++;
 8055638: f240 1104    	movw	r1, #0x104
 805563c: f2c2 0100    	movt	r1, #0x2000
 8055640: 6808         	ldr	r0, [r1]
 8055642: 3001         	adds	r0, #0x1
 8055644: 6008         	str	r0, [r1]
;             if( taskTASK_IS_RUNNING_OR_SCHEDULED_TO_YIELD( pxTCB ) != pdFALSE )
 8055646: 9802         	ldr	r0, [sp, #0x8]
 8055648: f240 1100    	movw	r1, #0x100
 805564c: f2c2 0100    	movt	r1, #0x2000
 8055650: 6809         	ldr	r1, [r1]
 8055652: 4288         	cmp	r0, r1
 8055654: d111         	bne	0x805567a <vTaskDelete+0x9a> @ imm = #0x22
 8055656: e7ff         	b	0x8055658 <vTaskDelete+0x78> @ imm = #-0x2
;                 vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 8055658: 9802         	ldr	r0, [sp, #0x8]
 805565a: f100 0180    	add.w	r1, r0, #0x80
 805565e: f240 1008    	movw	r0, #0x108
 8055662: f2c2 0000    	movt	r0, #0x2000
 8055666: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x8055708 <vTaskDelete+0x128>
 8055668: 4790         	blx	r2
;                 ++uxDeletedTasksWaitingCleanUp;
 805566a: f240 111c    	movw	r1, #0x11c
 805566e: f2c2 0100    	movt	r1, #0x2000
 8055672: 6808         	ldr	r0, [r1]
 8055674: 3001         	adds	r0, #0x1
 8055676: 6008         	str	r0, [r1]
;             }
 8055678: e009         	b	0x805568e <vTaskDelete+0xae> @ imm = #0x12
;                 --uxCurrentNumberOfTasks;
 805567a: f240 1120    	movw	r1, #0x120
 805567e: f2c2 0100    	movt	r1, #0x2000
 8055682: 6808         	ldr	r0, [r1]
 8055684: 3801         	subs	r0, #0x1
 8055686: 6008         	str	r0, [r1]
;                 prvResetNextTaskUnblockTime();
 8055688: 481e         	ldr	r0, [pc, #0x78]         @ 0x8055704 <vTaskDelete+0x124>
 805568a: 4780         	blx	r0
 805568c: e7ff         	b	0x805568e <vTaskDelete+0xae> @ imm = #-0x2
;             taskEXIT_CRITICAL();
 805568e: 481f         	ldr	r0, [pc, #0x7c]         @ 0x805570c <vTaskDelete+0x12c>
 8055690: 4780         	blx	r0
;             if( pxTCB != pxCurrentTCB )
 8055692: 9802         	ldr	r0, [sp, #0x8]
 8055694: f240 1100    	movw	r1, #0x100
 8055698: f2c2 0100    	movt	r1, #0x2000
 805569c: 6809         	ldr	r1, [r1]
 805569e: 4288         	cmp	r0, r1
 80556a0: d004         	beq	0x80556ac <vTaskDelete+0xcc> @ imm = #0x8
 80556a2: e7ff         	b	0x80556a4 <vTaskDelete+0xc4> @ imm = #-0x2
;                 prvDeleteTCB( pxTCB );
 80556a4: 9802         	ldr	r0, [sp, #0x8]
 80556a6: 491a         	ldr	r1, [pc, #0x68]         @ 0x8055710 <vTaskDelete+0x130>
 80556a8: 4788         	blx	r1
;             }
 80556aa: e7ff         	b	0x80556ac <vTaskDelete+0xcc> @ imm = #-0x2
;             if( xSchedulerRunning != pdFALSE )
 80556ac: f240 1024    	movw	r0, #0x124
 80556b0: f2c2 0000    	movt	r0, #0x2000
 80556b4: 6800         	ldr	r0, [r0]
 80556b6: b1c8         	cbz	r0, 0x80556ec <vTaskDelete+0x10c> @ imm = #0x32
 80556b8: e7ff         	b	0x80556ba <vTaskDelete+0xda> @ imm = #-0x2
;                 if( pxTCB == pxCurrentTCB )
 80556ba: 9802         	ldr	r0, [sp, #0x8]
 80556bc: f240 1100    	movw	r1, #0x100
 80556c0: f2c2 0100    	movt	r1, #0x2000
 80556c4: 6809         	ldr	r1, [r1]
 80556c6: 4288         	cmp	r0, r1
 80556c8: d10e         	bne	0x80556e8 <vTaskDelete+0x108> @ imm = #0x1c
 80556ca: e7ff         	b	0x80556cc <vTaskDelete+0xec> @ imm = #-0x2
;                     configASSERT( uxSchedulerSuspended == 0 );
 80556cc: f240 1028    	movw	r0, #0x128
 80556d0: f2c2 0000    	movt	r0, #0x2000
 80556d4: 6800         	ldr	r0, [r0]
 80556d6: b120         	cbz	r0, 0x80556e2 <vTaskDelete+0x102> @ imm = #0x8
 80556d8: e7ff         	b	0x80556da <vTaskDelete+0xfa> @ imm = #-0x2
 80556da: 480f         	ldr	r0, [pc, #0x3c]         @ 0x8055718 <vTaskDelete+0x138>
 80556dc: 4780         	blx	r0
 80556de: e7ff         	b	0x80556e0 <vTaskDelete+0x100> @ imm = #-0x2
 80556e0: e7fe         	b	0x80556e0 <vTaskDelete+0x100> @ imm = #-0x4
;                     portYIELD_WITHIN_API();
 80556e2: 480c         	ldr	r0, [pc, #0x30]         @ 0x8055714 <vTaskDelete+0x134>
 80556e4: 4780         	blx	r0
;                 }
 80556e6: e000         	b	0x80556ea <vTaskDelete+0x10a> @ imm = #0x0
 80556e8: e7ff         	b	0x80556ea <vTaskDelete+0x10a> @ imm = #-0x2
;             }
 80556ea: e7ff         	b	0x80556ec <vTaskDelete+0x10c> @ imm = #-0x2
;     }
 80556ec: b004         	add	sp, #0x10
 80556ee: bc80         	pop	{r7}
 80556f0: eba8 0809    	sub.w	r8, r8, r9
 80556f4: f858 fd50    	ldr	pc, [r8, #-80]!

080556f8 <$d.11>:
 80556f8: 49 cd 05 08  	.word	0x0805cd49
 80556fc: 13 a5 05 08  	.word	0x0805a513
 8055700: 13 a5 05 08  	.word	0x0805a513
 8055704: 1d 57 05 08  	.word	0x0805571d
 8055708: 6f a4 05 08  	.word	0x0805a46f
 805570c: 7d cd 05 08  	.word	0x0805cd7d
 8055710: 59 57 05 08  	.word	0x08055759
 8055714: 2f cd 05 08  	.word	0x0805cd2f
 8055718: 15 d7 05 08  	.word	0x0805d715

0805571c <prvResetNextTaskUnblockTime>:
;     if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 805571c: f240 1030    	movw	r0, #0x130
 8055720: f2c2 0000    	movt	r0, #0x2000
 8055724: 6800         	ldr	r0, [r0]
 8055726: 6800         	ldr	r0, [r0]
 8055728: b940         	cbnz	r0, 0x805573c <prvResetNextTaskUnblockTime+0x20> @ imm = #0x10
 805572a: e7ff         	b	0x805572c <prvResetNextTaskUnblockTime+0x10> @ imm = #-0x2
;         xNextTaskUnblockTime = portMAX_DELAY;
 805572c: f240 21a8    	movw	r1, #0x2a8
 8055730: f2c2 0100    	movt	r1, #0x2000
 8055734: f04f 30ff    	mov.w	r0, #0xffffffff
 8055738: 6008         	str	r0, [r1]
;     }
 805573a: e00c         	b	0x8055756 <prvResetNextTaskUnblockTime+0x3a> @ imm = #0x18
;         xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 805573c: f240 1030    	movw	r0, #0x130
 8055740: f2c2 0000    	movt	r0, #0x2000
 8055744: 6800         	ldr	r0, [r0]
 8055746: 68c0         	ldr	r0, [r0, #0xc]
 8055748: 6800         	ldr	r0, [r0]
 805574a: f240 21a8    	movw	r1, #0x2a8
 805574e: f2c2 0100    	movt	r1, #0x2000
 8055752: 6008         	str	r0, [r1]
 8055754: e7ff         	b	0x8055756 <prvResetNextTaskUnblockTime+0x3a> @ imm = #-0x2
; }
 8055756: 4770         	bx	lr

08055758 <prvDeleteTCB>:
;     {
 8055758: f848 eb2c    	str	lr, [r8], #44
 805575c: eb08 0809    	add.w	r8, r8, r9
 8055760: b480         	push	{r7}
 8055762: 466f         	mov	r7, sp
 8055764: b082         	sub	sp, #0x8
 8055766: 9001         	str	r0, [sp, #0x4]
;         portCLEAN_UP_TCB( pxTCB );
 8055768: 9801         	ldr	r0, [sp, #0x4]
;             if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 805576a: f890 00d5    	ldrb.w	r0, [r0, #0xd5]
 805576e: b948         	cbnz	r0, 0x8055784 <prvDeleteTCB+0x2c> @ imm = #0x12
 8055770: e7ff         	b	0x8055772 <prvDeleteTCB+0x1a> @ imm = #-0x2
;                 vPortFreeStack( pxTCB->pxStack );
 8055772: 9801         	ldr	r0, [sp, #0x4]
 8055774: f8d0 00ac    	ldr.w	r0, [r0, #0xac]
 8055778: 4912         	ldr	r1, [pc, #0x48]         @ 0x80557c4 <prvDeleteTCB+0x6c>
 805577a: 4788         	blx	r1
;                 vPortFree( pxTCB );
 805577c: 9801         	ldr	r0, [sp, #0x4]
 805577e: 4912         	ldr	r1, [pc, #0x48]         @ 0x80557c8 <prvDeleteTCB+0x70>
 8055780: 4788         	blx	r1
;             }
 8055782: e015         	b	0x80557b0 <prvDeleteTCB+0x58> @ imm = #0x2a
;             else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 8055784: 9801         	ldr	r0, [sp, #0x4]
 8055786: f890 00d5    	ldrb.w	r0, [r0, #0xd5]
 805578a: 2801         	cmp	r0, #0x1
 805578c: d104         	bne	0x8055798 <prvDeleteTCB+0x40> @ imm = #0x8
 805578e: e7ff         	b	0x8055790 <prvDeleteTCB+0x38> @ imm = #-0x2
;                 vPortFree( pxTCB );
 8055790: 9801         	ldr	r0, [sp, #0x4]
 8055792: 490b         	ldr	r1, [pc, #0x2c]         @ 0x80557c0 <prvDeleteTCB+0x68>
 8055794: 4788         	blx	r1
;             }
 8055796: e00a         	b	0x80557ae <prvDeleteTCB+0x56> @ imm = #0x14
;                 configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
 8055798: 9801         	ldr	r0, [sp, #0x4]
 805579a: f890 00d5    	ldrb.w	r0, [r0, #0xd5]
 805579e: 2802         	cmp	r0, #0x2
 80557a0: d004         	beq	0x80557ac <prvDeleteTCB+0x54> @ imm = #0x8
 80557a2: e7ff         	b	0x80557a4 <prvDeleteTCB+0x4c> @ imm = #-0x2
 80557a4: 4805         	ldr	r0, [pc, #0x14]         @ 0x80557bc <prvDeleteTCB+0x64>
 80557a6: 4780         	blx	r0
 80557a8: e7ff         	b	0x80557aa <prvDeleteTCB+0x52> @ imm = #-0x2
 80557aa: e7fe         	b	0x80557aa <prvDeleteTCB+0x52> @ imm = #-0x4
 80557ac: e7ff         	b	0x80557ae <prvDeleteTCB+0x56> @ imm = #-0x2
 80557ae: e7ff         	b	0x80557b0 <prvDeleteTCB+0x58> @ imm = #-0x2
;     }
 80557b0: b002         	add	sp, #0x8
 80557b2: bc80         	pop	{r7}
 80557b4: eba8 0809    	sub.w	r8, r8, r9
 80557b8: f858 fd2c    	ldr	pc, [r8, #-44]!

080557bc <$d.13>:
 80557bc: 15 d7 05 08  	.word	0x0805d715
 80557c0: 61 9a 05 08  	.word	0x08059a61
 80557c4: 61 9a 05 08  	.word	0x08059a61
 80557c8: 61 9a 05 08  	.word	0x08059a61

080557cc <xTaskDelayUntil>:
;     {
 80557cc: f848 eb14    	str	lr, [r8], #20
 80557d0: eb08 0809    	add.w	r8, r8, r9
 80557d4: b480         	push	{r7}
 80557d6: 466f         	mov	r7, sp
 80557d8: b086         	sub	sp, #0x18
 80557da: 9005         	str	r0, [sp, #0x14]
 80557dc: 9104         	str	r1, [sp, #0x10]
 80557de: 2000         	movs	r0, #0x0
;         BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 80557e0: 9001         	str	r0, [sp, #0x4]
;         configASSERT( pxPreviousWakeTime );
 80557e2: 9805         	ldr	r0, [sp, #0x14]
 80557e4: b920         	cbnz	r0, 0x80557f0 <xTaskDelayUntil+0x24> @ imm = #0x8
 80557e6: e7ff         	b	0x80557e8 <xTaskDelayUntil+0x1c> @ imm = #-0x2
 80557e8: 483a         	ldr	r0, [pc, #0xe8]         @ 0x80558d4 <xTaskDelayUntil+0x108>
 80557ea: 4780         	blx	r0
 80557ec: e7ff         	b	0x80557ee <xTaskDelayUntil+0x22> @ imm = #-0x2
 80557ee: e7fe         	b	0x80557ee <xTaskDelayUntil+0x22> @ imm = #-0x4
;         configASSERT( ( xTimeIncrement > 0U ) );
 80557f0: 9804         	ldr	r0, [sp, #0x10]
 80557f2: b920         	cbnz	r0, 0x80557fe <xTaskDelayUntil+0x32> @ imm = #0x8
 80557f4: e7ff         	b	0x80557f6 <xTaskDelayUntil+0x2a> @ imm = #-0x2
 80557f6: 4836         	ldr	r0, [pc, #0xd8]         @ 0x80558d0 <xTaskDelayUntil+0x104>
 80557f8: 4780         	blx	r0
 80557fa: e7ff         	b	0x80557fc <xTaskDelayUntil+0x30> @ imm = #-0x2
 80557fc: e7fe         	b	0x80557fc <xTaskDelayUntil+0x30> @ imm = #-0x4
;         vTaskSuspendAll();
 80557fe: 482f         	ldr	r0, [pc, #0xbc]         @ 0x80558bc <xTaskDelayUntil+0xf0>
 8055800: 4780         	blx	r0
;             const TickType_t xConstTickCount = xTickCount;
 8055802: f240 102c    	movw	r0, #0x12c
 8055806: f2c2 0000    	movt	r0, #0x2000
 805580a: 6800         	ldr	r0, [r0]
 805580c: 9000         	str	r0, [sp]
;             configASSERT( uxSchedulerSuspended == 1U );
 805580e: f240 1028    	movw	r0, #0x128
 8055812: f2c2 0000    	movt	r0, #0x2000
 8055816: 6800         	ldr	r0, [r0]
 8055818: 2801         	cmp	r0, #0x1
 805581a: d004         	beq	0x8055826 <xTaskDelayUntil+0x5a> @ imm = #0x8
 805581c: e7ff         	b	0x805581e <xTaskDelayUntil+0x52> @ imm = #-0x2
 805581e: 482b         	ldr	r0, [pc, #0xac]         @ 0x80558cc <xTaskDelayUntil+0x100>
 8055820: 4780         	blx	r0
 8055822: e7ff         	b	0x8055824 <xTaskDelayUntil+0x58> @ imm = #-0x2
 8055824: e7fe         	b	0x8055824 <xTaskDelayUntil+0x58> @ imm = #-0x4
;             xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8055826: 9805         	ldr	r0, [sp, #0x14]
 8055828: 6800         	ldr	r0, [r0]
 805582a: 9904         	ldr	r1, [sp, #0x10]
 805582c: 4408         	add	r0, r1
 805582e: 9003         	str	r0, [sp, #0xc]
;             if( xConstTickCount < *pxPreviousWakeTime )
 8055830: 9800         	ldr	r0, [sp]
 8055832: 9905         	ldr	r1, [sp, #0x14]
 8055834: 6809         	ldr	r1, [r1]
 8055836: 4288         	cmp	r0, r1
 8055838: d210         	bhs	0x805585c <xTaskDelayUntil+0x90> @ imm = #0x20
 805583a: e7ff         	b	0x805583c <xTaskDelayUntil+0x70> @ imm = #-0x2
;                 if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 805583c: 9803         	ldr	r0, [sp, #0xc]
 805583e: 9905         	ldr	r1, [sp, #0x14]
 8055840: 6809         	ldr	r1, [r1]
 8055842: 4288         	cmp	r0, r1
 8055844: d208         	bhs	0x8055858 <xTaskDelayUntil+0x8c> @ imm = #0x10
 8055846: e7ff         	b	0x8055848 <xTaskDelayUntil+0x7c> @ imm = #-0x2
 8055848: 9803         	ldr	r0, [sp, #0xc]
 805584a: 9900         	ldr	r1, [sp]
 805584c: 4288         	cmp	r0, r1
 805584e: d903         	bls	0x8055858 <xTaskDelayUntil+0x8c> @ imm = #0x6
 8055850: e7ff         	b	0x8055852 <xTaskDelayUntil+0x86> @ imm = #-0x2
 8055852: 2001         	movs	r0, #0x1
;                     xShouldDelay = pdTRUE;
 8055854: 9001         	str	r0, [sp, #0x4]
;                 }
 8055856: e000         	b	0x805585a <xTaskDelayUntil+0x8e> @ imm = #0x0
 8055858: e7ff         	b	0x805585a <xTaskDelayUntil+0x8e> @ imm = #-0x2
;             }
 805585a: e00f         	b	0x805587c <xTaskDelayUntil+0xb0> @ imm = #0x1e
;                 if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 805585c: 9803         	ldr	r0, [sp, #0xc]
 805585e: 9905         	ldr	r1, [sp, #0x14]
 8055860: 6809         	ldr	r1, [r1]
 8055862: 4288         	cmp	r0, r1
 8055864: d305         	blo	0x8055872 <xTaskDelayUntil+0xa6> @ imm = #0xa
 8055866: e7ff         	b	0x8055868 <xTaskDelayUntil+0x9c> @ imm = #-0x2
 8055868: 9803         	ldr	r0, [sp, #0xc]
 805586a: 9900         	ldr	r1, [sp]
 805586c: 4288         	cmp	r0, r1
 805586e: d903         	bls	0x8055878 <xTaskDelayUntil+0xac> @ imm = #0x6
 8055870: e7ff         	b	0x8055872 <xTaskDelayUntil+0xa6> @ imm = #-0x2
 8055872: 2001         	movs	r0, #0x1
;                     xShouldDelay = pdTRUE;
 8055874: 9001         	str	r0, [sp, #0x4]
;                 }
 8055876: e000         	b	0x805587a <xTaskDelayUntil+0xae> @ imm = #0x0
 8055878: e7ff         	b	0x805587a <xTaskDelayUntil+0xae> @ imm = #-0x2
 805587a: e7ff         	b	0x805587c <xTaskDelayUntil+0xb0> @ imm = #-0x2
;             *pxPreviousWakeTime = xTimeToWake;
 805587c: 9803         	ldr	r0, [sp, #0xc]
 805587e: 9905         	ldr	r1, [sp, #0x14]
 8055880: 6008         	str	r0, [r1]
;             if( xShouldDelay != pdFALSE )
 8055882: 9801         	ldr	r0, [sp, #0x4]
 8055884: b138         	cbz	r0, 0x8055896 <xTaskDelayUntil+0xca> @ imm = #0xe
 8055886: e7ff         	b	0x8055888 <xTaskDelayUntil+0xbc> @ imm = #-0x2
;                 prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 8055888: 9803         	ldr	r0, [sp, #0xc]
 805588a: 9900         	ldr	r1, [sp]
 805588c: 1a40         	subs	r0, r0, r1
 805588e: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80558c0 <xTaskDelayUntil+0xf4>
 8055890: 2100         	movs	r1, #0x0
 8055892: 4790         	blx	r2
;             }
 8055894: e000         	b	0x8055898 <xTaskDelayUntil+0xcc> @ imm = #0x0
 8055896: e7ff         	b	0x8055898 <xTaskDelayUntil+0xcc> @ imm = #-0x2
;         xAlreadyYielded = xTaskResumeAll();
 8055898: 480a         	ldr	r0, [pc, #0x28]         @ 0x80558c4 <xTaskDelayUntil+0xf8>
 805589a: 4780         	blx	r0
 805589c: 9002         	str	r0, [sp, #0x8]
;         if( xAlreadyYielded == pdFALSE )
 805589e: 9802         	ldr	r0, [sp, #0x8]
 80558a0: b918         	cbnz	r0, 0x80558aa <xTaskDelayUntil+0xde> @ imm = #0x6
 80558a2: e7ff         	b	0x80558a4 <xTaskDelayUntil+0xd8> @ imm = #-0x2
;             taskYIELD_WITHIN_API();
 80558a4: 4808         	ldr	r0, [pc, #0x20]         @ 0x80558c8 <xTaskDelayUntil+0xfc>
 80558a6: 4780         	blx	r0
;         }
 80558a8: e000         	b	0x80558ac <xTaskDelayUntil+0xe0> @ imm = #0x0
 80558aa: e7ff         	b	0x80558ac <xTaskDelayUntil+0xe0> @ imm = #-0x2
;         return xShouldDelay;
 80558ac: 9801         	ldr	r0, [sp, #0x4]
 80558ae: b006         	add	sp, #0x18
 80558b0: bc80         	pop	{r7}
 80558b2: eba8 0809    	sub.w	r8, r8, r9
 80558b6: f858 fd14    	ldr	pc, [r8, #-20]!
 80558ba: bf00         	nop

080558bc <$d.15>:
 80558bc: d9 58 05 08  	.word	0x080558d9
 80558c0: e9 58 05 08  	.word	0x080558e9
 80558c4: 0d 5a 05 08  	.word	0x08055a0d
 80558c8: 2f cd 05 08  	.word	0x0805cd2f
 80558cc: 15 d7 05 08  	.word	0x0805d715
 80558d0: 15 d7 05 08  	.word	0x0805d715
 80558d4: 15 d7 05 08  	.word	0x0805d715

080558d8 <vTaskSuspendAll>:
;         ++uxSchedulerSuspended;
 80558d8: f240 1128    	movw	r1, #0x128
 80558dc: f2c2 0100    	movt	r1, #0x2000
 80558e0: 6808         	ldr	r0, [r1]
 80558e2: 3001         	adds	r0, #0x1
 80558e4: 6008         	str	r0, [r1]
; }
 80558e6: 4770         	bx	lr

080558e8 <prvAddCurrentTaskToDelayedList>:
; {
 80558e8: f848 eb70    	str	lr, [r8], #112
 80558ec: eb08 0809    	add.w	r8, r8, r9
 80558f0: b480         	push	{r7}
 80558f2: 466f         	mov	r7, sp
 80558f4: b086         	sub	sp, #0x18
 80558f6: 9005         	str	r0, [sp, #0x14]
 80558f8: 9104         	str	r1, [sp, #0x10]
;     const TickType_t xConstTickCount = xTickCount;
 80558fa: f240 102c    	movw	r0, #0x12c
 80558fe: f2c2 0000    	movt	r0, #0x2000
 8055902: 6800         	ldr	r0, [r0]
 8055904: 9002         	str	r0, [sp, #0x8]
;     if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8055906: f240 1000    	movw	r0, #0x100
 805590a: f2c2 0000    	movt	r0, #0x2000
 805590e: 6800         	ldr	r0, [r0]
 8055910: 3080         	adds	r0, #0x80
 8055912: 493b         	ldr	r1, [pc, #0xec]         @ 0x8055a00 <prvAddCurrentTaskToDelayedList+0x118>
 8055914: 4788         	blx	r1
 8055916: b908         	cbnz	r0, 0x805591c <prvAddCurrentTaskToDelayedList+0x34> @ imm = #0x2
 8055918: e7ff         	b	0x805591a <prvAddCurrentTaskToDelayedList+0x32> @ imm = #-0x2
;     }
 805591a: e000         	b	0x805591e <prvAddCurrentTaskToDelayedList+0x36> @ imm = #0x0
 805591c: e7ff         	b	0x805591e <prvAddCurrentTaskToDelayedList+0x36> @ imm = #-0x2
;         if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 805591e: 9805         	ldr	r0, [sp, #0x14]
 8055920: 3001         	adds	r0, #0x1
 8055922: bb40         	cbnz	r0, 0x8055976 <prvAddCurrentTaskToDelayedList+0x8e> @ imm = #0x50
 8055924: e7ff         	b	0x8055926 <prvAddCurrentTaskToDelayedList+0x3e> @ imm = #-0x2
 8055926: 9804         	ldr	r0, [sp, #0x10]
 8055928: b328         	cbz	r0, 0x8055976 <prvAddCurrentTaskToDelayedList+0x8e> @ imm = #0x4a
 805592a: e7ff         	b	0x805592c <prvAddCurrentTaskToDelayedList+0x44> @ imm = #-0x2
;             listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 805592c: e7ff         	b	0x805592e <prvAddCurrentTaskToDelayedList+0x46> @ imm = #-0x2
 805592e: f240 114c    	movw	r1, #0x14c
 8055932: f2c2 0100    	movt	r1, #0x2000
 8055936: 6848         	ldr	r0, [r1, #0x4]
 8055938: 9001         	str	r0, [sp, #0x4]
 805593a: 9a01         	ldr	r2, [sp, #0x4]
 805593c: f240 1000    	movw	r0, #0x100
 8055940: f2c2 0000    	movt	r0, #0x2000
 8055944: 6803         	ldr	r3, [r0]
 8055946: f8c3 2084    	str.w	r2, [r3, #0x84]
 805594a: 9a01         	ldr	r2, [sp, #0x4]
 805594c: 6892         	ldr	r2, [r2, #0x8]
 805594e: 6803         	ldr	r3, [r0]
 8055950: f8c3 2088    	str.w	r2, [r3, #0x88]
 8055954: 6802         	ldr	r2, [r0]
 8055956: 3280         	adds	r2, #0x80
 8055958: 9b01         	ldr	r3, [sp, #0x4]
 805595a: 689b         	ldr	r3, [r3, #0x8]
 805595c: 605a         	str	r2, [r3, #0x4]
 805595e: 6802         	ldr	r2, [r0]
 8055960: 3280         	adds	r2, #0x80
 8055962: 9b01         	ldr	r3, [sp, #0x4]
 8055964: 609a         	str	r2, [r3, #0x8]
 8055966: 6800         	ldr	r0, [r0]
 8055968: f8c0 1090    	str.w	r1, [r0, #0x90]
 805596c: 6808         	ldr	r0, [r1]
 805596e: 3001         	adds	r0, #0x1
 8055970: 6008         	str	r0, [r1]
 8055972: e7ff         	b	0x8055974 <prvAddCurrentTaskToDelayedList+0x8c> @ imm = #-0x2
;         }
 8055974: e03e         	b	0x80559f4 <prvAddCurrentTaskToDelayedList+0x10c> @ imm = #0x7c
;             xTimeToWake = xConstTickCount + xTicksToWait;
 8055976: 9802         	ldr	r0, [sp, #0x8]
 8055978: 9905         	ldr	r1, [sp, #0x14]
 805597a: 4408         	add	r0, r1
 805597c: 9003         	str	r0, [sp, #0xc]
;             listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 805597e: 9803         	ldr	r0, [sp, #0xc]
 8055980: f240 1100    	movw	r1, #0x100
 8055984: f2c2 0100    	movt	r1, #0x2000
 8055988: 6809         	ldr	r1, [r1]
 805598a: f8c1 0080    	str.w	r0, [r1, #0x80]
;             if( xTimeToWake < xConstTickCount )
 805598e: 9803         	ldr	r0, [sp, #0xc]
 8055990: 9902         	ldr	r1, [sp, #0x8]
 8055992: 4288         	cmp	r0, r1
 8055994: d20e         	bhs	0x80559b4 <prvAddCurrentTaskToDelayedList+0xcc> @ imm = #0x1c
 8055996: e7ff         	b	0x8055998 <prvAddCurrentTaskToDelayedList+0xb0> @ imm = #-0x2
;                 vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8055998: f240 1034    	movw	r0, #0x134
 805599c: f2c2 0000    	movt	r0, #0x2000
 80559a0: 6800         	ldr	r0, [r0]
 80559a2: f240 1100    	movw	r1, #0x100
 80559a6: f2c2 0100    	movt	r1, #0x2000
 80559aa: 6809         	ldr	r1, [r1]
 80559ac: 3180         	adds	r1, #0x80
 80559ae: 4a16         	ldr	r2, [pc, #0x58]         @ 0x8055a08 <prvAddCurrentTaskToDelayedList+0x120>
 80559b0: 4790         	blx	r2
;             }
 80559b2: e01e         	b	0x80559f2 <prvAddCurrentTaskToDelayedList+0x10a> @ imm = #0x3c
;                 vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80559b4: f240 1030    	movw	r0, #0x130
 80559b8: f2c2 0000    	movt	r0, #0x2000
 80559bc: 6800         	ldr	r0, [r0]
 80559be: f240 1100    	movw	r1, #0x100
 80559c2: f2c2 0100    	movt	r1, #0x2000
 80559c6: 6809         	ldr	r1, [r1]
 80559c8: 3180         	adds	r1, #0x80
 80559ca: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x8055a04 <prvAddCurrentTaskToDelayedList+0x11c>
 80559cc: 4790         	blx	r2
;                 if( xTimeToWake < xNextTaskUnblockTime )
 80559ce: 9803         	ldr	r0, [sp, #0xc]
 80559d0: f240 21a8    	movw	r1, #0x2a8
 80559d4: f2c2 0100    	movt	r1, #0x2000
 80559d8: 6809         	ldr	r1, [r1]
 80559da: 4288         	cmp	r0, r1
 80559dc: d207         	bhs	0x80559ee <prvAddCurrentTaskToDelayedList+0x106> @ imm = #0xe
 80559de: e7ff         	b	0x80559e0 <prvAddCurrentTaskToDelayedList+0xf8> @ imm = #-0x2
;                     xNextTaskUnblockTime = xTimeToWake;
 80559e0: 9803         	ldr	r0, [sp, #0xc]
 80559e2: f240 21a8    	movw	r1, #0x2a8
 80559e6: f2c2 0100    	movt	r1, #0x2000
 80559ea: 6008         	str	r0, [r1]
;                 }
 80559ec: e000         	b	0x80559f0 <prvAddCurrentTaskToDelayedList+0x108> @ imm = #0x0
 80559ee: e7ff         	b	0x80559f0 <prvAddCurrentTaskToDelayedList+0x108> @ imm = #-0x2
 80559f0: e7ff         	b	0x80559f2 <prvAddCurrentTaskToDelayedList+0x10a> @ imm = #-0x2
 80559f2: e7ff         	b	0x80559f4 <prvAddCurrentTaskToDelayedList+0x10c> @ imm = #-0x2
; }
 80559f4: b006         	add	sp, #0x18
 80559f6: bc80         	pop	{r7}
 80559f8: eba8 0809    	sub.w	r8, r8, r9
 80559fc: f858 fd70    	ldr	pc, [r8, #-112]!

08055a00 <$d.17>:
 8055a00: 13 a5 05 08  	.word	0x0805a513
 8055a04: a9 a4 05 08  	.word	0x0805a4a9
 8055a08: a9 a4 05 08  	.word	0x0805a4a9

08055a0c <xTaskResumeAll>:
; {
 8055a0c: f848 eb30    	str	lr, [r8], #48
 8055a10: eb08 0809    	add.w	r8, r8, r9
 8055a14: b480         	push	{r7}
 8055a16: 466f         	mov	r7, sp
 8055a18: b088         	sub	sp, #0x20
 8055a1a: 2000         	movs	r0, #0x0
;     TCB_t * pxTCB = NULL;
 8055a1c: 9000         	str	r0, [sp]
 8055a1e: 9007         	str	r0, [sp, #0x1c]
;     BaseType_t xAlreadyYielded = pdFALSE;
 8055a20: 9006         	str	r0, [sp, #0x18]
;         taskENTER_CRITICAL();
 8055a22: 489b         	ldr	r0, [pc, #0x26c]        @ 0x8055c90 <xTaskResumeAll+0x284>
 8055a24: 4780         	blx	r0
 8055a26: 9800         	ldr	r0, [sp]
;             xCoreID = ( BaseType_t ) portGET_CORE_ID();
 8055a28: 9005         	str	r0, [sp, #0x14]
;             configASSERT( uxSchedulerSuspended != 0U );
 8055a2a: f240 1028    	movw	r0, #0x128
 8055a2e: f2c2 0000    	movt	r0, #0x2000
 8055a32: 6800         	ldr	r0, [r0]
 8055a34: b920         	cbnz	r0, 0x8055a40 <xTaskResumeAll+0x34> @ imm = #0x8
 8055a36: e7ff         	b	0x8055a38 <xTaskResumeAll+0x2c> @ imm = #-0x2
 8055a38: 489a         	ldr	r0, [pc, #0x268]        @ 0x8055ca4 <xTaskResumeAll+0x298>
 8055a3a: 4780         	blx	r0
 8055a3c: e7ff         	b	0x8055a3e <xTaskResumeAll+0x32> @ imm = #-0x2
 8055a3e: e7fe         	b	0x8055a3e <xTaskResumeAll+0x32> @ imm = #-0x4
;             --uxSchedulerSuspended;
 8055a40: f240 1028    	movw	r0, #0x128
 8055a44: f2c2 0000    	movt	r0, #0x2000
 8055a48: 6801         	ldr	r1, [r0]
 8055a4a: 3901         	subs	r1, #0x1
 8055a4c: 6001         	str	r1, [r0]
;             if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 8055a4e: 6800         	ldr	r0, [r0]
 8055a50: 2800         	cmp	r0, #0x0
 8055a52: f040 8113    	bne.w	0x8055c7c <xTaskResumeAll+0x270> @ imm = #0x226
 8055a56: e7ff         	b	0x8055a58 <xTaskResumeAll+0x4c> @ imm = #-0x2
;                 if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8055a58: f240 1020    	movw	r0, #0x120
 8055a5c: f2c2 0000    	movt	r0, #0x2000
 8055a60: 6800         	ldr	r0, [r0]
 8055a62: 2800         	cmp	r0, #0x0
 8055a64: f000 8109    	beq.w	0x8055c7a <xTaskResumeAll+0x26e> @ imm = #0x212
 8055a68: e7ff         	b	0x8055a6a <xTaskResumeAll+0x5e> @ imm = #-0x2
;                     while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8055a6a: e7ff         	b	0x8055a6c <xTaskResumeAll+0x60> @ imm = #-0x2
 8055a6c: f240 1038    	movw	r0, #0x138
 8055a70: f2c2 0000    	movt	r0, #0x2000
 8055a74: 6800         	ldr	r0, [r0]
 8055a76: 2800         	cmp	r0, #0x0
 8055a78: f000 80ba    	beq.w	0x8055bf0 <xTaskResumeAll+0x1e4> @ imm = #0x174
 8055a7c: e7ff         	b	0x8055a7e <xTaskResumeAll+0x72> @ imm = #-0x2
;                         pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8055a7e: f240 1038    	movw	r0, #0x138
 8055a82: f2c2 0000    	movt	r0, #0x2000
 8055a86: 68c0         	ldr	r0, [r0, #0xc]
 8055a88: 68c0         	ldr	r0, [r0, #0xc]
 8055a8a: 9007         	str	r0, [sp, #0x1c]
;                         listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 8055a8c: e7ff         	b	0x8055a8e <xTaskResumeAll+0x82> @ imm = #-0x2
 8055a8e: 9807         	ldr	r0, [sp, #0x1c]
 8055a90: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
 8055a94: 9004         	str	r0, [sp, #0x10]
 8055a96: 9807         	ldr	r0, [sp, #0x1c]
 8055a98: f8d0 1098    	ldr.w	r1, [r0, #0x98]
 8055a9c: f8d0 009c    	ldr.w	r0, [r0, #0x9c]
 8055aa0: 6088         	str	r0, [r1, #0x8]
 8055aa2: 9907         	ldr	r1, [sp, #0x1c]
 8055aa4: f8d1 0098    	ldr.w	r0, [r1, #0x98]
 8055aa8: f8d1 109c    	ldr.w	r1, [r1, #0x9c]
 8055aac: 6048         	str	r0, [r1, #0x4]
 8055aae: 9804         	ldr	r0, [sp, #0x10]
 8055ab0: 6840         	ldr	r0, [r0, #0x4]
 8055ab2: 9907         	ldr	r1, [sp, #0x1c]
 8055ab4: 3194         	adds	r1, #0x94
 8055ab6: 4288         	cmp	r0, r1
 8055ab8: d106         	bne	0x8055ac8 <xTaskResumeAll+0xbc> @ imm = #0xc
 8055aba: e7ff         	b	0x8055abc <xTaskResumeAll+0xb0> @ imm = #-0x2
 8055abc: 9807         	ldr	r0, [sp, #0x1c]
 8055abe: f8d0 009c    	ldr.w	r0, [r0, #0x9c]
 8055ac2: 9904         	ldr	r1, [sp, #0x10]
 8055ac4: 6048         	str	r0, [r1, #0x4]
 8055ac6: e7ff         	b	0x8055ac8 <xTaskResumeAll+0xbc> @ imm = #-0x2
 8055ac8: 9907         	ldr	r1, [sp, #0x1c]
 8055aca: 2000         	movs	r0, #0x0
 8055acc: f8c1 00a4    	str.w	r0, [r1, #0xa4]
 8055ad0: 9904         	ldr	r1, [sp, #0x10]
 8055ad2: 6808         	ldr	r0, [r1]
 8055ad4: 3801         	subs	r0, #0x1
 8055ad6: 6008         	str	r0, [r1]
 8055ad8: e7ff         	b	0x8055ada <xTaskResumeAll+0xce> @ imm = #-0x2
;                         listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8055ada: e7ff         	b	0x8055adc <xTaskResumeAll+0xd0> @ imm = #-0x2
 8055adc: 9807         	ldr	r0, [sp, #0x1c]
 8055ade: f8d0 0090    	ldr.w	r0, [r0, #0x90]
 8055ae2: 9003         	str	r0, [sp, #0xc]
 8055ae4: 9807         	ldr	r0, [sp, #0x1c]
 8055ae6: f8d0 1084    	ldr.w	r1, [r0, #0x84]
 8055aea: f8d0 0088    	ldr.w	r0, [r0, #0x88]
 8055aee: 6088         	str	r0, [r1, #0x8]
 8055af0: 9907         	ldr	r1, [sp, #0x1c]
 8055af2: f8d1 0084    	ldr.w	r0, [r1, #0x84]
 8055af6: f8d1 1088    	ldr.w	r1, [r1, #0x88]
 8055afa: 6048         	str	r0, [r1, #0x4]
 8055afc: 9803         	ldr	r0, [sp, #0xc]
 8055afe: 6840         	ldr	r0, [r0, #0x4]
 8055b00: 9907         	ldr	r1, [sp, #0x1c]
 8055b02: 3180         	adds	r1, #0x80
 8055b04: 4288         	cmp	r0, r1
 8055b06: d106         	bne	0x8055b16 <xTaskResumeAll+0x10a> @ imm = #0xc
 8055b08: e7ff         	b	0x8055b0a <xTaskResumeAll+0xfe> @ imm = #-0x2
 8055b0a: 9807         	ldr	r0, [sp, #0x1c]
 8055b0c: f8d0 0088    	ldr.w	r0, [r0, #0x88]
 8055b10: 9903         	ldr	r1, [sp, #0xc]
 8055b12: 6048         	str	r0, [r1, #0x4]
 8055b14: e7ff         	b	0x8055b16 <xTaskResumeAll+0x10a> @ imm = #-0x2
 8055b16: 9907         	ldr	r1, [sp, #0x1c]
 8055b18: 2000         	movs	r0, #0x0
 8055b1a: f8c1 0090    	str.w	r0, [r1, #0x90]
 8055b1e: 9903         	ldr	r1, [sp, #0xc]
 8055b20: 6808         	ldr	r0, [r1]
 8055b22: 3801         	subs	r0, #0x1
 8055b24: 6008         	str	r0, [r1]
 8055b26: e7ff         	b	0x8055b28 <xTaskResumeAll+0x11c> @ imm = #-0x2
;                         prvAddTaskToReadyList( pxTCB );
 8055b28: e7ff         	b	0x8055b2a <xTaskResumeAll+0x11e> @ imm = #-0x2
 8055b2a: e7ff         	b	0x8055b2c <xTaskResumeAll+0x120> @ imm = #-0x2
 8055b2c: 9807         	ldr	r0, [sp, #0x1c]
 8055b2e: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8055b32: f240 21a0    	movw	r1, #0x2a0
 8055b36: f2c2 0100    	movt	r1, #0x2000
 8055b3a: 6809         	ldr	r1, [r1]
 8055b3c: 4288         	cmp	r0, r1
 8055b3e: d909         	bls	0x8055b54 <xTaskResumeAll+0x148> @ imm = #0x12
 8055b40: e7ff         	b	0x8055b42 <xTaskResumeAll+0x136> @ imm = #-0x2
 8055b42: 9807         	ldr	r0, [sp, #0x1c]
 8055b44: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8055b48: f240 21a0    	movw	r1, #0x2a0
 8055b4c: f2c2 0100    	movt	r1, #0x2000
 8055b50: 6008         	str	r0, [r1]
 8055b52: e7ff         	b	0x8055b54 <xTaskResumeAll+0x148> @ imm = #-0x2
 8055b54: e7ff         	b	0x8055b56 <xTaskResumeAll+0x14a> @ imm = #-0x2
 8055b56: e7ff         	b	0x8055b58 <xTaskResumeAll+0x14c> @ imm = #-0x2
 8055b58: 9807         	ldr	r0, [sp, #0x1c]
 8055b5a: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8055b5e: eb00 0080    	add.w	r0, r0, r0, lsl #2
 8055b62: f240 1160    	movw	r1, #0x160
 8055b66: f2c2 0100    	movt	r1, #0x2000
 8055b6a: eb01 0080    	add.w	r0, r1, r0, lsl #2
 8055b6e: 6840         	ldr	r0, [r0, #0x4]
 8055b70: 9002         	str	r0, [sp, #0x8]
 8055b72: 9802         	ldr	r0, [sp, #0x8]
 8055b74: 9a07         	ldr	r2, [sp, #0x1c]
 8055b76: f8c2 0084    	str.w	r0, [r2, #0x84]
 8055b7a: 9802         	ldr	r0, [sp, #0x8]
 8055b7c: 6880         	ldr	r0, [r0, #0x8]
 8055b7e: 9a07         	ldr	r2, [sp, #0x1c]
 8055b80: f8c2 0088    	str.w	r0, [r2, #0x88]
 8055b84: 9807         	ldr	r0, [sp, #0x1c]
 8055b86: 3080         	adds	r0, #0x80
 8055b88: 9a02         	ldr	r2, [sp, #0x8]
 8055b8a: 6892         	ldr	r2, [r2, #0x8]
 8055b8c: 6050         	str	r0, [r2, #0x4]
 8055b8e: 9807         	ldr	r0, [sp, #0x1c]
 8055b90: 3080         	adds	r0, #0x80
 8055b92: 9a02         	ldr	r2, [sp, #0x8]
 8055b94: 6090         	str	r0, [r2, #0x8]
 8055b96: 9a07         	ldr	r2, [sp, #0x1c]
 8055b98: f8d2 00a8    	ldr.w	r0, [r2, #0xa8]
 8055b9c: eb00 0080    	add.w	r0, r0, r0, lsl #2
 8055ba0: eb01 0080    	add.w	r0, r1, r0, lsl #2
 8055ba4: f8c2 0090    	str.w	r0, [r2, #0x90]
 8055ba8: 9807         	ldr	r0, [sp, #0x1c]
 8055baa: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8055bae: eb00 0280    	add.w	r2, r0, r0, lsl #2
 8055bb2: f851 0022    	ldr.w	r0, [r1, r2, lsl #2]
 8055bb6: 3001         	adds	r0, #0x1
 8055bb8: f841 0022    	str.w	r0, [r1, r2, lsl #2]
 8055bbc: e7ff         	b	0x8055bbe <xTaskResumeAll+0x1b2> @ imm = #-0x2
 8055bbe: e7ff         	b	0x8055bc0 <xTaskResumeAll+0x1b4> @ imm = #-0x2
;                             if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8055bc0: 9807         	ldr	r0, [sp, #0x1c]
 8055bc2: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8055bc6: f240 1100    	movw	r1, #0x100
 8055bca: f2c2 0100    	movt	r1, #0x2000
 8055bce: 6809         	ldr	r1, [r1]
 8055bd0: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 8055bd4: 4288         	cmp	r0, r1
 8055bd6: d909         	bls	0x8055bec <xTaskResumeAll+0x1e0> @ imm = #0x12
 8055bd8: e7ff         	b	0x8055bda <xTaskResumeAll+0x1ce> @ imm = #-0x2
;                                 xYieldPendings[ xCoreID ] = pdTRUE;
 8055bda: 9a05         	ldr	r2, [sp, #0x14]
 8055bdc: f240 21a4    	movw	r1, #0x2a4
 8055be0: f2c2 0100    	movt	r1, #0x2000
 8055be4: 2001         	movs	r0, #0x1
 8055be6: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;                             }
 8055bea: e000         	b	0x8055bee <xTaskResumeAll+0x1e2> @ imm = #0x0
 8055bec: e7ff         	b	0x8055bee <xTaskResumeAll+0x1e2> @ imm = #-0x2
;                     while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8055bee: e73d         	b	0x8055a6c <xTaskResumeAll+0x60> @ imm = #-0x186
;                     if( pxTCB != NULL )
 8055bf0: 9807         	ldr	r0, [sp, #0x1c]
 8055bf2: b118         	cbz	r0, 0x8055bfc <xTaskResumeAll+0x1f0> @ imm = #0x6
 8055bf4: e7ff         	b	0x8055bf6 <xTaskResumeAll+0x1ea> @ imm = #-0x2
;                         prvResetNextTaskUnblockTime();
 8055bf6: 4827         	ldr	r0, [pc, #0x9c]         @ 0x8055c94 <xTaskResumeAll+0x288>
 8055bf8: 4780         	blx	r0
;                     }
 8055bfa: e7ff         	b	0x8055bfc <xTaskResumeAll+0x1f0> @ imm = #-0x2
;                         TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 8055bfc: f240 20b0    	movw	r0, #0x2b0
 8055c00: f2c2 0000    	movt	r0, #0x2000
 8055c04: 6800         	ldr	r0, [r0]
 8055c06: 9001         	str	r0, [sp, #0x4]
;                         if( xPendedCounts > ( TickType_t ) 0U )
 8055c08: 9801         	ldr	r0, [sp, #0x4]
 8055c0a: b1f0         	cbz	r0, 0x8055c4a <xTaskResumeAll+0x23e> @ imm = #0x3c
 8055c0c: e7ff         	b	0x8055c0e <xTaskResumeAll+0x202> @ imm = #-0x2
;                             do
 8055c0e: e7ff         	b	0x8055c10 <xTaskResumeAll+0x204> @ imm = #-0x2
;                                 if( xTaskIncrementTick() != pdFALSE )
 8055c10: 4821         	ldr	r0, [pc, #0x84]         @ 0x8055c98 <xTaskResumeAll+0x28c>
 8055c12: 4780         	blx	r0
 8055c14: b148         	cbz	r0, 0x8055c2a <xTaskResumeAll+0x21e> @ imm = #0x12
 8055c16: e7ff         	b	0x8055c18 <xTaskResumeAll+0x20c> @ imm = #-0x2
;                                     xYieldPendings[ xCoreID ] = pdTRUE;
 8055c18: 9a05         	ldr	r2, [sp, #0x14]
 8055c1a: f240 21a4    	movw	r1, #0x2a4
 8055c1e: f2c2 0100    	movt	r1, #0x2000
 8055c22: 2001         	movs	r0, #0x1
 8055c24: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;                                 }
 8055c28: e000         	b	0x8055c2c <xTaskResumeAll+0x220> @ imm = #0x0
 8055c2a: e7ff         	b	0x8055c2c <xTaskResumeAll+0x220> @ imm = #-0x2
;                                 --xPendedCounts;
 8055c2c: 9801         	ldr	r0, [sp, #0x4]
 8055c2e: 3801         	subs	r0, #0x1
 8055c30: 9001         	str	r0, [sp, #0x4]
;                             } while( xPendedCounts > ( TickType_t ) 0U );
 8055c32: e7ff         	b	0x8055c34 <xTaskResumeAll+0x228> @ imm = #-0x2
 8055c34: 9801         	ldr	r0, [sp, #0x4]
 8055c36: 2800         	cmp	r0, #0x0
 8055c38: d1ea         	bne	0x8055c10 <xTaskResumeAll+0x204> @ imm = #-0x2c
 8055c3a: e7ff         	b	0x8055c3c <xTaskResumeAll+0x230> @ imm = #-0x2
;                             xPendedTicks = 0;
 8055c3c: f240 21b0    	movw	r1, #0x2b0
 8055c40: f2c2 0100    	movt	r1, #0x2000
 8055c44: 2000         	movs	r0, #0x0
 8055c46: 6008         	str	r0, [r1]
;                         }
 8055c48: e000         	b	0x8055c4c <xTaskResumeAll+0x240> @ imm = #0x0
 8055c4a: e7ff         	b	0x8055c4c <xTaskResumeAll+0x240> @ imm = #-0x2
;                     if( xYieldPendings[ xCoreID ] != pdFALSE )
 8055c4c: 9905         	ldr	r1, [sp, #0x14]
 8055c4e: f240 20a4    	movw	r0, #0x2a4
 8055c52: f2c2 0000    	movt	r0, #0x2000
 8055c56: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
 8055c5a: b160         	cbz	r0, 0x8055c76 <xTaskResumeAll+0x26a> @ imm = #0x18
 8055c5c: e7ff         	b	0x8055c5e <xTaskResumeAll+0x252> @ imm = #-0x2
 8055c5e: 2001         	movs	r0, #0x1
;                             xAlreadyYielded = pdTRUE;
 8055c60: 9006         	str	r0, [sp, #0x18]
;                             taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
 8055c62: e7ff         	b	0x8055c64 <xTaskResumeAll+0x258> @ imm = #-0x2
 8055c64: f240 1000    	movw	r0, #0x100
 8055c68: f2c2 0000    	movt	r0, #0x2000
 8055c6c: 6800         	ldr	r0, [r0]
 8055c6e: 480b         	ldr	r0, [pc, #0x2c]         @ 0x8055c9c <xTaskResumeAll+0x290>
 8055c70: 4780         	blx	r0
 8055c72: e7ff         	b	0x8055c74 <xTaskResumeAll+0x268> @ imm = #-0x2
;                     }
 8055c74: e000         	b	0x8055c78 <xTaskResumeAll+0x26c> @ imm = #0x0
 8055c76: e7ff         	b	0x8055c78 <xTaskResumeAll+0x26c> @ imm = #-0x2
;                 }
 8055c78: e7ff         	b	0x8055c7a <xTaskResumeAll+0x26e> @ imm = #-0x2
;             }
 8055c7a: e000         	b	0x8055c7e <xTaskResumeAll+0x272> @ imm = #0x0
 8055c7c: e7ff         	b	0x8055c7e <xTaskResumeAll+0x272> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 8055c7e: 4808         	ldr	r0, [pc, #0x20]         @ 0x8055ca0 <xTaskResumeAll+0x294>
 8055c80: 4780         	blx	r0
;     return xAlreadyYielded;
 8055c82: 9806         	ldr	r0, [sp, #0x18]
 8055c84: b008         	add	sp, #0x20
 8055c86: bc80         	pop	{r7}
 8055c88: eba8 0809    	sub.w	r8, r8, r9
 8055c8c: f858 fd30    	ldr	pc, [r8, #-48]!

08055c90 <$d.19>:
 8055c90: 49 cd 05 08  	.word	0x0805cd49
 8055c94: 1d 57 05 08  	.word	0x0805571d
 8055c98: 2d 68 05 08  	.word	0x0805682d
 8055c9c: 2f cd 05 08  	.word	0x0805cd2f
 8055ca0: 7d cd 05 08  	.word	0x0805cd7d
 8055ca4: 15 d7 05 08  	.word	0x0805d715

08055ca8 <vTaskDelay>:
;     {
 8055ca8: f848 eb48    	str	lr, [r8], #72
 8055cac: eb08 0809    	add.w	r8, r8, r9
 8055cb0: b480         	push	{r7}
 8055cb2: 466f         	mov	r7, sp
 8055cb4: b082         	sub	sp, #0x8
 8055cb6: 9001         	str	r0, [sp, #0x4]
 8055cb8: 2000         	movs	r0, #0x0
;         BaseType_t xAlreadyYielded = pdFALSE;
 8055cba: 9000         	str	r0, [sp]
;         if( xTicksToDelay > ( TickType_t ) 0U )
 8055cbc: 9801         	ldr	r0, [sp, #0x4]
 8055cbe: b1b0         	cbz	r0, 0x8055cee <vTaskDelay+0x46> @ imm = #0x2c
 8055cc0: e7ff         	b	0x8055cc2 <vTaskDelay+0x1a> @ imm = #-0x2
;             vTaskSuspendAll();
 8055cc2: 4812         	ldr	r0, [pc, #0x48]         @ 0x8055d0c <vTaskDelay+0x64>
 8055cc4: 4780         	blx	r0
;                 configASSERT( uxSchedulerSuspended == 1U );
 8055cc6: f240 1028    	movw	r0, #0x128
 8055cca: f2c2 0000    	movt	r0, #0x2000
 8055cce: 6800         	ldr	r0, [r0]
 8055cd0: 2801         	cmp	r0, #0x1
 8055cd2: d004         	beq	0x8055cde <vTaskDelay+0x36> @ imm = #0x8
 8055cd4: e7ff         	b	0x8055cd6 <vTaskDelay+0x2e> @ imm = #-0x2
 8055cd6: 4811         	ldr	r0, [pc, #0x44]         @ 0x8055d1c <vTaskDelay+0x74>
 8055cd8: 4780         	blx	r0
 8055cda: e7ff         	b	0x8055cdc <vTaskDelay+0x34> @ imm = #-0x2
 8055cdc: e7fe         	b	0x8055cdc <vTaskDelay+0x34> @ imm = #-0x4
;                 prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8055cde: 9801         	ldr	r0, [sp, #0x4]
 8055ce0: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8055d10 <vTaskDelay+0x68>
 8055ce2: 2100         	movs	r1, #0x0
 8055ce4: 4790         	blx	r2
;             xAlreadyYielded = xTaskResumeAll();
 8055ce6: 480b         	ldr	r0, [pc, #0x2c]         @ 0x8055d14 <vTaskDelay+0x6c>
 8055ce8: 4780         	blx	r0
 8055cea: 9000         	str	r0, [sp]
;         }
 8055cec: e000         	b	0x8055cf0 <vTaskDelay+0x48> @ imm = #0x0
 8055cee: e7ff         	b	0x8055cf0 <vTaskDelay+0x48> @ imm = #-0x2
;         if( xAlreadyYielded == pdFALSE )
 8055cf0: 9800         	ldr	r0, [sp]
 8055cf2: b918         	cbnz	r0, 0x8055cfc <vTaskDelay+0x54> @ imm = #0x6
 8055cf4: e7ff         	b	0x8055cf6 <vTaskDelay+0x4e> @ imm = #-0x2
;             taskYIELD_WITHIN_API();
 8055cf6: 4808         	ldr	r0, [pc, #0x20]         @ 0x8055d18 <vTaskDelay+0x70>
 8055cf8: 4780         	blx	r0
;         }
 8055cfa: e000         	b	0x8055cfe <vTaskDelay+0x56> @ imm = #0x0
 8055cfc: e7ff         	b	0x8055cfe <vTaskDelay+0x56> @ imm = #-0x2
;     }
 8055cfe: b002         	add	sp, #0x8
 8055d00: bc80         	pop	{r7}
 8055d02: eba8 0809    	sub.w	r8, r8, r9
 8055d06: f858 fd48    	ldr	pc, [r8, #-72]!
 8055d0a: bf00         	nop

08055d0c <$d.21>:
 8055d0c: d9 58 05 08  	.word	0x080558d9
 8055d10: e9 58 05 08  	.word	0x080558e9
 8055d14: 0d 5a 05 08  	.word	0x08055a0d
 8055d18: 2f cd 05 08  	.word	0x0805cd2f
 8055d1c: 15 d7 05 08  	.word	0x0805d715

08055d20 <eTaskGetState>:
;     {
 8055d20: f848 eb08    	str	lr, [r8], #8
 8055d24: eb08 0809    	add.w	r8, r8, r9
 8055d28: b480         	push	{r7}
 8055d2a: 466f         	mov	r7, sp
 8055d2c: b088         	sub	sp, #0x20
 8055d2e: 9007         	str	r0, [sp, #0x1c]
;         const TCB_t * const pxTCB = xTask;
 8055d30: 9807         	ldr	r0, [sp, #0x1c]
 8055d32: 9001         	str	r0, [sp, #0x4]
;         configASSERT( pxTCB );
 8055d34: 9801         	ldr	r0, [sp, #0x4]
 8055d36: b920         	cbnz	r0, 0x8055d42 <eTaskGetState+0x22> @ imm = #0x8
 8055d38: e7ff         	b	0x8055d3a <eTaskGetState+0x1a> @ imm = #-0x2
 8055d3a: 484a         	ldr	r0, [pc, #0x128]        @ 0x8055e64 <eTaskGetState+0x144>
 8055d3c: 4780         	blx	r0
 8055d3e: e7ff         	b	0x8055d40 <eTaskGetState+0x20> @ imm = #-0x2
 8055d40: e7fe         	b	0x8055d40 <eTaskGetState+0x20> @ imm = #-0x4
;             if( pxTCB == pxCurrentTCB )
 8055d42: 9801         	ldr	r0, [sp, #0x4]
 8055d44: f240 1100    	movw	r1, #0x100
 8055d48: f2c2 0100    	movt	r1, #0x2000
 8055d4c: 6809         	ldr	r1, [r1]
 8055d4e: 4288         	cmp	r0, r1
 8055d50: d104         	bne	0x8055d5c <eTaskGetState+0x3c> @ imm = #0x8
 8055d52: e7ff         	b	0x8055d54 <eTaskGetState+0x34> @ imm = #-0x2
 8055d54: 2000         	movs	r0, #0x0
;                 eReturn = eRunning;
 8055d56: f807 0c05    	strb	r0, [r7, #-5]
;             }
 8055d5a: e076         	b	0x8055e4a <eTaskGetState+0x12a> @ imm = #0xec
;             taskENTER_CRITICAL();
 8055d5c: 483f         	ldr	r0, [pc, #0xfc]         @ 0x8055e5c <eTaskGetState+0x13c>
 8055d5e: 4780         	blx	r0
;                 pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 8055d60: 9801         	ldr	r0, [sp, #0x4]
 8055d62: f8d0 0090    	ldr.w	r0, [r0, #0x90]
 8055d66: 9005         	str	r0, [sp, #0x14]
;                 pxEventList = listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) );
 8055d68: 9801         	ldr	r0, [sp, #0x4]
 8055d6a: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
 8055d6e: 9004         	str	r0, [sp, #0x10]
;                 pxDelayedList = pxDelayedTaskList;
 8055d70: f240 1030    	movw	r0, #0x130
 8055d74: f2c2 0000    	movt	r0, #0x2000
 8055d78: 6800         	ldr	r0, [r0]
 8055d7a: 9003         	str	r0, [sp, #0xc]
;                 pxOverflowedDelayedList = pxOverflowDelayedTaskList;
 8055d7c: f240 1034    	movw	r0, #0x134
 8055d80: f2c2 0000    	movt	r0, #0x2000
 8055d84: 6800         	ldr	r0, [r0]
 8055d86: 9002         	str	r0, [sp, #0x8]
;             taskEXIT_CRITICAL();
 8055d88: 4835         	ldr	r0, [pc, #0xd4]         @ 0x8055e60 <eTaskGetState+0x140>
 8055d8a: 4780         	blx	r0
;             if( pxEventList == &xPendingReadyList )
 8055d8c: 9804         	ldr	r0, [sp, #0x10]
 8055d8e: f240 1138    	movw	r1, #0x138
 8055d92: f2c2 0100    	movt	r1, #0x2000
 8055d96: 4288         	cmp	r0, r1
 8055d98: d104         	bne	0x8055da4 <eTaskGetState+0x84> @ imm = #0x8
 8055d9a: e7ff         	b	0x8055d9c <eTaskGetState+0x7c> @ imm = #-0x2
 8055d9c: 2001         	movs	r0, #0x1
;                 eReturn = eReady;
 8055d9e: f807 0c05    	strb	r0, [r7, #-5]
;             }
 8055da2: e051         	b	0x8055e48 <eTaskGetState+0x128> @ imm = #0xa2
;             else if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
 8055da4: 9805         	ldr	r0, [sp, #0x14]
 8055da6: 9903         	ldr	r1, [sp, #0xc]
 8055da8: 4288         	cmp	r0, r1
 8055daa: d005         	beq	0x8055db8 <eTaskGetState+0x98> @ imm = #0xa
 8055dac: e7ff         	b	0x8055dae <eTaskGetState+0x8e> @ imm = #-0x2
 8055dae: 9805         	ldr	r0, [sp, #0x14]
 8055db0: 9902         	ldr	r1, [sp, #0x8]
 8055db2: 4288         	cmp	r0, r1
 8055db4: d104         	bne	0x8055dc0 <eTaskGetState+0xa0> @ imm = #0x8
 8055db6: e7ff         	b	0x8055db8 <eTaskGetState+0x98> @ imm = #-0x2
 8055db8: 2002         	movs	r0, #0x2
;                 eReturn = eBlocked;
 8055dba: f807 0c05    	strb	r0, [r7, #-5]
;             }
 8055dbe: e042         	b	0x8055e46 <eTaskGetState+0x126> @ imm = #0x84
;                 else if( pxStateList == &xSuspendedTaskList )
 8055dc0: 9805         	ldr	r0, [sp, #0x14]
 8055dc2: f240 114c    	movw	r1, #0x14c
 8055dc6: f2c2 0100    	movt	r1, #0x2000
 8055dca: 4288         	cmp	r0, r1
 8055dcc: d126         	bne	0x8055e1c <eTaskGetState+0xfc> @ imm = #0x4c
 8055dce: e7ff         	b	0x8055dd0 <eTaskGetState+0xb0> @ imm = #-0x2
;                     if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 8055dd0: 9801         	ldr	r0, [sp, #0x4]
 8055dd2: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
 8055dd6: b9e0         	cbnz	r0, 0x8055e12 <eTaskGetState+0xf2> @ imm = #0x38
 8055dd8: e7ff         	b	0x8055dda <eTaskGetState+0xba> @ imm = #-0x2
 8055dda: 2003         	movs	r0, #0x3
;                             eReturn = eSuspended;
 8055ddc: f807 0c05    	strb	r0, [r7, #-5]
 8055de0: 2000         	movs	r0, #0x0
;                             for( x = ( BaseType_t ) 0; x < ( BaseType_t ) configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 8055de2: 9000         	str	r0, [sp]
 8055de4: e7ff         	b	0x8055de6 <eTaskGetState+0xc6> @ imm = #-0x2
 8055de6: 9800         	ldr	r0, [sp]
 8055de8: 2800         	cmp	r0, #0x0
 8055dea: dc11         	bgt	0x8055e10 <eTaskGetState+0xf0> @ imm = #0x22
 8055dec: e7ff         	b	0x8055dee <eTaskGetState+0xce> @ imm = #-0x2
;                                 if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 8055dee: 9801         	ldr	r0, [sp, #0x4]
 8055df0: 9900         	ldr	r1, [sp]
 8055df2: 4408         	add	r0, r1
 8055df4: f890 00d4    	ldrb.w	r0, [r0, #0xd4]
 8055df8: 2801         	cmp	r0, #0x1
 8055dfa: d104         	bne	0x8055e06 <eTaskGetState+0xe6> @ imm = #0x8
 8055dfc: e7ff         	b	0x8055dfe <eTaskGetState+0xde> @ imm = #-0x2
 8055dfe: 2002         	movs	r0, #0x2
;                                     eReturn = eBlocked;
 8055e00: f807 0c05    	strb	r0, [r7, #-5]
;                                     break;
 8055e04: e004         	b	0x8055e10 <eTaskGetState+0xf0> @ imm = #0x8
;                             }
 8055e06: e7ff         	b	0x8055e08 <eTaskGetState+0xe8> @ imm = #-0x2
;                             for( x = ( BaseType_t ) 0; x < ( BaseType_t ) configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 8055e08: 9800         	ldr	r0, [sp]
 8055e0a: 3001         	adds	r0, #0x1
 8055e0c: 9000         	str	r0, [sp]
 8055e0e: e7ea         	b	0x8055de6 <eTaskGetState+0xc6> @ imm = #-0x2c
;                     }
 8055e10: e003         	b	0x8055e1a <eTaskGetState+0xfa> @ imm = #0x6
 8055e12: 2002         	movs	r0, #0x2
;                         eReturn = eBlocked;
 8055e14: f807 0c05    	strb	r0, [r7, #-5]
 8055e18: e7ff         	b	0x8055e1a <eTaskGetState+0xfa> @ imm = #-0x2
;                 }
 8055e1a: e013         	b	0x8055e44 <eTaskGetState+0x124> @ imm = #0x26
;                 else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 8055e1c: 9805         	ldr	r0, [sp, #0x14]
 8055e1e: f240 1108    	movw	r1, #0x108
 8055e22: f2c2 0100    	movt	r1, #0x2000
 8055e26: 4288         	cmp	r0, r1
 8055e28: d003         	beq	0x8055e32 <eTaskGetState+0x112> @ imm = #0x6
 8055e2a: e7ff         	b	0x8055e2c <eTaskGetState+0x10c> @ imm = #-0x2
 8055e2c: 9805         	ldr	r0, [sp, #0x14]
 8055e2e: b920         	cbnz	r0, 0x8055e3a <eTaskGetState+0x11a> @ imm = #0x8
 8055e30: e7ff         	b	0x8055e32 <eTaskGetState+0x112> @ imm = #-0x2
 8055e32: 2004         	movs	r0, #0x4
;                     eReturn = eDeleted;
 8055e34: f807 0c05    	strb	r0, [r7, #-5]
;                 }
 8055e38: e003         	b	0x8055e42 <eTaskGetState+0x122> @ imm = #0x6
 8055e3a: 2001         	movs	r0, #0x1
;                     eReturn = eReady;
 8055e3c: f807 0c05    	strb	r0, [r7, #-5]
 8055e40: e7ff         	b	0x8055e42 <eTaskGetState+0x122> @ imm = #-0x2
 8055e42: e7ff         	b	0x8055e44 <eTaskGetState+0x124> @ imm = #-0x2
 8055e44: e7ff         	b	0x8055e46 <eTaskGetState+0x126> @ imm = #-0x2
 8055e46: e7ff         	b	0x8055e48 <eTaskGetState+0x128> @ imm = #-0x2
 8055e48: e7ff         	b	0x8055e4a <eTaskGetState+0x12a> @ imm = #-0x2
;         return eReturn;
 8055e4a: f817 0c05    	ldrb	r0, [r7, #-5]
 8055e4e: b008         	add	sp, #0x20
 8055e50: bc80         	pop	{r7}
 8055e52: eba8 0809    	sub.w	r8, r8, r9
 8055e56: f858 fd08    	ldr	pc, [r8, #-8]!
 8055e5a: bf00         	nop

08055e5c <$d.23>:
 8055e5c: 49 cd 05 08  	.word	0x0805cd49
 8055e60: 7d cd 05 08  	.word	0x0805cd7d
 8055e64: 15 d7 05 08  	.word	0x0805d715

08055e68 <uxTaskPriorityGet>:
;     {
 8055e68: f848 eb4c    	str	lr, [r8], #76
 8055e6c: eb08 0809    	add.w	r8, r8, r9
 8055e70: b480         	push	{r7}
 8055e72: 466f         	mov	r7, sp
 8055e74: b084         	sub	sp, #0x10
 8055e76: 9003         	str	r0, [sp, #0xc]
;         taskENTER_CRITICAL();
 8055e78: 480e         	ldr	r0, [pc, #0x38]         @ 0x8055eb4 <uxTaskPriorityGet+0x4c>
 8055e7a: 4780         	blx	r0
;             pxTCB = prvGetTCBFromHandle( xTask );
 8055e7c: 9803         	ldr	r0, [sp, #0xc]
 8055e7e: b938         	cbnz	r0, 0x8055e90 <uxTaskPriorityGet+0x28> @ imm = #0xe
 8055e80: e7ff         	b	0x8055e82 <uxTaskPriorityGet+0x1a> @ imm = #-0x2
 8055e82: f240 1000    	movw	r0, #0x100
 8055e86: f2c2 0000    	movt	r0, #0x2000
 8055e8a: 6800         	ldr	r0, [r0]
 8055e8c: 9000         	str	r0, [sp]
 8055e8e: e002         	b	0x8055e96 <uxTaskPriorityGet+0x2e> @ imm = #0x4
 8055e90: 9803         	ldr	r0, [sp, #0xc]
 8055e92: 9000         	str	r0, [sp]
 8055e94: e7ff         	b	0x8055e96 <uxTaskPriorityGet+0x2e> @ imm = #-0x2
 8055e96: 9800         	ldr	r0, [sp]
 8055e98: 9002         	str	r0, [sp, #0x8]
;             uxReturn = pxTCB->uxPriority;
 8055e9a: 9802         	ldr	r0, [sp, #0x8]
 8055e9c: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8055ea0: 9001         	str	r0, [sp, #0x4]
;         taskEXIT_CRITICAL();
 8055ea2: 4805         	ldr	r0, [pc, #0x14]         @ 0x8055eb8 <uxTaskPriorityGet+0x50>
 8055ea4: 4780         	blx	r0
;         return uxReturn;
 8055ea6: 9801         	ldr	r0, [sp, #0x4]
 8055ea8: b004         	add	sp, #0x10
 8055eaa: bc80         	pop	{r7}
 8055eac: eba8 0809    	sub.w	r8, r8, r9
 8055eb0: f858 fd4c    	ldr	pc, [r8, #-76]!

08055eb4 <$d.25>:
 8055eb4: 49 cd 05 08  	.word	0x0805cd49
 8055eb8: 7d cd 05 08  	.word	0x0805cd7d

08055ebc <uxTaskPriorityGetFromISR>:
;     {
 8055ebc: f848 eb50    	str	lr, [r8], #80
 8055ec0: eb08 0809    	add.w	r8, r8, r9
 8055ec4: b480         	push	{r7}
 8055ec6: 466f         	mov	r7, sp
 8055ec8: b086         	sub	sp, #0x18
 8055eca: 9005         	str	r0, [sp, #0x14]
;         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8055ecc: 4810         	ldr	r0, [pc, #0x40]         @ 0x8055f10 <uxTaskPriorityGetFromISR+0x54>
 8055ece: 4780         	blx	r0
;         uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
 8055ed0: 4810         	ldr	r0, [pc, #0x40]         @ 0x8055f14 <uxTaskPriorityGetFromISR+0x58>
 8055ed2: 4780         	blx	r0
 8055ed4: 9002         	str	r0, [sp, #0x8]
;             pxTCB = prvGetTCBFromHandle( xTask );
 8055ed6: 9805         	ldr	r0, [sp, #0x14]
 8055ed8: b938         	cbnz	r0, 0x8055eea <uxTaskPriorityGetFromISR+0x2e> @ imm = #0xe
 8055eda: e7ff         	b	0x8055edc <uxTaskPriorityGetFromISR+0x20> @ imm = #-0x2
 8055edc: f240 1000    	movw	r0, #0x100
 8055ee0: f2c2 0000    	movt	r0, #0x2000
 8055ee4: 6800         	ldr	r0, [r0]
 8055ee6: 9001         	str	r0, [sp, #0x4]
 8055ee8: e002         	b	0x8055ef0 <uxTaskPriorityGetFromISR+0x34> @ imm = #0x4
 8055eea: 9805         	ldr	r0, [sp, #0x14]
 8055eec: 9001         	str	r0, [sp, #0x4]
 8055eee: e7ff         	b	0x8055ef0 <uxTaskPriorityGetFromISR+0x34> @ imm = #-0x2
 8055ef0: 9801         	ldr	r0, [sp, #0x4]
 8055ef2: 9004         	str	r0, [sp, #0x10]
;             uxReturn = pxTCB->uxPriority;
 8055ef4: 9804         	ldr	r0, [sp, #0x10]
 8055ef6: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8055efa: 9003         	str	r0, [sp, #0xc]
;         taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
 8055efc: 9802         	ldr	r0, [sp, #0x8]
 8055efe: 4906         	ldr	r1, [pc, #0x18]         @ 0x8055f18 <uxTaskPriorityGetFromISR+0x5c>
 8055f00: 4788         	blx	r1
;         return uxReturn;
 8055f02: 9803         	ldr	r0, [sp, #0xc]
 8055f04: b006         	add	sp, #0x18
 8055f06: bc80         	pop	{r7}
 8055f08: eba8 0809    	sub.w	r8, r8, r9
 8055f0c: f858 fd50    	ldr	pc, [r8, #-80]!

08055f10 <$d.27>:
 8055f10: 1d f8 05 08  	.word	0x0805f81d
 8055f14: 15 d7 05 08  	.word	0x0805d715
 8055f18: 2b d7 05 08  	.word	0x0805d72b

08055f1c <uxTaskBasePriorityGet>:
;     {
 8055f1c: f848 eb20    	str	lr, [r8], #32
 8055f20: eb08 0809    	add.w	r8, r8, r9
 8055f24: b480         	push	{r7}
 8055f26: 466f         	mov	r7, sp
 8055f28: b084         	sub	sp, #0x10
 8055f2a: 9003         	str	r0, [sp, #0xc]
;         taskENTER_CRITICAL();
 8055f2c: 480e         	ldr	r0, [pc, #0x38]         @ 0x8055f68 <uxTaskBasePriorityGet+0x4c>
 8055f2e: 4780         	blx	r0
;             pxTCB = prvGetTCBFromHandle( xTask );
 8055f30: 9803         	ldr	r0, [sp, #0xc]
 8055f32: b938         	cbnz	r0, 0x8055f44 <uxTaskBasePriorityGet+0x28> @ imm = #0xe
 8055f34: e7ff         	b	0x8055f36 <uxTaskBasePriorityGet+0x1a> @ imm = #-0x2
 8055f36: f240 1000    	movw	r0, #0x100
 8055f3a: f2c2 0000    	movt	r0, #0x2000
 8055f3e: 6800         	ldr	r0, [r0]
 8055f40: 9000         	str	r0, [sp]
 8055f42: e002         	b	0x8055f4a <uxTaskBasePriorityGet+0x2e> @ imm = #0x4
 8055f44: 9803         	ldr	r0, [sp, #0xc]
 8055f46: 9000         	str	r0, [sp]
 8055f48: e7ff         	b	0x8055f4a <uxTaskBasePriorityGet+0x2e> @ imm = #-0x2
 8055f4a: 9800         	ldr	r0, [sp]
 8055f4c: 9002         	str	r0, [sp, #0x8]
;             uxReturn = pxTCB->uxBasePriority;
 8055f4e: 9802         	ldr	r0, [sp, #0x8]
 8055f50: f8d0 00c8    	ldr.w	r0, [r0, #0xc8]
 8055f54: 9001         	str	r0, [sp, #0x4]
;         taskEXIT_CRITICAL();
 8055f56: 4805         	ldr	r0, [pc, #0x14]         @ 0x8055f6c <uxTaskBasePriorityGet+0x50>
 8055f58: 4780         	blx	r0
;         return uxReturn;
 8055f5a: 9801         	ldr	r0, [sp, #0x4]
 8055f5c: b004         	add	sp, #0x10
 8055f5e: bc80         	pop	{r7}
 8055f60: eba8 0809    	sub.w	r8, r8, r9
 8055f64: f858 fd20    	ldr	pc, [r8, #-32]!

08055f68 <$d.29>:
 8055f68: 49 cd 05 08  	.word	0x0805cd49
 8055f6c: 7d cd 05 08  	.word	0x0805cd7d

08055f70 <uxTaskBasePriorityGetFromISR>:
;     {
 8055f70: f848 eb78    	str	lr, [r8], #120
 8055f74: eb08 0809    	add.w	r8, r8, r9
 8055f78: b480         	push	{r7}
 8055f7a: 466f         	mov	r7, sp
 8055f7c: b086         	sub	sp, #0x18
 8055f7e: 9005         	str	r0, [sp, #0x14]
;         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8055f80: 4810         	ldr	r0, [pc, #0x40]         @ 0x8055fc4 <uxTaskBasePriorityGetFromISR+0x54>
 8055f82: 4780         	blx	r0
;         uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
 8055f84: 4810         	ldr	r0, [pc, #0x40]         @ 0x8055fc8 <uxTaskBasePriorityGetFromISR+0x58>
 8055f86: 4780         	blx	r0
 8055f88: 9002         	str	r0, [sp, #0x8]
;             pxTCB = prvGetTCBFromHandle( xTask );
 8055f8a: 9805         	ldr	r0, [sp, #0x14]
 8055f8c: b938         	cbnz	r0, 0x8055f9e <uxTaskBasePriorityGetFromISR+0x2e> @ imm = #0xe
 8055f8e: e7ff         	b	0x8055f90 <uxTaskBasePriorityGetFromISR+0x20> @ imm = #-0x2
 8055f90: f240 1000    	movw	r0, #0x100
 8055f94: f2c2 0000    	movt	r0, #0x2000
 8055f98: 6800         	ldr	r0, [r0]
 8055f9a: 9001         	str	r0, [sp, #0x4]
 8055f9c: e002         	b	0x8055fa4 <uxTaskBasePriorityGetFromISR+0x34> @ imm = #0x4
 8055f9e: 9805         	ldr	r0, [sp, #0x14]
 8055fa0: 9001         	str	r0, [sp, #0x4]
 8055fa2: e7ff         	b	0x8055fa4 <uxTaskBasePriorityGetFromISR+0x34> @ imm = #-0x2
 8055fa4: 9801         	ldr	r0, [sp, #0x4]
 8055fa6: 9004         	str	r0, [sp, #0x10]
;             uxReturn = pxTCB->uxBasePriority;
 8055fa8: 9804         	ldr	r0, [sp, #0x10]
 8055faa: f8d0 00c8    	ldr.w	r0, [r0, #0xc8]
 8055fae: 9003         	str	r0, [sp, #0xc]
;         taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
 8055fb0: 9802         	ldr	r0, [sp, #0x8]
 8055fb2: 4906         	ldr	r1, [pc, #0x18]         @ 0x8055fcc <uxTaskBasePriorityGetFromISR+0x5c>
 8055fb4: 4788         	blx	r1
;         return uxReturn;
 8055fb6: 9803         	ldr	r0, [sp, #0xc]
 8055fb8: b006         	add	sp, #0x18
 8055fba: bc80         	pop	{r7}
 8055fbc: eba8 0809    	sub.w	r8, r8, r9
 8055fc0: f858 fd78    	ldr	pc, [r8, #-120]!

08055fc4 <$d.31>:
 8055fc4: 1d f8 05 08  	.word	0x0805f81d
 8055fc8: 15 d7 05 08  	.word	0x0805d715
 8055fcc: 2b d7 05 08  	.word	0x0805d72b

08055fd0 <vTaskPrioritySet>:
;     {
 8055fd0: f848 eb04    	str	lr, [r8], #4
 8055fd4: eb08 0809    	add.w	r8, r8, r9
 8055fd8: b480         	push	{r7}
 8055fda: 466f         	mov	r7, sp
 8055fdc: b088         	sub	sp, #0x20
 8055fde: 9007         	str	r0, [sp, #0x1c]
 8055fe0: 9106         	str	r1, [sp, #0x18]
 8055fe2: 2000         	movs	r0, #0x0
;         BaseType_t xYieldRequired = pdFALSE;
 8055fe4: 9002         	str	r0, [sp, #0x8]
;         configASSERT( uxNewPriority < configMAX_PRIORITIES );
 8055fe6: 9806         	ldr	r0, [sp, #0x18]
 8055fe8: 2810         	cmp	r0, #0x10
 8055fea: d304         	blo	0x8055ff6 <vTaskPrioritySet+0x26> @ imm = #0x8
 8055fec: e7ff         	b	0x8055fee <vTaskPrioritySet+0x1e> @ imm = #-0x2
 8055fee: 4880         	ldr	r0, [pc, #0x200]        @ 0x80561f0 <vTaskPrioritySet+0x220>
 8055ff0: 4780         	blx	r0
 8055ff2: e7ff         	b	0x8055ff4 <vTaskPrioritySet+0x24> @ imm = #-0x2
 8055ff4: e7fe         	b	0x8055ff4 <vTaskPrioritySet+0x24> @ imm = #-0x4
;         if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 8055ff6: 9806         	ldr	r0, [sp, #0x18]
 8055ff8: 2810         	cmp	r0, #0x10
 8055ffa: d303         	blo	0x8056004 <vTaskPrioritySet+0x34> @ imm = #0x6
 8055ffc: e7ff         	b	0x8055ffe <vTaskPrioritySet+0x2e> @ imm = #-0x2
 8055ffe: 200f         	movs	r0, #0xf
;             uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 8056000: 9006         	str	r0, [sp, #0x18]
;         }
 8056002: e000         	b	0x8056006 <vTaskPrioritySet+0x36> @ imm = #0x0
 8056004: e7ff         	b	0x8056006 <vTaskPrioritySet+0x36> @ imm = #-0x2
;         taskENTER_CRITICAL();
 8056006: 4876         	ldr	r0, [pc, #0x1d8]        @ 0x80561e0 <vTaskPrioritySet+0x210>
 8056008: 4780         	blx	r0
;             pxTCB = prvGetTCBFromHandle( xTask );
 805600a: 9807         	ldr	r0, [sp, #0x1c]
 805600c: b938         	cbnz	r0, 0x805601e <vTaskPrioritySet+0x4e> @ imm = #0xe
 805600e: e7ff         	b	0x8056010 <vTaskPrioritySet+0x40> @ imm = #-0x2
 8056010: f240 1000    	movw	r0, #0x100
 8056014: f2c2 0000    	movt	r0, #0x2000
 8056018: 6800         	ldr	r0, [r0]
 805601a: 9000         	str	r0, [sp]
 805601c: e002         	b	0x8056024 <vTaskPrioritySet+0x54> @ imm = #0x4
 805601e: 9807         	ldr	r0, [sp, #0x1c]
 8056020: 9000         	str	r0, [sp]
 8056022: e7ff         	b	0x8056024 <vTaskPrioritySet+0x54> @ imm = #-0x2
 8056024: 9800         	ldr	r0, [sp]
 8056026: 9005         	str	r0, [sp, #0x14]
;                 uxCurrentBasePriority = pxTCB->uxBasePriority;
 8056028: 9805         	ldr	r0, [sp, #0x14]
 805602a: f8d0 00c8    	ldr.w	r0, [r0, #0xc8]
 805602e: 9004         	str	r0, [sp, #0x10]
;             if( uxCurrentBasePriority != uxNewPriority )
 8056030: 9804         	ldr	r0, [sp, #0x10]
 8056032: 9906         	ldr	r1, [sp, #0x18]
 8056034: 4288         	cmp	r0, r1
 8056036: f000 80ca    	beq.w	0x80561ce <vTaskPrioritySet+0x1fe> @ imm = #0x194
 805603a: e7ff         	b	0x805603c <vTaskPrioritySet+0x6c> @ imm = #-0x2
;                 if( uxNewPriority > uxCurrentBasePriority )
 805603c: 9806         	ldr	r0, [sp, #0x18]
 805603e: 9904         	ldr	r1, [sp, #0x10]
 8056040: 4288         	cmp	r0, r1
 8056042: d91b         	bls	0x805607c <vTaskPrioritySet+0xac> @ imm = #0x36
 8056044: e7ff         	b	0x8056046 <vTaskPrioritySet+0x76> @ imm = #-0x2
;                         if( pxTCB != pxCurrentTCB )
 8056046: 9805         	ldr	r0, [sp, #0x14]
 8056048: f240 1100    	movw	r1, #0x100
 805604c: f2c2 0100    	movt	r1, #0x2000
 8056050: 6809         	ldr	r1, [r1]
 8056052: 4288         	cmp	r0, r1
 8056054: d010         	beq	0x8056078 <vTaskPrioritySet+0xa8> @ imm = #0x20
 8056056: e7ff         	b	0x8056058 <vTaskPrioritySet+0x88> @ imm = #-0x2
;                             if( uxNewPriority > pxCurrentTCB->uxPriority )
 8056058: 9806         	ldr	r0, [sp, #0x18]
 805605a: f240 1100    	movw	r1, #0x100
 805605e: f2c2 0100    	movt	r1, #0x2000
 8056062: 6809         	ldr	r1, [r1]
 8056064: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 8056068: 4288         	cmp	r0, r1
 805606a: d903         	bls	0x8056074 <vTaskPrioritySet+0xa4> @ imm = #0x6
 805606c: e7ff         	b	0x805606e <vTaskPrioritySet+0x9e> @ imm = #-0x2
 805606e: 2001         	movs	r0, #0x1
;                                 xYieldRequired = pdTRUE;
 8056070: 9002         	str	r0, [sp, #0x8]
;                             }
 8056072: e000         	b	0x8056076 <vTaskPrioritySet+0xa6> @ imm = #0x0
 8056074: e7ff         	b	0x8056076 <vTaskPrioritySet+0xa6> @ imm = #-0x2
;                         }
 8056076: e000         	b	0x805607a <vTaskPrioritySet+0xaa> @ imm = #0x0
 8056078: e7ff         	b	0x805607a <vTaskPrioritySet+0xaa> @ imm = #-0x2
;                 }
 805607a: e00d         	b	0x8056098 <vTaskPrioritySet+0xc8> @ imm = #0x1a
;                 else if( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )
 805607c: 9805         	ldr	r0, [sp, #0x14]
 805607e: f240 1100    	movw	r1, #0x100
 8056082: f2c2 0100    	movt	r1, #0x2000
 8056086: 6809         	ldr	r1, [r1]
 8056088: 4288         	cmp	r0, r1
 805608a: d103         	bne	0x8056094 <vTaskPrioritySet+0xc4> @ imm = #0x6
 805608c: e7ff         	b	0x805608e <vTaskPrioritySet+0xbe> @ imm = #-0x2
 805608e: 2001         	movs	r0, #0x1
;                         xYieldRequired = pdTRUE;
 8056090: 9002         	str	r0, [sp, #0x8]
;                 }
 8056092: e000         	b	0x8056096 <vTaskPrioritySet+0xc6> @ imm = #0x0
 8056094: e7ff         	b	0x8056096 <vTaskPrioritySet+0xc6> @ imm = #-0x2
 8056096: e7ff         	b	0x8056098 <vTaskPrioritySet+0xc8> @ imm = #-0x2
;                 uxPriorityUsedOnEntry = pxTCB->uxPriority;
 8056098: 9805         	ldr	r0, [sp, #0x14]
 805609a: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805609e: 9003         	str	r0, [sp, #0xc]
;                     if( ( pxTCB->uxBasePriority == pxTCB->uxPriority ) || ( uxNewPriority > pxTCB->uxPriority ) )
 80560a0: 9805         	ldr	r0, [sp, #0x14]
 80560a2: f8d0 10a8    	ldr.w	r1, [r0, #0xa8]
 80560a6: f8d0 00c8    	ldr.w	r0, [r0, #0xc8]
 80560aa: 4288         	cmp	r0, r1
 80560ac: d007         	beq	0x80560be <vTaskPrioritySet+0xee> @ imm = #0xe
 80560ae: e7ff         	b	0x80560b0 <vTaskPrioritySet+0xe0> @ imm = #-0x2
 80560b0: 9806         	ldr	r0, [sp, #0x18]
 80560b2: 9905         	ldr	r1, [sp, #0x14]
 80560b4: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 80560b8: 4288         	cmp	r0, r1
 80560ba: d905         	bls	0x80560c8 <vTaskPrioritySet+0xf8> @ imm = #0xa
 80560bc: e7ff         	b	0x80560be <vTaskPrioritySet+0xee> @ imm = #-0x2
;                         pxTCB->uxPriority = uxNewPriority;
 80560be: 9806         	ldr	r0, [sp, #0x18]
 80560c0: 9905         	ldr	r1, [sp, #0x14]
 80560c2: f8c1 00a8    	str.w	r0, [r1, #0xa8]
;                     }
 80560c6: e000         	b	0x80560ca <vTaskPrioritySet+0xfa> @ imm = #0x0
 80560c8: e7ff         	b	0x80560ca <vTaskPrioritySet+0xfa> @ imm = #-0x2
;                     pxTCB->uxBasePriority = uxNewPriority;
 80560ca: 9806         	ldr	r0, [sp, #0x18]
 80560cc: 9905         	ldr	r1, [sp, #0x14]
 80560ce: f8c1 00c8    	str.w	r0, [r1, #0xc8]
;                 if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80560d2: 9805         	ldr	r0, [sp, #0x14]
 80560d4: f890 0097    	ldrb.w	r0, [r0, #0x97]
 80560d8: 0600         	lsls	r0, r0, #0x18
 80560da: 2800         	cmp	r0, #0x0
 80560dc: d407         	bmi	0x80560ee <vTaskPrioritySet+0x11e> @ imm = #0xe
 80560de: e7ff         	b	0x80560e0 <vTaskPrioritySet+0x110> @ imm = #-0x2
;                     listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80560e0: 9806         	ldr	r0, [sp, #0x18]
 80560e2: f1c0 0010    	rsb.w	r0, r0, #0x10
 80560e6: 9905         	ldr	r1, [sp, #0x14]
 80560e8: f8c1 0094    	str.w	r0, [r1, #0x94]
;                 }
 80560ec: e000         	b	0x80560f0 <vTaskPrioritySet+0x120> @ imm = #0x0
 80560ee: e7ff         	b	0x80560f0 <vTaskPrioritySet+0x120> @ imm = #-0x2
;                 if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80560f0: 9805         	ldr	r0, [sp, #0x14]
 80560f2: f8d0 0090    	ldr.w	r0, [r0, #0x90]
 80560f6: 9903         	ldr	r1, [sp, #0xc]
 80560f8: eb01 0281    	add.w	r2, r1, r1, lsl #2
 80560fc: f240 1160    	movw	r1, #0x160
 8056100: f2c2 0100    	movt	r1, #0x2000
 8056104: eb01 0182    	add.w	r1, r1, r2, lsl #2
 8056108: 4288         	cmp	r0, r1
 805610a: d155         	bne	0x80561b8 <vTaskPrioritySet+0x1e8> @ imm = #0xaa
 805610c: e7ff         	b	0x805610e <vTaskPrioritySet+0x13e> @ imm = #-0x2
;                     if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 805610e: 9805         	ldr	r0, [sp, #0x14]
 8056110: 3080         	adds	r0, #0x80
 8056112: 4934         	ldr	r1, [pc, #0xd0]         @ 0x80561e4 <vTaskPrioritySet+0x214>
 8056114: 4788         	blx	r1
 8056116: b908         	cbnz	r0, 0x805611c <vTaskPrioritySet+0x14c> @ imm = #0x2
 8056118: e7ff         	b	0x805611a <vTaskPrioritySet+0x14a> @ imm = #-0x2
;                     }
 805611a: e000         	b	0x805611e <vTaskPrioritySet+0x14e> @ imm = #0x0
 805611c: e7ff         	b	0x805611e <vTaskPrioritySet+0x14e> @ imm = #-0x2
;                     prvAddTaskToReadyList( pxTCB );
 805611e: e7ff         	b	0x8056120 <vTaskPrioritySet+0x150> @ imm = #-0x2
 8056120: e7ff         	b	0x8056122 <vTaskPrioritySet+0x152> @ imm = #-0x2
 8056122: 9805         	ldr	r0, [sp, #0x14]
 8056124: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8056128: f240 21a0    	movw	r1, #0x2a0
 805612c: f2c2 0100    	movt	r1, #0x2000
 8056130: 6809         	ldr	r1, [r1]
 8056132: 4288         	cmp	r0, r1
 8056134: d909         	bls	0x805614a <vTaskPrioritySet+0x17a> @ imm = #0x12
 8056136: e7ff         	b	0x8056138 <vTaskPrioritySet+0x168> @ imm = #-0x2
 8056138: 9805         	ldr	r0, [sp, #0x14]
 805613a: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805613e: f240 21a0    	movw	r1, #0x2a0
 8056142: f2c2 0100    	movt	r1, #0x2000
 8056146: 6008         	str	r0, [r1]
 8056148: e7ff         	b	0x805614a <vTaskPrioritySet+0x17a> @ imm = #-0x2
 805614a: e7ff         	b	0x805614c <vTaskPrioritySet+0x17c> @ imm = #-0x2
 805614c: e7ff         	b	0x805614e <vTaskPrioritySet+0x17e> @ imm = #-0x2
 805614e: 9805         	ldr	r0, [sp, #0x14]
 8056150: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8056154: eb00 0080    	add.w	r0, r0, r0, lsl #2
 8056158: f240 1160    	movw	r1, #0x160
 805615c: f2c2 0100    	movt	r1, #0x2000
 8056160: eb01 0080    	add.w	r0, r1, r0, lsl #2
 8056164: 6840         	ldr	r0, [r0, #0x4]
 8056166: 9001         	str	r0, [sp, #0x4]
 8056168: 9801         	ldr	r0, [sp, #0x4]
 805616a: 9a05         	ldr	r2, [sp, #0x14]
 805616c: f8c2 0084    	str.w	r0, [r2, #0x84]
 8056170: 9801         	ldr	r0, [sp, #0x4]
 8056172: 6880         	ldr	r0, [r0, #0x8]
 8056174: 9a05         	ldr	r2, [sp, #0x14]
 8056176: f8c2 0088    	str.w	r0, [r2, #0x88]
 805617a: 9805         	ldr	r0, [sp, #0x14]
 805617c: 3080         	adds	r0, #0x80
 805617e: 9a01         	ldr	r2, [sp, #0x4]
 8056180: 6892         	ldr	r2, [r2, #0x8]
 8056182: 6050         	str	r0, [r2, #0x4]
 8056184: 9805         	ldr	r0, [sp, #0x14]
 8056186: 3080         	adds	r0, #0x80
 8056188: 9a01         	ldr	r2, [sp, #0x4]
 805618a: 6090         	str	r0, [r2, #0x8]
 805618c: 9a05         	ldr	r2, [sp, #0x14]
 805618e: f8d2 00a8    	ldr.w	r0, [r2, #0xa8]
 8056192: eb00 0080    	add.w	r0, r0, r0, lsl #2
 8056196: eb01 0080    	add.w	r0, r1, r0, lsl #2
 805619a: f8c2 0090    	str.w	r0, [r2, #0x90]
 805619e: 9805         	ldr	r0, [sp, #0x14]
 80561a0: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80561a4: eb00 0280    	add.w	r2, r0, r0, lsl #2
 80561a8: f851 0022    	ldr.w	r0, [r1, r2, lsl #2]
 80561ac: 3001         	adds	r0, #0x1
 80561ae: f841 0022    	str.w	r0, [r1, r2, lsl #2]
 80561b2: e7ff         	b	0x80561b4 <vTaskPrioritySet+0x1e4> @ imm = #-0x2
 80561b4: e7ff         	b	0x80561b6 <vTaskPrioritySet+0x1e6> @ imm = #-0x2
;                 }
 80561b6: e000         	b	0x80561ba <vTaskPrioritySet+0x1ea> @ imm = #0x0
 80561b8: e7ff         	b	0x80561ba <vTaskPrioritySet+0x1ea> @ imm = #-0x2
;                 if( xYieldRequired != pdFALSE )
 80561ba: 9802         	ldr	r0, [sp, #0x8]
 80561bc: b128         	cbz	r0, 0x80561ca <vTaskPrioritySet+0x1fa> @ imm = #0xa
 80561be: e7ff         	b	0x80561c0 <vTaskPrioritySet+0x1f0> @ imm = #-0x2
;                     taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxTCB );
 80561c0: e7ff         	b	0x80561c2 <vTaskPrioritySet+0x1f2> @ imm = #-0x2
 80561c2: 4809         	ldr	r0, [pc, #0x24]         @ 0x80561e8 <vTaskPrioritySet+0x218>
 80561c4: 4780         	blx	r0
 80561c6: e7ff         	b	0x80561c8 <vTaskPrioritySet+0x1f8> @ imm = #-0x2
;                 }
 80561c8: e000         	b	0x80561cc <vTaskPrioritySet+0x1fc> @ imm = #0x0
 80561ca: e7ff         	b	0x80561cc <vTaskPrioritySet+0x1fc> @ imm = #-0x2
;             }
 80561cc: e7ff         	b	0x80561ce <vTaskPrioritySet+0x1fe> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 80561ce: 4807         	ldr	r0, [pc, #0x1c]         @ 0x80561ec <vTaskPrioritySet+0x21c>
 80561d0: 4780         	blx	r0
;     }
 80561d2: b008         	add	sp, #0x20
 80561d4: bc80         	pop	{r7}
 80561d6: eba8 0809    	sub.w	r8, r8, r9
 80561da: f858 fd04    	ldr	pc, [r8, #-4]!
 80561de: bf00         	nop

080561e0 <$d.33>:
 80561e0: 49 cd 05 08  	.word	0x0805cd49
 80561e4: 13 a5 05 08  	.word	0x0805a513
 80561e8: 2f cd 05 08  	.word	0x0805cd2f
 80561ec: 7d cd 05 08  	.word	0x0805cd7d
 80561f0: 15 d7 05 08  	.word	0x0805d715

080561f4 <vTaskSuspend>:
;     {
 80561f4: f848 eb64    	str	lr, [r8], #100
 80561f8: eb08 0809    	add.w	r8, r8, r9
 80561fc: b480         	push	{r7}
 80561fe: 466f         	mov	r7, sp
 8056200: b084         	sub	sp, #0x10
 8056202: 9003         	str	r0, [sp, #0xc]
;         taskENTER_CRITICAL();
 8056204: 484b         	ldr	r0, [pc, #0x12c]        @ 0x8056334 <vTaskSuspend+0x140>
 8056206: 4780         	blx	r0
;             pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 8056208: 9803         	ldr	r0, [sp, #0xc]
 805620a: b938         	cbnz	r0, 0x805621c <vTaskSuspend+0x28> @ imm = #0xe
 805620c: e7ff         	b	0x805620e <vTaskSuspend+0x1a> @ imm = #-0x2
 805620e: f240 1000    	movw	r0, #0x100
 8056212: f2c2 0000    	movt	r0, #0x2000
 8056216: 6800         	ldr	r0, [r0]
 8056218: 9000         	str	r0, [sp]
 805621a: e002         	b	0x8056222 <vTaskSuspend+0x2e> @ imm = #0x4
 805621c: 9803         	ldr	r0, [sp, #0xc]
 805621e: 9000         	str	r0, [sp]
 8056220: e7ff         	b	0x8056222 <vTaskSuspend+0x2e> @ imm = #-0x2
 8056222: 9800         	ldr	r0, [sp]
 8056224: 9002         	str	r0, [sp, #0x8]
;             if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8056226: 9802         	ldr	r0, [sp, #0x8]
 8056228: 3080         	adds	r0, #0x80
 805622a: 4943         	ldr	r1, [pc, #0x10c]        @ 0x8056338 <vTaskSuspend+0x144>
 805622c: 4788         	blx	r1
 805622e: b908         	cbnz	r0, 0x8056234 <vTaskSuspend+0x40> @ imm = #0x2
 8056230: e7ff         	b	0x8056232 <vTaskSuspend+0x3e> @ imm = #-0x2
;             }
 8056232: e000         	b	0x8056236 <vTaskSuspend+0x42> @ imm = #0x0
 8056234: e7ff         	b	0x8056236 <vTaskSuspend+0x42> @ imm = #-0x2
;             if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8056236: 9802         	ldr	r0, [sp, #0x8]
 8056238: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
 805623c: b128         	cbz	r0, 0x805624a <vTaskSuspend+0x56> @ imm = #0xa
 805623e: e7ff         	b	0x8056240 <vTaskSuspend+0x4c> @ imm = #-0x2
;                 ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8056240: 9802         	ldr	r0, [sp, #0x8]
 8056242: 3094         	adds	r0, #0x94
 8056244: 493d         	ldr	r1, [pc, #0xf4]         @ 0x805633c <vTaskSuspend+0x148>
 8056246: 4788         	blx	r1
;             }
 8056248: e000         	b	0x805624c <vTaskSuspend+0x58> @ imm = #0x0
 805624a: e7ff         	b	0x805624c <vTaskSuspend+0x58> @ imm = #-0x2
;             vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 805624c: 9802         	ldr	r0, [sp, #0x8]
 805624e: f100 0180    	add.w	r1, r0, #0x80
 8056252: f240 104c    	movw	r0, #0x14c
 8056256: f2c2 0000    	movt	r0, #0x2000
 805625a: 4a39         	ldr	r2, [pc, #0xe4]         @ 0x8056340 <vTaskSuspend+0x14c>
 805625c: 4790         	blx	r2
 805625e: 2000         	movs	r0, #0x0
;                 for( x = ( BaseType_t ) 0; x < ( BaseType_t ) configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 8056260: 9001         	str	r0, [sp, #0x4]
 8056262: e7ff         	b	0x8056264 <vTaskSuspend+0x70> @ imm = #-0x2
 8056264: 9801         	ldr	r0, [sp, #0x4]
 8056266: 2800         	cmp	r0, #0x0
 8056268: dc14         	bgt	0x8056294 <vTaskSuspend+0xa0> @ imm = #0x28
 805626a: e7ff         	b	0x805626c <vTaskSuspend+0x78> @ imm = #-0x2
;                     if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 805626c: 9802         	ldr	r0, [sp, #0x8]
 805626e: 9901         	ldr	r1, [sp, #0x4]
 8056270: 4408         	add	r0, r1
 8056272: f890 00d4    	ldrb.w	r0, [r0, #0xd4]
 8056276: 2801         	cmp	r0, #0x1
 8056278: d107         	bne	0x805628a <vTaskSuspend+0x96> @ imm = #0xe
 805627a: e7ff         	b	0x805627c <vTaskSuspend+0x88> @ imm = #-0x2
;                         pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
 805627c: 9802         	ldr	r0, [sp, #0x8]
 805627e: 9901         	ldr	r1, [sp, #0x4]
 8056280: 4401         	add	r1, r0
 8056282: 2000         	movs	r0, #0x0
 8056284: f881 00d4    	strb.w	r0, [r1, #0xd4]
;                     }
 8056288: e7ff         	b	0x805628a <vTaskSuspend+0x96> @ imm = #-0x2
;                 }
 805628a: e7ff         	b	0x805628c <vTaskSuspend+0x98> @ imm = #-0x2
;                 for( x = ( BaseType_t ) 0; x < ( BaseType_t ) configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 805628c: 9801         	ldr	r0, [sp, #0x4]
 805628e: 3001         	adds	r0, #0x1
 8056290: 9001         	str	r0, [sp, #0x4]
 8056292: e7e7         	b	0x8056264 <vTaskSuspend+0x70> @ imm = #-0x32
;             taskEXIT_CRITICAL();
 8056294: 482b         	ldr	r0, [pc, #0xac]         @ 0x8056344 <vTaskSuspend+0x150>
 8056296: 4780         	blx	r0
;             if( xSchedulerRunning != pdFALSE )
 8056298: f240 1024    	movw	r0, #0x124
 805629c: f2c2 0000    	movt	r0, #0x2000
 80562a0: 6800         	ldr	r0, [r0]
 80562a2: b138         	cbz	r0, 0x80562b4 <vTaskSuspend+0xc0> @ imm = #0xe
 80562a4: e7ff         	b	0x80562a6 <vTaskSuspend+0xb2> @ imm = #-0x2
;                 taskENTER_CRITICAL();
 80562a6: 4828         	ldr	r0, [pc, #0xa0]         @ 0x8056348 <vTaskSuspend+0x154>
 80562a8: 4780         	blx	r0
;                     prvResetNextTaskUnblockTime();
 80562aa: 4828         	ldr	r0, [pc, #0xa0]         @ 0x805634c <vTaskSuspend+0x158>
 80562ac: 4780         	blx	r0
;                 taskEXIT_CRITICAL();
 80562ae: 4828         	ldr	r0, [pc, #0xa0]         @ 0x8056350 <vTaskSuspend+0x15c>
 80562b0: 4780         	blx	r0
;             }
 80562b2: e000         	b	0x80562b6 <vTaskSuspend+0xc2> @ imm = #0x0
 80562b4: e7ff         	b	0x80562b6 <vTaskSuspend+0xc2> @ imm = #-0x2
;             if( pxTCB == pxCurrentTCB )
 80562b6: 9802         	ldr	r0, [sp, #0x8]
 80562b8: f240 1100    	movw	r1, #0x100
 80562bc: f2c2 0100    	movt	r1, #0x2000
 80562c0: 6809         	ldr	r1, [r1]
 80562c2: 4288         	cmp	r0, r1
 80562c4: d12e         	bne	0x8056324 <vTaskSuspend+0x130> @ imm = #0x5c
 80562c6: e7ff         	b	0x80562c8 <vTaskSuspend+0xd4> @ imm = #-0x2
;                 if( xSchedulerRunning != pdFALSE )
 80562c8: f240 1024    	movw	r0, #0x124
 80562cc: f2c2 0000    	movt	r0, #0x2000
 80562d0: 6800         	ldr	r0, [r0]
 80562d2: b170         	cbz	r0, 0x80562f2 <vTaskSuspend+0xfe> @ imm = #0x1c
 80562d4: e7ff         	b	0x80562d6 <vTaskSuspend+0xe2> @ imm = #-0x2
;                     configASSERT( uxSchedulerSuspended == 0 );
 80562d6: f240 1028    	movw	r0, #0x128
 80562da: f2c2 0000    	movt	r0, #0x2000
 80562de: 6800         	ldr	r0, [r0]
 80562e0: b120         	cbz	r0, 0x80562ec <vTaskSuspend+0xf8> @ imm = #0x8
 80562e2: e7ff         	b	0x80562e4 <vTaskSuspend+0xf0> @ imm = #-0x2
 80562e4: 481d         	ldr	r0, [pc, #0x74]         @ 0x805635c <vTaskSuspend+0x168>
 80562e6: 4780         	blx	r0
 80562e8: e7ff         	b	0x80562ea <vTaskSuspend+0xf6> @ imm = #-0x2
 80562ea: e7fe         	b	0x80562ea <vTaskSuspend+0xf6> @ imm = #-0x4
;                     portYIELD_WITHIN_API();
 80562ec: 481a         	ldr	r0, [pc, #0x68]         @ 0x8056358 <vTaskSuspend+0x164>
 80562ee: 4780         	blx	r0
;                 }
 80562f0: e017         	b	0x8056322 <vTaskSuspend+0x12e> @ imm = #0x2e
;                     if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 80562f2: f240 104c    	movw	r0, #0x14c
 80562f6: f2c2 0000    	movt	r0, #0x2000
 80562fa: 6800         	ldr	r0, [r0]
 80562fc: f240 1120    	movw	r1, #0x120
 8056300: f2c2 0100    	movt	r1, #0x2000
 8056304: 6809         	ldr	r1, [r1]
 8056306: 4288         	cmp	r0, r1
 8056308: d107         	bne	0x805631a <vTaskSuspend+0x126> @ imm = #0xe
 805630a: e7ff         	b	0x805630c <vTaskSuspend+0x118> @ imm = #-0x2
;                         pxCurrentTCB = NULL;
 805630c: f240 1100    	movw	r1, #0x100
 8056310: f2c2 0100    	movt	r1, #0x2000
 8056314: 2000         	movs	r0, #0x0
 8056316: 6008         	str	r0, [r1]
;                     }
 8056318: e002         	b	0x8056320 <vTaskSuspend+0x12c> @ imm = #0x4
;                         vTaskSwitchContext();
 805631a: 480e         	ldr	r0, [pc, #0x38]         @ 0x8056354 <vTaskSuspend+0x160>
 805631c: 4780         	blx	r0
 805631e: e7ff         	b	0x8056320 <vTaskSuspend+0x12c> @ imm = #-0x2
 8056320: e7ff         	b	0x8056322 <vTaskSuspend+0x12e> @ imm = #-0x2
;             }
 8056322: e000         	b	0x8056326 <vTaskSuspend+0x132> @ imm = #0x0
 8056324: e7ff         	b	0x8056326 <vTaskSuspend+0x132> @ imm = #-0x2
;     }
 8056326: b004         	add	sp, #0x10
 8056328: bc80         	pop	{r7}
 805632a: eba8 0809    	sub.w	r8, r8, r9
 805632e: f858 fd64    	ldr	pc, [r8, #-100]!
 8056332: bf00         	nop

08056334 <$d.35>:
 8056334: 49 cd 05 08  	.word	0x0805cd49
 8056338: 13 a5 05 08  	.word	0x0805a513
 805633c: 13 a5 05 08  	.word	0x0805a513
 8056340: 6f a4 05 08  	.word	0x0805a46f
 8056344: 7d cd 05 08  	.word	0x0805cd7d
 8056348: 49 cd 05 08  	.word	0x0805cd49
 805634c: 1d 57 05 08  	.word	0x0805571d
 8056350: 7d cd 05 08  	.word	0x0805cd7d
 8056354: 61 63 05 08  	.word	0x08056361
 8056358: 2f cd 05 08  	.word	0x0805cd2f
 805635c: 15 d7 05 08  	.word	0x0805d715

08056360 <vTaskSwitchContext>:
;     {
 8056360: f848 eb6c    	str	lr, [r8], #108
 8056364: eb08 0809    	add.w	r8, r8, r9
 8056368: b480         	push	{r7}
 805636a: 466f         	mov	r7, sp
 805636c: b082         	sub	sp, #0x8
;         if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
 805636e: f240 1028    	movw	r0, #0x128
 8056372: f2c2 0000    	movt	r0, #0x2000
 8056376: 6800         	ldr	r0, [r0]
 8056378: b138         	cbz	r0, 0x805638a <vTaskSwitchContext+0x2a> @ imm = #0xe
 805637a: e7ff         	b	0x805637c <vTaskSwitchContext+0x1c> @ imm = #-0x2
;             xYieldPendings[ 0 ] = pdTRUE;
 805637c: f240 21a4    	movw	r1, #0x2a4
 8056380: f2c2 0100    	movt	r1, #0x2000
 8056384: 2001         	movs	r0, #0x1
 8056386: 6008         	str	r0, [r1]
;         }
 8056388: e04d         	b	0x8056426 <vTaskSwitchContext+0xc6> @ imm = #0x9a
;             xYieldPendings[ 0 ] = pdFALSE;
 805638a: f240 21a4    	movw	r1, #0x2a4
 805638e: f2c2 0100    	movt	r1, #0x2000
 8056392: 2000         	movs	r0, #0x0
 8056394: 6008         	str	r0, [r1]
;             taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8056396: e7ff         	b	0x8056398 <vTaskSwitchContext+0x38> @ imm = #-0x2
 8056398: f240 20a0    	movw	r0, #0x2a0
 805639c: f2c2 0000    	movt	r0, #0x2000
 80563a0: 6800         	ldr	r0, [r0]
 80563a2: 9001         	str	r0, [sp, #0x4]
 80563a4: e7ff         	b	0x80563a6 <vTaskSwitchContext+0x46> @ imm = #-0x2
 80563a6: 9801         	ldr	r0, [sp, #0x4]
 80563a8: eb00 0180    	add.w	r1, r0, r0, lsl #2
 80563ac: f240 1060    	movw	r0, #0x160
 80563b0: f2c2 0000    	movt	r0, #0x2000
 80563b4: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
 80563b8: b958         	cbnz	r0, 0x80563d2 <vTaskSwitchContext+0x72> @ imm = #0x16
 80563ba: e7ff         	b	0x80563bc <vTaskSwitchContext+0x5c> @ imm = #-0x2
 80563bc: 9801         	ldr	r0, [sp, #0x4]
 80563be: b920         	cbnz	r0, 0x80563ca <vTaskSwitchContext+0x6a> @ imm = #0x8
 80563c0: e7ff         	b	0x80563c2 <vTaskSwitchContext+0x62> @ imm = #-0x2
 80563c2: 481c         	ldr	r0, [pc, #0x70]         @ 0x8056434 <vTaskSwitchContext+0xd4>
 80563c4: 4780         	blx	r0
 80563c6: e7ff         	b	0x80563c8 <vTaskSwitchContext+0x68> @ imm = #-0x2
 80563c8: e7fe         	b	0x80563c8 <vTaskSwitchContext+0x68> @ imm = #-0x4
 80563ca: 9801         	ldr	r0, [sp, #0x4]
 80563cc: 3801         	subs	r0, #0x1
 80563ce: 9001         	str	r0, [sp, #0x4]
 80563d0: e7e9         	b	0x80563a6 <vTaskSwitchContext+0x46> @ imm = #-0x2e
 80563d2: e7ff         	b	0x80563d4 <vTaskSwitchContext+0x74> @ imm = #-0x2
 80563d4: 9801         	ldr	r0, [sp, #0x4]
 80563d6: eb00 0180    	add.w	r1, r0, r0, lsl #2
 80563da: f240 1060    	movw	r0, #0x160
 80563de: f2c2 0000    	movt	r0, #0x2000
 80563e2: eb00 0081    	add.w	r0, r0, r1, lsl #2
 80563e6: 9000         	str	r0, [sp]
 80563e8: 9900         	ldr	r1, [sp]
 80563ea: 6848         	ldr	r0, [r1, #0x4]
 80563ec: 6840         	ldr	r0, [r0, #0x4]
 80563ee: 6048         	str	r0, [r1, #0x4]
 80563f0: 9900         	ldr	r1, [sp]
 80563f2: 6848         	ldr	r0, [r1, #0x4]
 80563f4: 3108         	adds	r1, #0x8
 80563f6: 4288         	cmp	r0, r1
 80563f8: d104         	bne	0x8056404 <vTaskSwitchContext+0xa4> @ imm = #0x8
 80563fa: e7ff         	b	0x80563fc <vTaskSwitchContext+0x9c> @ imm = #-0x2
 80563fc: 9900         	ldr	r1, [sp]
 80563fe: 68c8         	ldr	r0, [r1, #0xc]
 8056400: 6048         	str	r0, [r1, #0x4]
 8056402: e7ff         	b	0x8056404 <vTaskSwitchContext+0xa4> @ imm = #-0x2
 8056404: 9800         	ldr	r0, [sp]
 8056406: 6840         	ldr	r0, [r0, #0x4]
 8056408: 68c0         	ldr	r0, [r0, #0xc]
 805640a: f240 1100    	movw	r1, #0x100
 805640e: f2c2 0100    	movt	r1, #0x2000
 8056412: 6008         	str	r0, [r1]
 8056414: e7ff         	b	0x8056416 <vTaskSwitchContext+0xb6> @ imm = #-0x2
 8056416: 9801         	ldr	r0, [sp, #0x4]
 8056418: f240 21a0    	movw	r1, #0x2a0
 805641c: f2c2 0100    	movt	r1, #0x2000
 8056420: 6008         	str	r0, [r1]
 8056422: e7ff         	b	0x8056424 <vTaskSwitchContext+0xc4> @ imm = #-0x2
 8056424: e7ff         	b	0x8056426 <vTaskSwitchContext+0xc6> @ imm = #-0x2
;     }
 8056426: b002         	add	sp, #0x8
 8056428: bc80         	pop	{r7}
 805642a: eba8 0809    	sub.w	r8, r8, r9
 805642e: f858 fd6c    	ldr	pc, [r8, #-108]!
 8056432: bf00         	nop

08056434 <$d.37>:
 8056434: 15 d7 05 08  	.word	0x0805d715

08056438 <vTaskResume>:
;     {
 8056438: f848 eb70    	str	lr, [r8], #112
 805643c: eb08 0809    	add.w	r8, r8, r9
 8056440: b480         	push	{r7}
 8056442: 466f         	mov	r7, sp
 8056444: b084         	sub	sp, #0x10
 8056446: 9003         	str	r0, [sp, #0xc]
;         TCB_t * const pxTCB = xTaskToResume;
 8056448: 9803         	ldr	r0, [sp, #0xc]
 805644a: 9002         	str	r0, [sp, #0x8]
;         configASSERT( xTaskToResume );
 805644c: 9803         	ldr	r0, [sp, #0xc]
 805644e: b920         	cbnz	r0, 0x805645a <vTaskResume+0x22> @ imm = #0x8
 8056450: e7ff         	b	0x8056452 <vTaskResume+0x1a> @ imm = #-0x2
 8056452: 4849         	ldr	r0, [pc, #0x124]        @ 0x8056578 <vTaskResume+0x140>
 8056454: 4780         	blx	r0
 8056456: e7ff         	b	0x8056458 <vTaskResume+0x20> @ imm = #-0x2
 8056458: e7fe         	b	0x8056458 <vTaskResume+0x20> @ imm = #-0x4
;             if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 805645a: 9802         	ldr	r0, [sp, #0x8]
 805645c: f240 1100    	movw	r1, #0x100
 8056460: f2c2 0100    	movt	r1, #0x2000
 8056464: 6809         	ldr	r1, [r1]
 8056466: 4288         	cmp	r0, r1
 8056468: d074         	beq	0x8056554 <vTaskResume+0x11c> @ imm = #0xe8
 805646a: e7ff         	b	0x805646c <vTaskResume+0x34> @ imm = #-0x2
 805646c: 9802         	ldr	r0, [sp, #0x8]
 805646e: 2800         	cmp	r0, #0x0
 8056470: d070         	beq	0x8056554 <vTaskResume+0x11c> @ imm = #0xe0
 8056472: e7ff         	b	0x8056474 <vTaskResume+0x3c> @ imm = #-0x2
;             taskENTER_CRITICAL();
 8056474: 483b         	ldr	r0, [pc, #0xec]         @ 0x8056564 <vTaskResume+0x12c>
 8056476: 4780         	blx	r0
;                 if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 8056478: 9802         	ldr	r0, [sp, #0x8]
 805647a: 493b         	ldr	r1, [pc, #0xec]         @ 0x8056568 <vTaskResume+0x130>
 805647c: 4788         	blx	r1
 805647e: 2800         	cmp	r0, #0x0
 8056480: d064         	beq	0x805654c <vTaskResume+0x114> @ imm = #0xc8
 8056482: e7ff         	b	0x8056484 <vTaskResume+0x4c> @ imm = #-0x2
;                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8056484: 9802         	ldr	r0, [sp, #0x8]
 8056486: 3080         	adds	r0, #0x80
 8056488: 4938         	ldr	r1, [pc, #0xe0]         @ 0x805656c <vTaskResume+0x134>
 805648a: 4788         	blx	r1
;                     prvAddTaskToReadyList( pxTCB );
 805648c: e7ff         	b	0x805648e <vTaskResume+0x56> @ imm = #-0x2
 805648e: e7ff         	b	0x8056490 <vTaskResume+0x58> @ imm = #-0x2
 8056490: 9802         	ldr	r0, [sp, #0x8]
 8056492: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8056496: f240 21a0    	movw	r1, #0x2a0
 805649a: f2c2 0100    	movt	r1, #0x2000
 805649e: 6809         	ldr	r1, [r1]
 80564a0: 4288         	cmp	r0, r1
 80564a2: d909         	bls	0x80564b8 <vTaskResume+0x80> @ imm = #0x12
 80564a4: e7ff         	b	0x80564a6 <vTaskResume+0x6e> @ imm = #-0x2
 80564a6: 9802         	ldr	r0, [sp, #0x8]
 80564a8: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80564ac: f240 21a0    	movw	r1, #0x2a0
 80564b0: f2c2 0100    	movt	r1, #0x2000
 80564b4: 6008         	str	r0, [r1]
 80564b6: e7ff         	b	0x80564b8 <vTaskResume+0x80> @ imm = #-0x2
 80564b8: e7ff         	b	0x80564ba <vTaskResume+0x82> @ imm = #-0x2
 80564ba: e7ff         	b	0x80564bc <vTaskResume+0x84> @ imm = #-0x2
 80564bc: 9802         	ldr	r0, [sp, #0x8]
 80564be: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80564c2: eb00 0080    	add.w	r0, r0, r0, lsl #2
 80564c6: f240 1160    	movw	r1, #0x160
 80564ca: f2c2 0100    	movt	r1, #0x2000
 80564ce: eb01 0080    	add.w	r0, r1, r0, lsl #2
 80564d2: 6840         	ldr	r0, [r0, #0x4]
 80564d4: 9001         	str	r0, [sp, #0x4]
 80564d6: 9801         	ldr	r0, [sp, #0x4]
 80564d8: 9a02         	ldr	r2, [sp, #0x8]
 80564da: f8c2 0084    	str.w	r0, [r2, #0x84]
 80564de: 9801         	ldr	r0, [sp, #0x4]
 80564e0: 6880         	ldr	r0, [r0, #0x8]
 80564e2: 9a02         	ldr	r2, [sp, #0x8]
 80564e4: f8c2 0088    	str.w	r0, [r2, #0x88]
 80564e8: 9802         	ldr	r0, [sp, #0x8]
 80564ea: 3080         	adds	r0, #0x80
 80564ec: 9a01         	ldr	r2, [sp, #0x4]
 80564ee: 6892         	ldr	r2, [r2, #0x8]
 80564f0: 6050         	str	r0, [r2, #0x4]
 80564f2: 9802         	ldr	r0, [sp, #0x8]
 80564f4: 3080         	adds	r0, #0x80
 80564f6: 9a01         	ldr	r2, [sp, #0x4]
 80564f8: 6090         	str	r0, [r2, #0x8]
 80564fa: 9a02         	ldr	r2, [sp, #0x8]
 80564fc: f8d2 00a8    	ldr.w	r0, [r2, #0xa8]
 8056500: eb00 0080    	add.w	r0, r0, r0, lsl #2
 8056504: eb01 0080    	add.w	r0, r1, r0, lsl #2
 8056508: f8c2 0090    	str.w	r0, [r2, #0x90]
 805650c: 9802         	ldr	r0, [sp, #0x8]
 805650e: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8056512: eb00 0280    	add.w	r2, r0, r0, lsl #2
 8056516: f851 0022    	ldr.w	r0, [r1, r2, lsl #2]
 805651a: 3001         	adds	r0, #0x1
 805651c: f841 0022    	str.w	r0, [r1, r2, lsl #2]
 8056520: e7ff         	b	0x8056522 <vTaskResume+0xea> @ imm = #-0x2
 8056522: e7ff         	b	0x8056524 <vTaskResume+0xec> @ imm = #-0x2
;                     taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );
 8056524: e7ff         	b	0x8056526 <vTaskResume+0xee> @ imm = #-0x2
 8056526: f240 1000    	movw	r0, #0x100
 805652a: f2c2 0000    	movt	r0, #0x2000
 805652e: 6800         	ldr	r0, [r0]
 8056530: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8056534: 9902         	ldr	r1, [sp, #0x8]
 8056536: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 805653a: 4288         	cmp	r0, r1
 805653c: d203         	bhs	0x8056546 <vTaskResume+0x10e> @ imm = #0x6
 805653e: e7ff         	b	0x8056540 <vTaskResume+0x108> @ imm = #-0x2
 8056540: 480b         	ldr	r0, [pc, #0x2c]         @ 0x8056570 <vTaskResume+0x138>
 8056542: 4780         	blx	r0
 8056544: e000         	b	0x8056548 <vTaskResume+0x110> @ imm = #0x0
 8056546: e7ff         	b	0x8056548 <vTaskResume+0x110> @ imm = #-0x2
;                     taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );
 8056548: e7ff         	b	0x805654a <vTaskResume+0x112> @ imm = #-0x2
;                 }
 805654a: e000         	b	0x805654e <vTaskResume+0x116> @ imm = #0x0
 805654c: e7ff         	b	0x805654e <vTaskResume+0x116> @ imm = #-0x2
;             taskEXIT_CRITICAL();
 805654e: 4809         	ldr	r0, [pc, #0x24]         @ 0x8056574 <vTaskResume+0x13c>
 8056550: 4780         	blx	r0
;         }
 8056552: e000         	b	0x8056556 <vTaskResume+0x11e> @ imm = #0x0
 8056554: e7ff         	b	0x8056556 <vTaskResume+0x11e> @ imm = #-0x2
;     }
 8056556: b004         	add	sp, #0x10
 8056558: bc80         	pop	{r7}
 805655a: eba8 0809    	sub.w	r8, r8, r9
 805655e: f858 fd70    	ldr	pc, [r8, #-112]!
 8056562: bf00         	nop

08056564 <$d.39>:
 8056564: 49 cd 05 08  	.word	0x0805cd49
 8056568: 7d 65 05 08  	.word	0x0805657d
 805656c: 13 a5 05 08  	.word	0x0805a513
 8056570: 2f cd 05 08  	.word	0x0805cd2f
 8056574: 7d cd 05 08  	.word	0x0805cd7d
 8056578: 15 d7 05 08  	.word	0x0805d715

0805657c <prvTaskIsTaskSuspended>:
;     {
 805657c: f848 eb70    	str	lr, [r8], #112
 8056580: eb08 0809    	add.w	r8, r8, r9
 8056584: b480         	push	{r7}
 8056586: 466f         	mov	r7, sp
 8056588: b084         	sub	sp, #0x10
 805658a: 9003         	str	r0, [sp, #0xc]
 805658c: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFALSE;
 805658e: 9002         	str	r0, [sp, #0x8]
;         const TCB_t * const pxTCB = xTask;
 8056590: 9803         	ldr	r0, [sp, #0xc]
 8056592: 9001         	str	r0, [sp, #0x4]
;         configASSERT( xTask );
 8056594: 9803         	ldr	r0, [sp, #0xc]
 8056596: b920         	cbnz	r0, 0x80565a2 <prvTaskIsTaskSuspended+0x26> @ imm = #0x8
 8056598: e7ff         	b	0x805659a <prvTaskIsTaskSuspended+0x1e> @ imm = #-0x2
 805659a: 4816         	ldr	r0, [pc, #0x58]         @ 0x80565f4 <prvTaskIsTaskSuspended+0x78>
 805659c: 4780         	blx	r0
 805659e: e7ff         	b	0x80565a0 <prvTaskIsTaskSuspended+0x24> @ imm = #-0x2
 80565a0: e7fe         	b	0x80565a0 <prvTaskIsTaskSuspended+0x24> @ imm = #-0x4
;         if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 80565a2: 9801         	ldr	r0, [sp, #0x4]
 80565a4: f8d0 0090    	ldr.w	r0, [r0, #0x90]
 80565a8: f240 114c    	movw	r1, #0x14c
 80565ac: f2c2 0100    	movt	r1, #0x2000
 80565b0: 4288         	cmp	r0, r1
 80565b2: d116         	bne	0x80565e2 <prvTaskIsTaskSuspended+0x66> @ imm = #0x2c
 80565b4: e7ff         	b	0x80565b6 <prvTaskIsTaskSuspended+0x3a> @ imm = #-0x2
;             if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 80565b6: 9801         	ldr	r0, [sp, #0x4]
 80565b8: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
 80565bc: f240 1138    	movw	r1, #0x138
 80565c0: f2c2 0100    	movt	r1, #0x2000
 80565c4: 4288         	cmp	r0, r1
 80565c6: d00a         	beq	0x80565de <prvTaskIsTaskSuspended+0x62> @ imm = #0x14
 80565c8: e7ff         	b	0x80565ca <prvTaskIsTaskSuspended+0x4e> @ imm = #-0x2
;                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 80565ca: 9801         	ldr	r0, [sp, #0x4]
 80565cc: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
 80565d0: b918         	cbnz	r0, 0x80565da <prvTaskIsTaskSuspended+0x5e> @ imm = #0x6
 80565d2: e7ff         	b	0x80565d4 <prvTaskIsTaskSuspended+0x58> @ imm = #-0x2
 80565d4: 2001         	movs	r0, #0x1
;                     xReturn = pdTRUE;
 80565d6: 9002         	str	r0, [sp, #0x8]
;                 }
 80565d8: e000         	b	0x80565dc <prvTaskIsTaskSuspended+0x60> @ imm = #0x0
 80565da: e7ff         	b	0x80565dc <prvTaskIsTaskSuspended+0x60> @ imm = #-0x2
;             }
 80565dc: e000         	b	0x80565e0 <prvTaskIsTaskSuspended+0x64> @ imm = #0x0
 80565de: e7ff         	b	0x80565e0 <prvTaskIsTaskSuspended+0x64> @ imm = #-0x2
;         }
 80565e0: e000         	b	0x80565e4 <prvTaskIsTaskSuspended+0x68> @ imm = #0x0
 80565e2: e7ff         	b	0x80565e4 <prvTaskIsTaskSuspended+0x68> @ imm = #-0x2
;         return xReturn;
 80565e4: 9802         	ldr	r0, [sp, #0x8]
 80565e6: b004         	add	sp, #0x10
 80565e8: bc80         	pop	{r7}
 80565ea: eba8 0809    	sub.w	r8, r8, r9
 80565ee: f858 fd70    	ldr	pc, [r8, #-112]!
 80565f2: bf00         	nop

080565f4 <$d.41>:
 80565f4: 15 d7 05 08  	.word	0x0805d715

080565f8 <xTaskResumeFromISR>:
;     {
 80565f8: f848 eb48    	str	lr, [r8], #72
 80565fc: eb08 0809    	add.w	r8, r8, r9
 8056600: b480         	push	{r7}
 8056602: 466f         	mov	r7, sp
 8056604: b086         	sub	sp, #0x18
 8056606: 9005         	str	r0, [sp, #0x14]
 8056608: 2000         	movs	r0, #0x0
;         BaseType_t xYieldRequired = pdFALSE;
 805660a: 9004         	str	r0, [sp, #0x10]
;         TCB_t * const pxTCB = xTaskToResume;
 805660c: 9805         	ldr	r0, [sp, #0x14]
 805660e: 9003         	str	r0, [sp, #0xc]
;         configASSERT( xTaskToResume );
 8056610: 9805         	ldr	r0, [sp, #0x14]
 8056612: b920         	cbnz	r0, 0x805661e <xTaskResumeFromISR+0x26> @ imm = #0x8
 8056614: e7ff         	b	0x8056616 <xTaskResumeFromISR+0x1e> @ imm = #-0x2
 8056616: 4850         	ldr	r0, [pc, #0x140]        @ 0x8056758 <xTaskResumeFromISR+0x160>
 8056618: 4780         	blx	r0
 805661a: e7ff         	b	0x805661c <xTaskResumeFromISR+0x24> @ imm = #-0x2
 805661c: e7fe         	b	0x805661c <xTaskResumeFromISR+0x24> @ imm = #-0x4
;         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 805661e: 4848         	ldr	r0, [pc, #0x120]        @ 0x8056740 <xTaskResumeFromISR+0x148>
 8056620: 4780         	blx	r0
;         uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
 8056622: 4848         	ldr	r0, [pc, #0x120]        @ 0x8056744 <xTaskResumeFromISR+0x14c>
 8056624: 4780         	blx	r0
 8056626: 9002         	str	r0, [sp, #0x8]
;             if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 8056628: 9803         	ldr	r0, [sp, #0xc]
 805662a: 4947         	ldr	r1, [pc, #0x11c]        @ 0x8056748 <xTaskResumeFromISR+0x150>
 805662c: 4788         	blx	r1
 805662e: 2800         	cmp	r0, #0x0
 8056630: d07a         	beq	0x8056728 <xTaskResumeFromISR+0x130> @ imm = #0xf4
 8056632: e7ff         	b	0x8056634 <xTaskResumeFromISR+0x3c> @ imm = #-0x2
;                 if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 8056634: f240 1028    	movw	r0, #0x128
 8056638: f2c2 0000    	movt	r0, #0x2000
 805663c: 6800         	ldr	r0, [r0]
 805663e: 2800         	cmp	r0, #0x0
 8056640: d167         	bne	0x8056712 <xTaskResumeFromISR+0x11a> @ imm = #0xce
 8056642: e7ff         	b	0x8056644 <xTaskResumeFromISR+0x4c> @ imm = #-0x2
;                         if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8056644: 9803         	ldr	r0, [sp, #0xc]
 8056646: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805664a: f240 1100    	movw	r1, #0x100
 805664e: f2c2 0100    	movt	r1, #0x2000
 8056652: 6809         	ldr	r1, [r1]
 8056654: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 8056658: 4288         	cmp	r0, r1
 805665a: d908         	bls	0x805666e <xTaskResumeFromISR+0x76> @ imm = #0x10
 805665c: e7ff         	b	0x805665e <xTaskResumeFromISR+0x66> @ imm = #-0x2
 805665e: 2001         	movs	r0, #0x1
;                             xYieldRequired = pdTRUE;
 8056660: 9004         	str	r0, [sp, #0x10]
;                             xYieldPendings[ 0 ] = pdTRUE;
 8056662: f240 21a4    	movw	r1, #0x2a4
 8056666: f2c2 0100    	movt	r1, #0x2000
 805666a: 6008         	str	r0, [r1]
;                         }
 805666c: e000         	b	0x8056670 <xTaskResumeFromISR+0x78> @ imm = #0x0
 805666e: e7ff         	b	0x8056670 <xTaskResumeFromISR+0x78> @ imm = #-0x2
;                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8056670: 9803         	ldr	r0, [sp, #0xc]
 8056672: 3080         	adds	r0, #0x80
 8056674: 4936         	ldr	r1, [pc, #0xd8]         @ 0x8056750 <xTaskResumeFromISR+0x158>
 8056676: 4788         	blx	r1
;                     prvAddTaskToReadyList( pxTCB );
 8056678: e7ff         	b	0x805667a <xTaskResumeFromISR+0x82> @ imm = #-0x2
 805667a: e7ff         	b	0x805667c <xTaskResumeFromISR+0x84> @ imm = #-0x2
 805667c: 9803         	ldr	r0, [sp, #0xc]
 805667e: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8056682: f240 21a0    	movw	r1, #0x2a0
 8056686: f2c2 0100    	movt	r1, #0x2000
 805668a: 6809         	ldr	r1, [r1]
 805668c: 4288         	cmp	r0, r1
 805668e: d909         	bls	0x80566a4 <xTaskResumeFromISR+0xac> @ imm = #0x12
 8056690: e7ff         	b	0x8056692 <xTaskResumeFromISR+0x9a> @ imm = #-0x2
 8056692: 9803         	ldr	r0, [sp, #0xc]
 8056694: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8056698: f240 21a0    	movw	r1, #0x2a0
 805669c: f2c2 0100    	movt	r1, #0x2000
 80566a0: 6008         	str	r0, [r1]
 80566a2: e7ff         	b	0x80566a4 <xTaskResumeFromISR+0xac> @ imm = #-0x2
 80566a4: e7ff         	b	0x80566a6 <xTaskResumeFromISR+0xae> @ imm = #-0x2
 80566a6: e7ff         	b	0x80566a8 <xTaskResumeFromISR+0xb0> @ imm = #-0x2
 80566a8: 9803         	ldr	r0, [sp, #0xc]
 80566aa: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80566ae: eb00 0080    	add.w	r0, r0, r0, lsl #2
 80566b2: f240 1160    	movw	r1, #0x160
 80566b6: f2c2 0100    	movt	r1, #0x2000
 80566ba: eb01 0080    	add.w	r0, r1, r0, lsl #2
 80566be: 6840         	ldr	r0, [r0, #0x4]
 80566c0: 9001         	str	r0, [sp, #0x4]
 80566c2: 9801         	ldr	r0, [sp, #0x4]
 80566c4: 9a03         	ldr	r2, [sp, #0xc]
 80566c6: f8c2 0084    	str.w	r0, [r2, #0x84]
 80566ca: 9801         	ldr	r0, [sp, #0x4]
 80566cc: 6880         	ldr	r0, [r0, #0x8]
 80566ce: 9a03         	ldr	r2, [sp, #0xc]
 80566d0: f8c2 0088    	str.w	r0, [r2, #0x88]
 80566d4: 9803         	ldr	r0, [sp, #0xc]
 80566d6: 3080         	adds	r0, #0x80
 80566d8: 9a01         	ldr	r2, [sp, #0x4]
 80566da: 6892         	ldr	r2, [r2, #0x8]
 80566dc: 6050         	str	r0, [r2, #0x4]
 80566de: 9803         	ldr	r0, [sp, #0xc]
 80566e0: 3080         	adds	r0, #0x80
 80566e2: 9a01         	ldr	r2, [sp, #0x4]
 80566e4: 6090         	str	r0, [r2, #0x8]
 80566e6: 9a03         	ldr	r2, [sp, #0xc]
 80566e8: f8d2 00a8    	ldr.w	r0, [r2, #0xa8]
 80566ec: eb00 0080    	add.w	r0, r0, r0, lsl #2
 80566f0: eb01 0080    	add.w	r0, r1, r0, lsl #2
 80566f4: f8c2 0090    	str.w	r0, [r2, #0x90]
 80566f8: 9803         	ldr	r0, [sp, #0xc]
 80566fa: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80566fe: eb00 0280    	add.w	r2, r0, r0, lsl #2
 8056702: f851 0022    	ldr.w	r0, [r1, r2, lsl #2]
 8056706: 3001         	adds	r0, #0x1
 8056708: f841 0022    	str.w	r0, [r1, r2, lsl #2]
 805670c: e7ff         	b	0x805670e <xTaskResumeFromISR+0x116> @ imm = #-0x2
 805670e: e7ff         	b	0x8056710 <xTaskResumeFromISR+0x118> @ imm = #-0x2
;                 }
 8056710: e009         	b	0x8056726 <xTaskResumeFromISR+0x12e> @ imm = #0x12
;                     vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8056712: 9803         	ldr	r0, [sp, #0xc]
 8056714: f100 0194    	add.w	r1, r0, #0x94
 8056718: f240 1038    	movw	r0, #0x138
 805671c: f2c2 0000    	movt	r0, #0x2000
 8056720: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x805674c <xTaskResumeFromISR+0x154>
 8056722: 4790         	blx	r2
 8056724: e7ff         	b	0x8056726 <xTaskResumeFromISR+0x12e> @ imm = #-0x2
;             }
 8056726: e000         	b	0x805672a <xTaskResumeFromISR+0x132> @ imm = #0x0
 8056728: e7ff         	b	0x805672a <xTaskResumeFromISR+0x132> @ imm = #-0x2
;         taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
 805672a: 9802         	ldr	r0, [sp, #0x8]
 805672c: 4909         	ldr	r1, [pc, #0x24]         @ 0x8056754 <xTaskResumeFromISR+0x15c>
 805672e: 4788         	blx	r1
;         return xYieldRequired;
 8056730: 9804         	ldr	r0, [sp, #0x10]
 8056732: b006         	add	sp, #0x18
 8056734: bc80         	pop	{r7}
 8056736: eba8 0809    	sub.w	r8, r8, r9
 805673a: f858 fd48    	ldr	pc, [r8, #-72]!
 805673e: bf00         	nop

08056740 <$d.43>:
 8056740: 1d f8 05 08  	.word	0x0805f81d
 8056744: 15 d7 05 08  	.word	0x0805d715
 8056748: 7d 65 05 08  	.word	0x0805657d
 805674c: 6f a4 05 08  	.word	0x0805a46f
 8056750: 13 a5 05 08  	.word	0x0805a513
 8056754: 2b d7 05 08  	.word	0x0805d72b
 8056758: 15 d7 05 08  	.word	0x0805d715

0805675c <vTaskStartScheduler>:
; {
 805675c: f848 eb40    	str	lr, [r8], #64
 8056760: eb08 0809    	add.w	r8, r8, r9
 8056764: b480         	push	{r7}
 8056766: 466f         	mov	r7, sp
 8056768: b082         	sub	sp, #0x8
;     xReturn = prvCreateIdleTasks();
 805676a: 481e         	ldr	r0, [pc, #0x78]         @ 0x80567e4 <vTaskStartScheduler+0x88>
 805676c: 4780         	blx	r0
 805676e: 9001         	str	r0, [sp, #0x4]
;         if( xReturn == pdPASS )
 8056770: 9801         	ldr	r0, [sp, #0x4]
 8056772: 2801         	cmp	r0, #0x1
 8056774: d104         	bne	0x8056780 <vTaskStartScheduler+0x24> @ imm = #0x8
 8056776: e7ff         	b	0x8056778 <vTaskStartScheduler+0x1c> @ imm = #-0x2
;             xReturn = xTimerCreateTimerTask();
 8056778: 481b         	ldr	r0, [pc, #0x6c]         @ 0x80567e8 <vTaskStartScheduler+0x8c>
 805677a: 4780         	blx	r0
 805677c: 9001         	str	r0, [sp, #0x4]
;         }
 805677e: e000         	b	0x8056782 <vTaskStartScheduler+0x26> @ imm = #0x0
 8056780: e7ff         	b	0x8056782 <vTaskStartScheduler+0x26> @ imm = #-0x2
;     if( xReturn == pdPASS )
 8056782: 9801         	ldr	r0, [sp, #0x4]
 8056784: 2801         	cmp	r0, #0x1
 8056786: d118         	bne	0x80567ba <vTaskStartScheduler+0x5e> @ imm = #0x30
 8056788: e7ff         	b	0x805678a <vTaskStartScheduler+0x2e> @ imm = #-0x2
;         portDISABLE_INTERRUPTS();
 805678a: 4819         	ldr	r0, [pc, #0x64]         @ 0x80567f0 <vTaskStartScheduler+0x94>
 805678c: 4780         	blx	r0
;         xNextTaskUnblockTime = portMAX_DELAY;
 805678e: f240 21a8    	movw	r1, #0x2a8
 8056792: f2c2 0100    	movt	r1, #0x2000
 8056796: f04f 30ff    	mov.w	r0, #0xffffffff
 805679a: 6008         	str	r0, [r1]
;         xSchedulerRunning = pdTRUE;
 805679c: f240 1124    	movw	r1, #0x124
 80567a0: f2c2 0100    	movt	r1, #0x2000
 80567a4: 2001         	movs	r0, #0x1
 80567a6: 6008         	str	r0, [r1]
;         xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 80567a8: f240 112c    	movw	r1, #0x12c
 80567ac: f2c2 0100    	movt	r1, #0x2000
 80567b0: 2000         	movs	r0, #0x0
 80567b2: 6008         	str	r0, [r1]
;         xPortStartScheduler();
 80567b4: 480f         	ldr	r0, [pc, #0x3c]         @ 0x80567f4 <vTaskStartScheduler+0x98>
 80567b6: 4780         	blx	r0
;     }
 80567b8: e008         	b	0x80567cc <vTaskStartScheduler+0x70> @ imm = #0x10
;         configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 80567ba: 9801         	ldr	r0, [sp, #0x4]
 80567bc: 3001         	adds	r0, #0x1
 80567be: b920         	cbnz	r0, 0x80567ca <vTaskStartScheduler+0x6e> @ imm = #0x8
 80567c0: e7ff         	b	0x80567c2 <vTaskStartScheduler+0x66> @ imm = #-0x2
 80567c2: 480a         	ldr	r0, [pc, #0x28]         @ 0x80567ec <vTaskStartScheduler+0x90>
 80567c4: 4780         	blx	r0
 80567c6: e7ff         	b	0x80567c8 <vTaskStartScheduler+0x6c> @ imm = #-0x2
 80567c8: e7fe         	b	0x80567c8 <vTaskStartScheduler+0x6c> @ imm = #-0x4
 80567ca: e7ff         	b	0x80567cc <vTaskStartScheduler+0x70> @ imm = #-0x2
;     ( void ) uxTopUsedPriority;
 80567cc: f64f 20e8    	movw	r0, #0xfae8
 80567d0: f6c0 0005    	movt	r0, #0x805
 80567d4: 6800         	ldr	r0, [r0]
; }
 80567d6: b002         	add	sp, #0x8
 80567d8: bc80         	pop	{r7}
 80567da: eba8 0809    	sub.w	r8, r8, r9
 80567de: f858 fd40    	ldr	pc, [r8, #-64]!
 80567e2: bf00         	nop

080567e4 <$d.45>:
 80567e4: 21 f7 05 08  	.word	0x0805f721
 80567e8: 89 8a 05 08  	.word	0x08058a89
 80567ec: 15 d7 05 08  	.word	0x0805d715
 80567f0: 15 d7 05 08  	.word	0x0805d715
 80567f4: d5 d0 05 08  	.word	0x0805d0d5

080567f8 <vTaskEndScheduler>:
; {
 80567f8: f848 eb24    	str	lr, [r8], #36
 80567fc: eb08 0809    	add.w	r8, r8, r9
 8056800: b480         	push	{r7}
 8056802: 466f         	mov	r7, sp
;     portDISABLE_INTERRUPTS();
 8056804: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8056824 <vTaskEndScheduler+0x2c>
 8056806: 4780         	blx	r0
;     xSchedulerRunning = pdFALSE;
 8056808: f240 1124    	movw	r1, #0x124
 805680c: f2c2 0100    	movt	r1, #0x2000
 8056810: 2000         	movs	r0, #0x0
 8056812: 6008         	str	r0, [r1]
;     vPortEndScheduler();
 8056814: 4804         	ldr	r0, [pc, #0x10]         @ 0x8056828 <vTaskEndScheduler+0x30>
 8056816: 4780         	blx	r0
; }
 8056818: bc80         	pop	{r7}
 805681a: eba8 0809    	sub.w	r8, r8, r9
 805681e: f858 fd24    	ldr	pc, [r8, #-36]!
 8056822: bf00         	nop

08056824 <$d.49>:
 8056824: 15 d7 05 08  	.word	0x0805d715
 8056828: 2d d3 05 08  	.word	0x0805d32d

0805682c <xTaskIncrementTick>:
; {
 805682c: f848 eb5c    	str	lr, [r8], #92
 8056830: eb08 0809    	add.w	r8, r8, r9
 8056834: b480         	push	{r7}
 8056836: 466f         	mov	r7, sp
 8056838: b088         	sub	sp, #0x20
 805683a: 2000         	movs	r0, #0x0
;     BaseType_t xSwitchRequired = pdFALSE;
 805683c: 9005         	str	r0, [sp, #0x14]
;     if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 805683e: f240 1028    	movw	r0, #0x128
 8056842: f2c2 0000    	movt	r0, #0x2000
 8056846: 6800         	ldr	r0, [r0]
 8056848: 2800         	cmp	r0, #0x0
 805684a: f040 813f    	bne.w	0x8056acc <xTaskIncrementTick+0x2a0> @ imm = #0x27e
 805684e: e7ff         	b	0x8056850 <xTaskIncrementTick+0x24> @ imm = #-0x2
;         const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8056850: f240 112c    	movw	r1, #0x12c
 8056854: f2c2 0100    	movt	r1, #0x2000
 8056858: 6808         	ldr	r0, [r1]
 805685a: 3001         	adds	r0, #0x1
 805685c: 9004         	str	r0, [sp, #0x10]
;         xTickCount = xConstTickCount;
 805685e: 9804         	ldr	r0, [sp, #0x10]
 8056860: 6008         	str	r0, [r1]
;         if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8056862: 9804         	ldr	r0, [sp, #0x10]
 8056864: bb30         	cbnz	r0, 0x80568b4 <xTaskIncrementTick+0x88> @ imm = #0x4c
 8056866: e7ff         	b	0x8056868 <xTaskIncrementTick+0x3c> @ imm = #-0x2
;             taskSWITCH_DELAYED_LISTS();
 8056868: e7ff         	b	0x805686a <xTaskIncrementTick+0x3e> @ imm = #-0x2
 805686a: f240 1030    	movw	r0, #0x130
 805686e: f2c2 0000    	movt	r0, #0x2000
 8056872: 6800         	ldr	r0, [r0]
 8056874: 6800         	ldr	r0, [r0]
 8056876: b120         	cbz	r0, 0x8056882 <xTaskIncrementTick+0x56> @ imm = #0x8
 8056878: e7ff         	b	0x805687a <xTaskIncrementTick+0x4e> @ imm = #-0x2
 805687a: 489d         	ldr	r0, [pc, #0x274]        @ 0x8056af0 <xTaskIncrementTick+0x2c4>
 805687c: 4780         	blx	r0
 805687e: e7ff         	b	0x8056880 <xTaskIncrementTick+0x54> @ imm = #-0x2
 8056880: e7fe         	b	0x8056880 <xTaskIncrementTick+0x54> @ imm = #-0x4
 8056882: f240 1230    	movw	r2, #0x130
 8056886: f2c2 0200    	movt	r2, #0x2000
 805688a: 6810         	ldr	r0, [r2]
 805688c: 9003         	str	r0, [sp, #0xc]
 805688e: f240 1134    	movw	r1, #0x134
 8056892: f2c2 0100    	movt	r1, #0x2000
 8056896: 6808         	ldr	r0, [r1]
 8056898: 6010         	str	r0, [r2]
 805689a: 9803         	ldr	r0, [sp, #0xc]
 805689c: 6008         	str	r0, [r1]
 805689e: f240 21b4    	movw	r1, #0x2b4
 80568a2: f2c2 0100    	movt	r1, #0x2000
 80568a6: 6808         	ldr	r0, [r1]
 80568a8: 3001         	adds	r0, #0x1
 80568aa: 6008         	str	r0, [r1]
 80568ac: 488f         	ldr	r0, [pc, #0x23c]        @ 0x8056aec <xTaskIncrementTick+0x2c0>
 80568ae: 4780         	blx	r0
 80568b0: e7ff         	b	0x80568b2 <xTaskIncrementTick+0x86> @ imm = #-0x2
;         }
 80568b2: e000         	b	0x80568b6 <xTaskIncrementTick+0x8a> @ imm = #0x0
 80568b4: e7ff         	b	0x80568b6 <xTaskIncrementTick+0x8a> @ imm = #-0x2
;         if( xConstTickCount >= xNextTaskUnblockTime )
 80568b6: 9804         	ldr	r0, [sp, #0x10]
 80568b8: f240 21a8    	movw	r1, #0x2a8
 80568bc: f2c2 0100    	movt	r1, #0x2000
 80568c0: 6809         	ldr	r1, [r1]
 80568c2: 4288         	cmp	r0, r1
 80568c4: f0c0 80e0    	blo.w	0x8056a88 <xTaskIncrementTick+0x25c> @ imm = #0x1c0
 80568c8: e7ff         	b	0x80568ca <xTaskIncrementTick+0x9e> @ imm = #-0x2
;             for( ; ; )
 80568ca: e7ff         	b	0x80568cc <xTaskIncrementTick+0xa0> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80568cc: f240 1030    	movw	r0, #0x130
 80568d0: f2c2 0000    	movt	r0, #0x2000
 80568d4: 6800         	ldr	r0, [r0]
 80568d6: 6800         	ldr	r0, [r0]
 80568d8: b940         	cbnz	r0, 0x80568ec <xTaskIncrementTick+0xc0> @ imm = #0x10
 80568da: e7ff         	b	0x80568dc <xTaskIncrementTick+0xb0> @ imm = #-0x2
;                     xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80568dc: f240 21a8    	movw	r1, #0x2a8
 80568e0: f2c2 0100    	movt	r1, #0x2000
 80568e4: f04f 30ff    	mov.w	r0, #0xffffffff
 80568e8: 6008         	str	r0, [r1]
;                     break;
 80568ea: e0cc         	b	0x8056a86 <xTaskIncrementTick+0x25a> @ imm = #0x198
;                     pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80568ec: f240 1030    	movw	r0, #0x130
 80568f0: f2c2 0000    	movt	r0, #0x2000
 80568f4: 6800         	ldr	r0, [r0]
 80568f6: 68c0         	ldr	r0, [r0, #0xc]
 80568f8: 68c0         	ldr	r0, [r0, #0xc]
 80568fa: 9007         	str	r0, [sp, #0x1c]
;                     xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 80568fc: 9807         	ldr	r0, [sp, #0x1c]
 80568fe: f8d0 0080    	ldr.w	r0, [r0, #0x80]
 8056902: 9006         	str	r0, [sp, #0x18]
;                     if( xConstTickCount < xItemValue )
 8056904: 9804         	ldr	r0, [sp, #0x10]
 8056906: 9906         	ldr	r1, [sp, #0x18]
 8056908: 4288         	cmp	r0, r1
 805690a: d207         	bhs	0x805691c <xTaskIncrementTick+0xf0> @ imm = #0xe
 805690c: e7ff         	b	0x805690e <xTaskIncrementTick+0xe2> @ imm = #-0x2
;                         xNextTaskUnblockTime = xItemValue;
 805690e: 9806         	ldr	r0, [sp, #0x18]
 8056910: f240 21a8    	movw	r1, #0x2a8
 8056914: f2c2 0100    	movt	r1, #0x2000
 8056918: 6008         	str	r0, [r1]
;                         break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */
 805691a: e0b4         	b	0x8056a86 <xTaskIncrementTick+0x25a> @ imm = #0x168
 805691c: e7ff         	b	0x805691e <xTaskIncrementTick+0xf2> @ imm = #-0x2
;                     listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 805691e: e7ff         	b	0x8056920 <xTaskIncrementTick+0xf4> @ imm = #-0x2
 8056920: 9807         	ldr	r0, [sp, #0x1c]
 8056922: f8d0 0090    	ldr.w	r0, [r0, #0x90]
 8056926: 9002         	str	r0, [sp, #0x8]
 8056928: 9807         	ldr	r0, [sp, #0x1c]
 805692a: f8d0 1084    	ldr.w	r1, [r0, #0x84]
 805692e: f8d0 0088    	ldr.w	r0, [r0, #0x88]
 8056932: 6088         	str	r0, [r1, #0x8]
 8056934: 9907         	ldr	r1, [sp, #0x1c]
 8056936: f8d1 0084    	ldr.w	r0, [r1, #0x84]
 805693a: f8d1 1088    	ldr.w	r1, [r1, #0x88]
 805693e: 6048         	str	r0, [r1, #0x4]
 8056940: 9802         	ldr	r0, [sp, #0x8]
 8056942: 6840         	ldr	r0, [r0, #0x4]
 8056944: 9907         	ldr	r1, [sp, #0x1c]
 8056946: 3180         	adds	r1, #0x80
 8056948: 4288         	cmp	r0, r1
 805694a: d106         	bne	0x805695a <xTaskIncrementTick+0x12e> @ imm = #0xc
 805694c: e7ff         	b	0x805694e <xTaskIncrementTick+0x122> @ imm = #-0x2
 805694e: 9807         	ldr	r0, [sp, #0x1c]
 8056950: f8d0 0088    	ldr.w	r0, [r0, #0x88]
 8056954: 9902         	ldr	r1, [sp, #0x8]
 8056956: 6048         	str	r0, [r1, #0x4]
 8056958: e7ff         	b	0x805695a <xTaskIncrementTick+0x12e> @ imm = #-0x2
 805695a: 9907         	ldr	r1, [sp, #0x1c]
 805695c: 2000         	movs	r0, #0x0
 805695e: f8c1 0090    	str.w	r0, [r1, #0x90]
 8056962: 9902         	ldr	r1, [sp, #0x8]
 8056964: 6808         	ldr	r0, [r1]
 8056966: 3801         	subs	r0, #0x1
 8056968: 6008         	str	r0, [r1]
 805696a: e7ff         	b	0x805696c <xTaskIncrementTick+0x140> @ imm = #-0x2
;                     if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 805696c: 9807         	ldr	r0, [sp, #0x1c]
 805696e: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
 8056972: b340         	cbz	r0, 0x80569c6 <xTaskIncrementTick+0x19a> @ imm = #0x50
 8056974: e7ff         	b	0x8056976 <xTaskIncrementTick+0x14a> @ imm = #-0x2
;                         listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 8056976: e7ff         	b	0x8056978 <xTaskIncrementTick+0x14c> @ imm = #-0x2
 8056978: 9807         	ldr	r0, [sp, #0x1c]
 805697a: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
 805697e: 9001         	str	r0, [sp, #0x4]
 8056980: 9807         	ldr	r0, [sp, #0x1c]
 8056982: f8d0 1098    	ldr.w	r1, [r0, #0x98]
 8056986: f8d0 009c    	ldr.w	r0, [r0, #0x9c]
 805698a: 6088         	str	r0, [r1, #0x8]
 805698c: 9907         	ldr	r1, [sp, #0x1c]
 805698e: f8d1 0098    	ldr.w	r0, [r1, #0x98]
 8056992: f8d1 109c    	ldr.w	r1, [r1, #0x9c]
 8056996: 6048         	str	r0, [r1, #0x4]
 8056998: 9801         	ldr	r0, [sp, #0x4]
 805699a: 6840         	ldr	r0, [r0, #0x4]
 805699c: 9907         	ldr	r1, [sp, #0x1c]
 805699e: 3194         	adds	r1, #0x94
 80569a0: 4288         	cmp	r0, r1
 80569a2: d106         	bne	0x80569b2 <xTaskIncrementTick+0x186> @ imm = #0xc
 80569a4: e7ff         	b	0x80569a6 <xTaskIncrementTick+0x17a> @ imm = #-0x2
 80569a6: 9807         	ldr	r0, [sp, #0x1c]
 80569a8: f8d0 009c    	ldr.w	r0, [r0, #0x9c]
 80569ac: 9901         	ldr	r1, [sp, #0x4]
 80569ae: 6048         	str	r0, [r1, #0x4]
 80569b0: e7ff         	b	0x80569b2 <xTaskIncrementTick+0x186> @ imm = #-0x2
 80569b2: 9907         	ldr	r1, [sp, #0x1c]
 80569b4: 2000         	movs	r0, #0x0
 80569b6: f8c1 00a4    	str.w	r0, [r1, #0xa4]
 80569ba: 9901         	ldr	r1, [sp, #0x4]
 80569bc: 6808         	ldr	r0, [r1]
 80569be: 3801         	subs	r0, #0x1
 80569c0: 6008         	str	r0, [r1]
 80569c2: e7ff         	b	0x80569c4 <xTaskIncrementTick+0x198> @ imm = #-0x2
;                     }
 80569c4: e000         	b	0x80569c8 <xTaskIncrementTick+0x19c> @ imm = #0x0
 80569c6: e7ff         	b	0x80569c8 <xTaskIncrementTick+0x19c> @ imm = #-0x2
;                     prvAddTaskToReadyList( pxTCB );
 80569c8: e7ff         	b	0x80569ca <xTaskIncrementTick+0x19e> @ imm = #-0x2
 80569ca: e7ff         	b	0x80569cc <xTaskIncrementTick+0x1a0> @ imm = #-0x2
 80569cc: 9807         	ldr	r0, [sp, #0x1c]
 80569ce: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80569d2: f240 21a0    	movw	r1, #0x2a0
 80569d6: f2c2 0100    	movt	r1, #0x2000
 80569da: 6809         	ldr	r1, [r1]
 80569dc: 4288         	cmp	r0, r1
 80569de: d909         	bls	0x80569f4 <xTaskIncrementTick+0x1c8> @ imm = #0x12
 80569e0: e7ff         	b	0x80569e2 <xTaskIncrementTick+0x1b6> @ imm = #-0x2
 80569e2: 9807         	ldr	r0, [sp, #0x1c]
 80569e4: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80569e8: f240 21a0    	movw	r1, #0x2a0
 80569ec: f2c2 0100    	movt	r1, #0x2000
 80569f0: 6008         	str	r0, [r1]
 80569f2: e7ff         	b	0x80569f4 <xTaskIncrementTick+0x1c8> @ imm = #-0x2
 80569f4: e7ff         	b	0x80569f6 <xTaskIncrementTick+0x1ca> @ imm = #-0x2
 80569f6: e7ff         	b	0x80569f8 <xTaskIncrementTick+0x1cc> @ imm = #-0x2
 80569f8: 9807         	ldr	r0, [sp, #0x1c]
 80569fa: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80569fe: eb00 0080    	add.w	r0, r0, r0, lsl #2
 8056a02: f240 1160    	movw	r1, #0x160
 8056a06: f2c2 0100    	movt	r1, #0x2000
 8056a0a: eb01 0080    	add.w	r0, r1, r0, lsl #2
 8056a0e: 6840         	ldr	r0, [r0, #0x4]
 8056a10: 9000         	str	r0, [sp]
 8056a12: 9800         	ldr	r0, [sp]
 8056a14: 9a07         	ldr	r2, [sp, #0x1c]
 8056a16: f8c2 0084    	str.w	r0, [r2, #0x84]
 8056a1a: 9800         	ldr	r0, [sp]
 8056a1c: 6880         	ldr	r0, [r0, #0x8]
 8056a1e: 9a07         	ldr	r2, [sp, #0x1c]
 8056a20: f8c2 0088    	str.w	r0, [r2, #0x88]
 8056a24: 9807         	ldr	r0, [sp, #0x1c]
 8056a26: 3080         	adds	r0, #0x80
 8056a28: 9a00         	ldr	r2, [sp]
 8056a2a: 6892         	ldr	r2, [r2, #0x8]
 8056a2c: 6050         	str	r0, [r2, #0x4]
 8056a2e: 9807         	ldr	r0, [sp, #0x1c]
 8056a30: 3080         	adds	r0, #0x80
 8056a32: 9a00         	ldr	r2, [sp]
 8056a34: 6090         	str	r0, [r2, #0x8]
 8056a36: 9a07         	ldr	r2, [sp, #0x1c]
 8056a38: f8d2 00a8    	ldr.w	r0, [r2, #0xa8]
 8056a3c: eb00 0080    	add.w	r0, r0, r0, lsl #2
 8056a40: eb01 0080    	add.w	r0, r1, r0, lsl #2
 8056a44: f8c2 0090    	str.w	r0, [r2, #0x90]
 8056a48: 9807         	ldr	r0, [sp, #0x1c]
 8056a4a: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8056a4e: eb00 0280    	add.w	r2, r0, r0, lsl #2
 8056a52: f851 0022    	ldr.w	r0, [r1, r2, lsl #2]
 8056a56: 3001         	adds	r0, #0x1
 8056a58: f841 0022    	str.w	r0, [r1, r2, lsl #2]
 8056a5c: e7ff         	b	0x8056a5e <xTaskIncrementTick+0x232> @ imm = #-0x2
 8056a5e: e7ff         	b	0x8056a60 <xTaskIncrementTick+0x234> @ imm = #-0x2
;                             if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8056a60: 9807         	ldr	r0, [sp, #0x1c]
 8056a62: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8056a66: f240 1100    	movw	r1, #0x100
 8056a6a: f2c2 0100    	movt	r1, #0x2000
 8056a6e: 6809         	ldr	r1, [r1]
 8056a70: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 8056a74: 4288         	cmp	r0, r1
 8056a76: d903         	bls	0x8056a80 <xTaskIncrementTick+0x254> @ imm = #0x6
 8056a78: e7ff         	b	0x8056a7a <xTaskIncrementTick+0x24e> @ imm = #-0x2
 8056a7a: 2001         	movs	r0, #0x1
;                                 xSwitchRequired = pdTRUE;
 8056a7c: 9005         	str	r0, [sp, #0x14]
;                             }
 8056a7e: e000         	b	0x8056a82 <xTaskIncrementTick+0x256> @ imm = #0x0
 8056a80: e7ff         	b	0x8056a82 <xTaskIncrementTick+0x256> @ imm = #-0x2
 8056a82: e7ff         	b	0x8056a84 <xTaskIncrementTick+0x258> @ imm = #-0x2
;             for( ; ; )
 8056a84: e722         	b	0x80568cc <xTaskIncrementTick+0xa0> @ imm = #-0x1bc
;         }
 8056a86: e7ff         	b	0x8056a88 <xTaskIncrementTick+0x25c> @ imm = #-0x2
;                 if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8056a88: f240 1000    	movw	r0, #0x100
 8056a8c: f2c2 0000    	movt	r0, #0x2000
 8056a90: 6800         	ldr	r0, [r0]
 8056a92: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8056a96: eb00 0180    	add.w	r1, r0, r0, lsl #2
 8056a9a: f240 1060    	movw	r0, #0x160
 8056a9e: f2c2 0000    	movt	r0, #0x2000
 8056aa2: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
 8056aa6: 2802         	cmp	r0, #0x2
 8056aa8: d303         	blo	0x8056ab2 <xTaskIncrementTick+0x286> @ imm = #0x6
 8056aaa: e7ff         	b	0x8056aac <xTaskIncrementTick+0x280> @ imm = #-0x2
 8056aac: 2001         	movs	r0, #0x1
;                     xSwitchRequired = pdTRUE;
 8056aae: 9005         	str	r0, [sp, #0x14]
;                 }
 8056ab0: e000         	b	0x8056ab4 <xTaskIncrementTick+0x288> @ imm = #0x0
 8056ab2: e7ff         	b	0x8056ab4 <xTaskIncrementTick+0x288> @ imm = #-0x2
;                 if( xYieldPendings[ 0 ] != pdFALSE )
 8056ab4: f240 20a4    	movw	r0, #0x2a4
 8056ab8: f2c2 0000    	movt	r0, #0x2000
 8056abc: 6800         	ldr	r0, [r0]
 8056abe: b118         	cbz	r0, 0x8056ac8 <xTaskIncrementTick+0x29c> @ imm = #0x6
 8056ac0: e7ff         	b	0x8056ac2 <xTaskIncrementTick+0x296> @ imm = #-0x2
 8056ac2: 2001         	movs	r0, #0x1
;                     xSwitchRequired = pdTRUE;
 8056ac4: 9005         	str	r0, [sp, #0x14]
;                 }
 8056ac6: e000         	b	0x8056aca <xTaskIncrementTick+0x29e> @ imm = #0x0
 8056ac8: e7ff         	b	0x8056aca <xTaskIncrementTick+0x29e> @ imm = #-0x2
;     }
 8056aca: e007         	b	0x8056adc <xTaskIncrementTick+0x2b0> @ imm = #0xe
;         ++xPendedTicks;
 8056acc: f240 21b0    	movw	r1, #0x2b0
 8056ad0: f2c2 0100    	movt	r1, #0x2000
 8056ad4: 6808         	ldr	r0, [r1]
 8056ad6: 3001         	adds	r0, #0x1
 8056ad8: 6008         	str	r0, [r1]
 8056ada: e7ff         	b	0x8056adc <xTaskIncrementTick+0x2b0> @ imm = #-0x2
;     return xSwitchRequired;
 8056adc: 9805         	ldr	r0, [sp, #0x14]
 8056ade: b008         	add	sp, #0x20
 8056ae0: bc80         	pop	{r7}
 8056ae2: eba8 0809    	sub.w	r8, r8, r9
 8056ae6: f858 fd5c    	ldr	pc, [r8, #-92]!
 8056aea: bf00         	nop

08056aec <$d.51>:
 8056aec: 1d 57 05 08  	.word	0x0805571d
 8056af0: 15 d7 05 08  	.word	0x0805d715

08056af4 <xTaskGetTickCount>:
; {
 8056af4: b081         	sub	sp, #0x4
;         xTicks = xTickCount;
 8056af6: f240 102c    	movw	r0, #0x12c
 8056afa: f2c2 0000    	movt	r0, #0x2000
 8056afe: 6800         	ldr	r0, [r0]
 8056b00: 9000         	str	r0, [sp]
;     return xTicks;
 8056b02: 9800         	ldr	r0, [sp]
 8056b04: b001         	add	sp, #0x4
 8056b06: 4770         	bx	lr

08056b08 <xTaskGetTickCountFromISR>:
; {
 8056b08: f848 eb64    	str	lr, [r8], #100
 8056b0c: eb08 0809    	add.w	r8, r8, r9
 8056b10: b480         	push	{r7}
 8056b12: 466f         	mov	r7, sp
 8056b14: b082         	sub	sp, #0x8
;     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8056b16: 4808         	ldr	r0, [pc, #0x20]         @ 0x8056b38 <xTaskGetTickCountFromISR+0x30>
 8056b18: 4780         	blx	r0
 8056b1a: 2000         	movs	r0, #0x0
;     uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 8056b1c: 9000         	str	r0, [sp]
;         xReturn = xTickCount;
 8056b1e: f240 102c    	movw	r0, #0x12c
 8056b22: f2c2 0000    	movt	r0, #0x2000
 8056b26: 6800         	ldr	r0, [r0]
 8056b28: 9001         	str	r0, [sp, #0x4]
;     return xReturn;
 8056b2a: 9801         	ldr	r0, [sp, #0x4]
 8056b2c: b002         	add	sp, #0x8
 8056b2e: bc80         	pop	{r7}
 8056b30: eba8 0809    	sub.w	r8, r8, r9
 8056b34: f858 fd64    	ldr	pc, [r8, #-100]!

08056b38 <$d.53>:
 8056b38: 1d f8 05 08  	.word	0x0805f81d

08056b3c <uxTaskGetNumberOfTasks>:
;     return uxCurrentNumberOfTasks;
 8056b3c: f240 1020    	movw	r0, #0x120
 8056b40: f2c2 0000    	movt	r0, #0x2000
 8056b44: 6800         	ldr	r0, [r0]
 8056b46: 4770         	bx	lr

08056b48 <pcTaskGetName>:
; {
 8056b48: f848 eb30    	str	lr, [r8], #48
 8056b4c: eb08 0809    	add.w	r8, r8, r9
 8056b50: b480         	push	{r7}
 8056b52: 466f         	mov	r7, sp
 8056b54: b084         	sub	sp, #0x10
 8056b56: 9003         	str	r0, [sp, #0xc]
;     pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 8056b58: 9803         	ldr	r0, [sp, #0xc]
 8056b5a: b938         	cbnz	r0, 0x8056b6c <pcTaskGetName+0x24> @ imm = #0xe
 8056b5c: e7ff         	b	0x8056b5e <pcTaskGetName+0x16> @ imm = #-0x2
 8056b5e: f240 1000    	movw	r0, #0x100
 8056b62: f2c2 0000    	movt	r0, #0x2000
 8056b66: 6800         	ldr	r0, [r0]
 8056b68: 9001         	str	r0, [sp, #0x4]
 8056b6a: e002         	b	0x8056b72 <pcTaskGetName+0x2a> @ imm = #0x4
 8056b6c: 9803         	ldr	r0, [sp, #0xc]
 8056b6e: 9001         	str	r0, [sp, #0x4]
 8056b70: e7ff         	b	0x8056b72 <pcTaskGetName+0x2a> @ imm = #-0x2
 8056b72: 9801         	ldr	r0, [sp, #0x4]
 8056b74: 9002         	str	r0, [sp, #0x8]
;     configASSERT( pxTCB );
 8056b76: 9802         	ldr	r0, [sp, #0x8]
 8056b78: b920         	cbnz	r0, 0x8056b84 <pcTaskGetName+0x3c> @ imm = #0x8
 8056b7a: e7ff         	b	0x8056b7c <pcTaskGetName+0x34> @ imm = #-0x2
 8056b7c: 4805         	ldr	r0, [pc, #0x14]         @ 0x8056b94 <pcTaskGetName+0x4c>
 8056b7e: 4780         	blx	r0
 8056b80: e7ff         	b	0x8056b82 <pcTaskGetName+0x3a> @ imm = #-0x2
 8056b82: e7fe         	b	0x8056b82 <pcTaskGetName+0x3a> @ imm = #-0x4
;     return &( pxTCB->pcTaskName[ 0 ] );
 8056b84: 9802         	ldr	r0, [sp, #0x8]
 8056b86: 30b0         	adds	r0, #0xb0
 8056b88: b004         	add	sp, #0x10
 8056b8a: bc80         	pop	{r7}
 8056b8c: eba8 0809    	sub.w	r8, r8, r9
 8056b90: f858 fd30    	ldr	pc, [r8, #-48]!

08056b94 <$d.55>:
 8056b94: 15 d7 05 08  	.word	0x0805d715

08056b98 <uxTaskGetSystemState>:
;     {
 8056b98: f848 eb60    	str	lr, [r8], #96
 8056b9c: eb08 0809    	add.w	r8, r8, r9
 8056ba0: b480         	push	{r7}
 8056ba2: 466f         	mov	r7, sp
 8056ba4: b08c         	sub	sp, #0x30
 8056ba6: 900b         	str	r0, [sp, #0x2c]
 8056ba8: 910a         	str	r1, [sp, #0x28]
 8056baa: 9209         	str	r2, [sp, #0x24]
 8056bac: 2000         	movs	r0, #0x0
;         UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 8056bae: 9008         	str	r0, [sp, #0x20]
 8056bb0: 2010         	movs	r0, #0x10
 8056bb2: 9007         	str	r0, [sp, #0x1c]
;         vTaskSuspendAll();
 8056bb4: 4843         	ldr	r0, [pc, #0x10c]        @ 0x8056cc4 <uxTaskGetSystemState+0x12c>
 8056bb6: 4780         	blx	r0
;             if( uxArraySize >= uxCurrentNumberOfTasks )
 8056bb8: 980a         	ldr	r0, [sp, #0x28]
 8056bba: f240 1120    	movw	r1, #0x120
 8056bbe: f2c2 0100    	movt	r1, #0x2000
 8056bc2: 6809         	ldr	r1, [r1]
 8056bc4: 4288         	cmp	r0, r1
 8056bc6: d373         	blo	0x8056cb0 <uxTaskGetSystemState+0x118> @ imm = #0xe6
 8056bc8: e7ff         	b	0x8056bca <uxTaskGetSystemState+0x32> @ imm = #-0x2
;                 do
 8056bca: e7ff         	b	0x8056bcc <uxTaskGetSystemState+0x34> @ imm = #-0x2
;                     uxQueue--;
 8056bcc: 9807         	ldr	r0, [sp, #0x1c]
 8056bce: 3801         	subs	r0, #0x1
 8056bd0: 9007         	str	r0, [sp, #0x1c]
;                     uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady ) );
 8056bd2: 9908         	ldr	r1, [sp, #0x20]
 8056bd4: 9106         	str	r1, [sp, #0x18]
 8056bd6: 980b         	ldr	r0, [sp, #0x2c]
 8056bd8: eb01 01c1    	add.w	r1, r1, r1, lsl #3
 8056bdc: eb00 0081    	add.w	r0, r0, r1, lsl #2
 8056be0: 9907         	ldr	r1, [sp, #0x1c]
 8056be2: eb01 0281    	add.w	r2, r1, r1, lsl #2
 8056be6: f240 1160    	movw	r1, #0x160
 8056bea: f2c2 0100    	movt	r1, #0x2000
 8056bee: eb01 0182    	add.w	r1, r1, r2, lsl #2
 8056bf2: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8056cc8 <uxTaskGetSystemState+0x130>
 8056bf4: 2201         	movs	r2, #0x1
 8056bf6: 4798         	blx	r3
 8056bf8: 4601         	mov	r1, r0
 8056bfa: 9806         	ldr	r0, [sp, #0x18]
 8056bfc: 4408         	add	r0, r1
 8056bfe: 9008         	str	r0, [sp, #0x20]
;                 } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8056c00: e7ff         	b	0x8056c02 <uxTaskGetSystemState+0x6a> @ imm = #-0x2
 8056c02: 9807         	ldr	r0, [sp, #0x1c]
 8056c04: 2800         	cmp	r0, #0x0
 8056c06: d1e1         	bne	0x8056bcc <uxTaskGetSystemState+0x34> @ imm = #-0x3e
 8056c08: e7ff         	b	0x8056c0a <uxTaskGetSystemState+0x72> @ imm = #-0x2
;                 uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked ) );
 8056c0a: 9908         	ldr	r1, [sp, #0x20]
 8056c0c: 9102         	str	r1, [sp, #0x8]
 8056c0e: 980b         	ldr	r0, [sp, #0x2c]
 8056c10: eb01 01c1    	add.w	r1, r1, r1, lsl #3
 8056c14: eb00 0081    	add.w	r0, r0, r1, lsl #2
 8056c18: f240 1130    	movw	r1, #0x130
 8056c1c: f2c2 0100    	movt	r1, #0x2000
 8056c20: 6809         	ldr	r1, [r1]
 8056c22: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x8056ccc <uxTaskGetSystemState+0x134>
 8056c24: 2202         	movs	r2, #0x2
 8056c26: 9201         	str	r2, [sp, #0x4]
 8056c28: 4798         	blx	r3
 8056c2a: 9a01         	ldr	r2, [sp, #0x4]
 8056c2c: 4601         	mov	r1, r0
 8056c2e: 9802         	ldr	r0, [sp, #0x8]
 8056c30: 4408         	add	r0, r1
 8056c32: 9008         	str	r0, [sp, #0x20]
;                 uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked ) );
 8056c34: 9908         	ldr	r1, [sp, #0x20]
 8056c36: 9103         	str	r1, [sp, #0xc]
 8056c38: 980b         	ldr	r0, [sp, #0x2c]
 8056c3a: eb01 01c1    	add.w	r1, r1, r1, lsl #3
 8056c3e: eb00 0081    	add.w	r0, r0, r1, lsl #2
 8056c42: f240 1134    	movw	r1, #0x134
 8056c46: f2c2 0100    	movt	r1, #0x2000
 8056c4a: 6809         	ldr	r1, [r1]
 8056c4c: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8056cd0 <uxTaskGetSystemState+0x138>
 8056c4e: 4798         	blx	r3
 8056c50: 4601         	mov	r1, r0
 8056c52: 9803         	ldr	r0, [sp, #0xc]
 8056c54: 4408         	add	r0, r1
 8056c56: 9008         	str	r0, [sp, #0x20]
;                     uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted ) );
 8056c58: 9908         	ldr	r1, [sp, #0x20]
 8056c5a: 9104         	str	r1, [sp, #0x10]
 8056c5c: 980b         	ldr	r0, [sp, #0x2c]
 8056c5e: eb01 01c1    	add.w	r1, r1, r1, lsl #3
 8056c62: eb00 0081    	add.w	r0, r0, r1, lsl #2
 8056c66: f240 1108    	movw	r1, #0x108
 8056c6a: f2c2 0100    	movt	r1, #0x2000
 8056c6e: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8056cd4 <uxTaskGetSystemState+0x13c>
 8056c70: 2204         	movs	r2, #0x4
 8056c72: 4798         	blx	r3
 8056c74: 4601         	mov	r1, r0
 8056c76: 9804         	ldr	r0, [sp, #0x10]
 8056c78: 4408         	add	r0, r1
 8056c7a: 9008         	str	r0, [sp, #0x20]
;                     uxTask = ( UBaseType_t ) ( uxTask + prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended ) );
 8056c7c: 9908         	ldr	r1, [sp, #0x20]
 8056c7e: 9105         	str	r1, [sp, #0x14]
 8056c80: 980b         	ldr	r0, [sp, #0x2c]
 8056c82: eb01 01c1    	add.w	r1, r1, r1, lsl #3
 8056c86: eb00 0081    	add.w	r0, r0, r1, lsl #2
 8056c8a: f240 114c    	movw	r1, #0x14c
 8056c8e: f2c2 0100    	movt	r1, #0x2000
 8056c92: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8056cd8 <uxTaskGetSystemState+0x140>
 8056c94: 2203         	movs	r2, #0x3
 8056c96: 4798         	blx	r3
 8056c98: 4601         	mov	r1, r0
 8056c9a: 9805         	ldr	r0, [sp, #0x14]
 8056c9c: 4408         	add	r0, r1
 8056c9e: 9008         	str	r0, [sp, #0x20]
;                     if( pulTotalRunTime != NULL )
 8056ca0: 9809         	ldr	r0, [sp, #0x24]
 8056ca2: b120         	cbz	r0, 0x8056cae <uxTaskGetSystemState+0x116> @ imm = #0x8
 8056ca4: e7ff         	b	0x8056ca6 <uxTaskGetSystemState+0x10e> @ imm = #-0x2
;                         *pulTotalRunTime = 0;
 8056ca6: 9909         	ldr	r1, [sp, #0x24]
 8056ca8: 2000         	movs	r0, #0x0
 8056caa: 6008         	str	r0, [r1]
;                     }
 8056cac: e7ff         	b	0x8056cae <uxTaskGetSystemState+0x116> @ imm = #-0x2
;             }
 8056cae: e000         	b	0x8056cb2 <uxTaskGetSystemState+0x11a> @ imm = #0x0
 8056cb0: e7ff         	b	0x8056cb2 <uxTaskGetSystemState+0x11a> @ imm = #-0x2
;         ( void ) xTaskResumeAll();
 8056cb2: 480a         	ldr	r0, [pc, #0x28]         @ 0x8056cdc <uxTaskGetSystemState+0x144>
 8056cb4: 4780         	blx	r0
;         return uxTask;
 8056cb6: 9808         	ldr	r0, [sp, #0x20]
 8056cb8: b00c         	add	sp, #0x30
 8056cba: bc80         	pop	{r7}
 8056cbc: eba8 0809    	sub.w	r8, r8, r9
 8056cc0: f858 fd60    	ldr	pc, [r8, #-96]!

08056cc4 <$d.57>:
 8056cc4: d9 58 05 08  	.word	0x080558d9
 8056cc8: e1 6c 05 08  	.word	0x08056ce1
 8056ccc: e1 6c 05 08  	.word	0x08056ce1
 8056cd0: e1 6c 05 08  	.word	0x08056ce1
 8056cd4: e1 6c 05 08  	.word	0x08056ce1
 8056cd8: e1 6c 05 08  	.word	0x08056ce1
 8056cdc: 0d 5a 05 08  	.word	0x08055a0d

08056ce0 <prvListTasksWithinSingleList>:
;     {
 8056ce0: f848 eb2c    	str	lr, [r8], #44
 8056ce4: eb08 0809    	add.w	r8, r8, r9
 8056ce8: b480         	push	{r7}
 8056cea: 466f         	mov	r7, sp
 8056cec: b088         	sub	sp, #0x20
 8056cee: 9007         	str	r0, [sp, #0x1c]
 8056cf0: 9106         	str	r1, [sp, #0x18]
 8056cf2: f807 2c09    	strb	r2, [r7, #-9]
 8056cf6: 2000         	movs	r0, #0x0
;         UBaseType_t uxTask = 0;
 8056cf8: 9002         	str	r0, [sp, #0x8]
;         if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 8056cfa: 9806         	ldr	r0, [sp, #0x18]
 8056cfc: 6800         	ldr	r0, [r0]
 8056cfe: 2800         	cmp	r0, #0x0
 8056d00: d044         	beq	0x8056d8c <prvListTasksWithinSingleList+0xac> @ imm = #0x88
 8056d02: e7ff         	b	0x8056d04 <prvListTasksWithinSingleList+0x24> @ imm = #-0x2
;             listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8056d04: e7ff         	b	0x8056d06 <prvListTasksWithinSingleList+0x26> @ imm = #-0x2
 8056d06: 9806         	ldr	r0, [sp, #0x18]
 8056d08: 9001         	str	r0, [sp, #0x4]
 8056d0a: 9901         	ldr	r1, [sp, #0x4]
 8056d0c: 6848         	ldr	r0, [r1, #0x4]
 8056d0e: 6840         	ldr	r0, [r0, #0x4]
 8056d10: 6048         	str	r0, [r1, #0x4]
 8056d12: 9901         	ldr	r1, [sp, #0x4]
 8056d14: 6848         	ldr	r0, [r1, #0x4]
 8056d16: 3108         	adds	r1, #0x8
 8056d18: 4288         	cmp	r0, r1
 8056d1a: d104         	bne	0x8056d26 <prvListTasksWithinSingleList+0x46> @ imm = #0x8
 8056d1c: e7ff         	b	0x8056d1e <prvListTasksWithinSingleList+0x3e> @ imm = #-0x2
 8056d1e: 9901         	ldr	r1, [sp, #0x4]
 8056d20: 68c8         	ldr	r0, [r1, #0xc]
 8056d22: 6048         	str	r0, [r1, #0x4]
 8056d24: e7ff         	b	0x8056d26 <prvListTasksWithinSingleList+0x46> @ imm = #-0x2
 8056d26: 9801         	ldr	r0, [sp, #0x4]
 8056d28: 6840         	ldr	r0, [r0, #0x4]
 8056d2a: 68c0         	ldr	r0, [r0, #0xc]
 8056d2c: 9003         	str	r0, [sp, #0xc]
 8056d2e: e7ff         	b	0x8056d30 <prvListTasksWithinSingleList+0x50> @ imm = #-0x2
;             do
 8056d30: e7ff         	b	0x8056d32 <prvListTasksWithinSingleList+0x52> @ imm = #-0x2
;                 listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8056d32: e7ff         	b	0x8056d34 <prvListTasksWithinSingleList+0x54> @ imm = #-0x2
 8056d34: 9806         	ldr	r0, [sp, #0x18]
 8056d36: 9000         	str	r0, [sp]
 8056d38: 9900         	ldr	r1, [sp]
 8056d3a: 6848         	ldr	r0, [r1, #0x4]
 8056d3c: 6840         	ldr	r0, [r0, #0x4]
 8056d3e: 6048         	str	r0, [r1, #0x4]
 8056d40: 9900         	ldr	r1, [sp]
 8056d42: 6848         	ldr	r0, [r1, #0x4]
 8056d44: 3108         	adds	r1, #0x8
 8056d46: 4288         	cmp	r0, r1
 8056d48: d104         	bne	0x8056d54 <prvListTasksWithinSingleList+0x74> @ imm = #0x8
 8056d4a: e7ff         	b	0x8056d4c <prvListTasksWithinSingleList+0x6c> @ imm = #-0x2
 8056d4c: 9900         	ldr	r1, [sp]
 8056d4e: 68c8         	ldr	r0, [r1, #0xc]
 8056d50: 6048         	str	r0, [r1, #0x4]
 8056d52: e7ff         	b	0x8056d54 <prvListTasksWithinSingleList+0x74> @ imm = #-0x2
 8056d54: 9800         	ldr	r0, [sp]
 8056d56: 6840         	ldr	r0, [r0, #0x4]
 8056d58: 68c0         	ldr	r0, [r0, #0xc]
 8056d5a: 9004         	str	r0, [sp, #0x10]
 8056d5c: e7ff         	b	0x8056d5e <prvListTasksWithinSingleList+0x7e> @ imm = #-0x2
;                 vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 8056d5e: 9804         	ldr	r0, [sp, #0x10]
 8056d60: 9907         	ldr	r1, [sp, #0x1c]
 8056d62: 9a02         	ldr	r2, [sp, #0x8]
 8056d64: eb02 02c2    	add.w	r2, r2, r2, lsl #3
 8056d68: eb01 0182    	add.w	r1, r1, r2, lsl #2
 8056d6c: f817 3c09    	ldrb	r3, [r7, #-9]
 8056d70: f8df c028    	ldr.w	r12, [pc, #0x28]        @ 0x8056d9c <prvListTasksWithinSingleList+0xbc>
 8056d74: 2201         	movs	r2, #0x1
 8056d76: 47e0         	blx	r12
;                 uxTask++;
 8056d78: 9802         	ldr	r0, [sp, #0x8]
 8056d7a: 3001         	adds	r0, #0x1
 8056d7c: 9002         	str	r0, [sp, #0x8]
;             } while( pxNextTCB != pxFirstTCB );
 8056d7e: e7ff         	b	0x8056d80 <prvListTasksWithinSingleList+0xa0> @ imm = #-0x2
 8056d80: 9804         	ldr	r0, [sp, #0x10]
 8056d82: 9903         	ldr	r1, [sp, #0xc]
 8056d84: 4288         	cmp	r0, r1
 8056d86: d1d4         	bne	0x8056d32 <prvListTasksWithinSingleList+0x52> @ imm = #-0x58
 8056d88: e7ff         	b	0x8056d8a <prvListTasksWithinSingleList+0xaa> @ imm = #-0x2
;         }
 8056d8a: e000         	b	0x8056d8e <prvListTasksWithinSingleList+0xae> @ imm = #0x0
 8056d8c: e7ff         	b	0x8056d8e <prvListTasksWithinSingleList+0xae> @ imm = #-0x2
;         return uxTask;
 8056d8e: 9802         	ldr	r0, [sp, #0x8]
 8056d90: b008         	add	sp, #0x20
 8056d92: bc80         	pop	{r7}
 8056d94: eba8 0809    	sub.w	r8, r8, r9
 8056d98: f858 fd2c    	ldr	pc, [r8, #-44]!

08056d9c <$d.59>:
 8056d9c: 3d 75 05 08  	.word	0x0805753d

08056da0 <xTaskCatchUpTicks>:
; {
 8056da0: f848 eb4c    	str	lr, [r8], #76
 8056da4: eb08 0809    	add.w	r8, r8, r9
 8056da8: b480         	push	{r7}
 8056daa: 466f         	mov	r7, sp
 8056dac: b082         	sub	sp, #0x8
 8056dae: 9001         	str	r0, [sp, #0x4]
;     configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );
 8056db0: f240 1028    	movw	r0, #0x128
 8056db4: f2c2 0000    	movt	r0, #0x2000
 8056db8: 6800         	ldr	r0, [r0]
 8056dba: b120         	cbz	r0, 0x8056dc6 <xTaskCatchUpTicks+0x26> @ imm = #0x8
 8056dbc: e7ff         	b	0x8056dbe <xTaskCatchUpTicks+0x1e> @ imm = #-0x2
 8056dbe: 4812         	ldr	r0, [pc, #0x48]         @ 0x8056e08 <xTaskCatchUpTicks+0x68>
 8056dc0: 4780         	blx	r0
 8056dc2: e7ff         	b	0x8056dc4 <xTaskCatchUpTicks+0x24> @ imm = #-0x2
 8056dc4: e7fe         	b	0x8056dc4 <xTaskCatchUpTicks+0x24> @ imm = #-0x4
;     vTaskSuspendAll();
 8056dc6: 480c         	ldr	r0, [pc, #0x30]         @ 0x8056df8 <xTaskCatchUpTicks+0x58>
 8056dc8: 4780         	blx	r0
;     taskENTER_CRITICAL();
 8056dca: 480c         	ldr	r0, [pc, #0x30]         @ 0x8056dfc <xTaskCatchUpTicks+0x5c>
 8056dcc: 4780         	blx	r0
;         xPendedTicks += xTicksToCatchUp;
 8056dce: 9a01         	ldr	r2, [sp, #0x4]
 8056dd0: f240 21b0    	movw	r1, #0x2b0
 8056dd4: f2c2 0100    	movt	r1, #0x2000
 8056dd8: 6808         	ldr	r0, [r1]
 8056dda: 4410         	add	r0, r2
 8056ddc: 6008         	str	r0, [r1]
;     taskEXIT_CRITICAL();
 8056dde: 4808         	ldr	r0, [pc, #0x20]         @ 0x8056e00 <xTaskCatchUpTicks+0x60>
 8056de0: 4780         	blx	r0
;     xYieldOccurred = xTaskResumeAll();
 8056de2: 4808         	ldr	r0, [pc, #0x20]         @ 0x8056e04 <xTaskCatchUpTicks+0x64>
 8056de4: 4780         	blx	r0
 8056de6: 9000         	str	r0, [sp]
;     return xYieldOccurred;
 8056de8: 9800         	ldr	r0, [sp]
 8056dea: b002         	add	sp, #0x8
 8056dec: bc80         	pop	{r7}
 8056dee: eba8 0809    	sub.w	r8, r8, r9
 8056df2: f858 fd4c    	ldr	pc, [r8, #-76]!
 8056df6: bf00         	nop

08056df8 <$d.61>:
 8056df8: d9 58 05 08  	.word	0x080558d9
 8056dfc: 49 cd 05 08  	.word	0x0805cd49
 8056e00: 7d cd 05 08  	.word	0x0805cd7d
 8056e04: 0d 5a 05 08  	.word	0x08055a0d
 8056e08: 15 d7 05 08  	.word	0x0805d715

08056e0c <vTaskPlaceOnEventList>:
; {
 8056e0c: f848 eb50    	str	lr, [r8], #80
 8056e10: eb08 0809    	add.w	r8, r8, r9
 8056e14: b480         	push	{r7}
 8056e16: 466f         	mov	r7, sp
 8056e18: b082         	sub	sp, #0x8
 8056e1a: 9001         	str	r0, [sp, #0x4]
 8056e1c: 9100         	str	r1, [sp]
;     configASSERT( pxEventList );
 8056e1e: 9801         	ldr	r0, [sp, #0x4]
 8056e20: b920         	cbnz	r0, 0x8056e2c <vTaskPlaceOnEventList+0x20> @ imm = #0x8
 8056e22: e7ff         	b	0x8056e24 <vTaskPlaceOnEventList+0x18> @ imm = #-0x2
 8056e24: 480d         	ldr	r0, [pc, #0x34]         @ 0x8056e5c <vTaskPlaceOnEventList+0x50>
 8056e26: 4780         	blx	r0
 8056e28: e7ff         	b	0x8056e2a <vTaskPlaceOnEventList+0x1e> @ imm = #-0x2
 8056e2a: e7fe         	b	0x8056e2a <vTaskPlaceOnEventList+0x1e> @ imm = #-0x4
;     vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8056e2c: 9801         	ldr	r0, [sp, #0x4]
 8056e2e: f240 1100    	movw	r1, #0x100
 8056e32: f2c2 0100    	movt	r1, #0x2000
 8056e36: 6809         	ldr	r1, [r1]
 8056e38: 3194         	adds	r1, #0x94
 8056e3a: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8056e54 <vTaskPlaceOnEventList+0x48>
 8056e3c: 4790         	blx	r2
;     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8056e3e: 9800         	ldr	r0, [sp]
 8056e40: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8056e58 <vTaskPlaceOnEventList+0x4c>
 8056e42: 2101         	movs	r1, #0x1
 8056e44: 4790         	blx	r2
; }
 8056e46: b002         	add	sp, #0x8
 8056e48: bc80         	pop	{r7}
 8056e4a: eba8 0809    	sub.w	r8, r8, r9
 8056e4e: f858 fd50    	ldr	pc, [r8, #-80]!
 8056e52: bf00         	nop

08056e54 <$d.63>:
 8056e54: a9 a4 05 08  	.word	0x0805a4a9
 8056e58: e9 58 05 08  	.word	0x080558e9
 8056e5c: 15 d7 05 08  	.word	0x0805d715

08056e60 <vTaskPlaceOnUnorderedEventList>:
; {
 8056e60: f848 eb50    	str	lr, [r8], #80
 8056e64: eb08 0809    	add.w	r8, r8, r9
 8056e68: b480         	push	{r7}
 8056e6a: 466f         	mov	r7, sp
 8056e6c: b084         	sub	sp, #0x10
 8056e6e: 9003         	str	r0, [sp, #0xc]
 8056e70: 9102         	str	r1, [sp, #0x8]
 8056e72: 9201         	str	r2, [sp, #0x4]
;     configASSERT( pxEventList );
 8056e74: 9803         	ldr	r0, [sp, #0xc]
 8056e76: b920         	cbnz	r0, 0x8056e82 <vTaskPlaceOnUnorderedEventList+0x22> @ imm = #0x8
 8056e78: e7ff         	b	0x8056e7a <vTaskPlaceOnUnorderedEventList+0x1a> @ imm = #-0x2
 8056e7a: 4825         	ldr	r0, [pc, #0x94]         @ 0x8056f10 <vTaskPlaceOnUnorderedEventList+0xb0>
 8056e7c: 4780         	blx	r0
 8056e7e: e7ff         	b	0x8056e80 <vTaskPlaceOnUnorderedEventList+0x20> @ imm = #-0x2
 8056e80: e7fe         	b	0x8056e80 <vTaskPlaceOnUnorderedEventList+0x20> @ imm = #-0x4
;     configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );
 8056e82: f240 1028    	movw	r0, #0x128
 8056e86: f2c2 0000    	movt	r0, #0x2000
 8056e8a: 6800         	ldr	r0, [r0]
 8056e8c: b920         	cbnz	r0, 0x8056e98 <vTaskPlaceOnUnorderedEventList+0x38> @ imm = #0x8
 8056e8e: e7ff         	b	0x8056e90 <vTaskPlaceOnUnorderedEventList+0x30> @ imm = #-0x2
 8056e90: 481e         	ldr	r0, [pc, #0x78]         @ 0x8056f0c <vTaskPlaceOnUnorderedEventList+0xac>
 8056e92: 4780         	blx	r0
 8056e94: e7ff         	b	0x8056e96 <vTaskPlaceOnUnorderedEventList+0x36> @ imm = #-0x2
 8056e96: e7fe         	b	0x8056e96 <vTaskPlaceOnUnorderedEventList+0x36> @ imm = #-0x4
;     listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 8056e98: 9802         	ldr	r0, [sp, #0x8]
 8056e9a: f040 4000    	orr	r0, r0, #0x80000000
 8056e9e: f240 1100    	movw	r1, #0x100
 8056ea2: f2c2 0100    	movt	r1, #0x2000
 8056ea6: 6809         	ldr	r1, [r1]
 8056ea8: f8c1 0094    	str.w	r0, [r1, #0x94]
;     listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8056eac: e7ff         	b	0x8056eae <vTaskPlaceOnUnorderedEventList+0x4e> @ imm = #-0x2
 8056eae: 9803         	ldr	r0, [sp, #0xc]
 8056eb0: 6840         	ldr	r0, [r0, #0x4]
 8056eb2: 9000         	str	r0, [sp]
 8056eb4: 9800         	ldr	r0, [sp]
 8056eb6: f240 1100    	movw	r1, #0x100
 8056eba: f2c2 0100    	movt	r1, #0x2000
 8056ebe: 680a         	ldr	r2, [r1]
 8056ec0: f8c2 0098    	str.w	r0, [r2, #0x98]
 8056ec4: 9800         	ldr	r0, [sp]
 8056ec6: 6880         	ldr	r0, [r0, #0x8]
 8056ec8: 680a         	ldr	r2, [r1]
 8056eca: f8c2 009c    	str.w	r0, [r2, #0x9c]
 8056ece: 6808         	ldr	r0, [r1]
 8056ed0: 3094         	adds	r0, #0x94
 8056ed2: 9a00         	ldr	r2, [sp]
 8056ed4: 6892         	ldr	r2, [r2, #0x8]
 8056ed6: 6050         	str	r0, [r2, #0x4]
 8056ed8: 6808         	ldr	r0, [r1]
 8056eda: 3094         	adds	r0, #0x94
 8056edc: 9a00         	ldr	r2, [sp]
 8056ede: 6090         	str	r0, [r2, #0x8]
 8056ee0: 9803         	ldr	r0, [sp, #0xc]
 8056ee2: 6809         	ldr	r1, [r1]
 8056ee4: f8c1 00a4    	str.w	r0, [r1, #0xa4]
 8056ee8: 9903         	ldr	r1, [sp, #0xc]
 8056eea: 6808         	ldr	r0, [r1]
 8056eec: 3001         	adds	r0, #0x1
 8056eee: 6008         	str	r0, [r1]
 8056ef0: e7ff         	b	0x8056ef2 <vTaskPlaceOnUnorderedEventList+0x92> @ imm = #-0x2
;     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8056ef2: 9801         	ldr	r0, [sp, #0x4]
 8056ef4: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8056f08 <vTaskPlaceOnUnorderedEventList+0xa8>
 8056ef6: 2101         	movs	r1, #0x1
 8056ef8: 4790         	blx	r2
; }
 8056efa: b004         	add	sp, #0x10
 8056efc: bc80         	pop	{r7}
 8056efe: eba8 0809    	sub.w	r8, r8, r9
 8056f02: f858 fd50    	ldr	pc, [r8, #-80]!
 8056f06: bf00         	nop

08056f08 <$d.65>:
 8056f08: e9 58 05 08  	.word	0x080558e9
 8056f0c: 15 d7 05 08  	.word	0x0805d715
 8056f10: 15 d7 05 08  	.word	0x0805d715

08056f14 <vTaskPlaceOnEventListRestricted>:
;     {
 8056f14: f848 eb24    	str	lr, [r8], #36
 8056f18: eb08 0809    	add.w	r8, r8, r9
 8056f1c: b480         	push	{r7}
 8056f1e: 466f         	mov	r7, sp
 8056f20: b084         	sub	sp, #0x10
 8056f22: 9003         	str	r0, [sp, #0xc]
 8056f24: 9102         	str	r1, [sp, #0x8]
 8056f26: 9201         	str	r2, [sp, #0x4]
;         configASSERT( pxEventList );
 8056f28: 9803         	ldr	r0, [sp, #0xc]
 8056f2a: b920         	cbnz	r0, 0x8056f36 <vTaskPlaceOnEventListRestricted+0x22> @ imm = #0x8
 8056f2c: e7ff         	b	0x8056f2e <vTaskPlaceOnEventListRestricted+0x1a> @ imm = #-0x2
 8056f2e: 481d         	ldr	r0, [pc, #0x74]         @ 0x8056fa4 <vTaskPlaceOnEventListRestricted+0x90>
 8056f30: 4780         	blx	r0
 8056f32: e7ff         	b	0x8056f34 <vTaskPlaceOnEventListRestricted+0x20> @ imm = #-0x2
 8056f34: e7fe         	b	0x8056f34 <vTaskPlaceOnEventListRestricted+0x20> @ imm = #-0x4
;         listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8056f36: e7ff         	b	0x8056f38 <vTaskPlaceOnEventListRestricted+0x24> @ imm = #-0x2
 8056f38: 9803         	ldr	r0, [sp, #0xc]
 8056f3a: 6840         	ldr	r0, [r0, #0x4]
 8056f3c: 9000         	str	r0, [sp]
 8056f3e: 9800         	ldr	r0, [sp]
 8056f40: f240 1100    	movw	r1, #0x100
 8056f44: f2c2 0100    	movt	r1, #0x2000
 8056f48: 680a         	ldr	r2, [r1]
 8056f4a: f8c2 0098    	str.w	r0, [r2, #0x98]
 8056f4e: 9800         	ldr	r0, [sp]
 8056f50: 6880         	ldr	r0, [r0, #0x8]
 8056f52: 680a         	ldr	r2, [r1]
 8056f54: f8c2 009c    	str.w	r0, [r2, #0x9c]
 8056f58: 6808         	ldr	r0, [r1]
 8056f5a: 3094         	adds	r0, #0x94
 8056f5c: 9a00         	ldr	r2, [sp]
 8056f5e: 6892         	ldr	r2, [r2, #0x8]
 8056f60: 6050         	str	r0, [r2, #0x4]
 8056f62: 6808         	ldr	r0, [r1]
 8056f64: 3094         	adds	r0, #0x94
 8056f66: 9a00         	ldr	r2, [sp]
 8056f68: 6090         	str	r0, [r2, #0x8]
 8056f6a: 9803         	ldr	r0, [sp, #0xc]
 8056f6c: 6809         	ldr	r1, [r1]
 8056f6e: f8c1 00a4    	str.w	r0, [r1, #0xa4]
 8056f72: 9903         	ldr	r1, [sp, #0xc]
 8056f74: 6808         	ldr	r0, [r1]
 8056f76: 3001         	adds	r0, #0x1
 8056f78: 6008         	str	r0, [r1]
 8056f7a: e7ff         	b	0x8056f7c <vTaskPlaceOnEventListRestricted+0x68> @ imm = #-0x2
;         if( xWaitIndefinitely != pdFALSE )
 8056f7c: 9801         	ldr	r0, [sp, #0x4]
 8056f7e: b120         	cbz	r0, 0x8056f8a <vTaskPlaceOnEventListRestricted+0x76> @ imm = #0x8
 8056f80: e7ff         	b	0x8056f82 <vTaskPlaceOnEventListRestricted+0x6e> @ imm = #-0x2
 8056f82: f04f 30ff    	mov.w	r0, #0xffffffff
;             xTicksToWait = portMAX_DELAY;
 8056f86: 9002         	str	r0, [sp, #0x8]
;         }
 8056f88: e7ff         	b	0x8056f8a <vTaskPlaceOnEventListRestricted+0x76> @ imm = #-0x2
;         prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8056f8a: 9802         	ldr	r0, [sp, #0x8]
 8056f8c: 9901         	ldr	r1, [sp, #0x4]
 8056f8e: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8056fa0 <vTaskPlaceOnEventListRestricted+0x8c>
 8056f90: 4790         	blx	r2
;     }
 8056f92: b004         	add	sp, #0x10
 8056f94: bc80         	pop	{r7}
 8056f96: eba8 0809    	sub.w	r8, r8, r9
 8056f9a: f858 fd24    	ldr	pc, [r8, #-36]!
 8056f9e: bf00         	nop

08056fa0 <$d.67>:
 8056fa0: e9 58 05 08  	.word	0x080558e9
 8056fa4: 15 d7 05 08  	.word	0x0805d715

08056fa8 <xTaskRemoveFromEventList>:
; {
 8056fa8: f848 eb40    	str	lr, [r8], #64
 8056fac: eb08 0809    	add.w	r8, r8, r9
 8056fb0: b480         	push	{r7}
 8056fb2: 466f         	mov	r7, sp
 8056fb4: b088         	sub	sp, #0x20
 8056fb6: 9007         	str	r0, [sp, #0x1c]
;     pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8056fb8: 9807         	ldr	r0, [sp, #0x1c]
 8056fba: 68c0         	ldr	r0, [r0, #0xc]
 8056fbc: 68c0         	ldr	r0, [r0, #0xc]
 8056fbe: 9006         	str	r0, [sp, #0x18]
;     configASSERT( pxUnblockedTCB );
 8056fc0: 9806         	ldr	r0, [sp, #0x18]
 8056fc2: b920         	cbnz	r0, 0x8056fce <xTaskRemoveFromEventList+0x26> @ imm = #0x8
 8056fc4: e7ff         	b	0x8056fc6 <xTaskRemoveFromEventList+0x1e> @ imm = #-0x2
 8056fc6: 4873         	ldr	r0, [pc, #0x1cc]        @ 0x8057194 <xTaskRemoveFromEventList+0x1ec>
 8056fc8: 4780         	blx	r0
 8056fca: e7ff         	b	0x8056fcc <xTaskRemoveFromEventList+0x24> @ imm = #-0x2
 8056fcc: e7fe         	b	0x8056fcc <xTaskRemoveFromEventList+0x24> @ imm = #-0x4
;     listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
 8056fce: e7ff         	b	0x8056fd0 <xTaskRemoveFromEventList+0x28> @ imm = #-0x2
 8056fd0: 9806         	ldr	r0, [sp, #0x18]
 8056fd2: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
 8056fd6: 9004         	str	r0, [sp, #0x10]
 8056fd8: 9806         	ldr	r0, [sp, #0x18]
 8056fda: f8d0 1098    	ldr.w	r1, [r0, #0x98]
 8056fde: f8d0 009c    	ldr.w	r0, [r0, #0x9c]
 8056fe2: 6088         	str	r0, [r1, #0x8]
 8056fe4: 9906         	ldr	r1, [sp, #0x18]
 8056fe6: f8d1 0098    	ldr.w	r0, [r1, #0x98]
 8056fea: f8d1 109c    	ldr.w	r1, [r1, #0x9c]
 8056fee: 6048         	str	r0, [r1, #0x4]
 8056ff0: 9804         	ldr	r0, [sp, #0x10]
 8056ff2: 6840         	ldr	r0, [r0, #0x4]
 8056ff4: 9906         	ldr	r1, [sp, #0x18]
 8056ff6: 3194         	adds	r1, #0x94
 8056ff8: 4288         	cmp	r0, r1
 8056ffa: d106         	bne	0x805700a <xTaskRemoveFromEventList+0x62> @ imm = #0xc
 8056ffc: e7ff         	b	0x8056ffe <xTaskRemoveFromEventList+0x56> @ imm = #-0x2
 8056ffe: 9806         	ldr	r0, [sp, #0x18]
 8057000: f8d0 009c    	ldr.w	r0, [r0, #0x9c]
 8057004: 9904         	ldr	r1, [sp, #0x10]
 8057006: 6048         	str	r0, [r1, #0x4]
 8057008: e7ff         	b	0x805700a <xTaskRemoveFromEventList+0x62> @ imm = #-0x2
 805700a: 9906         	ldr	r1, [sp, #0x18]
 805700c: 2000         	movs	r0, #0x0
 805700e: f8c1 00a4    	str.w	r0, [r1, #0xa4]
 8057012: 9904         	ldr	r1, [sp, #0x10]
 8057014: 6808         	ldr	r0, [r1]
 8057016: 3801         	subs	r0, #0x1
 8057018: 6008         	str	r0, [r1]
 805701a: e7ff         	b	0x805701c <xTaskRemoveFromEventList+0x74> @ imm = #-0x2
;     if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 805701c: f240 1028    	movw	r0, #0x128
 8057020: f2c2 0000    	movt	r0, #0x2000
 8057024: 6800         	ldr	r0, [r0]
 8057026: 2800         	cmp	r0, #0x0
 8057028: d174         	bne	0x8057114 <xTaskRemoveFromEventList+0x16c> @ imm = #0xe8
 805702a: e7ff         	b	0x805702c <xTaskRemoveFromEventList+0x84> @ imm = #-0x2
;         listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 805702c: e7ff         	b	0x805702e <xTaskRemoveFromEventList+0x86> @ imm = #-0x2
 805702e: 9806         	ldr	r0, [sp, #0x18]
 8057030: f8d0 0090    	ldr.w	r0, [r0, #0x90]
 8057034: 9003         	str	r0, [sp, #0xc]
 8057036: 9806         	ldr	r0, [sp, #0x18]
 8057038: f8d0 1084    	ldr.w	r1, [r0, #0x84]
 805703c: f8d0 0088    	ldr.w	r0, [r0, #0x88]
 8057040: 6088         	str	r0, [r1, #0x8]
 8057042: 9906         	ldr	r1, [sp, #0x18]
 8057044: f8d1 0084    	ldr.w	r0, [r1, #0x84]
 8057048: f8d1 1088    	ldr.w	r1, [r1, #0x88]
 805704c: 6048         	str	r0, [r1, #0x4]
 805704e: 9803         	ldr	r0, [sp, #0xc]
 8057050: 6840         	ldr	r0, [r0, #0x4]
 8057052: 9906         	ldr	r1, [sp, #0x18]
 8057054: 3180         	adds	r1, #0x80
 8057056: 4288         	cmp	r0, r1
 8057058: d106         	bne	0x8057068 <xTaskRemoveFromEventList+0xc0> @ imm = #0xc
 805705a: e7ff         	b	0x805705c <xTaskRemoveFromEventList+0xb4> @ imm = #-0x2
 805705c: 9806         	ldr	r0, [sp, #0x18]
 805705e: f8d0 0088    	ldr.w	r0, [r0, #0x88]
 8057062: 9903         	ldr	r1, [sp, #0xc]
 8057064: 6048         	str	r0, [r1, #0x4]
 8057066: e7ff         	b	0x8057068 <xTaskRemoveFromEventList+0xc0> @ imm = #-0x2
 8057068: 9906         	ldr	r1, [sp, #0x18]
 805706a: 2000         	movs	r0, #0x0
 805706c: f8c1 0090    	str.w	r0, [r1, #0x90]
 8057070: 9903         	ldr	r1, [sp, #0xc]
 8057072: 6808         	ldr	r0, [r1]
 8057074: 3801         	subs	r0, #0x1
 8057076: 6008         	str	r0, [r1]
 8057078: e7ff         	b	0x805707a <xTaskRemoveFromEventList+0xd2> @ imm = #-0x2
;         prvAddTaskToReadyList( pxUnblockedTCB );
 805707a: e7ff         	b	0x805707c <xTaskRemoveFromEventList+0xd4> @ imm = #-0x2
 805707c: e7ff         	b	0x805707e <xTaskRemoveFromEventList+0xd6> @ imm = #-0x2
 805707e: 9806         	ldr	r0, [sp, #0x18]
 8057080: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057084: f240 21a0    	movw	r1, #0x2a0
 8057088: f2c2 0100    	movt	r1, #0x2000
 805708c: 6809         	ldr	r1, [r1]
 805708e: 4288         	cmp	r0, r1
 8057090: d909         	bls	0x80570a6 <xTaskRemoveFromEventList+0xfe> @ imm = #0x12
 8057092: e7ff         	b	0x8057094 <xTaskRemoveFromEventList+0xec> @ imm = #-0x2
 8057094: 9806         	ldr	r0, [sp, #0x18]
 8057096: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805709a: f240 21a0    	movw	r1, #0x2a0
 805709e: f2c2 0100    	movt	r1, #0x2000
 80570a2: 6008         	str	r0, [r1]
 80570a4: e7ff         	b	0x80570a6 <xTaskRemoveFromEventList+0xfe> @ imm = #-0x2
 80570a6: e7ff         	b	0x80570a8 <xTaskRemoveFromEventList+0x100> @ imm = #-0x2
 80570a8: e7ff         	b	0x80570aa <xTaskRemoveFromEventList+0x102> @ imm = #-0x2
 80570aa: 9806         	ldr	r0, [sp, #0x18]
 80570ac: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80570b0: eb00 0080    	add.w	r0, r0, r0, lsl #2
 80570b4: f240 1160    	movw	r1, #0x160
 80570b8: f2c2 0100    	movt	r1, #0x2000
 80570bc: eb01 0080    	add.w	r0, r1, r0, lsl #2
 80570c0: 6840         	ldr	r0, [r0, #0x4]
 80570c2: 9002         	str	r0, [sp, #0x8]
 80570c4: 9802         	ldr	r0, [sp, #0x8]
 80570c6: 9a06         	ldr	r2, [sp, #0x18]
 80570c8: f8c2 0084    	str.w	r0, [r2, #0x84]
 80570cc: 9802         	ldr	r0, [sp, #0x8]
 80570ce: 6880         	ldr	r0, [r0, #0x8]
 80570d0: 9a06         	ldr	r2, [sp, #0x18]
 80570d2: f8c2 0088    	str.w	r0, [r2, #0x88]
 80570d6: 9806         	ldr	r0, [sp, #0x18]
 80570d8: 3080         	adds	r0, #0x80
 80570da: 9a02         	ldr	r2, [sp, #0x8]
 80570dc: 6892         	ldr	r2, [r2, #0x8]
 80570de: 6050         	str	r0, [r2, #0x4]
 80570e0: 9806         	ldr	r0, [sp, #0x18]
 80570e2: 3080         	adds	r0, #0x80
 80570e4: 9a02         	ldr	r2, [sp, #0x8]
 80570e6: 6090         	str	r0, [r2, #0x8]
 80570e8: 9a06         	ldr	r2, [sp, #0x18]
 80570ea: f8d2 00a8    	ldr.w	r0, [r2, #0xa8]
 80570ee: eb00 0080    	add.w	r0, r0, r0, lsl #2
 80570f2: eb01 0080    	add.w	r0, r1, r0, lsl #2
 80570f6: f8c2 0090    	str.w	r0, [r2, #0x90]
 80570fa: 9806         	ldr	r0, [sp, #0x18]
 80570fc: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057100: eb00 0280    	add.w	r2, r0, r0, lsl #2
 8057104: f851 0022    	ldr.w	r0, [r1, r2, lsl #2]
 8057108: 3001         	adds	r0, #0x1
 805710a: f841 0022    	str.w	r0, [r1, r2, lsl #2]
 805710e: e7ff         	b	0x8057110 <xTaskRemoveFromEventList+0x168> @ imm = #-0x2
 8057110: e7ff         	b	0x8057112 <xTaskRemoveFromEventList+0x16a> @ imm = #-0x2
;     }
 8057112: e020         	b	0x8057156 <xTaskRemoveFromEventList+0x1ae> @ imm = #0x40
;         listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8057114: e7ff         	b	0x8057116 <xTaskRemoveFromEventList+0x16e> @ imm = #-0x2
 8057116: f240 1138    	movw	r1, #0x138
 805711a: f2c2 0100    	movt	r1, #0x2000
 805711e: 6848         	ldr	r0, [r1, #0x4]
 8057120: 9001         	str	r0, [sp, #0x4]
 8057122: 9801         	ldr	r0, [sp, #0x4]
 8057124: 9a06         	ldr	r2, [sp, #0x18]
 8057126: f8c2 0098    	str.w	r0, [r2, #0x98]
 805712a: 9801         	ldr	r0, [sp, #0x4]
 805712c: 6880         	ldr	r0, [r0, #0x8]
 805712e: 9a06         	ldr	r2, [sp, #0x18]
 8057130: f8c2 009c    	str.w	r0, [r2, #0x9c]
 8057134: 9806         	ldr	r0, [sp, #0x18]
 8057136: 3094         	adds	r0, #0x94
 8057138: 9a01         	ldr	r2, [sp, #0x4]
 805713a: 6892         	ldr	r2, [r2, #0x8]
 805713c: 6050         	str	r0, [r2, #0x4]
 805713e: 9806         	ldr	r0, [sp, #0x18]
 8057140: 3094         	adds	r0, #0x94
 8057142: 9a01         	ldr	r2, [sp, #0x4]
 8057144: 6090         	str	r0, [r2, #0x8]
 8057146: 9806         	ldr	r0, [sp, #0x18]
 8057148: f8c0 10a4    	str.w	r1, [r0, #0xa4]
 805714c: 6808         	ldr	r0, [r1]
 805714e: 3001         	adds	r0, #0x1
 8057150: 6008         	str	r0, [r1]
 8057152: e7ff         	b	0x8057154 <xTaskRemoveFromEventList+0x1ac> @ imm = #-0x2
 8057154: e7ff         	b	0x8057156 <xTaskRemoveFromEventList+0x1ae> @ imm = #-0x2
;         if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8057156: 9806         	ldr	r0, [sp, #0x18]
 8057158: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805715c: f240 1100    	movw	r1, #0x100
 8057160: f2c2 0100    	movt	r1, #0x2000
 8057164: 6809         	ldr	r1, [r1]
 8057166: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 805716a: 4288         	cmp	r0, r1
 805716c: d908         	bls	0x8057180 <xTaskRemoveFromEventList+0x1d8> @ imm = #0x10
 805716e: e7ff         	b	0x8057170 <xTaskRemoveFromEventList+0x1c8> @ imm = #-0x2
 8057170: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
 8057172: 9005         	str	r0, [sp, #0x14]
;             xYieldPendings[ 0 ] = pdTRUE;
 8057174: f240 21a4    	movw	r1, #0x2a4
 8057178: f2c2 0100    	movt	r1, #0x2000
 805717c: 6008         	str	r0, [r1]
;         }
 805717e: e002         	b	0x8057186 <xTaskRemoveFromEventList+0x1de> @ imm = #0x4
 8057180: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
 8057182: 9005         	str	r0, [sp, #0x14]
 8057184: e7ff         	b	0x8057186 <xTaskRemoveFromEventList+0x1de> @ imm = #-0x2
;     return xReturn;
 8057186: 9805         	ldr	r0, [sp, #0x14]
 8057188: b008         	add	sp, #0x20
 805718a: bc80         	pop	{r7}
 805718c: eba8 0809    	sub.w	r8, r8, r9
 8057190: f858 fd40    	ldr	pc, [r8, #-64]!

08057194 <$d.69>:
 8057194: 15 d7 05 08  	.word	0x0805d715

08057198 <vTaskRemoveFromUnorderedEventList>:
; {
 8057198: f848 eb20    	str	lr, [r8], #32
 805719c: eb08 0809    	add.w	r8, r8, r9
 80571a0: b480         	push	{r7}
 80571a2: 466f         	mov	r7, sp
 80571a4: b086         	sub	sp, #0x18
 80571a6: 9005         	str	r0, [sp, #0x14]
 80571a8: 9104         	str	r1, [sp, #0x10]
;     configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );
 80571aa: f240 1028    	movw	r0, #0x128
 80571ae: f2c2 0000    	movt	r0, #0x2000
 80571b2: 6800         	ldr	r0, [r0]
 80571b4: b920         	cbnz	r0, 0x80571c0 <vTaskRemoveFromUnorderedEventList+0x28> @ imm = #0x8
 80571b6: e7ff         	b	0x80571b8 <vTaskRemoveFromUnorderedEventList+0x20> @ imm = #-0x2
 80571b8: 4860         	ldr	r0, [pc, #0x180]        @ 0x805733c <vTaskRemoveFromUnorderedEventList+0x1a4>
 80571ba: 4780         	blx	r0
 80571bc: e7ff         	b	0x80571be <vTaskRemoveFromUnorderedEventList+0x26> @ imm = #-0x2
 80571be: e7fe         	b	0x80571be <vTaskRemoveFromUnorderedEventList+0x26> @ imm = #-0x4
;     listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 80571c0: 9804         	ldr	r0, [sp, #0x10]
 80571c2: f040 4000    	orr	r0, r0, #0x80000000
 80571c6: 9905         	ldr	r1, [sp, #0x14]
 80571c8: 6008         	str	r0, [r1]
;     pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80571ca: 9805         	ldr	r0, [sp, #0x14]
 80571cc: 68c0         	ldr	r0, [r0, #0xc]
 80571ce: 9003         	str	r0, [sp, #0xc]
;     configASSERT( pxUnblockedTCB );
 80571d0: 9803         	ldr	r0, [sp, #0xc]
 80571d2: b920         	cbnz	r0, 0x80571de <vTaskRemoveFromUnorderedEventList+0x46> @ imm = #0x8
 80571d4: e7ff         	b	0x80571d6 <vTaskRemoveFromUnorderedEventList+0x3e> @ imm = #-0x2
 80571d6: 4858         	ldr	r0, [pc, #0x160]        @ 0x8057338 <vTaskRemoveFromUnorderedEventList+0x1a0>
 80571d8: 4780         	blx	r0
 80571da: e7ff         	b	0x80571dc <vTaskRemoveFromUnorderedEventList+0x44> @ imm = #-0x2
 80571dc: e7fe         	b	0x80571dc <vTaskRemoveFromUnorderedEventList+0x44> @ imm = #-0x4
;     listREMOVE_ITEM( pxEventListItem );
 80571de: e7ff         	b	0x80571e0 <vTaskRemoveFromUnorderedEventList+0x48> @ imm = #-0x2
 80571e0: 9805         	ldr	r0, [sp, #0x14]
 80571e2: 6900         	ldr	r0, [r0, #0x10]
 80571e4: 9002         	str	r0, [sp, #0x8]
 80571e6: 9805         	ldr	r0, [sp, #0x14]
 80571e8: 6841         	ldr	r1, [r0, #0x4]
 80571ea: 6880         	ldr	r0, [r0, #0x8]
 80571ec: 6088         	str	r0, [r1, #0x8]
 80571ee: 9905         	ldr	r1, [sp, #0x14]
 80571f0: 6848         	ldr	r0, [r1, #0x4]
 80571f2: 6889         	ldr	r1, [r1, #0x8]
 80571f4: 6048         	str	r0, [r1, #0x4]
 80571f6: 9802         	ldr	r0, [sp, #0x8]
 80571f8: 6840         	ldr	r0, [r0, #0x4]
 80571fa: 9905         	ldr	r1, [sp, #0x14]
 80571fc: 4288         	cmp	r0, r1
 80571fe: d105         	bne	0x805720c <vTaskRemoveFromUnorderedEventList+0x74> @ imm = #0xa
 8057200: e7ff         	b	0x8057202 <vTaskRemoveFromUnorderedEventList+0x6a> @ imm = #-0x2
 8057202: 9805         	ldr	r0, [sp, #0x14]
 8057204: 6880         	ldr	r0, [r0, #0x8]
 8057206: 9902         	ldr	r1, [sp, #0x8]
 8057208: 6048         	str	r0, [r1, #0x4]
 805720a: e7ff         	b	0x805720c <vTaskRemoveFromUnorderedEventList+0x74> @ imm = #-0x2
 805720c: 9905         	ldr	r1, [sp, #0x14]
 805720e: 2000         	movs	r0, #0x0
 8057210: 6108         	str	r0, [r1, #0x10]
 8057212: 9902         	ldr	r1, [sp, #0x8]
 8057214: 6808         	ldr	r0, [r1]
 8057216: 3801         	subs	r0, #0x1
 8057218: 6008         	str	r0, [r1]
 805721a: e7ff         	b	0x805721c <vTaskRemoveFromUnorderedEventList+0x84> @ imm = #-0x2
;     listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 805721c: e7ff         	b	0x805721e <vTaskRemoveFromUnorderedEventList+0x86> @ imm = #-0x2
 805721e: 9803         	ldr	r0, [sp, #0xc]
 8057220: f8d0 0090    	ldr.w	r0, [r0, #0x90]
 8057224: 9001         	str	r0, [sp, #0x4]
 8057226: 9803         	ldr	r0, [sp, #0xc]
 8057228: f8d0 1084    	ldr.w	r1, [r0, #0x84]
 805722c: f8d0 0088    	ldr.w	r0, [r0, #0x88]
 8057230: 6088         	str	r0, [r1, #0x8]
 8057232: 9903         	ldr	r1, [sp, #0xc]
 8057234: f8d1 0084    	ldr.w	r0, [r1, #0x84]
 8057238: f8d1 1088    	ldr.w	r1, [r1, #0x88]
 805723c: 6048         	str	r0, [r1, #0x4]
 805723e: 9801         	ldr	r0, [sp, #0x4]
 8057240: 6840         	ldr	r0, [r0, #0x4]
 8057242: 9903         	ldr	r1, [sp, #0xc]
 8057244: 3180         	adds	r1, #0x80
 8057246: 4288         	cmp	r0, r1
 8057248: d106         	bne	0x8057258 <vTaskRemoveFromUnorderedEventList+0xc0> @ imm = #0xc
 805724a: e7ff         	b	0x805724c <vTaskRemoveFromUnorderedEventList+0xb4> @ imm = #-0x2
 805724c: 9803         	ldr	r0, [sp, #0xc]
 805724e: f8d0 0088    	ldr.w	r0, [r0, #0x88]
 8057252: 9901         	ldr	r1, [sp, #0x4]
 8057254: 6048         	str	r0, [r1, #0x4]
 8057256: e7ff         	b	0x8057258 <vTaskRemoveFromUnorderedEventList+0xc0> @ imm = #-0x2
 8057258: 9903         	ldr	r1, [sp, #0xc]
 805725a: 2000         	movs	r0, #0x0
 805725c: f8c1 0090    	str.w	r0, [r1, #0x90]
 8057260: 9901         	ldr	r1, [sp, #0x4]
 8057262: 6808         	ldr	r0, [r1]
 8057264: 3801         	subs	r0, #0x1
 8057266: 6008         	str	r0, [r1]
 8057268: e7ff         	b	0x805726a <vTaskRemoveFromUnorderedEventList+0xd2> @ imm = #-0x2
;     prvAddTaskToReadyList( pxUnblockedTCB );
 805726a: e7ff         	b	0x805726c <vTaskRemoveFromUnorderedEventList+0xd4> @ imm = #-0x2
 805726c: e7ff         	b	0x805726e <vTaskRemoveFromUnorderedEventList+0xd6> @ imm = #-0x2
 805726e: 9803         	ldr	r0, [sp, #0xc]
 8057270: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057274: f240 21a0    	movw	r1, #0x2a0
 8057278: f2c2 0100    	movt	r1, #0x2000
 805727c: 6809         	ldr	r1, [r1]
 805727e: 4288         	cmp	r0, r1
 8057280: d909         	bls	0x8057296 <vTaskRemoveFromUnorderedEventList+0xfe> @ imm = #0x12
 8057282: e7ff         	b	0x8057284 <vTaskRemoveFromUnorderedEventList+0xec> @ imm = #-0x2
 8057284: 9803         	ldr	r0, [sp, #0xc]
 8057286: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805728a: f240 21a0    	movw	r1, #0x2a0
 805728e: f2c2 0100    	movt	r1, #0x2000
 8057292: 6008         	str	r0, [r1]
 8057294: e7ff         	b	0x8057296 <vTaskRemoveFromUnorderedEventList+0xfe> @ imm = #-0x2
 8057296: e7ff         	b	0x8057298 <vTaskRemoveFromUnorderedEventList+0x100> @ imm = #-0x2
 8057298: e7ff         	b	0x805729a <vTaskRemoveFromUnorderedEventList+0x102> @ imm = #-0x2
 805729a: 9803         	ldr	r0, [sp, #0xc]
 805729c: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80572a0: eb00 0080    	add.w	r0, r0, r0, lsl #2
 80572a4: f240 1160    	movw	r1, #0x160
 80572a8: f2c2 0100    	movt	r1, #0x2000
 80572ac: eb01 0080    	add.w	r0, r1, r0, lsl #2
 80572b0: 6840         	ldr	r0, [r0, #0x4]
 80572b2: 9000         	str	r0, [sp]
 80572b4: 9800         	ldr	r0, [sp]
 80572b6: 9a03         	ldr	r2, [sp, #0xc]
 80572b8: f8c2 0084    	str.w	r0, [r2, #0x84]
 80572bc: 9800         	ldr	r0, [sp]
 80572be: 6880         	ldr	r0, [r0, #0x8]
 80572c0: 9a03         	ldr	r2, [sp, #0xc]
 80572c2: f8c2 0088    	str.w	r0, [r2, #0x88]
 80572c6: 9803         	ldr	r0, [sp, #0xc]
 80572c8: 3080         	adds	r0, #0x80
 80572ca: 9a00         	ldr	r2, [sp]
 80572cc: 6892         	ldr	r2, [r2, #0x8]
 80572ce: 6050         	str	r0, [r2, #0x4]
 80572d0: 9803         	ldr	r0, [sp, #0xc]
 80572d2: 3080         	adds	r0, #0x80
 80572d4: 9a00         	ldr	r2, [sp]
 80572d6: 6090         	str	r0, [r2, #0x8]
 80572d8: 9a03         	ldr	r2, [sp, #0xc]
 80572da: f8d2 00a8    	ldr.w	r0, [r2, #0xa8]
 80572de: eb00 0080    	add.w	r0, r0, r0, lsl #2
 80572e2: eb01 0080    	add.w	r0, r1, r0, lsl #2
 80572e6: f8c2 0090    	str.w	r0, [r2, #0x90]
 80572ea: 9803         	ldr	r0, [sp, #0xc]
 80572ec: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80572f0: eb00 0280    	add.w	r2, r0, r0, lsl #2
 80572f4: f851 0022    	ldr.w	r0, [r1, r2, lsl #2]
 80572f8: 3001         	adds	r0, #0x1
 80572fa: f841 0022    	str.w	r0, [r1, r2, lsl #2]
 80572fe: e7ff         	b	0x8057300 <vTaskRemoveFromUnorderedEventList+0x168> @ imm = #-0x2
 8057300: e7ff         	b	0x8057302 <vTaskRemoveFromUnorderedEventList+0x16a> @ imm = #-0x2
;         if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8057302: 9803         	ldr	r0, [sp, #0xc]
 8057304: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057308: f240 1100    	movw	r1, #0x100
 805730c: f2c2 0100    	movt	r1, #0x2000
 8057310: 6809         	ldr	r1, [r1]
 8057312: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 8057316: 4288         	cmp	r0, r1
 8057318: d907         	bls	0x805732a <vTaskRemoveFromUnorderedEventList+0x192> @ imm = #0xe
 805731a: e7ff         	b	0x805731c <vTaskRemoveFromUnorderedEventList+0x184> @ imm = #-0x2
;             xYieldPendings[ 0 ] = pdTRUE;
 805731c: f240 21a4    	movw	r1, #0x2a4
 8057320: f2c2 0100    	movt	r1, #0x2000
 8057324: 2001         	movs	r0, #0x1
 8057326: 6008         	str	r0, [r1]
;         }
 8057328: e7ff         	b	0x805732a <vTaskRemoveFromUnorderedEventList+0x192> @ imm = #-0x2
; }
 805732a: b006         	add	sp, #0x18
 805732c: bc80         	pop	{r7}
 805732e: eba8 0809    	sub.w	r8, r8, r9
 8057332: f858 fd20    	ldr	pc, [r8, #-32]!
 8057336: bf00         	nop

08057338 <$d.71>:
 8057338: 15 d7 05 08  	.word	0x0805d715
 805733c: 15 d7 05 08  	.word	0x0805d715

08057340 <vTaskSetTimeOutState>:
; {
 8057340: f848 eb28    	str	lr, [r8], #40
 8057344: eb08 0809    	add.w	r8, r8, r9
 8057348: b480         	push	{r7}
 805734a: 466f         	mov	r7, sp
 805734c: b082         	sub	sp, #0x8
 805734e: 9001         	str	r0, [sp, #0x4]
;     configASSERT( pxTimeOut );
 8057350: 9801         	ldr	r0, [sp, #0x4]
 8057352: b920         	cbnz	r0, 0x805735e <vTaskSetTimeOutState+0x1e> @ imm = #0x8
 8057354: e7ff         	b	0x8057356 <vTaskSetTimeOutState+0x16> @ imm = #-0x2
 8057356: 4810         	ldr	r0, [pc, #0x40]         @ 0x8057398 <vTaskSetTimeOutState+0x58>
 8057358: 4780         	blx	r0
 805735a: e7ff         	b	0x805735c <vTaskSetTimeOutState+0x1c> @ imm = #-0x2
 805735c: e7fe         	b	0x805735c <vTaskSetTimeOutState+0x1c> @ imm = #-0x4
;     taskENTER_CRITICAL();
 805735e: 480c         	ldr	r0, [pc, #0x30]         @ 0x8057390 <vTaskSetTimeOutState+0x50>
 8057360: 4780         	blx	r0
;         pxTimeOut->xOverflowCount = xNumOfOverflows;
 8057362: f240 20b4    	movw	r0, #0x2b4
 8057366: f2c2 0000    	movt	r0, #0x2000
 805736a: 6800         	ldr	r0, [r0]
 805736c: 9901         	ldr	r1, [sp, #0x4]
 805736e: 6008         	str	r0, [r1]
;         pxTimeOut->xTimeOnEntering = xTickCount;
 8057370: f240 102c    	movw	r0, #0x12c
 8057374: f2c2 0000    	movt	r0, #0x2000
 8057378: 6800         	ldr	r0, [r0]
 805737a: 9901         	ldr	r1, [sp, #0x4]
 805737c: 6048         	str	r0, [r1, #0x4]
;     taskEXIT_CRITICAL();
 805737e: 4805         	ldr	r0, [pc, #0x14]         @ 0x8057394 <vTaskSetTimeOutState+0x54>
 8057380: 4780         	blx	r0
; }
 8057382: b002         	add	sp, #0x8
 8057384: bc80         	pop	{r7}
 8057386: eba8 0809    	sub.w	r8, r8, r9
 805738a: f858 fd28    	ldr	pc, [r8, #-40]!
 805738e: bf00         	nop

08057390 <$d.73>:
 8057390: 49 cd 05 08  	.word	0x0805cd49
 8057394: 7d cd 05 08  	.word	0x0805cd7d
 8057398: 15 d7 05 08  	.word	0x0805d715

0805739c <vTaskInternalSetTimeOutState>:
; {
 805739c: b081         	sub	sp, #0x4
 805739e: 9000         	str	r0, [sp]
;     pxTimeOut->xOverflowCount = xNumOfOverflows;
 80573a0: f240 20b4    	movw	r0, #0x2b4
 80573a4: f2c2 0000    	movt	r0, #0x2000
 80573a8: 6800         	ldr	r0, [r0]
 80573aa: 9900         	ldr	r1, [sp]
 80573ac: 6008         	str	r0, [r1]
;     pxTimeOut->xTimeOnEntering = xTickCount;
 80573ae: f240 102c    	movw	r0, #0x12c
 80573b2: f2c2 0000    	movt	r0, #0x2000
 80573b6: 6800         	ldr	r0, [r0]
 80573b8: 9900         	ldr	r1, [sp]
 80573ba: 6048         	str	r0, [r1, #0x4]
; }
 80573bc: b001         	add	sp, #0x4
 80573be: 4770         	bx	lr

080573c0 <xTaskCheckForTimeOut>:
; {
 80573c0: f848 eb54    	str	lr, [r8], #84
 80573c4: eb08 0809    	add.w	r8, r8, r9
 80573c8: b480         	push	{r7}
 80573ca: 466f         	mov	r7, sp
 80573cc: b086         	sub	sp, #0x18
 80573ce: 9005         	str	r0, [sp, #0x14]
 80573d0: 9104         	str	r1, [sp, #0x10]
;     configASSERT( pxTimeOut );
 80573d2: 9805         	ldr	r0, [sp, #0x14]
 80573d4: b920         	cbnz	r0, 0x80573e0 <xTaskCheckForTimeOut+0x20> @ imm = #0x8
 80573d6: e7ff         	b	0x80573d8 <xTaskCheckForTimeOut+0x18> @ imm = #-0x2
 80573d8: 482f         	ldr	r0, [pc, #0xbc]         @ 0x8057498 <xTaskCheckForTimeOut+0xd8>
 80573da: 4780         	blx	r0
 80573dc: e7ff         	b	0x80573de <xTaskCheckForTimeOut+0x1e> @ imm = #-0x2
 80573de: e7fe         	b	0x80573de <xTaskCheckForTimeOut+0x1e> @ imm = #-0x4
;     configASSERT( pxTicksToWait );
 80573e0: 9804         	ldr	r0, [sp, #0x10]
 80573e2: b920         	cbnz	r0, 0x80573ee <xTaskCheckForTimeOut+0x2e> @ imm = #0x8
 80573e4: e7ff         	b	0x80573e6 <xTaskCheckForTimeOut+0x26> @ imm = #-0x2
 80573e6: 482b         	ldr	r0, [pc, #0xac]         @ 0x8057494 <xTaskCheckForTimeOut+0xd4>
 80573e8: 4780         	blx	r0
 80573ea: e7ff         	b	0x80573ec <xTaskCheckForTimeOut+0x2c> @ imm = #-0x2
 80573ec: e7fe         	b	0x80573ec <xTaskCheckForTimeOut+0x2c> @ imm = #-0x4
;     taskENTER_CRITICAL();
 80573ee: 4826         	ldr	r0, [pc, #0x98]         @ 0x8057488 <xTaskCheckForTimeOut+0xc8>
 80573f0: 4780         	blx	r0
;         const TickType_t xConstTickCount = xTickCount;
 80573f2: f240 102c    	movw	r0, #0x12c
 80573f6: f2c2 0000    	movt	r0, #0x2000
 80573fa: 6800         	ldr	r0, [r0]
 80573fc: 9002         	str	r0, [sp, #0x8]
;         const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 80573fe: 9802         	ldr	r0, [sp, #0x8]
 8057400: 9905         	ldr	r1, [sp, #0x14]
 8057402: 6849         	ldr	r1, [r1, #0x4]
 8057404: 1a40         	subs	r0, r0, r1
 8057406: 9001         	str	r0, [sp, #0x4]
;             if( *pxTicksToWait == portMAX_DELAY )
 8057408: 9804         	ldr	r0, [sp, #0x10]
 805740a: 6800         	ldr	r0, [r0]
 805740c: 3001         	adds	r0, #0x1
 805740e: b918         	cbnz	r0, 0x8057418 <xTaskCheckForTimeOut+0x58> @ imm = #0x6
 8057410: e7ff         	b	0x8057412 <xTaskCheckForTimeOut+0x52> @ imm = #-0x2
 8057412: 2000         	movs	r0, #0x0
;                 xReturn = pdFALSE;
 8057414: 9003         	str	r0, [sp, #0xc]
;             }
 8057416: e02e         	b	0x8057476 <xTaskCheckForTimeOut+0xb6> @ imm = #0x5c
;         if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8057418: f240 20b4    	movw	r0, #0x2b4
 805741c: f2c2 0000    	movt	r0, #0x2000
 8057420: 6800         	ldr	r0, [r0]
 8057422: 9905         	ldr	r1, [sp, #0x14]
 8057424: 6809         	ldr	r1, [r1]
 8057426: 4288         	cmp	r0, r1
 8057428: d00c         	beq	0x8057444 <xTaskCheckForTimeOut+0x84> @ imm = #0x18
 805742a: e7ff         	b	0x805742c <xTaskCheckForTimeOut+0x6c> @ imm = #-0x2
 805742c: 9802         	ldr	r0, [sp, #0x8]
 805742e: 9905         	ldr	r1, [sp, #0x14]
 8057430: 6849         	ldr	r1, [r1, #0x4]
 8057432: 4288         	cmp	r0, r1
 8057434: d306         	blo	0x8057444 <xTaskCheckForTimeOut+0x84> @ imm = #0xc
 8057436: e7ff         	b	0x8057438 <xTaskCheckForTimeOut+0x78> @ imm = #-0x2
 8057438: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
 805743a: 9003         	str	r0, [sp, #0xc]
;             *pxTicksToWait = ( TickType_t ) 0;
 805743c: 9904         	ldr	r1, [sp, #0x10]
 805743e: 2000         	movs	r0, #0x0
 8057440: 6008         	str	r0, [r1]
;         }
 8057442: e017         	b	0x8057474 <xTaskCheckForTimeOut+0xb4> @ imm = #0x2e
;         else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8057444: 9801         	ldr	r0, [sp, #0x4]
 8057446: 9904         	ldr	r1, [sp, #0x10]
 8057448: 6809         	ldr	r1, [r1]
 805744a: 4288         	cmp	r0, r1
 805744c: d20b         	bhs	0x8057466 <xTaskCheckForTimeOut+0xa6> @ imm = #0x16
 805744e: e7ff         	b	0x8057450 <xTaskCheckForTimeOut+0x90> @ imm = #-0x2
;             *pxTicksToWait -= xElapsedTime;
 8057450: 9a01         	ldr	r2, [sp, #0x4]
 8057452: 9904         	ldr	r1, [sp, #0x10]
 8057454: 6808         	ldr	r0, [r1]
 8057456: 1a80         	subs	r0, r0, r2
 8057458: 6008         	str	r0, [r1]
;             vTaskInternalSetTimeOutState( pxTimeOut );
 805745a: 9805         	ldr	r0, [sp, #0x14]
 805745c: 490b         	ldr	r1, [pc, #0x2c]         @ 0x805748c <xTaskCheckForTimeOut+0xcc>
 805745e: 4788         	blx	r1
 8057460: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
 8057462: 9003         	str	r0, [sp, #0xc]
;         }
 8057464: e005         	b	0x8057472 <xTaskCheckForTimeOut+0xb2> @ imm = #0xa
;             *pxTicksToWait = ( TickType_t ) 0;
 8057466: 9904         	ldr	r1, [sp, #0x10]
 8057468: 2000         	movs	r0, #0x0
 805746a: 6008         	str	r0, [r1]
 805746c: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
 805746e: 9003         	str	r0, [sp, #0xc]
 8057470: e7ff         	b	0x8057472 <xTaskCheckForTimeOut+0xb2> @ imm = #-0x2
 8057472: e7ff         	b	0x8057474 <xTaskCheckForTimeOut+0xb4> @ imm = #-0x2
 8057474: e7ff         	b	0x8057476 <xTaskCheckForTimeOut+0xb6> @ imm = #-0x2
;     taskEXIT_CRITICAL();
 8057476: 4806         	ldr	r0, [pc, #0x18]         @ 0x8057490 <xTaskCheckForTimeOut+0xd0>
 8057478: 4780         	blx	r0
;     return xReturn;
 805747a: 9803         	ldr	r0, [sp, #0xc]
 805747c: b006         	add	sp, #0x18
 805747e: bc80         	pop	{r7}
 8057480: eba8 0809    	sub.w	r8, r8, r9
 8057484: f858 fd54    	ldr	pc, [r8, #-84]!

08057488 <$d.75>:
 8057488: 49 cd 05 08  	.word	0x0805cd49
 805748c: 9d 73 05 08  	.word	0x0805739d
 8057490: 7d cd 05 08  	.word	0x0805cd7d
 8057494: 15 d7 05 08  	.word	0x0805d715
 8057498: 15 d7 05 08  	.word	0x0805d715

0805749c <vTaskMissedYield>:
;     xYieldPendings[ portGET_CORE_ID() ] = pdTRUE;
 805749c: f240 21a4    	movw	r1, #0x2a4
 80574a0: f2c2 0100    	movt	r1, #0x2000
 80574a4: 2001         	movs	r0, #0x1
 80574a6: 6008         	str	r0, [r1]
; }
 80574a8: 4770         	bx	lr

080574aa <uxTaskGetTaskNumber>:
;     {
 80574aa: b083         	sub	sp, #0xc
 80574ac: 9002         	str	r0, [sp, #0x8]
;         if( xTask != NULL )
 80574ae: 9802         	ldr	r0, [sp, #0x8]
 80574b0: b138         	cbz	r0, 0x80574c2 <uxTaskGetTaskNumber+0x18> @ imm = #0xe
 80574b2: e7ff         	b	0x80574b4 <uxTaskGetTaskNumber+0xa> @ imm = #-0x2
;             pxTCB = xTask;
 80574b4: 9802         	ldr	r0, [sp, #0x8]
 80574b6: 9000         	str	r0, [sp]
;             uxReturn = pxTCB->uxTaskNumber;
 80574b8: 9800         	ldr	r0, [sp]
 80574ba: f8d0 00c4    	ldr.w	r0, [r0, #0xc4]
 80574be: 9001         	str	r0, [sp, #0x4]
;         }
 80574c0: e002         	b	0x80574c8 <uxTaskGetTaskNumber+0x1e> @ imm = #0x4
 80574c2: 2000         	movs	r0, #0x0
;             uxReturn = 0U;
 80574c4: 9001         	str	r0, [sp, #0x4]
 80574c6: e7ff         	b	0x80574c8 <uxTaskGetTaskNumber+0x1e> @ imm = #-0x2
;         return uxReturn;
 80574c8: 9801         	ldr	r0, [sp, #0x4]
 80574ca: b003         	add	sp, #0xc
 80574cc: 4770         	bx	lr

080574ce <vTaskSetTaskNumber>:
;     {
 80574ce: b083         	sub	sp, #0xc
 80574d0: 9002         	str	r0, [sp, #0x8]
 80574d2: 9101         	str	r1, [sp, #0x4]
;         if( xTask != NULL )
 80574d4: 9802         	ldr	r0, [sp, #0x8]
 80574d6: b138         	cbz	r0, 0x80574e8 <vTaskSetTaskNumber+0x1a> @ imm = #0xe
 80574d8: e7ff         	b	0x80574da <vTaskSetTaskNumber+0xc> @ imm = #-0x2
;             pxTCB = xTask;
 80574da: 9802         	ldr	r0, [sp, #0x8]
 80574dc: 9000         	str	r0, [sp]
;             pxTCB->uxTaskNumber = uxHandle;
 80574de: 9801         	ldr	r0, [sp, #0x4]
 80574e0: 9900         	ldr	r1, [sp]
 80574e2: f8c1 00c4    	str.w	r0, [r1, #0xc4]
;         }
 80574e6: e7ff         	b	0x80574e8 <vTaskSetTaskNumber+0x1a> @ imm = #-0x2
;     }
 80574e8: b003         	add	sp, #0xc
 80574ea: 4770         	bx	lr

080574ec <vTaskAllocateMPURegions>:
;     {
 80574ec: f848 eb20    	str	lr, [r8], #32
 80574f0: eb08 0809    	add.w	r8, r8, r9
 80574f4: b480         	push	{r7}
 80574f6: 466f         	mov	r7, sp
 80574f8: b084         	sub	sp, #0x10
 80574fa: 9003         	str	r0, [sp, #0xc]
 80574fc: 9102         	str	r1, [sp, #0x8]
;         pxTCB = prvGetTCBFromHandle( xTaskToModify );
 80574fe: 9803         	ldr	r0, [sp, #0xc]
 8057500: b938         	cbnz	r0, 0x8057512 <vTaskAllocateMPURegions+0x26> @ imm = #0xe
 8057502: e7ff         	b	0x8057504 <vTaskAllocateMPURegions+0x18> @ imm = #-0x2
 8057504: f240 1000    	movw	r0, #0x100
 8057508: f2c2 0000    	movt	r0, #0x2000
 805750c: 6800         	ldr	r0, [r0]
 805750e: 9000         	str	r0, [sp]
 8057510: e002         	b	0x8057518 <vTaskAllocateMPURegions+0x2c> @ imm = #0x4
 8057512: 9803         	ldr	r0, [sp, #0xc]
 8057514: 9000         	str	r0, [sp]
 8057516: e7ff         	b	0x8057518 <vTaskAllocateMPURegions+0x2c> @ imm = #-0x2
 8057518: 9800         	ldr	r0, [sp]
 805751a: 9001         	str	r0, [sp, #0x4]
;         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), pxRegions, NULL, 0 );
 805751c: 9801         	ldr	r0, [sp, #0x4]
 805751e: 3004         	adds	r0, #0x4
 8057520: 9902         	ldr	r1, [sp, #0x8]
 8057522: f8df c014    	ldr.w	r12, [pc, #0x14]        @ 0x8057538 <vTaskAllocateMPURegions+0x4c>
 8057526: 2300         	movs	r3, #0x0
 8057528: 461a         	mov	r2, r3
 805752a: 47e0         	blx	r12
;     }
 805752c: b004         	add	sp, #0x10
 805752e: bc80         	pop	{r7}
 8057530: eba8 0809    	sub.w	r8, r8, r9
 8057534: f858 fd20    	ldr	pc, [r8, #-32]!

08057538 <$d.77>:
 8057538: 61 d3 05 08  	.word	0x0805d361

0805753c <vTaskGetInfo>:
;     {
 805753c: f848 eb04    	str	lr, [r8], #4
 8057540: eb08 0809    	add.w	r8, r8, r9
 8057544: b480         	push	{r7}
 8057546: 466f         	mov	r7, sp
 8057548: b086         	sub	sp, #0x18
 805754a: 9005         	str	r0, [sp, #0x14]
 805754c: 9104         	str	r1, [sp, #0x10]
 805754e: 9203         	str	r2, [sp, #0xc]
 8057550: f807 3c0d    	strb	r3, [r7, #-13]
;         pxTCB = prvGetTCBFromHandle( xTask );
 8057554: 9805         	ldr	r0, [sp, #0x14]
 8057556: b938         	cbnz	r0, 0x8057568 <vTaskGetInfo+0x2c> @ imm = #0xe
 8057558: e7ff         	b	0x805755a <vTaskGetInfo+0x1e> @ imm = #-0x2
 805755a: f240 1000    	movw	r0, #0x100
 805755e: f2c2 0000    	movt	r0, #0x2000
 8057562: 6800         	ldr	r0, [r0]
 8057564: 9000         	str	r0, [sp]
 8057566: e002         	b	0x805756e <vTaskGetInfo+0x32> @ imm = #0x4
 8057568: 9805         	ldr	r0, [sp, #0x14]
 805756a: 9000         	str	r0, [sp]
 805756c: e7ff         	b	0x805756e <vTaskGetInfo+0x32> @ imm = #-0x2
 805756e: 9800         	ldr	r0, [sp]
 8057570: 9001         	str	r0, [sp, #0x4]
;         pxTaskStatus->xHandle = pxTCB;
 8057572: 9801         	ldr	r0, [sp, #0x4]
 8057574: 9904         	ldr	r1, [sp, #0x10]
 8057576: 6008         	str	r0, [r1]
;         pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
 8057578: 9801         	ldr	r0, [sp, #0x4]
 805757a: 30b0         	adds	r0, #0xb0
 805757c: 9904         	ldr	r1, [sp, #0x10]
 805757e: 6048         	str	r0, [r1, #0x4]
;         pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 8057580: 9801         	ldr	r0, [sp, #0x4]
 8057582: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057586: 9904         	ldr	r1, [sp, #0x10]
 8057588: 6108         	str	r0, [r1, #0x10]
;         pxTaskStatus->pxStackBase = pxTCB->pxStack;
 805758a: 9801         	ldr	r0, [sp, #0x4]
 805758c: f8d0 00ac    	ldr.w	r0, [r0, #0xac]
 8057590: 9904         	ldr	r1, [sp, #0x10]
 8057592: 61c8         	str	r0, [r1, #0x1c]
;         pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 8057594: 9801         	ldr	r0, [sp, #0x4]
 8057596: f8d0 00c0    	ldr.w	r0, [r0, #0xc0]
 805759a: 9904         	ldr	r1, [sp, #0x10]
 805759c: 6088         	str	r0, [r1, #0x8]
;             pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 805759e: 9801         	ldr	r0, [sp, #0x4]
 80575a0: f8d0 00c8    	ldr.w	r0, [r0, #0xc8]
 80575a4: 9904         	ldr	r1, [sp, #0x10]
 80575a6: 6148         	str	r0, [r1, #0x14]
;             pxTaskStatus->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
 80575a8: 9904         	ldr	r1, [sp, #0x10]
 80575aa: 2000         	movs	r0, #0x0
 80575ac: 6188         	str	r0, [r1, #0x18]
;         if( eState != eInvalid )
 80575ae: f817 0c0d    	ldrb	r0, [r7, #-13]
 80575b2: 2805         	cmp	r0, #0x5
 80575b4: d038         	beq	0x8057628 <vTaskGetInfo+0xec> @ imm = #0x70
 80575b6: e7ff         	b	0x80575b8 <vTaskGetInfo+0x7c> @ imm = #-0x2
;             if( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )
 80575b8: 9801         	ldr	r0, [sp, #0x4]
 80575ba: f240 1100    	movw	r1, #0x100
 80575be: f2c2 0100    	movt	r1, #0x2000
 80575c2: 6809         	ldr	r1, [r1]
 80575c4: 4288         	cmp	r0, r1
 80575c6: d104         	bne	0x80575d2 <vTaskGetInfo+0x96> @ imm = #0x8
 80575c8: e7ff         	b	0x80575ca <vTaskGetInfo+0x8e> @ imm = #-0x2
;                 pxTaskStatus->eCurrentState = eRunning;
 80575ca: 9904         	ldr	r1, [sp, #0x10]
 80575cc: 2000         	movs	r0, #0x0
 80575ce: 7308         	strb	r0, [r1, #0xc]
;             }
 80575d0: e029         	b	0x8057626 <vTaskGetInfo+0xea> @ imm = #0x52
;                 pxTaskStatus->eCurrentState = eState;
 80575d2: f817 0c0d    	ldrb	r0, [r7, #-13]
 80575d6: 9904         	ldr	r1, [sp, #0x10]
 80575d8: 7308         	strb	r0, [r1, #0xc]
;                     if( eState == eSuspended )
 80575da: f817 0c0d    	ldrb	r0, [r7, #-13]
 80575de: 2803         	cmp	r0, #0x3
 80575e0: d10e         	bne	0x8057600 <vTaskGetInfo+0xc4> @ imm = #0x1c
 80575e2: e7ff         	b	0x80575e4 <vTaskGetInfo+0xa8> @ imm = #-0x2
;                         vTaskSuspendAll();
 80575e4: 481f         	ldr	r0, [pc, #0x7c]         @ 0x8057664 <vTaskGetInfo+0x128>
 80575e6: 4780         	blx	r0
;                             if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80575e8: 9801         	ldr	r0, [sp, #0x4]
 80575ea: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
 80575ee: b120         	cbz	r0, 0x80575fa <vTaskGetInfo+0xbe> @ imm = #0x8
 80575f0: e7ff         	b	0x80575f2 <vTaskGetInfo+0xb6> @ imm = #-0x2
;                                 pxTaskStatus->eCurrentState = eBlocked;
 80575f2: 9904         	ldr	r1, [sp, #0x10]
 80575f4: 2002         	movs	r0, #0x2
 80575f6: 7308         	strb	r0, [r1, #0xc]
;                             }
 80575f8: e7ff         	b	0x80575fa <vTaskGetInfo+0xbe> @ imm = #-0x2
;                         ( void ) xTaskResumeAll();
 80575fa: 481b         	ldr	r0, [pc, #0x6c]         @ 0x8057668 <vTaskGetInfo+0x12c>
 80575fc: 4780         	blx	r0
;                     }
 80575fe: e7ff         	b	0x8057600 <vTaskGetInfo+0xc4> @ imm = #-0x2
;                 taskENTER_CRITICAL();
 8057600: 481a         	ldr	r0, [pc, #0x68]         @ 0x805766c <vTaskGetInfo+0x130>
 8057602: 4780         	blx	r0
;                     if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdFALSE )
 8057604: 9801         	ldr	r0, [sp, #0x4]
 8057606: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
 805760a: f240 1138    	movw	r1, #0x138
 805760e: f2c2 0100    	movt	r1, #0x2000
 8057612: 4288         	cmp	r0, r1
 8057614: d104         	bne	0x8057620 <vTaskGetInfo+0xe4> @ imm = #0x8
 8057616: e7ff         	b	0x8057618 <vTaskGetInfo+0xdc> @ imm = #-0x2
;                         pxTaskStatus->eCurrentState = eReady;
 8057618: 9904         	ldr	r1, [sp, #0x10]
 805761a: 2001         	movs	r0, #0x1
 805761c: 7308         	strb	r0, [r1, #0xc]
;                     }
 805761e: e7ff         	b	0x8057620 <vTaskGetInfo+0xe4> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
 8057620: 4813         	ldr	r0, [pc, #0x4c]         @ 0x8057670 <vTaskGetInfo+0x134>
 8057622: 4780         	blx	r0
 8057624: e7ff         	b	0x8057626 <vTaskGetInfo+0xea> @ imm = #-0x2
;         }
 8057626: e005         	b	0x8057634 <vTaskGetInfo+0xf8> @ imm = #0xa
;             pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
 8057628: 9801         	ldr	r0, [sp, #0x4]
 805762a: 490d         	ldr	r1, [pc, #0x34]         @ 0x8057660 <vTaskGetInfo+0x124>
 805762c: 4788         	blx	r1
 805762e: 9904         	ldr	r1, [sp, #0x10]
 8057630: 7308         	strb	r0, [r1, #0xc]
 8057632: e7ff         	b	0x8057634 <vTaskGetInfo+0xf8> @ imm = #-0x2
;         if( xGetFreeStackSpace != pdFALSE )
 8057634: 9803         	ldr	r0, [sp, #0xc]
 8057636: b140         	cbz	r0, 0x805764a <vTaskGetInfo+0x10e> @ imm = #0x10
 8057638: e7ff         	b	0x805763a <vTaskGetInfo+0xfe> @ imm = #-0x2
;                 pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 805763a: 9801         	ldr	r0, [sp, #0x4]
 805763c: f8d0 00ac    	ldr.w	r0, [r0, #0xac]
 8057640: 490c         	ldr	r1, [pc, #0x30]         @ 0x8057674 <vTaskGetInfo+0x138>
 8057642: 4788         	blx	r1
 8057644: 9904         	ldr	r1, [sp, #0x10]
 8057646: 8408         	strh	r0, [r1, #0x20]
;         }
 8057648: e003         	b	0x8057652 <vTaskGetInfo+0x116> @ imm = #0x6
;             pxTaskStatus->usStackHighWaterMark = 0;
 805764a: 9904         	ldr	r1, [sp, #0x10]
 805764c: 2000         	movs	r0, #0x0
 805764e: 8408         	strh	r0, [r1, #0x20]
 8057650: e7ff         	b	0x8057652 <vTaskGetInfo+0x116> @ imm = #-0x2
;     }
 8057652: b006         	add	sp, #0x18
 8057654: bc80         	pop	{r7}
 8057656: eba8 0809    	sub.w	r8, r8, r9
 805765a: f858 fd04    	ldr	pc, [r8, #-4]!
 805765e: bf00         	nop

08057660 <$d.79>:
 8057660: 21 5d 05 08  	.word	0x08055d21
 8057664: d9 58 05 08  	.word	0x080558d9
 8057668: 0d 5a 05 08  	.word	0x08055a0d
 805766c: 49 cd 05 08  	.word	0x0805cd49
 8057670: 7d cd 05 08  	.word	0x0805cd7d
 8057674: 79 76 05 08  	.word	0x08057679

08057678 <prvTaskCheckFreeStackSpace>:
;     {
 8057678: b082         	sub	sp, #0x8
 805767a: 9001         	str	r0, [sp, #0x4]
 805767c: 2000         	movs	r0, #0x0
;         uint32_t ulCount = 0U;
 805767e: 9000         	str	r0, [sp]
;         while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8057680: e7ff         	b	0x8057682 <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x2
 8057682: 9801         	ldr	r0, [sp, #0x4]
 8057684: 7800         	ldrb	r0, [r0]
 8057686: 28a5         	cmp	r0, #0xa5
 8057688: d107         	bne	0x805769a <prvTaskCheckFreeStackSpace+0x22> @ imm = #0xe
 805768a: e7ff         	b	0x805768c <prvTaskCheckFreeStackSpace+0x14> @ imm = #-0x2
;             pucStackByte -= portSTACK_GROWTH;
 805768c: 9801         	ldr	r0, [sp, #0x4]
 805768e: 3001         	adds	r0, #0x1
 8057690: 9001         	str	r0, [sp, #0x4]
;             ulCount++;
 8057692: 9800         	ldr	r0, [sp]
 8057694: 3001         	adds	r0, #0x1
 8057696: 9000         	str	r0, [sp]
;         while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 8057698: e7f3         	b	0x8057682 <prvTaskCheckFreeStackSpace+0xa> @ imm = #-0x1a
;         ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 805769a: 9800         	ldr	r0, [sp]
 805769c: 0880         	lsrs	r0, r0, #0x2
 805769e: 9000         	str	r0, [sp]
;         return ( configSTACK_DEPTH_TYPE ) ulCount;
 80576a0: f8bd 0000    	ldrh.w	r0, [sp]
 80576a4: b002         	add	sp, #0x8
 80576a6: 4770         	bx	lr

080576a8 <uxTaskGetStackHighWaterMark>:
;     {
 80576a8: f848 eb58    	str	lr, [r8], #88
 80576ac: eb08 0809    	add.w	r8, r8, r9
 80576b0: b480         	push	{r7}
 80576b2: 466f         	mov	r7, sp
 80576b4: b086         	sub	sp, #0x18
 80576b6: 9005         	str	r0, [sp, #0x14]
;         pxTCB = prvGetTCBFromHandle( xTask );
 80576b8: 9805         	ldr	r0, [sp, #0x14]
 80576ba: b938         	cbnz	r0, 0x80576cc <uxTaskGetStackHighWaterMark+0x24> @ imm = #0xe
 80576bc: e7ff         	b	0x80576be <uxTaskGetStackHighWaterMark+0x16> @ imm = #-0x2
 80576be: f240 1000    	movw	r0, #0x100
 80576c2: f2c2 0000    	movt	r0, #0x2000
 80576c6: 6800         	ldr	r0, [r0]
 80576c8: 9001         	str	r0, [sp, #0x4]
 80576ca: e002         	b	0x80576d2 <uxTaskGetStackHighWaterMark+0x2a> @ imm = #0x4
 80576cc: 9805         	ldr	r0, [sp, #0x14]
 80576ce: 9001         	str	r0, [sp, #0x4]
 80576d0: e7ff         	b	0x80576d2 <uxTaskGetStackHighWaterMark+0x2a> @ imm = #-0x2
 80576d2: 9801         	ldr	r0, [sp, #0x4]
 80576d4: 9004         	str	r0, [sp, #0x10]
;             pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 80576d6: 9804         	ldr	r0, [sp, #0x10]
 80576d8: f8d0 00ac    	ldr.w	r0, [r0, #0xac]
 80576dc: 9003         	str	r0, [sp, #0xc]
;         uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 80576de: 9803         	ldr	r0, [sp, #0xc]
 80576e0: 4904         	ldr	r1, [pc, #0x10]         @ 0x80576f4 <uxTaskGetStackHighWaterMark+0x4c>
 80576e2: 4788         	blx	r1
 80576e4: 9002         	str	r0, [sp, #0x8]
;         return uxReturn;
 80576e6: 9802         	ldr	r0, [sp, #0x8]
 80576e8: b006         	add	sp, #0x18
 80576ea: bc80         	pop	{r7}
 80576ec: eba8 0809    	sub.w	r8, r8, r9
 80576f0: f858 fd58    	ldr	pc, [r8, #-88]!

080576f4 <$d.81>:
 80576f4: 79 76 05 08  	.word	0x08057679

080576f8 <xTaskGetCurrentTaskHandle>:
;         {
 80576f8: b081         	sub	sp, #0x4
;             xReturn = pxCurrentTCB;
 80576fa: f240 1000    	movw	r0, #0x100
 80576fe: f2c2 0000    	movt	r0, #0x2000
 8057702: 6800         	ldr	r0, [r0]
 8057704: 9000         	str	r0, [sp]
;             return xReturn;
 8057706: 9800         	ldr	r0, [sp]
 8057708: b001         	add	sp, #0x4
 805770a: 4770         	bx	lr

0805770c <xTaskGetSchedulerState>:
;     {
 805770c: b081         	sub	sp, #0x4
;         if( xSchedulerRunning == pdFALSE )
 805770e: f240 1024    	movw	r0, #0x124
 8057712: f2c2 0000    	movt	r0, #0x2000
 8057716: 6800         	ldr	r0, [r0]
 8057718: b918         	cbnz	r0, 0x8057722 <xTaskGetSchedulerState+0x16> @ imm = #0x6
 805771a: e7ff         	b	0x805771c <xTaskGetSchedulerState+0x10> @ imm = #-0x2
 805771c: 2001         	movs	r0, #0x1
;             xReturn = taskSCHEDULER_NOT_STARTED;
 805771e: 9000         	str	r0, [sp]
;         }
 8057720: e00d         	b	0x805773e <xTaskGetSchedulerState+0x32> @ imm = #0x1a
;                 if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 8057722: f240 1028    	movw	r0, #0x128
 8057726: f2c2 0000    	movt	r0, #0x2000
 805772a: 6800         	ldr	r0, [r0]
 805772c: b918         	cbnz	r0, 0x8057736 <xTaskGetSchedulerState+0x2a> @ imm = #0x6
 805772e: e7ff         	b	0x8057730 <xTaskGetSchedulerState+0x24> @ imm = #-0x2
 8057730: 2002         	movs	r0, #0x2
;                     xReturn = taskSCHEDULER_RUNNING;
 8057732: 9000         	str	r0, [sp]
;                 }
 8057734: e002         	b	0x805773c <xTaskGetSchedulerState+0x30> @ imm = #0x4
 8057736: 2000         	movs	r0, #0x0
;                     xReturn = taskSCHEDULER_SUSPENDED;
 8057738: 9000         	str	r0, [sp]
 805773a: e7ff         	b	0x805773c <xTaskGetSchedulerState+0x30> @ imm = #-0x2
 805773c: e7ff         	b	0x805773e <xTaskGetSchedulerState+0x32> @ imm = #-0x2
;         return xReturn;
 805773e: 9800         	ldr	r0, [sp]
 8057740: b001         	add	sp, #0x4
 8057742: 4770         	bx	lr

08057744 <xTaskPriorityInherit>:
;     {
 8057744: f848 eb40    	str	lr, [r8], #64
 8057748: eb08 0809    	add.w	r8, r8, r9
 805774c: b480         	push	{r7}
 805774e: 466f         	mov	r7, sp
 8057750: b084         	sub	sp, #0x10
 8057752: 9003         	str	r0, [sp, #0xc]
;         TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 8057754: 9803         	ldr	r0, [sp, #0xc]
 8057756: 9002         	str	r0, [sp, #0x8]
 8057758: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFALSE;
 805775a: 9001         	str	r0, [sp, #0x4]
;         if( pxMutexHolder != NULL )
 805775c: 9803         	ldr	r0, [sp, #0xc]
 805775e: 2800         	cmp	r0, #0x0
 8057760: f000 80b4    	beq.w	0x80578cc <xTaskPriorityInherit+0x188> @ imm = #0x168
 8057764: e7ff         	b	0x8057766 <xTaskPriorityInherit+0x22> @ imm = #-0x2
;             if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 8057766: 9802         	ldr	r0, [sp, #0x8]
 8057768: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805776c: f240 1100    	movw	r1, #0x100
 8057770: f2c2 0100    	movt	r1, #0x2000
 8057774: 6809         	ldr	r1, [r1]
 8057776: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 805777a: 4288         	cmp	r0, r1
 805777c: f080 8093    	bhs.w	0x80578a6 <xTaskPriorityInherit+0x162> @ imm = #0x126
 8057780: e7ff         	b	0x8057782 <xTaskPriorityInherit+0x3e> @ imm = #-0x2
;                 if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8057782: 9802         	ldr	r0, [sp, #0x8]
 8057784: f890 0097    	ldrb.w	r0, [r0, #0x97]
 8057788: 0600         	lsls	r0, r0, #0x18
 805778a: 2800         	cmp	r0, #0x0
 805778c: d40d         	bmi	0x80577aa <xTaskPriorityInherit+0x66> @ imm = #0x1a
 805778e: e7ff         	b	0x8057790 <xTaskPriorityInherit+0x4c> @ imm = #-0x2
;                     listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8057790: f240 1000    	movw	r0, #0x100
 8057794: f2c2 0000    	movt	r0, #0x2000
 8057798: 6800         	ldr	r0, [r0]
 805779a: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805779e: f1c0 0010    	rsb.w	r0, r0, #0x10
 80577a2: 9902         	ldr	r1, [sp, #0x8]
 80577a4: f8c1 0094    	str.w	r0, [r1, #0x94]
;                 }
 80577a8: e000         	b	0x80577ac <xTaskPriorityInherit+0x68> @ imm = #0x0
 80577aa: e7ff         	b	0x80577ac <xTaskPriorityInherit+0x68> @ imm = #-0x2
;                 if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 80577ac: 9902         	ldr	r1, [sp, #0x8]
 80577ae: f8d1 0090    	ldr.w	r0, [r1, #0x90]
 80577b2: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 80577b6: eb01 0281    	add.w	r2, r1, r1, lsl #2
 80577ba: f240 1160    	movw	r1, #0x160
 80577be: f2c2 0100    	movt	r1, #0x2000
 80577c2: eb01 0182    	add.w	r1, r1, r2, lsl #2
 80577c6: 4288         	cmp	r0, r1
 80577c8: d15f         	bne	0x805788a <xTaskPriorityInherit+0x146> @ imm = #0xbe
 80577ca: e7ff         	b	0x80577cc <xTaskPriorityInherit+0x88> @ imm = #-0x2
;                     if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80577cc: 9802         	ldr	r0, [sp, #0x8]
 80577ce: 3080         	adds	r0, #0x80
 80577d0: 4942         	ldr	r1, [pc, #0x108]        @ 0x80578dc <xTaskPriorityInherit+0x198>
 80577d2: 4788         	blx	r1
 80577d4: b908         	cbnz	r0, 0x80577da <xTaskPriorityInherit+0x96> @ imm = #0x2
 80577d6: e7ff         	b	0x80577d8 <xTaskPriorityInherit+0x94> @ imm = #-0x2
;                     }
 80577d8: e000         	b	0x80577dc <xTaskPriorityInherit+0x98> @ imm = #0x0
 80577da: e7ff         	b	0x80577dc <xTaskPriorityInherit+0x98> @ imm = #-0x2
;                     pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 80577dc: f240 1000    	movw	r0, #0x100
 80577e0: f2c2 0000    	movt	r0, #0x2000
 80577e4: 6800         	ldr	r0, [r0]
 80577e6: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80577ea: 9902         	ldr	r1, [sp, #0x8]
 80577ec: f8c1 00a8    	str.w	r0, [r1, #0xa8]
;                     prvAddTaskToReadyList( pxMutexHolderTCB );
 80577f0: e7ff         	b	0x80577f2 <xTaskPriorityInherit+0xae> @ imm = #-0x2
 80577f2: e7ff         	b	0x80577f4 <xTaskPriorityInherit+0xb0> @ imm = #-0x2
 80577f4: 9802         	ldr	r0, [sp, #0x8]
 80577f6: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80577fa: f240 21a0    	movw	r1, #0x2a0
 80577fe: f2c2 0100    	movt	r1, #0x2000
 8057802: 6809         	ldr	r1, [r1]
 8057804: 4288         	cmp	r0, r1
 8057806: d909         	bls	0x805781c <xTaskPriorityInherit+0xd8> @ imm = #0x12
 8057808: e7ff         	b	0x805780a <xTaskPriorityInherit+0xc6> @ imm = #-0x2
 805780a: 9802         	ldr	r0, [sp, #0x8]
 805780c: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057810: f240 21a0    	movw	r1, #0x2a0
 8057814: f2c2 0100    	movt	r1, #0x2000
 8057818: 6008         	str	r0, [r1]
 805781a: e7ff         	b	0x805781c <xTaskPriorityInherit+0xd8> @ imm = #-0x2
 805781c: e7ff         	b	0x805781e <xTaskPriorityInherit+0xda> @ imm = #-0x2
 805781e: e7ff         	b	0x8057820 <xTaskPriorityInherit+0xdc> @ imm = #-0x2
 8057820: 9802         	ldr	r0, [sp, #0x8]
 8057822: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057826: eb00 0080    	add.w	r0, r0, r0, lsl #2
 805782a: f240 1160    	movw	r1, #0x160
 805782e: f2c2 0100    	movt	r1, #0x2000
 8057832: eb01 0080    	add.w	r0, r1, r0, lsl #2
 8057836: 6840         	ldr	r0, [r0, #0x4]
 8057838: 9000         	str	r0, [sp]
 805783a: 9800         	ldr	r0, [sp]
 805783c: 9a02         	ldr	r2, [sp, #0x8]
 805783e: f8c2 0084    	str.w	r0, [r2, #0x84]
 8057842: 9800         	ldr	r0, [sp]
 8057844: 6880         	ldr	r0, [r0, #0x8]
 8057846: 9a02         	ldr	r2, [sp, #0x8]
 8057848: f8c2 0088    	str.w	r0, [r2, #0x88]
 805784c: 9802         	ldr	r0, [sp, #0x8]
 805784e: 3080         	adds	r0, #0x80
 8057850: 9a00         	ldr	r2, [sp]
 8057852: 6892         	ldr	r2, [r2, #0x8]
 8057854: 6050         	str	r0, [r2, #0x4]
 8057856: 9802         	ldr	r0, [sp, #0x8]
 8057858: 3080         	adds	r0, #0x80
 805785a: 9a00         	ldr	r2, [sp]
 805785c: 6090         	str	r0, [r2, #0x8]
 805785e: 9a02         	ldr	r2, [sp, #0x8]
 8057860: f8d2 00a8    	ldr.w	r0, [r2, #0xa8]
 8057864: eb00 0080    	add.w	r0, r0, r0, lsl #2
 8057868: eb01 0080    	add.w	r0, r1, r0, lsl #2
 805786c: f8c2 0090    	str.w	r0, [r2, #0x90]
 8057870: 9802         	ldr	r0, [sp, #0x8]
 8057872: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057876: eb00 0280    	add.w	r2, r0, r0, lsl #2
 805787a: f851 0022    	ldr.w	r0, [r1, r2, lsl #2]
 805787e: 3001         	adds	r0, #0x1
 8057880: f841 0022    	str.w	r0, [r1, r2, lsl #2]
 8057884: e7ff         	b	0x8057886 <xTaskPriorityInherit+0x142> @ imm = #-0x2
 8057886: e7ff         	b	0x8057888 <xTaskPriorityInherit+0x144> @ imm = #-0x2
;                 }
 8057888: e00a         	b	0x80578a0 <xTaskPriorityInherit+0x15c> @ imm = #0x14
;                     pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 805788a: f240 1000    	movw	r0, #0x100
 805788e: f2c2 0000    	movt	r0, #0x2000
 8057892: 6800         	ldr	r0, [r0]
 8057894: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057898: 9902         	ldr	r1, [sp, #0x8]
 805789a: f8c1 00a8    	str.w	r0, [r1, #0xa8]
 805789e: e7ff         	b	0x80578a0 <xTaskPriorityInherit+0x15c> @ imm = #-0x2
 80578a0: 2001         	movs	r0, #0x1
;                 xReturn = pdTRUE;
 80578a2: 9001         	str	r0, [sp, #0x4]
;             }
 80578a4: e011         	b	0x80578ca <xTaskPriorityInherit+0x186> @ imm = #0x22
;                 if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 80578a6: 9802         	ldr	r0, [sp, #0x8]
 80578a8: f8d0 00c8    	ldr.w	r0, [r0, #0xc8]
 80578ac: f240 1100    	movw	r1, #0x100
 80578b0: f2c2 0100    	movt	r1, #0x2000
 80578b4: 6809         	ldr	r1, [r1]
 80578b6: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 80578ba: 4288         	cmp	r0, r1
 80578bc: d203         	bhs	0x80578c6 <xTaskPriorityInherit+0x182> @ imm = #0x6
 80578be: e7ff         	b	0x80578c0 <xTaskPriorityInherit+0x17c> @ imm = #-0x2
 80578c0: 2001         	movs	r0, #0x1
;                     xReturn = pdTRUE;
 80578c2: 9001         	str	r0, [sp, #0x4]
;                 }
 80578c4: e000         	b	0x80578c8 <xTaskPriorityInherit+0x184> @ imm = #0x0
 80578c6: e7ff         	b	0x80578c8 <xTaskPriorityInherit+0x184> @ imm = #-0x2
 80578c8: e7ff         	b	0x80578ca <xTaskPriorityInherit+0x186> @ imm = #-0x2
;         }
 80578ca: e000         	b	0x80578ce <xTaskPriorityInherit+0x18a> @ imm = #0x0
 80578cc: e7ff         	b	0x80578ce <xTaskPriorityInherit+0x18a> @ imm = #-0x2
;         return xReturn;
 80578ce: 9801         	ldr	r0, [sp, #0x4]
 80578d0: b004         	add	sp, #0x10
 80578d2: bc80         	pop	{r7}
 80578d4: eba8 0809    	sub.w	r8, r8, r9
 80578d8: f858 fd40    	ldr	pc, [r8, #-64]!

080578dc <$d.83>:
 80578dc: 13 a5 05 08  	.word	0x0805a513

080578e0 <xTaskPriorityDisinherit>:
;     {
 80578e0: f848 eb5c    	str	lr, [r8], #92
 80578e4: eb08 0809    	add.w	r8, r8, r9
 80578e8: b480         	push	{r7}
 80578ea: 466f         	mov	r7, sp
 80578ec: b084         	sub	sp, #0x10
 80578ee: 9003         	str	r0, [sp, #0xc]
;         TCB_t * const pxTCB = pxMutexHolder;
 80578f0: 9803         	ldr	r0, [sp, #0xc]
 80578f2: 9002         	str	r0, [sp, #0x8]
 80578f4: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFALSE;
 80578f6: 9001         	str	r0, [sp, #0x4]
;         if( pxMutexHolder != NULL )
 80578f8: 9803         	ldr	r0, [sp, #0xc]
 80578fa: 2800         	cmp	r0, #0x0
 80578fc: f000 8092    	beq.w	0x8057a24 <xTaskPriorityDisinherit+0x144> @ imm = #0x124
 8057900: e7ff         	b	0x8057902 <xTaskPriorityDisinherit+0x22> @ imm = #-0x2
;             configASSERT( pxTCB == pxCurrentTCB );
 8057902: 9802         	ldr	r0, [sp, #0x8]
 8057904: f240 1100    	movw	r1, #0x100
 8057908: f2c2 0100    	movt	r1, #0x2000
 805790c: 6809         	ldr	r1, [r1]
 805790e: 4288         	cmp	r0, r1
 8057910: d004         	beq	0x805791c <xTaskPriorityDisinherit+0x3c> @ imm = #0x8
 8057912: e7ff         	b	0x8057914 <xTaskPriorityDisinherit+0x34> @ imm = #-0x2
 8057914: 4849         	ldr	r0, [pc, #0x124]        @ 0x8057a3c <xTaskPriorityDisinherit+0x15c>
 8057916: 4780         	blx	r0
 8057918: e7ff         	b	0x805791a <xTaskPriorityDisinherit+0x3a> @ imm = #-0x2
 805791a: e7fe         	b	0x805791a <xTaskPriorityDisinherit+0x3a> @ imm = #-0x4
;             configASSERT( pxTCB->uxMutexesHeld );
 805791c: 9802         	ldr	r0, [sp, #0x8]
 805791e: f8d0 00cc    	ldr.w	r0, [r0, #0xcc]
 8057922: b920         	cbnz	r0, 0x805792e <xTaskPriorityDisinherit+0x4e> @ imm = #0x8
 8057924: e7ff         	b	0x8057926 <xTaskPriorityDisinherit+0x46> @ imm = #-0x2
 8057926: 4844         	ldr	r0, [pc, #0x110]        @ 0x8057a38 <xTaskPriorityDisinherit+0x158>
 8057928: 4780         	blx	r0
 805792a: e7ff         	b	0x805792c <xTaskPriorityDisinherit+0x4c> @ imm = #-0x2
 805792c: e7fe         	b	0x805792c <xTaskPriorityDisinherit+0x4c> @ imm = #-0x4
;             ( pxTCB->uxMutexesHeld )--;
 805792e: 9902         	ldr	r1, [sp, #0x8]
 8057930: f8d1 00cc    	ldr.w	r0, [r1, #0xcc]
 8057934: 3801         	subs	r0, #0x1
 8057936: f8c1 00cc    	str.w	r0, [r1, #0xcc]
;             if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 805793a: 9902         	ldr	r1, [sp, #0x8]
 805793c: f8d1 00a8    	ldr.w	r0, [r1, #0xa8]
 8057940: f8d1 10c8    	ldr.w	r1, [r1, #0xc8]
 8057944: 4288         	cmp	r0, r1
 8057946: d06b         	beq	0x8057a20 <xTaskPriorityDisinherit+0x140> @ imm = #0xd6
 8057948: e7ff         	b	0x805794a <xTaskPriorityDisinherit+0x6a> @ imm = #-0x2
;                 if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 805794a: 9802         	ldr	r0, [sp, #0x8]
 805794c: f8d0 00cc    	ldr.w	r0, [r0, #0xcc]
 8057950: 2800         	cmp	r0, #0x0
 8057952: d163         	bne	0x8057a1c <xTaskPriorityDisinherit+0x13c> @ imm = #0xc6
 8057954: e7ff         	b	0x8057956 <xTaskPriorityDisinherit+0x76> @ imm = #-0x2
;                     if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8057956: 9802         	ldr	r0, [sp, #0x8]
 8057958: 3080         	adds	r0, #0x80
 805795a: 4936         	ldr	r1, [pc, #0xd8]         @ 0x8057a34 <xTaskPriorityDisinherit+0x154>
 805795c: 4788         	blx	r1
 805795e: b908         	cbnz	r0, 0x8057964 <xTaskPriorityDisinherit+0x84> @ imm = #0x2
 8057960: e7ff         	b	0x8057962 <xTaskPriorityDisinherit+0x82> @ imm = #-0x2
;                     }
 8057962: e000         	b	0x8057966 <xTaskPriorityDisinherit+0x86> @ imm = #0x0
 8057964: e7ff         	b	0x8057966 <xTaskPriorityDisinherit+0x86> @ imm = #-0x2
;                     pxTCB->uxPriority = pxTCB->uxBasePriority;
 8057966: 9902         	ldr	r1, [sp, #0x8]
 8057968: f8d1 00c8    	ldr.w	r0, [r1, #0xc8]
 805796c: f8c1 00a8    	str.w	r0, [r1, #0xa8]
;                     listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8057970: 9902         	ldr	r1, [sp, #0x8]
 8057972: f8d1 00a8    	ldr.w	r0, [r1, #0xa8]
 8057976: f1c0 0010    	rsb.w	r0, r0, #0x10
 805797a: f8c1 0094    	str.w	r0, [r1, #0x94]
;                     prvAddTaskToReadyList( pxTCB );
 805797e: e7ff         	b	0x8057980 <xTaskPriorityDisinherit+0xa0> @ imm = #-0x2
 8057980: e7ff         	b	0x8057982 <xTaskPriorityDisinherit+0xa2> @ imm = #-0x2
 8057982: 9802         	ldr	r0, [sp, #0x8]
 8057984: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057988: f240 21a0    	movw	r1, #0x2a0
 805798c: f2c2 0100    	movt	r1, #0x2000
 8057990: 6809         	ldr	r1, [r1]
 8057992: 4288         	cmp	r0, r1
 8057994: d909         	bls	0x80579aa <xTaskPriorityDisinherit+0xca> @ imm = #0x12
 8057996: e7ff         	b	0x8057998 <xTaskPriorityDisinherit+0xb8> @ imm = #-0x2
 8057998: 9802         	ldr	r0, [sp, #0x8]
 805799a: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805799e: f240 21a0    	movw	r1, #0x2a0
 80579a2: f2c2 0100    	movt	r1, #0x2000
 80579a6: 6008         	str	r0, [r1]
 80579a8: e7ff         	b	0x80579aa <xTaskPriorityDisinherit+0xca> @ imm = #-0x2
 80579aa: e7ff         	b	0x80579ac <xTaskPriorityDisinherit+0xcc> @ imm = #-0x2
 80579ac: e7ff         	b	0x80579ae <xTaskPriorityDisinherit+0xce> @ imm = #-0x2
 80579ae: 9802         	ldr	r0, [sp, #0x8]
 80579b0: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80579b4: eb00 0080    	add.w	r0, r0, r0, lsl #2
 80579b8: f240 1160    	movw	r1, #0x160
 80579bc: f2c2 0100    	movt	r1, #0x2000
 80579c0: eb01 0080    	add.w	r0, r1, r0, lsl #2
 80579c4: 6840         	ldr	r0, [r0, #0x4]
 80579c6: 9000         	str	r0, [sp]
 80579c8: 9800         	ldr	r0, [sp]
 80579ca: 9a02         	ldr	r2, [sp, #0x8]
 80579cc: f8c2 0084    	str.w	r0, [r2, #0x84]
 80579d0: 9800         	ldr	r0, [sp]
 80579d2: 6880         	ldr	r0, [r0, #0x8]
 80579d4: 9a02         	ldr	r2, [sp, #0x8]
 80579d6: f8c2 0088    	str.w	r0, [r2, #0x88]
 80579da: 9802         	ldr	r0, [sp, #0x8]
 80579dc: 3080         	adds	r0, #0x80
 80579de: 9a00         	ldr	r2, [sp]
 80579e0: 6892         	ldr	r2, [r2, #0x8]
 80579e2: 6050         	str	r0, [r2, #0x4]
 80579e4: 9802         	ldr	r0, [sp, #0x8]
 80579e6: 3080         	adds	r0, #0x80
 80579e8: 9a00         	ldr	r2, [sp]
 80579ea: 6090         	str	r0, [r2, #0x8]
 80579ec: 9a02         	ldr	r2, [sp, #0x8]
 80579ee: f8d2 00a8    	ldr.w	r0, [r2, #0xa8]
 80579f2: eb00 0080    	add.w	r0, r0, r0, lsl #2
 80579f6: eb01 0080    	add.w	r0, r1, r0, lsl #2
 80579fa: f8c2 0090    	str.w	r0, [r2, #0x90]
 80579fe: 9802         	ldr	r0, [sp, #0x8]
 8057a00: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057a04: eb00 0280    	add.w	r2, r0, r0, lsl #2
 8057a08: f851 0022    	ldr.w	r0, [r1, r2, lsl #2]
 8057a0c: 3001         	adds	r0, #0x1
 8057a0e: f841 0022    	str.w	r0, [r1, r2, lsl #2]
 8057a12: e7ff         	b	0x8057a14 <xTaskPriorityDisinherit+0x134> @ imm = #-0x2
 8057a14: e7ff         	b	0x8057a16 <xTaskPriorityDisinherit+0x136> @ imm = #-0x2
 8057a16: 2001         	movs	r0, #0x1
;                     xReturn = pdTRUE;
 8057a18: 9001         	str	r0, [sp, #0x4]
;                 }
 8057a1a: e000         	b	0x8057a1e <xTaskPriorityDisinherit+0x13e> @ imm = #0x0
 8057a1c: e7ff         	b	0x8057a1e <xTaskPriorityDisinherit+0x13e> @ imm = #-0x2
;             }
 8057a1e: e000         	b	0x8057a22 <xTaskPriorityDisinherit+0x142> @ imm = #0x0
 8057a20: e7ff         	b	0x8057a22 <xTaskPriorityDisinherit+0x142> @ imm = #-0x2
;         }
 8057a22: e000         	b	0x8057a26 <xTaskPriorityDisinherit+0x146> @ imm = #0x0
 8057a24: e7ff         	b	0x8057a26 <xTaskPriorityDisinherit+0x146> @ imm = #-0x2
;         return xReturn;
 8057a26: 9801         	ldr	r0, [sp, #0x4]
 8057a28: b004         	add	sp, #0x10
 8057a2a: bc80         	pop	{r7}
 8057a2c: eba8 0809    	sub.w	r8, r8, r9
 8057a30: f858 fd5c    	ldr	pc, [r8, #-92]!

08057a34 <$d.85>:
 8057a34: 13 a5 05 08  	.word	0x0805a513
 8057a38: 15 d7 05 08  	.word	0x0805d715
 8057a3c: 15 d7 05 08  	.word	0x0805d715

08057a40 <vTaskPriorityDisinheritAfterTimeout>:
;     {
 8057a40: f848 eb7c    	str	lr, [r8], #124
 8057a44: eb08 0809    	add.w	r8, r8, r9
 8057a48: b480         	push	{r7}
 8057a4a: 466f         	mov	r7, sp
 8057a4c: b088         	sub	sp, #0x20
 8057a4e: 9007         	str	r0, [sp, #0x1c]
 8057a50: 9106         	str	r1, [sp, #0x18]
;         TCB_t * const pxTCB = pxMutexHolder;
 8057a52: 9807         	ldr	r0, [sp, #0x1c]
 8057a54: 9005         	str	r0, [sp, #0x14]
 8057a56: 2001         	movs	r0, #0x1
;         const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 8057a58: 9002         	str	r0, [sp, #0x8]
;         if( pxMutexHolder != NULL )
 8057a5a: 9807         	ldr	r0, [sp, #0x1c]
 8057a5c: 2800         	cmp	r0, #0x0
 8057a5e: f000 80b6    	beq.w	0x8057bce <vTaskPriorityDisinheritAfterTimeout+0x18e> @ imm = #0x16c
 8057a62: e7ff         	b	0x8057a64 <vTaskPriorityDisinheritAfterTimeout+0x24> @ imm = #-0x2
;             configASSERT( pxTCB->uxMutexesHeld );
 8057a64: 9805         	ldr	r0, [sp, #0x14]
 8057a66: f8d0 00cc    	ldr.w	r0, [r0, #0xcc]
 8057a6a: b920         	cbnz	r0, 0x8057a76 <vTaskPriorityDisinheritAfterTimeout+0x36> @ imm = #0x8
 8057a6c: e7ff         	b	0x8057a6e <vTaskPriorityDisinheritAfterTimeout+0x2e> @ imm = #-0x2
 8057a6e: 485d         	ldr	r0, [pc, #0x174]        @ 0x8057be4 <vTaskPriorityDisinheritAfterTimeout+0x1a4>
 8057a70: 4780         	blx	r0
 8057a72: e7ff         	b	0x8057a74 <vTaskPriorityDisinheritAfterTimeout+0x34> @ imm = #-0x2
 8057a74: e7fe         	b	0x8057a74 <vTaskPriorityDisinheritAfterTimeout+0x34> @ imm = #-0x4
;             if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 8057a76: 9805         	ldr	r0, [sp, #0x14]
 8057a78: f8d0 00c8    	ldr.w	r0, [r0, #0xc8]
 8057a7c: 9906         	ldr	r1, [sp, #0x18]
 8057a7e: 4288         	cmp	r0, r1
 8057a80: d203         	bhs	0x8057a8a <vTaskPriorityDisinheritAfterTimeout+0x4a> @ imm = #0x6
 8057a82: e7ff         	b	0x8057a84 <vTaskPriorityDisinheritAfterTimeout+0x44> @ imm = #-0x2
;                 uxPriorityToUse = uxHighestPriorityWaitingTask;
 8057a84: 9806         	ldr	r0, [sp, #0x18]
 8057a86: 9003         	str	r0, [sp, #0xc]
;             }
 8057a88: e004         	b	0x8057a94 <vTaskPriorityDisinheritAfterTimeout+0x54> @ imm = #0x8
;                 uxPriorityToUse = pxTCB->uxBasePriority;
 8057a8a: 9805         	ldr	r0, [sp, #0x14]
 8057a8c: f8d0 00c8    	ldr.w	r0, [r0, #0xc8]
 8057a90: 9003         	str	r0, [sp, #0xc]
 8057a92: e7ff         	b	0x8057a94 <vTaskPriorityDisinheritAfterTimeout+0x54> @ imm = #-0x2
;             if( pxTCB->uxPriority != uxPriorityToUse )
 8057a94: 9805         	ldr	r0, [sp, #0x14]
 8057a96: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057a9a: 9903         	ldr	r1, [sp, #0xc]
 8057a9c: 4288         	cmp	r0, r1
 8057a9e: f000 8094    	beq.w	0x8057bca <vTaskPriorityDisinheritAfterTimeout+0x18a> @ imm = #0x128
 8057aa2: e7ff         	b	0x8057aa4 <vTaskPriorityDisinheritAfterTimeout+0x64> @ imm = #-0x2
;                 if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 8057aa4: 9805         	ldr	r0, [sp, #0x14]
 8057aa6: f8d0 00cc    	ldr.w	r0, [r0, #0xcc]
 8057aaa: 2801         	cmp	r0, #0x1
 8057aac: f040 808b    	bne.w	0x8057bc6 <vTaskPriorityDisinheritAfterTimeout+0x186> @ imm = #0x116
 8057ab0: e7ff         	b	0x8057ab2 <vTaskPriorityDisinheritAfterTimeout+0x72> @ imm = #-0x2
;                     configASSERT( pxTCB != pxCurrentTCB );
 8057ab2: 9805         	ldr	r0, [sp, #0x14]
 8057ab4: f240 1100    	movw	r1, #0x100
 8057ab8: f2c2 0100    	movt	r1, #0x2000
 8057abc: 6809         	ldr	r1, [r1]
 8057abe: 4288         	cmp	r0, r1
 8057ac0: d104         	bne	0x8057acc <vTaskPriorityDisinheritAfterTimeout+0x8c> @ imm = #0x8
 8057ac2: e7ff         	b	0x8057ac4 <vTaskPriorityDisinheritAfterTimeout+0x84> @ imm = #-0x2
 8057ac4: 4846         	ldr	r0, [pc, #0x118]        @ 0x8057be0 <vTaskPriorityDisinheritAfterTimeout+0x1a0>
 8057ac6: 4780         	blx	r0
 8057ac8: e7ff         	b	0x8057aca <vTaskPriorityDisinheritAfterTimeout+0x8a> @ imm = #-0x2
 8057aca: e7fe         	b	0x8057aca <vTaskPriorityDisinheritAfterTimeout+0x8a> @ imm = #-0x4
;                     uxPriorityUsedOnEntry = pxTCB->uxPriority;
 8057acc: 9805         	ldr	r0, [sp, #0x14]
 8057ace: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057ad2: 9004         	str	r0, [sp, #0x10]
;                     pxTCB->uxPriority = uxPriorityToUse;
 8057ad4: 9803         	ldr	r0, [sp, #0xc]
 8057ad6: 9905         	ldr	r1, [sp, #0x14]
 8057ad8: f8c1 00a8    	str.w	r0, [r1, #0xa8]
;                     if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8057adc: 9805         	ldr	r0, [sp, #0x14]
 8057ade: f890 0097    	ldrb.w	r0, [r0, #0x97]
 8057ae2: 0600         	lsls	r0, r0, #0x18
 8057ae4: 2800         	cmp	r0, #0x0
 8057ae6: d407         	bmi	0x8057af8 <vTaskPriorityDisinheritAfterTimeout+0xb8> @ imm = #0xe
 8057ae8: e7ff         	b	0x8057aea <vTaskPriorityDisinheritAfterTimeout+0xaa> @ imm = #-0x2
;                         listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8057aea: 9803         	ldr	r0, [sp, #0xc]
 8057aec: f1c0 0010    	rsb.w	r0, r0, #0x10
 8057af0: 9905         	ldr	r1, [sp, #0x14]
 8057af2: f8c1 0094    	str.w	r0, [r1, #0x94]
;                     }
 8057af6: e000         	b	0x8057afa <vTaskPriorityDisinheritAfterTimeout+0xba> @ imm = #0x0
 8057af8: e7ff         	b	0x8057afa <vTaskPriorityDisinheritAfterTimeout+0xba> @ imm = #-0x2
;                     if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8057afa: 9805         	ldr	r0, [sp, #0x14]
 8057afc: f8d0 0090    	ldr.w	r0, [r0, #0x90]
 8057b00: 9904         	ldr	r1, [sp, #0x10]
 8057b02: eb01 0281    	add.w	r2, r1, r1, lsl #2
 8057b06: f240 1160    	movw	r1, #0x160
 8057b0a: f2c2 0100    	movt	r1, #0x2000
 8057b0e: eb01 0182    	add.w	r1, r1, r2, lsl #2
 8057b12: 4288         	cmp	r0, r1
 8057b14: d155         	bne	0x8057bc2 <vTaskPriorityDisinheritAfterTimeout+0x182> @ imm = #0xaa
 8057b16: e7ff         	b	0x8057b18 <vTaskPriorityDisinheritAfterTimeout+0xd8> @ imm = #-0x2
;                         if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8057b18: 9805         	ldr	r0, [sp, #0x14]
 8057b1a: 3080         	adds	r0, #0x80
 8057b1c: 492f         	ldr	r1, [pc, #0xbc]         @ 0x8057bdc <vTaskPriorityDisinheritAfterTimeout+0x19c>
 8057b1e: 4788         	blx	r1
 8057b20: b908         	cbnz	r0, 0x8057b26 <vTaskPriorityDisinheritAfterTimeout+0xe6> @ imm = #0x2
 8057b22: e7ff         	b	0x8057b24 <vTaskPriorityDisinheritAfterTimeout+0xe4> @ imm = #-0x2
;                         }
 8057b24: e000         	b	0x8057b28 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #0x0
 8057b26: e7ff         	b	0x8057b28 <vTaskPriorityDisinheritAfterTimeout+0xe8> @ imm = #-0x2
;                         prvAddTaskToReadyList( pxTCB );
 8057b28: e7ff         	b	0x8057b2a <vTaskPriorityDisinheritAfterTimeout+0xea> @ imm = #-0x2
 8057b2a: e7ff         	b	0x8057b2c <vTaskPriorityDisinheritAfterTimeout+0xec> @ imm = #-0x2
 8057b2c: 9805         	ldr	r0, [sp, #0x14]
 8057b2e: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057b32: f240 21a0    	movw	r1, #0x2a0
 8057b36: f2c2 0100    	movt	r1, #0x2000
 8057b3a: 6809         	ldr	r1, [r1]
 8057b3c: 4288         	cmp	r0, r1
 8057b3e: d909         	bls	0x8057b54 <vTaskPriorityDisinheritAfterTimeout+0x114> @ imm = #0x12
 8057b40: e7ff         	b	0x8057b42 <vTaskPriorityDisinheritAfterTimeout+0x102> @ imm = #-0x2
 8057b42: 9805         	ldr	r0, [sp, #0x14]
 8057b44: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057b48: f240 21a0    	movw	r1, #0x2a0
 8057b4c: f2c2 0100    	movt	r1, #0x2000
 8057b50: 6008         	str	r0, [r1]
 8057b52: e7ff         	b	0x8057b54 <vTaskPriorityDisinheritAfterTimeout+0x114> @ imm = #-0x2
 8057b54: e7ff         	b	0x8057b56 <vTaskPriorityDisinheritAfterTimeout+0x116> @ imm = #-0x2
 8057b56: e7ff         	b	0x8057b58 <vTaskPriorityDisinheritAfterTimeout+0x118> @ imm = #-0x2
 8057b58: 9805         	ldr	r0, [sp, #0x14]
 8057b5a: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057b5e: eb00 0080    	add.w	r0, r0, r0, lsl #2
 8057b62: f240 1160    	movw	r1, #0x160
 8057b66: f2c2 0100    	movt	r1, #0x2000
 8057b6a: eb01 0080    	add.w	r0, r1, r0, lsl #2
 8057b6e: 6840         	ldr	r0, [r0, #0x4]
 8057b70: 9001         	str	r0, [sp, #0x4]
 8057b72: 9801         	ldr	r0, [sp, #0x4]
 8057b74: 9a05         	ldr	r2, [sp, #0x14]
 8057b76: f8c2 0084    	str.w	r0, [r2, #0x84]
 8057b7a: 9801         	ldr	r0, [sp, #0x4]
 8057b7c: 6880         	ldr	r0, [r0, #0x8]
 8057b7e: 9a05         	ldr	r2, [sp, #0x14]
 8057b80: f8c2 0088    	str.w	r0, [r2, #0x88]
 8057b84: 9805         	ldr	r0, [sp, #0x14]
 8057b86: 3080         	adds	r0, #0x80
 8057b88: 9a01         	ldr	r2, [sp, #0x4]
 8057b8a: 6892         	ldr	r2, [r2, #0x8]
 8057b8c: 6050         	str	r0, [r2, #0x4]
 8057b8e: 9805         	ldr	r0, [sp, #0x14]
 8057b90: 3080         	adds	r0, #0x80
 8057b92: 9a01         	ldr	r2, [sp, #0x4]
 8057b94: 6090         	str	r0, [r2, #0x8]
 8057b96: 9a05         	ldr	r2, [sp, #0x14]
 8057b98: f8d2 00a8    	ldr.w	r0, [r2, #0xa8]
 8057b9c: eb00 0080    	add.w	r0, r0, r0, lsl #2
 8057ba0: eb01 0080    	add.w	r0, r1, r0, lsl #2
 8057ba4: f8c2 0090    	str.w	r0, [r2, #0x90]
 8057ba8: 9805         	ldr	r0, [sp, #0x14]
 8057baa: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057bae: eb00 0280    	add.w	r2, r0, r0, lsl #2
 8057bb2: f851 0022    	ldr.w	r0, [r1, r2, lsl #2]
 8057bb6: 3001         	adds	r0, #0x1
 8057bb8: f841 0022    	str.w	r0, [r1, r2, lsl #2]
 8057bbc: e7ff         	b	0x8057bbe <vTaskPriorityDisinheritAfterTimeout+0x17e> @ imm = #-0x2
 8057bbe: e7ff         	b	0x8057bc0 <vTaskPriorityDisinheritAfterTimeout+0x180> @ imm = #-0x2
;                     }
 8057bc0: e000         	b	0x8057bc4 <vTaskPriorityDisinheritAfterTimeout+0x184> @ imm = #0x0
 8057bc2: e7ff         	b	0x8057bc4 <vTaskPriorityDisinheritAfterTimeout+0x184> @ imm = #-0x2
;                 }
 8057bc4: e000         	b	0x8057bc8 <vTaskPriorityDisinheritAfterTimeout+0x188> @ imm = #0x0
 8057bc6: e7ff         	b	0x8057bc8 <vTaskPriorityDisinheritAfterTimeout+0x188> @ imm = #-0x2
;             }
 8057bc8: e000         	b	0x8057bcc <vTaskPriorityDisinheritAfterTimeout+0x18c> @ imm = #0x0
 8057bca: e7ff         	b	0x8057bcc <vTaskPriorityDisinheritAfterTimeout+0x18c> @ imm = #-0x2
;         }
 8057bcc: e000         	b	0x8057bd0 <vTaskPriorityDisinheritAfterTimeout+0x190> @ imm = #0x0
 8057bce: e7ff         	b	0x8057bd0 <vTaskPriorityDisinheritAfterTimeout+0x190> @ imm = #-0x2
;     }
 8057bd0: b008         	add	sp, #0x20
 8057bd2: bc80         	pop	{r7}
 8057bd4: eba8 0809    	sub.w	r8, r8, r9
 8057bd8: f858 fd7c    	ldr	pc, [r8, #-124]!

08057bdc <$d.87>:
 8057bdc: 13 a5 05 08  	.word	0x0805a513
 8057be0: 15 d7 05 08  	.word	0x0805d715
 8057be4: 15 d7 05 08  	.word	0x0805d715

08057be8 <uxTaskResetEventItemValue>:
; {
 8057be8: b081         	sub	sp, #0x4
;     uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 8057bea: f240 1100    	movw	r1, #0x100
 8057bee: f2c2 0100    	movt	r1, #0x2000
 8057bf2: 6808         	ldr	r0, [r1]
 8057bf4: f8d0 0094    	ldr.w	r0, [r0, #0x94]
 8057bf8: 9000         	str	r0, [sp]
;     listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8057bfa: 6808         	ldr	r0, [r1]
 8057bfc: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8057c00: f1c0 0010    	rsb.w	r0, r0, #0x10
 8057c04: 6809         	ldr	r1, [r1]
 8057c06: f8c1 0094    	str.w	r0, [r1, #0x94]
;     return uxReturn;
 8057c0a: 9800         	ldr	r0, [sp]
 8057c0c: b001         	add	sp, #0x4
 8057c0e: 4770         	bx	lr

08057c10 <pvTaskIncrementMutexHeldCount>:
;     {
 8057c10: b081         	sub	sp, #0x4
;         pxTCB = pxCurrentTCB;
 8057c12: f240 1000    	movw	r0, #0x100
 8057c16: f2c2 0000    	movt	r0, #0x2000
 8057c1a: 6800         	ldr	r0, [r0]
 8057c1c: 9000         	str	r0, [sp]
;         if( pxTCB != NULL )
 8057c1e: 9800         	ldr	r0, [sp]
 8057c20: b138         	cbz	r0, 0x8057c32 <pvTaskIncrementMutexHeldCount+0x22> @ imm = #0xe
 8057c22: e7ff         	b	0x8057c24 <pvTaskIncrementMutexHeldCount+0x14> @ imm = #-0x2
;             ( pxTCB->uxMutexesHeld )++;
 8057c24: 9900         	ldr	r1, [sp]
 8057c26: f8d1 00cc    	ldr.w	r0, [r1, #0xcc]
 8057c2a: 3001         	adds	r0, #0x1
 8057c2c: f8c1 00cc    	str.w	r0, [r1, #0xcc]
;         }
 8057c30: e7ff         	b	0x8057c32 <pvTaskIncrementMutexHeldCount+0x22> @ imm = #-0x2
;         return pxTCB;
 8057c32: 9800         	ldr	r0, [sp]
 8057c34: b001         	add	sp, #0x4
 8057c36: 4770         	bx	lr

08057c38 <ulTaskGenericNotifyTake>:
;     {
 8057c38: f848 eb7c    	str	lr, [r8], #124
 8057c3c: eb08 0809    	add.w	r8, r8, r9
 8057c40: b480         	push	{r7}
 8057c42: 466f         	mov	r7, sp
 8057c44: b086         	sub	sp, #0x18
 8057c46: 9005         	str	r0, [sp, #0x14]
 8057c48: 9104         	str	r1, [sp, #0x10]
 8057c4a: 9203         	str	r2, [sp, #0xc]
;         configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 8057c4c: 9805         	ldr	r0, [sp, #0x14]
 8057c4e: b120         	cbz	r0, 0x8057c5a <ulTaskGenericNotifyTake+0x22> @ imm = #0x8
 8057c50: e7ff         	b	0x8057c52 <ulTaskGenericNotifyTake+0x1a> @ imm = #-0x2
 8057c52: 4847         	ldr	r0, [pc, #0x11c]        @ 0x8057d70 <ulTaskGenericNotifyTake+0x138>
 8057c54: 4780         	blx	r0
 8057c56: e7ff         	b	0x8057c58 <ulTaskGenericNotifyTake+0x20> @ imm = #-0x2
 8057c58: e7fe         	b	0x8057c58 <ulTaskGenericNotifyTake+0x20> @ imm = #-0x4
;         taskENTER_CRITICAL();
 8057c5a: 483b         	ldr	r0, [pc, #0xec]         @ 0x8057d48 <ulTaskGenericNotifyTake+0x110>
 8057c5c: 4780         	blx	r0
;         if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0UL )
 8057c5e: f240 1000    	movw	r0, #0x100
 8057c62: f2c2 0000    	movt	r0, #0x2000
 8057c66: 6800         	ldr	r0, [r0]
 8057c68: 9905         	ldr	r1, [sp, #0x14]
 8057c6a: eb00 0081    	add.w	r0, r0, r1, lsl #2
 8057c6e: f8d0 00d0    	ldr.w	r0, [r0, #0xd0]
 8057c72: bb20         	cbnz	r0, 0x8057cbe <ulTaskGenericNotifyTake+0x86> @ imm = #0x48
 8057c74: e7ff         	b	0x8057c76 <ulTaskGenericNotifyTake+0x3e> @ imm = #-0x2
;             pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
 8057c76: f240 1000    	movw	r0, #0x100
 8057c7a: f2c2 0000    	movt	r0, #0x2000
 8057c7e: 6800         	ldr	r0, [r0]
 8057c80: 9905         	ldr	r1, [sp, #0x14]
 8057c82: 4401         	add	r1, r0
 8057c84: 2001         	movs	r0, #0x1
 8057c86: f881 00d4    	strb.w	r0, [r1, #0xd4]
;             if( xTicksToWait > ( TickType_t ) 0 )
 8057c8a: 9803         	ldr	r0, [sp, #0xc]
 8057c8c: b198         	cbz	r0, 0x8057cb6 <ulTaskGenericNotifyTake+0x7e> @ imm = #0x26
 8057c8e: e7ff         	b	0x8057c90 <ulTaskGenericNotifyTake+0x58> @ imm = #-0x2
;                 vTaskSuspendAll();
 8057c90: 4830         	ldr	r0, [pc, #0xc0]         @ 0x8057d54 <ulTaskGenericNotifyTake+0x11c>
 8057c92: 4780         	blx	r0
;                     taskEXIT_CRITICAL();
 8057c94: 4830         	ldr	r0, [pc, #0xc0]         @ 0x8057d58 <ulTaskGenericNotifyTake+0x120>
 8057c96: 4780         	blx	r0
;                     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8057c98: 9803         	ldr	r0, [sp, #0xc]
 8057c9a: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x8057d5c <ulTaskGenericNotifyTake+0x124>
 8057c9c: 2101         	movs	r1, #0x1
 8057c9e: 4790         	blx	r2
;                 xAlreadyYielded = xTaskResumeAll();
 8057ca0: 482f         	ldr	r0, [pc, #0xbc]         @ 0x8057d60 <ulTaskGenericNotifyTake+0x128>
 8057ca2: 4780         	blx	r0
 8057ca4: 9001         	str	r0, [sp, #0x4]
;                 if( xAlreadyYielded == pdFALSE )
 8057ca6: 9801         	ldr	r0, [sp, #0x4]
 8057ca8: b918         	cbnz	r0, 0x8057cb2 <ulTaskGenericNotifyTake+0x7a> @ imm = #0x6
 8057caa: e7ff         	b	0x8057cac <ulTaskGenericNotifyTake+0x74> @ imm = #-0x2
;                     taskYIELD_WITHIN_API();
 8057cac: 482d         	ldr	r0, [pc, #0xb4]         @ 0x8057d64 <ulTaskGenericNotifyTake+0x12c>
 8057cae: 4780         	blx	r0
;                 }
 8057cb0: e000         	b	0x8057cb4 <ulTaskGenericNotifyTake+0x7c> @ imm = #0x0
 8057cb2: e7ff         	b	0x8057cb4 <ulTaskGenericNotifyTake+0x7c> @ imm = #-0x2
;             }
 8057cb4: e002         	b	0x8057cbc <ulTaskGenericNotifyTake+0x84> @ imm = #0x4
;                 taskEXIT_CRITICAL();
 8057cb6: 4826         	ldr	r0, [pc, #0x98]         @ 0x8057d50 <ulTaskGenericNotifyTake+0x118>
 8057cb8: 4780         	blx	r0
 8057cba: e7ff         	b	0x8057cbc <ulTaskGenericNotifyTake+0x84> @ imm = #-0x2
;         }
 8057cbc: e002         	b	0x8057cc4 <ulTaskGenericNotifyTake+0x8c> @ imm = #0x4
;             taskEXIT_CRITICAL();
 8057cbe: 4823         	ldr	r0, [pc, #0x8c]         @ 0x8057d4c <ulTaskGenericNotifyTake+0x114>
 8057cc0: 4780         	blx	r0
 8057cc2: e7ff         	b	0x8057cc4 <ulTaskGenericNotifyTake+0x8c> @ imm = #-0x2
;         taskENTER_CRITICAL();
 8057cc4: 4828         	ldr	r0, [pc, #0xa0]         @ 0x8057d68 <ulTaskGenericNotifyTake+0x130>
 8057cc6: 4780         	blx	r0
;             ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];
 8057cc8: f240 1000    	movw	r0, #0x100
 8057ccc: f2c2 0000    	movt	r0, #0x2000
 8057cd0: 6800         	ldr	r0, [r0]
 8057cd2: 9905         	ldr	r1, [sp, #0x14]
 8057cd4: eb00 0081    	add.w	r0, r0, r1, lsl #2
 8057cd8: f8d0 00d0    	ldr.w	r0, [r0, #0xd0]
 8057cdc: 9002         	str	r0, [sp, #0x8]
;             if( ulReturn != 0UL )
 8057cde: 9802         	ldr	r0, [sp, #0x8]
 8057ce0: b1e8         	cbz	r0, 0x8057d1e <ulTaskGenericNotifyTake+0xe6> @ imm = #0x3a
 8057ce2: e7ff         	b	0x8057ce4 <ulTaskGenericNotifyTake+0xac> @ imm = #-0x2
;                 if( xClearCountOnExit != pdFALSE )
 8057ce4: 9804         	ldr	r0, [sp, #0x10]
 8057ce6: b160         	cbz	r0, 0x8057d02 <ulTaskGenericNotifyTake+0xca> @ imm = #0x18
 8057ce8: e7ff         	b	0x8057cea <ulTaskGenericNotifyTake+0xb2> @ imm = #-0x2
;                     pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = 0UL;
 8057cea: f240 1000    	movw	r0, #0x100
 8057cee: f2c2 0000    	movt	r0, #0x2000
 8057cf2: 6800         	ldr	r0, [r0]
 8057cf4: 9905         	ldr	r1, [sp, #0x14]
 8057cf6: eb00 0181    	add.w	r1, r0, r1, lsl #2
 8057cfa: 2000         	movs	r0, #0x0
 8057cfc: f8c1 00d0    	str.w	r0, [r1, #0xd0]
;                 }
 8057d00: e00c         	b	0x8057d1c <ulTaskGenericNotifyTake+0xe4> @ imm = #0x18
;                     pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ulReturn - ( uint32_t ) 1;
 8057d02: 9802         	ldr	r0, [sp, #0x8]
 8057d04: 3801         	subs	r0, #0x1
 8057d06: f240 1100    	movw	r1, #0x100
 8057d0a: f2c2 0100    	movt	r1, #0x2000
 8057d0e: 6809         	ldr	r1, [r1]
 8057d10: 9a05         	ldr	r2, [sp, #0x14]
 8057d12: eb01 0182    	add.w	r1, r1, r2, lsl #2
 8057d16: f8c1 00d0    	str.w	r0, [r1, #0xd0]
 8057d1a: e7ff         	b	0x8057d1c <ulTaskGenericNotifyTake+0xe4> @ imm = #-0x2
;             }
 8057d1c: e000         	b	0x8057d20 <ulTaskGenericNotifyTake+0xe8> @ imm = #0x0
 8057d1e: e7ff         	b	0x8057d20 <ulTaskGenericNotifyTake+0xe8> @ imm = #-0x2
;             pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
 8057d20: f240 1000    	movw	r0, #0x100
 8057d24: f2c2 0000    	movt	r0, #0x2000
 8057d28: 6800         	ldr	r0, [r0]
 8057d2a: 9905         	ldr	r1, [sp, #0x14]
 8057d2c: 4401         	add	r1, r0
 8057d2e: 2000         	movs	r0, #0x0
 8057d30: f881 00d4    	strb.w	r0, [r1, #0xd4]
;         taskEXIT_CRITICAL();
 8057d34: 480d         	ldr	r0, [pc, #0x34]         @ 0x8057d6c <ulTaskGenericNotifyTake+0x134>
 8057d36: 4780         	blx	r0
;         return ulReturn;
 8057d38: 9802         	ldr	r0, [sp, #0x8]
 8057d3a: b006         	add	sp, #0x18
 8057d3c: bc80         	pop	{r7}
 8057d3e: eba8 0809    	sub.w	r8, r8, r9
 8057d42: f858 fd7c    	ldr	pc, [r8, #-124]!
 8057d46: bf00         	nop

08057d48 <$d.89>:
 8057d48: 49 cd 05 08  	.word	0x0805cd49
 8057d4c: 7d cd 05 08  	.word	0x0805cd7d
 8057d50: 7d cd 05 08  	.word	0x0805cd7d
 8057d54: d9 58 05 08  	.word	0x080558d9
 8057d58: 7d cd 05 08  	.word	0x0805cd7d
 8057d5c: e9 58 05 08  	.word	0x080558e9
 8057d60: 0d 5a 05 08  	.word	0x08055a0d
 8057d64: 2f cd 05 08  	.word	0x0805cd2f
 8057d68: 49 cd 05 08  	.word	0x0805cd49
 8057d6c: 7d cd 05 08  	.word	0x0805cd7d
 8057d70: 15 d7 05 08  	.word	0x0805d715

08057d74 <xTaskGenericNotifyWait>:
;     {
 8057d74: f848 eb20    	str	lr, [r8], #32
 8057d78: eb08 0809    	add.w	r8, r8, r9
 8057d7c: b480         	push	{r7}
 8057d7e: 466f         	mov	r7, sp
 8057d80: b086         	sub	sp, #0x18
 8057d82: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 8057d86: 9005         	str	r0, [sp, #0x14]
 8057d88: 9104         	str	r1, [sp, #0x10]
 8057d8a: 9203         	str	r2, [sp, #0xc]
 8057d8c: 9302         	str	r3, [sp, #0x8]
;         configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 8057d8e: 9805         	ldr	r0, [sp, #0x14]
 8057d90: b120         	cbz	r0, 0x8057d9c <xTaskGenericNotifyWait+0x28> @ imm = #0x8
 8057d92: e7ff         	b	0x8057d94 <xTaskGenericNotifyWait+0x20> @ imm = #-0x2
 8057d94: 484d         	ldr	r0, [pc, #0x134]        @ 0x8057ecc <xTaskGenericNotifyWait+0x158>
 8057d96: 4780         	blx	r0
 8057d98: e7ff         	b	0x8057d9a <xTaskGenericNotifyWait+0x26> @ imm = #-0x2
 8057d9a: e7fe         	b	0x8057d9a <xTaskGenericNotifyWait+0x26> @ imm = #-0x4
;         taskENTER_CRITICAL();
 8057d9c: 4841         	ldr	r0, [pc, #0x104]        @ 0x8057ea4 <xTaskGenericNotifyWait+0x130>
 8057d9e: 4780         	blx	r0
;         if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
 8057da0: f240 1000    	movw	r0, #0x100
 8057da4: f2c2 0000    	movt	r0, #0x2000
 8057da8: 6800         	ldr	r0, [r0]
 8057daa: 9905         	ldr	r1, [sp, #0x14]
 8057dac: 4408         	add	r0, r1
 8057dae: f890 00d4    	ldrb.w	r0, [r0, #0xd4]
 8057db2: 2802         	cmp	r0, #0x2
 8057db4: d02e         	beq	0x8057e14 <xTaskGenericNotifyWait+0xa0> @ imm = #0x5c
 8057db6: e7ff         	b	0x8057db8 <xTaskGenericNotifyWait+0x44> @ imm = #-0x2
;             pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnEntry;
 8057db8: 9b04         	ldr	r3, [sp, #0x10]
 8057dba: f240 1000    	movw	r0, #0x100
 8057dbe: f2c2 0000    	movt	r0, #0x2000
 8057dc2: 6801         	ldr	r1, [r0]
 8057dc4: 9a05         	ldr	r2, [sp, #0x14]
 8057dc6: eb01 0282    	add.w	r2, r1, r2, lsl #2
 8057dca: f8d2 10d0    	ldr.w	r1, [r2, #0xd0]
 8057dce: 4399         	bics	r1, r3
 8057dd0: f8c2 10d0    	str.w	r1, [r2, #0xd0]
;             pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
 8057dd4: 6800         	ldr	r0, [r0]
 8057dd6: 9905         	ldr	r1, [sp, #0x14]
 8057dd8: 4401         	add	r1, r0
 8057dda: 2001         	movs	r0, #0x1
 8057ddc: f881 00d4    	strb.w	r0, [r1, #0xd4]
;             if( xTicksToWait > ( TickType_t ) 0 )
 8057de0: 68b8         	ldr	r0, [r7, #0x8]
 8057de2: b198         	cbz	r0, 0x8057e0c <xTaskGenericNotifyWait+0x98> @ imm = #0x26
 8057de4: e7ff         	b	0x8057de6 <xTaskGenericNotifyWait+0x72> @ imm = #-0x2
;                 vTaskSuspendAll();
 8057de6: 4832         	ldr	r0, [pc, #0xc8]         @ 0x8057eb0 <xTaskGenericNotifyWait+0x13c>
 8057de8: 4780         	blx	r0
;                     taskEXIT_CRITICAL();
 8057dea: 4832         	ldr	r0, [pc, #0xc8]         @ 0x8057eb4 <xTaskGenericNotifyWait+0x140>
 8057dec: 4780         	blx	r0
;                     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8057dee: 68b8         	ldr	r0, [r7, #0x8]
 8057df0: 4a31         	ldr	r2, [pc, #0xc4]         @ 0x8057eb8 <xTaskGenericNotifyWait+0x144>
 8057df2: 2101         	movs	r1, #0x1
 8057df4: 4790         	blx	r2
;                 xAlreadyYielded = xTaskResumeAll();
 8057df6: 4831         	ldr	r0, [pc, #0xc4]         @ 0x8057ebc <xTaskGenericNotifyWait+0x148>
 8057df8: 4780         	blx	r0
 8057dfa: 9000         	str	r0, [sp]
;                 if( xAlreadyYielded == pdFALSE )
 8057dfc: 9800         	ldr	r0, [sp]
 8057dfe: b918         	cbnz	r0, 0x8057e08 <xTaskGenericNotifyWait+0x94> @ imm = #0x6
 8057e00: e7ff         	b	0x8057e02 <xTaskGenericNotifyWait+0x8e> @ imm = #-0x2
;                     taskYIELD_WITHIN_API();
 8057e02: 482f         	ldr	r0, [pc, #0xbc]         @ 0x8057ec0 <xTaskGenericNotifyWait+0x14c>
 8057e04: 4780         	blx	r0
;                 }
 8057e06: e000         	b	0x8057e0a <xTaskGenericNotifyWait+0x96> @ imm = #0x0
 8057e08: e7ff         	b	0x8057e0a <xTaskGenericNotifyWait+0x96> @ imm = #-0x2
;             }
 8057e0a: e002         	b	0x8057e12 <xTaskGenericNotifyWait+0x9e> @ imm = #0x4
;                 taskEXIT_CRITICAL();
 8057e0c: 4827         	ldr	r0, [pc, #0x9c]         @ 0x8057eac <xTaskGenericNotifyWait+0x138>
 8057e0e: 4780         	blx	r0
 8057e10: e7ff         	b	0x8057e12 <xTaskGenericNotifyWait+0x9e> @ imm = #-0x2
;         }
 8057e12: e002         	b	0x8057e1a <xTaskGenericNotifyWait+0xa6> @ imm = #0x4
;             taskEXIT_CRITICAL();
 8057e14: 4824         	ldr	r0, [pc, #0x90]         @ 0x8057ea8 <xTaskGenericNotifyWait+0x134>
 8057e16: 4780         	blx	r0
 8057e18: e7ff         	b	0x8057e1a <xTaskGenericNotifyWait+0xa6> @ imm = #-0x2
;         taskENTER_CRITICAL();
 8057e1a: 482a         	ldr	r0, [pc, #0xa8]         @ 0x8057ec4 <xTaskGenericNotifyWait+0x150>
 8057e1c: 4780         	blx	r0
;             if( pulNotificationValue != NULL )
 8057e1e: 9802         	ldr	r0, [sp, #0x8]
 8057e20: b168         	cbz	r0, 0x8057e3e <xTaskGenericNotifyWait+0xca> @ imm = #0x1a
 8057e22: e7ff         	b	0x8057e24 <xTaskGenericNotifyWait+0xb0> @ imm = #-0x2
;                 *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];
 8057e24: f240 1000    	movw	r0, #0x100
 8057e28: f2c2 0000    	movt	r0, #0x2000
 8057e2c: 6800         	ldr	r0, [r0]
 8057e2e: 9905         	ldr	r1, [sp, #0x14]
 8057e30: eb00 0081    	add.w	r0, r0, r1, lsl #2
 8057e34: f8d0 00d0    	ldr.w	r0, [r0, #0xd0]
 8057e38: 9902         	ldr	r1, [sp, #0x8]
 8057e3a: 6008         	str	r0, [r1]
;             }
 8057e3c: e7ff         	b	0x8057e3e <xTaskGenericNotifyWait+0xca> @ imm = #-0x2
;             if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
 8057e3e: f240 1000    	movw	r0, #0x100
 8057e42: f2c2 0000    	movt	r0, #0x2000
 8057e46: 6800         	ldr	r0, [r0]
 8057e48: 9905         	ldr	r1, [sp, #0x14]
 8057e4a: 4408         	add	r0, r1
 8057e4c: f890 00d4    	ldrb.w	r0, [r0, #0xd4]
 8057e50: 2802         	cmp	r0, #0x2
 8057e52: d003         	beq	0x8057e5c <xTaskGenericNotifyWait+0xe8> @ imm = #0x6
 8057e54: e7ff         	b	0x8057e56 <xTaskGenericNotifyWait+0xe2> @ imm = #-0x2
 8057e56: 2000         	movs	r0, #0x0
;                 xReturn = pdFALSE;
 8057e58: 9001         	str	r0, [sp, #0x4]
;             }
 8057e5a: e010         	b	0x8057e7e <xTaskGenericNotifyWait+0x10a> @ imm = #0x20
;                 pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnExit;
 8057e5c: 9a03         	ldr	r2, [sp, #0xc]
 8057e5e: f240 1000    	movw	r0, #0x100
 8057e62: f2c2 0000    	movt	r0, #0x2000
 8057e66: 6800         	ldr	r0, [r0]
 8057e68: 9905         	ldr	r1, [sp, #0x14]
 8057e6a: eb00 0181    	add.w	r1, r0, r1, lsl #2
 8057e6e: f8d1 00d0    	ldr.w	r0, [r1, #0xd0]
 8057e72: 4390         	bics	r0, r2
 8057e74: f8c1 00d0    	str.w	r0, [r1, #0xd0]
 8057e78: 2001         	movs	r0, #0x1
;                 xReturn = pdTRUE;
 8057e7a: 9001         	str	r0, [sp, #0x4]
 8057e7c: e7ff         	b	0x8057e7e <xTaskGenericNotifyWait+0x10a> @ imm = #-0x2
;             pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
 8057e7e: f240 1000    	movw	r0, #0x100
 8057e82: f2c2 0000    	movt	r0, #0x2000
 8057e86: 6800         	ldr	r0, [r0]
 8057e88: 9905         	ldr	r1, [sp, #0x14]
 8057e8a: 4401         	add	r1, r0
 8057e8c: 2000         	movs	r0, #0x0
 8057e8e: f881 00d4    	strb.w	r0, [r1, #0xd4]
;         taskEXIT_CRITICAL();
 8057e92: 480d         	ldr	r0, [pc, #0x34]         @ 0x8057ec8 <xTaskGenericNotifyWait+0x154>
 8057e94: 4780         	blx	r0
;         return xReturn;
 8057e96: 9801         	ldr	r0, [sp, #0x4]
 8057e98: b006         	add	sp, #0x18
 8057e9a: bc80         	pop	{r7}
 8057e9c: eba8 0809    	sub.w	r8, r8, r9
 8057ea0: f858 fd20    	ldr	pc, [r8, #-32]!

08057ea4 <$d.91>:
 8057ea4: 49 cd 05 08  	.word	0x0805cd49
 8057ea8: 7d cd 05 08  	.word	0x0805cd7d
 8057eac: 7d cd 05 08  	.word	0x0805cd7d
 8057eb0: d9 58 05 08  	.word	0x080558d9
 8057eb4: 7d cd 05 08  	.word	0x0805cd7d
 8057eb8: e9 58 05 08  	.word	0x080558e9
 8057ebc: 0d 5a 05 08  	.word	0x08055a0d
 8057ec0: 2f cd 05 08  	.word	0x0805cd2f
 8057ec4: 49 cd 05 08  	.word	0x0805cd49
 8057ec8: 7d cd 05 08  	.word	0x0805cd7d
 8057ecc: 15 d7 05 08  	.word	0x0805d715

08057ed0 <xTaskGenericNotify>:
;     {
 8057ed0: f848 eb74    	str	lr, [r8], #116
 8057ed4: eb08 0809    	add.w	r8, r8, r9
 8057ed8: b480         	push	{r7}
 8057eda: 466f         	mov	r7, sp
 8057edc: b08a         	sub	sp, #0x28
 8057ede: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 8057ee2: 9009         	str	r0, [sp, #0x24]
 8057ee4: 9108         	str	r1, [sp, #0x20]
 8057ee6: 9207         	str	r2, [sp, #0x1c]
 8057ee8: f807 3c0d    	strb	r3, [r7, #-13]
 8057eec: 2001         	movs	r0, #0x1
;         BaseType_t xReturn = pdPASS;
 8057eee: 9004         	str	r0, [sp, #0x10]
;         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 8057ef0: 9808         	ldr	r0, [sp, #0x20]
 8057ef2: b120         	cbz	r0, 0x8057efe <xTaskGenericNotify+0x2e> @ imm = #0x8
 8057ef4: e7ff         	b	0x8057ef6 <xTaskGenericNotify+0x26> @ imm = #-0x2
 8057ef6: 4893         	ldr	r0, [pc, #0x24c]        @ 0x8058144 <xTaskGenericNotify+0x274>
 8057ef8: 4780         	blx	r0
 8057efa: e7ff         	b	0x8057efc <xTaskGenericNotify+0x2c> @ imm = #-0x2
 8057efc: e7fe         	b	0x8057efc <xTaskGenericNotify+0x2c> @ imm = #-0x4
;         configASSERT( xTaskToNotify );
 8057efe: 9809         	ldr	r0, [sp, #0x24]
 8057f00: b920         	cbnz	r0, 0x8057f0c <xTaskGenericNotify+0x3c> @ imm = #0x8
 8057f02: e7ff         	b	0x8057f04 <xTaskGenericNotify+0x34> @ imm = #-0x2
 8057f04: 488e         	ldr	r0, [pc, #0x238]        @ 0x8058140 <xTaskGenericNotify+0x270>
 8057f06: 4780         	blx	r0
 8057f08: e7ff         	b	0x8057f0a <xTaskGenericNotify+0x3a> @ imm = #-0x2
 8057f0a: e7fe         	b	0x8057f0a <xTaskGenericNotify+0x3a> @ imm = #-0x4
;         pxTCB = xTaskToNotify;
 8057f0c: 9809         	ldr	r0, [sp, #0x24]
 8057f0e: 9005         	str	r0, [sp, #0x14]
;         taskENTER_CRITICAL();
 8057f10: 4886         	ldr	r0, [pc, #0x218]        @ 0x805812c <xTaskGenericNotify+0x25c>
 8057f12: 4780         	blx	r0
;             if( pulPreviousNotificationValue != NULL )
 8057f14: 68b8         	ldr	r0, [r7, #0x8]
 8057f16: b148         	cbz	r0, 0x8057f2c <xTaskGenericNotify+0x5c> @ imm = #0x12
 8057f18: e7ff         	b	0x8057f1a <xTaskGenericNotify+0x4a> @ imm = #-0x2
;                 *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 8057f1a: 9805         	ldr	r0, [sp, #0x14]
 8057f1c: 9908         	ldr	r1, [sp, #0x20]
 8057f1e: eb00 0081    	add.w	r0, r0, r1, lsl #2
 8057f22: f8d0 00d0    	ldr.w	r0, [r0, #0xd0]
 8057f26: 68b9         	ldr	r1, [r7, #0x8]
 8057f28: 6008         	str	r0, [r1]
;             }
 8057f2a: e7ff         	b	0x8057f2c <xTaskGenericNotify+0x5c> @ imm = #-0x2
;             ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 8057f2c: 9805         	ldr	r0, [sp, #0x14]
 8057f2e: 9908         	ldr	r1, [sp, #0x20]
 8057f30: 4408         	add	r0, r1
 8057f32: f890 00d4    	ldrb.w	r0, [r0, #0xd4]
 8057f36: f807 0c19    	strb	r0, [r7, #-25]
;             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 8057f3a: 9805         	ldr	r0, [sp, #0x14]
 8057f3c: 9908         	ldr	r1, [sp, #0x20]
 8057f3e: 4401         	add	r1, r0
 8057f40: 2002         	movs	r0, #0x2
 8057f42: f881 00d4    	strb.w	r0, [r1, #0xd4]
;             switch( eAction )
 8057f46: f817 0c0d    	ldrb	r0, [r7, #-13]
 8057f4a: 4601         	mov	r1, r0
 8057f4c: 9100         	str	r1, [sp]
 8057f4e: 2800         	cmp	r0, #0x0
 8057f50: d03e         	beq	0x8057fd0 <xTaskGenericNotify+0x100> @ imm = #0x7c
 8057f52: e7ff         	b	0x8057f54 <xTaskGenericNotify+0x84> @ imm = #-0x2
 8057f54: 9800         	ldr	r0, [sp]
 8057f56: 2801         	cmp	r0, #0x1
 8057f58: d00c         	beq	0x8057f74 <xTaskGenericNotify+0xa4> @ imm = #0x18
 8057f5a: e7ff         	b	0x8057f5c <xTaskGenericNotify+0x8c> @ imm = #-0x2
 8057f5c: 9800         	ldr	r0, [sp]
 8057f5e: 2802         	cmp	r0, #0x2
 8057f60: d013         	beq	0x8057f8a <xTaskGenericNotify+0xba> @ imm = #0x26
 8057f62: e7ff         	b	0x8057f64 <xTaskGenericNotify+0x94> @ imm = #-0x2
 8057f64: 9800         	ldr	r0, [sp]
 8057f66: 2803         	cmp	r0, #0x3
 8057f68: d019         	beq	0x8057f9e <xTaskGenericNotify+0xce> @ imm = #0x32
 8057f6a: e7ff         	b	0x8057f6c <xTaskGenericNotify+0x9c> @ imm = #-0x2
 8057f6c: 9800         	ldr	r0, [sp]
 8057f6e: 2804         	cmp	r0, #0x4
 8057f70: d01d         	beq	0x8057fae <xTaskGenericNotify+0xde> @ imm = #0x3a
 8057f72: e02e         	b	0x8057fd2 <xTaskGenericNotify+0x102> @ imm = #0x5c
;                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 8057f74: 9a07         	ldr	r2, [sp, #0x1c]
 8057f76: 9805         	ldr	r0, [sp, #0x14]
 8057f78: 9908         	ldr	r1, [sp, #0x20]
 8057f7a: eb00 0181    	add.w	r1, r0, r1, lsl #2
 8057f7e: f8d1 00d0    	ldr.w	r0, [r1, #0xd0]
 8057f82: 4310         	orrs	r0, r2
 8057f84: f8c1 00d0    	str.w	r0, [r1, #0xd0]
;                     break;
 8057f88: e02f         	b	0x8057fea <xTaskGenericNotify+0x11a> @ imm = #0x5e
;                     ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 8057f8a: 9805         	ldr	r0, [sp, #0x14]
 8057f8c: 9908         	ldr	r1, [sp, #0x20]
 8057f8e: eb00 0181    	add.w	r1, r0, r1, lsl #2
 8057f92: f8d1 00d0    	ldr.w	r0, [r1, #0xd0]
 8057f96: 3001         	adds	r0, #0x1
 8057f98: f8c1 00d0    	str.w	r0, [r1, #0xd0]
;                     break;
 8057f9c: e025         	b	0x8057fea <xTaskGenericNotify+0x11a> @ imm = #0x4a
;                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 8057f9e: 9807         	ldr	r0, [sp, #0x1c]
 8057fa0: 9905         	ldr	r1, [sp, #0x14]
 8057fa2: 9a08         	ldr	r2, [sp, #0x20]
 8057fa4: eb01 0182    	add.w	r1, r1, r2, lsl #2
 8057fa8: f8c1 00d0    	str.w	r0, [r1, #0xd0]
;                     break;
 8057fac: e01d         	b	0x8057fea <xTaskGenericNotify+0x11a> @ imm = #0x3a
;                     if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 8057fae: f817 0c19    	ldrb	r0, [r7, #-25]
 8057fb2: 2802         	cmp	r0, #0x2
 8057fb4: d008         	beq	0x8057fc8 <xTaskGenericNotify+0xf8> @ imm = #0x10
 8057fb6: e7ff         	b	0x8057fb8 <xTaskGenericNotify+0xe8> @ imm = #-0x2
;                         pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 8057fb8: 9807         	ldr	r0, [sp, #0x1c]
 8057fba: 9905         	ldr	r1, [sp, #0x14]
 8057fbc: 9a08         	ldr	r2, [sp, #0x20]
 8057fbe: eb01 0182    	add.w	r1, r1, r2, lsl #2
 8057fc2: f8c1 00d0    	str.w	r0, [r1, #0xd0]
;                     }
 8057fc6: e002         	b	0x8057fce <xTaskGenericNotify+0xfe> @ imm = #0x4
 8057fc8: 2000         	movs	r0, #0x0
;                         xReturn = pdFAIL;
 8057fca: 9004         	str	r0, [sp, #0x10]
 8057fcc: e7ff         	b	0x8057fce <xTaskGenericNotify+0xfe> @ imm = #-0x2
;                     break;
 8057fce: e00c         	b	0x8057fea <xTaskGenericNotify+0x11a> @ imm = #0x18
;                     break;
 8057fd0: e00b         	b	0x8057fea <xTaskGenericNotify+0x11a> @ imm = #0x16
;                     configASSERT( xTickCount == ( TickType_t ) 0 );
 8057fd2: f240 102c    	movw	r0, #0x12c
 8057fd6: f2c2 0000    	movt	r0, #0x2000
 8057fda: 6800         	ldr	r0, [r0]
 8057fdc: b120         	cbz	r0, 0x8057fe8 <xTaskGenericNotify+0x118> @ imm = #0x8
 8057fde: e7ff         	b	0x8057fe0 <xTaskGenericNotify+0x110> @ imm = #-0x2
 8057fe0: 4856         	ldr	r0, [pc, #0x158]        @ 0x805813c <xTaskGenericNotify+0x26c>
 8057fe2: 4780         	blx	r0
 8057fe4: e7ff         	b	0x8057fe6 <xTaskGenericNotify+0x116> @ imm = #-0x2
 8057fe6: e7fe         	b	0x8057fe6 <xTaskGenericNotify+0x116> @ imm = #-0x4
;                     break;
 8057fe8: e7ff         	b	0x8057fea <xTaskGenericNotify+0x11a> @ imm = #-0x2
;             if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8057fea: f817 0c19    	ldrb	r0, [r7, #-25]
 8057fee: 2801         	cmp	r0, #0x1
 8057ff0: f040 8091    	bne.w	0x8058116 <xTaskGenericNotify+0x246> @ imm = #0x122
 8057ff4: e7ff         	b	0x8057ff6 <xTaskGenericNotify+0x126> @ imm = #-0x2
;                 listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8057ff6: e7ff         	b	0x8057ff8 <xTaskGenericNotify+0x128> @ imm = #-0x2
 8057ff8: 9805         	ldr	r0, [sp, #0x14]
 8057ffa: f8d0 0090    	ldr.w	r0, [r0, #0x90]
 8057ffe: 9002         	str	r0, [sp, #0x8]
 8058000: 9805         	ldr	r0, [sp, #0x14]
 8058002: f8d0 1084    	ldr.w	r1, [r0, #0x84]
 8058006: f8d0 0088    	ldr.w	r0, [r0, #0x88]
 805800a: 6088         	str	r0, [r1, #0x8]
 805800c: 9905         	ldr	r1, [sp, #0x14]
 805800e: f8d1 0084    	ldr.w	r0, [r1, #0x84]
 8058012: f8d1 1088    	ldr.w	r1, [r1, #0x88]
 8058016: 6048         	str	r0, [r1, #0x4]
 8058018: 9802         	ldr	r0, [sp, #0x8]
 805801a: 6840         	ldr	r0, [r0, #0x4]
 805801c: 9905         	ldr	r1, [sp, #0x14]
 805801e: 3180         	adds	r1, #0x80
 8058020: 4288         	cmp	r0, r1
 8058022: d106         	bne	0x8058032 <xTaskGenericNotify+0x162> @ imm = #0xc
 8058024: e7ff         	b	0x8058026 <xTaskGenericNotify+0x156> @ imm = #-0x2
 8058026: 9805         	ldr	r0, [sp, #0x14]
 8058028: f8d0 0088    	ldr.w	r0, [r0, #0x88]
 805802c: 9902         	ldr	r1, [sp, #0x8]
 805802e: 6048         	str	r0, [r1, #0x4]
 8058030: e7ff         	b	0x8058032 <xTaskGenericNotify+0x162> @ imm = #-0x2
 8058032: 9905         	ldr	r1, [sp, #0x14]
 8058034: 2000         	movs	r0, #0x0
 8058036: f8c1 0090    	str.w	r0, [r1, #0x90]
 805803a: 9902         	ldr	r1, [sp, #0x8]
 805803c: 6808         	ldr	r0, [r1]
 805803e: 3801         	subs	r0, #0x1
 8058040: 6008         	str	r0, [r1]
 8058042: e7ff         	b	0x8058044 <xTaskGenericNotify+0x174> @ imm = #-0x2
;                 prvAddTaskToReadyList( pxTCB );
 8058044: e7ff         	b	0x8058046 <xTaskGenericNotify+0x176> @ imm = #-0x2
 8058046: e7ff         	b	0x8058048 <xTaskGenericNotify+0x178> @ imm = #-0x2
 8058048: 9805         	ldr	r0, [sp, #0x14]
 805804a: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805804e: f240 21a0    	movw	r1, #0x2a0
 8058052: f2c2 0100    	movt	r1, #0x2000
 8058056: 6809         	ldr	r1, [r1]
 8058058: 4288         	cmp	r0, r1
 805805a: d909         	bls	0x8058070 <xTaskGenericNotify+0x1a0> @ imm = #0x12
 805805c: e7ff         	b	0x805805e <xTaskGenericNotify+0x18e> @ imm = #-0x2
 805805e: 9805         	ldr	r0, [sp, #0x14]
 8058060: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8058064: f240 21a0    	movw	r1, #0x2a0
 8058068: f2c2 0100    	movt	r1, #0x2000
 805806c: 6008         	str	r0, [r1]
 805806e: e7ff         	b	0x8058070 <xTaskGenericNotify+0x1a0> @ imm = #-0x2
 8058070: e7ff         	b	0x8058072 <xTaskGenericNotify+0x1a2> @ imm = #-0x2
 8058072: e7ff         	b	0x8058074 <xTaskGenericNotify+0x1a4> @ imm = #-0x2
 8058074: 9805         	ldr	r0, [sp, #0x14]
 8058076: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805807a: eb00 0080    	add.w	r0, r0, r0, lsl #2
 805807e: f240 1160    	movw	r1, #0x160
 8058082: f2c2 0100    	movt	r1, #0x2000
 8058086: eb01 0080    	add.w	r0, r1, r0, lsl #2
 805808a: 6840         	ldr	r0, [r0, #0x4]
 805808c: 9001         	str	r0, [sp, #0x4]
 805808e: 9801         	ldr	r0, [sp, #0x4]
 8058090: 9a05         	ldr	r2, [sp, #0x14]
 8058092: f8c2 0084    	str.w	r0, [r2, #0x84]
 8058096: 9801         	ldr	r0, [sp, #0x4]
 8058098: 6880         	ldr	r0, [r0, #0x8]
 805809a: 9a05         	ldr	r2, [sp, #0x14]
 805809c: f8c2 0088    	str.w	r0, [r2, #0x88]
 80580a0: 9805         	ldr	r0, [sp, #0x14]
 80580a2: 3080         	adds	r0, #0x80
 80580a4: 9a01         	ldr	r2, [sp, #0x4]
 80580a6: 6892         	ldr	r2, [r2, #0x8]
 80580a8: 6050         	str	r0, [r2, #0x4]
 80580aa: 9805         	ldr	r0, [sp, #0x14]
 80580ac: 3080         	adds	r0, #0x80
 80580ae: 9a01         	ldr	r2, [sp, #0x4]
 80580b0: 6090         	str	r0, [r2, #0x8]
 80580b2: 9a05         	ldr	r2, [sp, #0x14]
 80580b4: f8d2 00a8    	ldr.w	r0, [r2, #0xa8]
 80580b8: eb00 0080    	add.w	r0, r0, r0, lsl #2
 80580bc: eb01 0080    	add.w	r0, r1, r0, lsl #2
 80580c0: f8c2 0090    	str.w	r0, [r2, #0x90]
 80580c4: 9805         	ldr	r0, [sp, #0x14]
 80580c6: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80580ca: eb00 0280    	add.w	r2, r0, r0, lsl #2
 80580ce: f851 0022    	ldr.w	r0, [r1, r2, lsl #2]
 80580d2: 3001         	adds	r0, #0x1
 80580d4: f841 0022    	str.w	r0, [r1, r2, lsl #2]
 80580d8: e7ff         	b	0x80580da <xTaskGenericNotify+0x20a> @ imm = #-0x2
 80580da: e7ff         	b	0x80580dc <xTaskGenericNotify+0x20c> @ imm = #-0x2
;                 configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 80580dc: 9805         	ldr	r0, [sp, #0x14]
 80580de: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
 80580e2: b120         	cbz	r0, 0x80580ee <xTaskGenericNotify+0x21e> @ imm = #0x8
 80580e4: e7ff         	b	0x80580e6 <xTaskGenericNotify+0x216> @ imm = #-0x2
 80580e6: 4814         	ldr	r0, [pc, #0x50]         @ 0x8058138 <xTaskGenericNotify+0x268>
 80580e8: 4780         	blx	r0
 80580ea: e7ff         	b	0x80580ec <xTaskGenericNotify+0x21c> @ imm = #-0x2
 80580ec: e7fe         	b	0x80580ec <xTaskGenericNotify+0x21c> @ imm = #-0x4
;                 taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );
 80580ee: e7ff         	b	0x80580f0 <xTaskGenericNotify+0x220> @ imm = #-0x2
 80580f0: f240 1000    	movw	r0, #0x100
 80580f4: f2c2 0000    	movt	r0, #0x2000
 80580f8: 6800         	ldr	r0, [r0]
 80580fa: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80580fe: 9905         	ldr	r1, [sp, #0x14]
 8058100: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 8058104: 4288         	cmp	r0, r1
 8058106: d203         	bhs	0x8058110 <xTaskGenericNotify+0x240> @ imm = #0x6
 8058108: e7ff         	b	0x805810a <xTaskGenericNotify+0x23a> @ imm = #-0x2
 805810a: 4809         	ldr	r0, [pc, #0x24]         @ 0x8058130 <xTaskGenericNotify+0x260>
 805810c: 4780         	blx	r0
 805810e: e000         	b	0x8058112 <xTaskGenericNotify+0x242> @ imm = #0x0
 8058110: e7ff         	b	0x8058112 <xTaskGenericNotify+0x242> @ imm = #-0x2
;                 taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );
 8058112: e7ff         	b	0x8058114 <xTaskGenericNotify+0x244> @ imm = #-0x2
;             }
 8058114: e000         	b	0x8058118 <xTaskGenericNotify+0x248> @ imm = #0x0
 8058116: e7ff         	b	0x8058118 <xTaskGenericNotify+0x248> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 8058118: 4806         	ldr	r0, [pc, #0x18]         @ 0x8058134 <xTaskGenericNotify+0x264>
 805811a: 4780         	blx	r0
;         return xReturn;
 805811c: 9804         	ldr	r0, [sp, #0x10]
 805811e: b00a         	add	sp, #0x28
 8058120: bc80         	pop	{r7}
 8058122: eba8 0809    	sub.w	r8, r8, r9
 8058126: f858 fd74    	ldr	pc, [r8, #-116]!
 805812a: bf00         	nop

0805812c <$d.93>:
 805812c: 49 cd 05 08  	.word	0x0805cd49
 8058130: 2f cd 05 08  	.word	0x0805cd2f
 8058134: 7d cd 05 08  	.word	0x0805cd7d
 8058138: 15 d7 05 08  	.word	0x0805d715
 805813c: 15 d7 05 08  	.word	0x0805d715
 8058140: 15 d7 05 08  	.word	0x0805d715
 8058144: 15 d7 05 08  	.word	0x0805d715

08058148 <xTaskGenericNotifyFromISR>:
;     {
 8058148: f848 eb2c    	str	lr, [r8], #44
 805814c: eb08 0809    	add.w	r8, r8, r9
 8058150: b480         	push	{r7}
 8058152: 466f         	mov	r7, sp
 8058154: b08c         	sub	sp, #0x30
 8058156: f8d7 c00c    	ldr.w	r12, [r7, #0xc]
 805815a: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805815e: 900b         	str	r0, [sp, #0x2c]
 8058160: 910a         	str	r1, [sp, #0x28]
 8058162: 9209         	str	r2, [sp, #0x24]
 8058164: f807 3c0d    	strb	r3, [r7, #-13]
 8058168: 2001         	movs	r0, #0x1
;         BaseType_t xReturn = pdPASS;
 805816a: 9005         	str	r0, [sp, #0x14]
;         configASSERT( xTaskToNotify );
 805816c: 980b         	ldr	r0, [sp, #0x2c]
 805816e: b920         	cbnz	r0, 0x805817a <xTaskGenericNotifyFromISR+0x32> @ imm = #0x8
 8058170: e7ff         	b	0x8058172 <xTaskGenericNotifyFromISR+0x2a> @ imm = #-0x2
 8058172: 48ae         	ldr	r0, [pc, #0x2b8]        @ 0x805842c <xTaskGenericNotifyFromISR+0x2e4>
 8058174: 4780         	blx	r0
 8058176: e7ff         	b	0x8058178 <xTaskGenericNotifyFromISR+0x30> @ imm = #-0x2
 8058178: e7fe         	b	0x8058178 <xTaskGenericNotifyFromISR+0x30> @ imm = #-0x4
;         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 805817a: 980a         	ldr	r0, [sp, #0x28]
 805817c: b120         	cbz	r0, 0x8058188 <xTaskGenericNotifyFromISR+0x40> @ imm = #0x8
 805817e: e7ff         	b	0x8058180 <xTaskGenericNotifyFromISR+0x38> @ imm = #-0x2
 8058180: 48a9         	ldr	r0, [pc, #0x2a4]        @ 0x8058428 <xTaskGenericNotifyFromISR+0x2e0>
 8058182: 4780         	blx	r0
 8058184: e7ff         	b	0x8058186 <xTaskGenericNotifyFromISR+0x3e> @ imm = #-0x2
 8058186: e7fe         	b	0x8058186 <xTaskGenericNotifyFromISR+0x3e> @ imm = #-0x4
;         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8058188: 48a2         	ldr	r0, [pc, #0x288]        @ 0x8058414 <xTaskGenericNotifyFromISR+0x2cc>
 805818a: 4780         	blx	r0
;         pxTCB = xTaskToNotify;
 805818c: 980b         	ldr	r0, [sp, #0x2c]
 805818e: 9007         	str	r0, [sp, #0x1c]
;         uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
 8058190: 48a1         	ldr	r0, [pc, #0x284]        @ 0x8058418 <xTaskGenericNotifyFromISR+0x2d0>
 8058192: 4780         	blx	r0
 8058194: 9004         	str	r0, [sp, #0x10]
;             if( pulPreviousNotificationValue != NULL )
 8058196: 68b8         	ldr	r0, [r7, #0x8]
 8058198: b148         	cbz	r0, 0x80581ae <xTaskGenericNotifyFromISR+0x66> @ imm = #0x12
 805819a: e7ff         	b	0x805819c <xTaskGenericNotifyFromISR+0x54> @ imm = #-0x2
;                 *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 805819c: 9807         	ldr	r0, [sp, #0x1c]
 805819e: 990a         	ldr	r1, [sp, #0x28]
 80581a0: eb00 0081    	add.w	r0, r0, r1, lsl #2
 80581a4: f8d0 00d0    	ldr.w	r0, [r0, #0xd0]
 80581a8: 68b9         	ldr	r1, [r7, #0x8]
 80581aa: 6008         	str	r0, [r1]
;             }
 80581ac: e7ff         	b	0x80581ae <xTaskGenericNotifyFromISR+0x66> @ imm = #-0x2
;             ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 80581ae: 9807         	ldr	r0, [sp, #0x1c]
 80581b0: 990a         	ldr	r1, [sp, #0x28]
 80581b2: 4408         	add	r0, r1
 80581b4: f890 00d4    	ldrb.w	r0, [r0, #0xd4]
 80581b8: f807 0c15    	strb	r0, [r7, #-21]
;             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 80581bc: 9807         	ldr	r0, [sp, #0x1c]
 80581be: 990a         	ldr	r1, [sp, #0x28]
 80581c0: 4401         	add	r1, r0
 80581c2: 2002         	movs	r0, #0x2
 80581c4: f881 00d4    	strb.w	r0, [r1, #0xd4]
;             switch( eAction )
 80581c8: f817 0c0d    	ldrb	r0, [r7, #-13]
 80581cc: 4601         	mov	r1, r0
 80581ce: 9100         	str	r1, [sp]
 80581d0: 2800         	cmp	r0, #0x0
 80581d2: d03e         	beq	0x8058252 <xTaskGenericNotifyFromISR+0x10a> @ imm = #0x7c
 80581d4: e7ff         	b	0x80581d6 <xTaskGenericNotifyFromISR+0x8e> @ imm = #-0x2
 80581d6: 9800         	ldr	r0, [sp]
 80581d8: 2801         	cmp	r0, #0x1
 80581da: d00c         	beq	0x80581f6 <xTaskGenericNotifyFromISR+0xae> @ imm = #0x18
 80581dc: e7ff         	b	0x80581de <xTaskGenericNotifyFromISR+0x96> @ imm = #-0x2
 80581de: 9800         	ldr	r0, [sp]
 80581e0: 2802         	cmp	r0, #0x2
 80581e2: d013         	beq	0x805820c <xTaskGenericNotifyFromISR+0xc4> @ imm = #0x26
 80581e4: e7ff         	b	0x80581e6 <xTaskGenericNotifyFromISR+0x9e> @ imm = #-0x2
 80581e6: 9800         	ldr	r0, [sp]
 80581e8: 2803         	cmp	r0, #0x3
 80581ea: d019         	beq	0x8058220 <xTaskGenericNotifyFromISR+0xd8> @ imm = #0x32
 80581ec: e7ff         	b	0x80581ee <xTaskGenericNotifyFromISR+0xa6> @ imm = #-0x2
 80581ee: 9800         	ldr	r0, [sp]
 80581f0: 2804         	cmp	r0, #0x4
 80581f2: d01d         	beq	0x8058230 <xTaskGenericNotifyFromISR+0xe8> @ imm = #0x3a
 80581f4: e02e         	b	0x8058254 <xTaskGenericNotifyFromISR+0x10c> @ imm = #0x5c
;                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 80581f6: 9a09         	ldr	r2, [sp, #0x24]
 80581f8: 9807         	ldr	r0, [sp, #0x1c]
 80581fa: 990a         	ldr	r1, [sp, #0x28]
 80581fc: eb00 0181    	add.w	r1, r0, r1, lsl #2
 8058200: f8d1 00d0    	ldr.w	r0, [r1, #0xd0]
 8058204: 4310         	orrs	r0, r2
 8058206: f8c1 00d0    	str.w	r0, [r1, #0xd0]
;                     break;
 805820a: e02f         	b	0x805826c <xTaskGenericNotifyFromISR+0x124> @ imm = #0x5e
;                     ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 805820c: 9807         	ldr	r0, [sp, #0x1c]
 805820e: 990a         	ldr	r1, [sp, #0x28]
 8058210: eb00 0181    	add.w	r1, r0, r1, lsl #2
 8058214: f8d1 00d0    	ldr.w	r0, [r1, #0xd0]
 8058218: 3001         	adds	r0, #0x1
 805821a: f8c1 00d0    	str.w	r0, [r1, #0xd0]
;                     break;
 805821e: e025         	b	0x805826c <xTaskGenericNotifyFromISR+0x124> @ imm = #0x4a
;                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 8058220: 9809         	ldr	r0, [sp, #0x24]
 8058222: 9907         	ldr	r1, [sp, #0x1c]
 8058224: 9a0a         	ldr	r2, [sp, #0x28]
 8058226: eb01 0182    	add.w	r1, r1, r2, lsl #2
 805822a: f8c1 00d0    	str.w	r0, [r1, #0xd0]
;                     break;
 805822e: e01d         	b	0x805826c <xTaskGenericNotifyFromISR+0x124> @ imm = #0x3a
;                     if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 8058230: f817 0c15    	ldrb	r0, [r7, #-21]
 8058234: 2802         	cmp	r0, #0x2
 8058236: d008         	beq	0x805824a <xTaskGenericNotifyFromISR+0x102> @ imm = #0x10
 8058238: e7ff         	b	0x805823a <xTaskGenericNotifyFromISR+0xf2> @ imm = #-0x2
;                         pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 805823a: 9809         	ldr	r0, [sp, #0x24]
 805823c: 9907         	ldr	r1, [sp, #0x1c]
 805823e: 9a0a         	ldr	r2, [sp, #0x28]
 8058240: eb01 0182    	add.w	r1, r1, r2, lsl #2
 8058244: f8c1 00d0    	str.w	r0, [r1, #0xd0]
;                     }
 8058248: e002         	b	0x8058250 <xTaskGenericNotifyFromISR+0x108> @ imm = #0x4
 805824a: 2000         	movs	r0, #0x0
;                         xReturn = pdFAIL;
 805824c: 9005         	str	r0, [sp, #0x14]
 805824e: e7ff         	b	0x8058250 <xTaskGenericNotifyFromISR+0x108> @ imm = #-0x2
;                     break;
 8058250: e00c         	b	0x805826c <xTaskGenericNotifyFromISR+0x124> @ imm = #0x18
;                     break;
 8058252: e00b         	b	0x805826c <xTaskGenericNotifyFromISR+0x124> @ imm = #0x16
;                     configASSERT( xTickCount == ( TickType_t ) 0 );
 8058254: f240 102c    	movw	r0, #0x12c
 8058258: f2c2 0000    	movt	r0, #0x2000
 805825c: 6800         	ldr	r0, [r0]
 805825e: b120         	cbz	r0, 0x805826a <xTaskGenericNotifyFromISR+0x122> @ imm = #0x8
 8058260: e7ff         	b	0x8058262 <xTaskGenericNotifyFromISR+0x11a> @ imm = #-0x2
 8058262: 4870         	ldr	r0, [pc, #0x1c0]        @ 0x8058424 <xTaskGenericNotifyFromISR+0x2dc>
 8058264: 4780         	blx	r0
 8058266: e7ff         	b	0x8058268 <xTaskGenericNotifyFromISR+0x120> @ imm = #-0x2
 8058268: e7fe         	b	0x8058268 <xTaskGenericNotifyFromISR+0x120> @ imm = #-0x4
;                     break;
 805826a: e7ff         	b	0x805826c <xTaskGenericNotifyFromISR+0x124> @ imm = #-0x2
;             if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 805826c: f817 0c15    	ldrb	r0, [r7, #-21]
 8058270: 2801         	cmp	r0, #0x1
 8058272: f040 80c4    	bne.w	0x80583fe <xTaskGenericNotifyFromISR+0x2b6> @ imm = #0x188
 8058276: e7ff         	b	0x8058278 <xTaskGenericNotifyFromISR+0x130> @ imm = #-0x2
;                 configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 8058278: 9807         	ldr	r0, [sp, #0x1c]
 805827a: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
 805827e: b120         	cbz	r0, 0x805828a <xTaskGenericNotifyFromISR+0x142> @ imm = #0x8
 8058280: e7ff         	b	0x8058282 <xTaskGenericNotifyFromISR+0x13a> @ imm = #-0x2
 8058282: 4867         	ldr	r0, [pc, #0x19c]        @ 0x8058420 <xTaskGenericNotifyFromISR+0x2d8>
 8058284: 4780         	blx	r0
 8058286: e7ff         	b	0x8058288 <xTaskGenericNotifyFromISR+0x140> @ imm = #-0x2
 8058288: e7fe         	b	0x8058288 <xTaskGenericNotifyFromISR+0x140> @ imm = #-0x4
;                 if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 805828a: f240 1028    	movw	r0, #0x128
 805828e: f2c2 0000    	movt	r0, #0x2000
 8058292: 6800         	ldr	r0, [r0]
 8058294: 2800         	cmp	r0, #0x0
 8058296: d174         	bne	0x8058382 <xTaskGenericNotifyFromISR+0x23a> @ imm = #0xe8
 8058298: e7ff         	b	0x805829a <xTaskGenericNotifyFromISR+0x152> @ imm = #-0x2
;                     listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 805829a: e7ff         	b	0x805829c <xTaskGenericNotifyFromISR+0x154> @ imm = #-0x2
 805829c: 9807         	ldr	r0, [sp, #0x1c]
 805829e: f8d0 0090    	ldr.w	r0, [r0, #0x90]
 80582a2: 9003         	str	r0, [sp, #0xc]
 80582a4: 9807         	ldr	r0, [sp, #0x1c]
 80582a6: f8d0 1084    	ldr.w	r1, [r0, #0x84]
 80582aa: f8d0 0088    	ldr.w	r0, [r0, #0x88]
 80582ae: 6088         	str	r0, [r1, #0x8]
 80582b0: 9907         	ldr	r1, [sp, #0x1c]
 80582b2: f8d1 0084    	ldr.w	r0, [r1, #0x84]
 80582b6: f8d1 1088    	ldr.w	r1, [r1, #0x88]
 80582ba: 6048         	str	r0, [r1, #0x4]
 80582bc: 9803         	ldr	r0, [sp, #0xc]
 80582be: 6840         	ldr	r0, [r0, #0x4]
 80582c0: 9907         	ldr	r1, [sp, #0x1c]
 80582c2: 3180         	adds	r1, #0x80
 80582c4: 4288         	cmp	r0, r1
 80582c6: d106         	bne	0x80582d6 <xTaskGenericNotifyFromISR+0x18e> @ imm = #0xc
 80582c8: e7ff         	b	0x80582ca <xTaskGenericNotifyFromISR+0x182> @ imm = #-0x2
 80582ca: 9807         	ldr	r0, [sp, #0x1c]
 80582cc: f8d0 0088    	ldr.w	r0, [r0, #0x88]
 80582d0: 9903         	ldr	r1, [sp, #0xc]
 80582d2: 6048         	str	r0, [r1, #0x4]
 80582d4: e7ff         	b	0x80582d6 <xTaskGenericNotifyFromISR+0x18e> @ imm = #-0x2
 80582d6: 9907         	ldr	r1, [sp, #0x1c]
 80582d8: 2000         	movs	r0, #0x0
 80582da: f8c1 0090    	str.w	r0, [r1, #0x90]
 80582de: 9903         	ldr	r1, [sp, #0xc]
 80582e0: 6808         	ldr	r0, [r1]
 80582e2: 3801         	subs	r0, #0x1
 80582e4: 6008         	str	r0, [r1]
 80582e6: e7ff         	b	0x80582e8 <xTaskGenericNotifyFromISR+0x1a0> @ imm = #-0x2
;                     prvAddTaskToReadyList( pxTCB );
 80582e8: e7ff         	b	0x80582ea <xTaskGenericNotifyFromISR+0x1a2> @ imm = #-0x2
 80582ea: e7ff         	b	0x80582ec <xTaskGenericNotifyFromISR+0x1a4> @ imm = #-0x2
 80582ec: 9807         	ldr	r0, [sp, #0x1c]
 80582ee: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80582f2: f240 21a0    	movw	r1, #0x2a0
 80582f6: f2c2 0100    	movt	r1, #0x2000
 80582fa: 6809         	ldr	r1, [r1]
 80582fc: 4288         	cmp	r0, r1
 80582fe: d909         	bls	0x8058314 <xTaskGenericNotifyFromISR+0x1cc> @ imm = #0x12
 8058300: e7ff         	b	0x8058302 <xTaskGenericNotifyFromISR+0x1ba> @ imm = #-0x2
 8058302: 9807         	ldr	r0, [sp, #0x1c]
 8058304: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8058308: f240 21a0    	movw	r1, #0x2a0
 805830c: f2c2 0100    	movt	r1, #0x2000
 8058310: 6008         	str	r0, [r1]
 8058312: e7ff         	b	0x8058314 <xTaskGenericNotifyFromISR+0x1cc> @ imm = #-0x2
 8058314: e7ff         	b	0x8058316 <xTaskGenericNotifyFromISR+0x1ce> @ imm = #-0x2
 8058316: e7ff         	b	0x8058318 <xTaskGenericNotifyFromISR+0x1d0> @ imm = #-0x2
 8058318: 9807         	ldr	r0, [sp, #0x1c]
 805831a: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805831e: eb00 0080    	add.w	r0, r0, r0, lsl #2
 8058322: f240 1160    	movw	r1, #0x160
 8058326: f2c2 0100    	movt	r1, #0x2000
 805832a: eb01 0080    	add.w	r0, r1, r0, lsl #2
 805832e: 6840         	ldr	r0, [r0, #0x4]
 8058330: 9002         	str	r0, [sp, #0x8]
 8058332: 9802         	ldr	r0, [sp, #0x8]
 8058334: 9a07         	ldr	r2, [sp, #0x1c]
 8058336: f8c2 0084    	str.w	r0, [r2, #0x84]
 805833a: 9802         	ldr	r0, [sp, #0x8]
 805833c: 6880         	ldr	r0, [r0, #0x8]
 805833e: 9a07         	ldr	r2, [sp, #0x1c]
 8058340: f8c2 0088    	str.w	r0, [r2, #0x88]
 8058344: 9807         	ldr	r0, [sp, #0x1c]
 8058346: 3080         	adds	r0, #0x80
 8058348: 9a02         	ldr	r2, [sp, #0x8]
 805834a: 6892         	ldr	r2, [r2, #0x8]
 805834c: 6050         	str	r0, [r2, #0x4]
 805834e: 9807         	ldr	r0, [sp, #0x1c]
 8058350: 3080         	adds	r0, #0x80
 8058352: 9a02         	ldr	r2, [sp, #0x8]
 8058354: 6090         	str	r0, [r2, #0x8]
 8058356: 9a07         	ldr	r2, [sp, #0x1c]
 8058358: f8d2 00a8    	ldr.w	r0, [r2, #0xa8]
 805835c: eb00 0080    	add.w	r0, r0, r0, lsl #2
 8058360: eb01 0080    	add.w	r0, r1, r0, lsl #2
 8058364: f8c2 0090    	str.w	r0, [r2, #0x90]
 8058368: 9807         	ldr	r0, [sp, #0x1c]
 805836a: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805836e: eb00 0280    	add.w	r2, r0, r0, lsl #2
 8058372: f851 0022    	ldr.w	r0, [r1, r2, lsl #2]
 8058376: 3001         	adds	r0, #0x1
 8058378: f841 0022    	str.w	r0, [r1, r2, lsl #2]
 805837c: e7ff         	b	0x805837e <xTaskGenericNotifyFromISR+0x236> @ imm = #-0x2
 805837e: e7ff         	b	0x8058380 <xTaskGenericNotifyFromISR+0x238> @ imm = #-0x2
;                 }
 8058380: e020         	b	0x80583c4 <xTaskGenericNotifyFromISR+0x27c> @ imm = #0x40
;                     listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8058382: e7ff         	b	0x8058384 <xTaskGenericNotifyFromISR+0x23c> @ imm = #-0x2
 8058384: f240 1138    	movw	r1, #0x138
 8058388: f2c2 0100    	movt	r1, #0x2000
 805838c: 6848         	ldr	r0, [r1, #0x4]
 805838e: 9001         	str	r0, [sp, #0x4]
 8058390: 9801         	ldr	r0, [sp, #0x4]
 8058392: 9a07         	ldr	r2, [sp, #0x1c]
 8058394: f8c2 0098    	str.w	r0, [r2, #0x98]
 8058398: 9801         	ldr	r0, [sp, #0x4]
 805839a: 6880         	ldr	r0, [r0, #0x8]
 805839c: 9a07         	ldr	r2, [sp, #0x1c]
 805839e: f8c2 009c    	str.w	r0, [r2, #0x9c]
 80583a2: 9807         	ldr	r0, [sp, #0x1c]
 80583a4: 3094         	adds	r0, #0x94
 80583a6: 9a01         	ldr	r2, [sp, #0x4]
 80583a8: 6892         	ldr	r2, [r2, #0x8]
 80583aa: 6050         	str	r0, [r2, #0x4]
 80583ac: 9807         	ldr	r0, [sp, #0x1c]
 80583ae: 3094         	adds	r0, #0x94
 80583b0: 9a01         	ldr	r2, [sp, #0x4]
 80583b2: 6090         	str	r0, [r2, #0x8]
 80583b4: 9807         	ldr	r0, [sp, #0x1c]
 80583b6: f8c0 10a4    	str.w	r1, [r0, #0xa4]
 80583ba: 6808         	ldr	r0, [r1]
 80583bc: 3001         	adds	r0, #0x1
 80583be: 6008         	str	r0, [r1]
 80583c0: e7ff         	b	0x80583c2 <xTaskGenericNotifyFromISR+0x27a> @ imm = #-0x2
 80583c2: e7ff         	b	0x80583c4 <xTaskGenericNotifyFromISR+0x27c> @ imm = #-0x2
;                     if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 80583c4: 9807         	ldr	r0, [sp, #0x1c]
 80583c6: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80583ca: f240 1100    	movw	r1, #0x100
 80583ce: f2c2 0100    	movt	r1, #0x2000
 80583d2: 6809         	ldr	r1, [r1]
 80583d4: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 80583d8: 4288         	cmp	r0, r1
 80583da: d90e         	bls	0x80583fa <xTaskGenericNotifyFromISR+0x2b2> @ imm = #0x1c
 80583dc: e7ff         	b	0x80583de <xTaskGenericNotifyFromISR+0x296> @ imm = #-0x2
;                         if( pxHigherPriorityTaskWoken != NULL )
 80583de: 68f8         	ldr	r0, [r7, #0xc]
 80583e0: b120         	cbz	r0, 0x80583ec <xTaskGenericNotifyFromISR+0x2a4> @ imm = #0x8
 80583e2: e7ff         	b	0x80583e4 <xTaskGenericNotifyFromISR+0x29c> @ imm = #-0x2
;                             *pxHigherPriorityTaskWoken = pdTRUE;
 80583e4: 68f9         	ldr	r1, [r7, #0xc]
 80583e6: 2001         	movs	r0, #0x1
 80583e8: 6008         	str	r0, [r1]
;                         }
 80583ea: e7ff         	b	0x80583ec <xTaskGenericNotifyFromISR+0x2a4> @ imm = #-0x2
;                         xYieldPendings[ 0 ] = pdTRUE;
 80583ec: f240 21a4    	movw	r1, #0x2a4
 80583f0: f2c2 0100    	movt	r1, #0x2000
 80583f4: 2001         	movs	r0, #0x1
 80583f6: 6008         	str	r0, [r1]
;                     }
 80583f8: e000         	b	0x80583fc <xTaskGenericNotifyFromISR+0x2b4> @ imm = #0x0
 80583fa: e7ff         	b	0x80583fc <xTaskGenericNotifyFromISR+0x2b4> @ imm = #-0x2
;             }
 80583fc: e7ff         	b	0x80583fe <xTaskGenericNotifyFromISR+0x2b6> @ imm = #-0x2
;         taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
 80583fe: 9804         	ldr	r0, [sp, #0x10]
 8058400: 4906         	ldr	r1, [pc, #0x18]         @ 0x805841c <xTaskGenericNotifyFromISR+0x2d4>
 8058402: 4788         	blx	r1
;         return xReturn;
 8058404: 9805         	ldr	r0, [sp, #0x14]
 8058406: b00c         	add	sp, #0x30
 8058408: bc80         	pop	{r7}
 805840a: eba8 0809    	sub.w	r8, r8, r9
 805840e: f858 fd2c    	ldr	pc, [r8, #-44]!
 8058412: bf00         	nop

08058414 <$d.95>:
 8058414: 1d f8 05 08  	.word	0x0805f81d
 8058418: 15 d7 05 08  	.word	0x0805d715
 805841c: 2b d7 05 08  	.word	0x0805d72b
 8058420: 15 d7 05 08  	.word	0x0805d715
 8058424: 15 d7 05 08  	.word	0x0805d715
 8058428: 15 d7 05 08  	.word	0x0805d715
 805842c: 15 d7 05 08  	.word	0x0805d715

08058430 <vTaskGenericNotifyGiveFromISR>:
;     {
 8058430: f848 eb08    	str	lr, [r8], #8
 8058434: eb08 0809    	add.w	r8, r8, r9
 8058438: b480         	push	{r7}
 805843a: 466f         	mov	r7, sp
 805843c: b08a         	sub	sp, #0x28
 805843e: 9009         	str	r0, [sp, #0x24]
 8058440: 9108         	str	r1, [sp, #0x20]
 8058442: 9207         	str	r2, [sp, #0x1c]
;         configASSERT( xTaskToNotify );
 8058444: 9809         	ldr	r0, [sp, #0x24]
 8058446: b920         	cbnz	r0, 0x8058452 <vTaskGenericNotifyGiveFromISR+0x22> @ imm = #0x8
 8058448: e7ff         	b	0x805844a <vTaskGenericNotifyGiveFromISR+0x1a> @ imm = #-0x2
 805844a: 4882         	ldr	r0, [pc, #0x208]        @ 0x8058654 <vTaskGenericNotifyGiveFromISR+0x224>
 805844c: 4780         	blx	r0
 805844e: e7ff         	b	0x8058450 <vTaskGenericNotifyGiveFromISR+0x20> @ imm = #-0x2
 8058450: e7fe         	b	0x8058450 <vTaskGenericNotifyGiveFromISR+0x20> @ imm = #-0x4
;         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 8058452: 9808         	ldr	r0, [sp, #0x20]
 8058454: b120         	cbz	r0, 0x8058460 <vTaskGenericNotifyGiveFromISR+0x30> @ imm = #0x8
 8058456: e7ff         	b	0x8058458 <vTaskGenericNotifyGiveFromISR+0x28> @ imm = #-0x2
 8058458: 487d         	ldr	r0, [pc, #0x1f4]        @ 0x8058650 <vTaskGenericNotifyGiveFromISR+0x220>
 805845a: 4780         	blx	r0
 805845c: e7ff         	b	0x805845e <vTaskGenericNotifyGiveFromISR+0x2e> @ imm = #-0x2
 805845e: e7fe         	b	0x805845e <vTaskGenericNotifyGiveFromISR+0x2e> @ imm = #-0x4
;         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8058460: 4877         	ldr	r0, [pc, #0x1dc]        @ 0x8058640 <vTaskGenericNotifyGiveFromISR+0x210>
 8058462: 4780         	blx	r0
;         pxTCB = xTaskToNotify;
 8058464: 9809         	ldr	r0, [sp, #0x24]
 8058466: 9006         	str	r0, [sp, #0x18]
;         uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
 8058468: 4876         	ldr	r0, [pc, #0x1d8]        @ 0x8058644 <vTaskGenericNotifyGiveFromISR+0x214>
 805846a: 4780         	blx	r0
 805846c: 9004         	str	r0, [sp, #0x10]
;             ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 805846e: 9806         	ldr	r0, [sp, #0x18]
 8058470: 9908         	ldr	r1, [sp, #0x20]
 8058472: 4408         	add	r0, r1
 8058474: f890 00d4    	ldrb.w	r0, [r0, #0xd4]
 8058478: f807 0c11    	strb	r0, [r7, #-17]
;             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 805847c: 9806         	ldr	r0, [sp, #0x18]
 805847e: 9908         	ldr	r1, [sp, #0x20]
 8058480: 4401         	add	r1, r0
 8058482: 2002         	movs	r0, #0x2
 8058484: f881 00d4    	strb.w	r0, [r1, #0xd4]
;             ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 8058488: 9806         	ldr	r0, [sp, #0x18]
 805848a: 9908         	ldr	r1, [sp, #0x20]
 805848c: eb00 0181    	add.w	r1, r0, r1, lsl #2
 8058490: f8d1 00d0    	ldr.w	r0, [r1, #0xd0]
 8058494: 3001         	adds	r0, #0x1
 8058496: f8c1 00d0    	str.w	r0, [r1, #0xd0]
;             if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 805849a: f817 0c11    	ldrb	r0, [r7, #-17]
 805849e: 2801         	cmp	r0, #0x1
 80584a0: f040 80c4    	bne.w	0x805862c <vTaskGenericNotifyGiveFromISR+0x1fc> @ imm = #0x188
 80584a4: e7ff         	b	0x80584a6 <vTaskGenericNotifyGiveFromISR+0x76> @ imm = #-0x2
;                 configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 80584a6: 9806         	ldr	r0, [sp, #0x18]
 80584a8: f8d0 00a4    	ldr.w	r0, [r0, #0xa4]
 80584ac: b120         	cbz	r0, 0x80584b8 <vTaskGenericNotifyGiveFromISR+0x88> @ imm = #0x8
 80584ae: e7ff         	b	0x80584b0 <vTaskGenericNotifyGiveFromISR+0x80> @ imm = #-0x2
 80584b0: 4866         	ldr	r0, [pc, #0x198]        @ 0x805864c <vTaskGenericNotifyGiveFromISR+0x21c>
 80584b2: 4780         	blx	r0
 80584b4: e7ff         	b	0x80584b6 <vTaskGenericNotifyGiveFromISR+0x86> @ imm = #-0x2
 80584b6: e7fe         	b	0x80584b6 <vTaskGenericNotifyGiveFromISR+0x86> @ imm = #-0x4
;                 if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 80584b8: f240 1028    	movw	r0, #0x128
 80584bc: f2c2 0000    	movt	r0, #0x2000
 80584c0: 6800         	ldr	r0, [r0]
 80584c2: 2800         	cmp	r0, #0x0
 80584c4: d174         	bne	0x80585b0 <vTaskGenericNotifyGiveFromISR+0x180> @ imm = #0xe8
 80584c6: e7ff         	b	0x80584c8 <vTaskGenericNotifyGiveFromISR+0x98> @ imm = #-0x2
;                     listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 80584c8: e7ff         	b	0x80584ca <vTaskGenericNotifyGiveFromISR+0x9a> @ imm = #-0x2
 80584ca: 9806         	ldr	r0, [sp, #0x18]
 80584cc: f8d0 0090    	ldr.w	r0, [r0, #0x90]
 80584d0: 9003         	str	r0, [sp, #0xc]
 80584d2: 9806         	ldr	r0, [sp, #0x18]
 80584d4: f8d0 1084    	ldr.w	r1, [r0, #0x84]
 80584d8: f8d0 0088    	ldr.w	r0, [r0, #0x88]
 80584dc: 6088         	str	r0, [r1, #0x8]
 80584de: 9906         	ldr	r1, [sp, #0x18]
 80584e0: f8d1 0084    	ldr.w	r0, [r1, #0x84]
 80584e4: f8d1 1088    	ldr.w	r1, [r1, #0x88]
 80584e8: 6048         	str	r0, [r1, #0x4]
 80584ea: 9803         	ldr	r0, [sp, #0xc]
 80584ec: 6840         	ldr	r0, [r0, #0x4]
 80584ee: 9906         	ldr	r1, [sp, #0x18]
 80584f0: 3180         	adds	r1, #0x80
 80584f2: 4288         	cmp	r0, r1
 80584f4: d106         	bne	0x8058504 <vTaskGenericNotifyGiveFromISR+0xd4> @ imm = #0xc
 80584f6: e7ff         	b	0x80584f8 <vTaskGenericNotifyGiveFromISR+0xc8> @ imm = #-0x2
 80584f8: 9806         	ldr	r0, [sp, #0x18]
 80584fa: f8d0 0088    	ldr.w	r0, [r0, #0x88]
 80584fe: 9903         	ldr	r1, [sp, #0xc]
 8058500: 6048         	str	r0, [r1, #0x4]
 8058502: e7ff         	b	0x8058504 <vTaskGenericNotifyGiveFromISR+0xd4> @ imm = #-0x2
 8058504: 9906         	ldr	r1, [sp, #0x18]
 8058506: 2000         	movs	r0, #0x0
 8058508: f8c1 0090    	str.w	r0, [r1, #0x90]
 805850c: 9903         	ldr	r1, [sp, #0xc]
 805850e: 6808         	ldr	r0, [r1]
 8058510: 3801         	subs	r0, #0x1
 8058512: 6008         	str	r0, [r1]
 8058514: e7ff         	b	0x8058516 <vTaskGenericNotifyGiveFromISR+0xe6> @ imm = #-0x2
;                     prvAddTaskToReadyList( pxTCB );
 8058516: e7ff         	b	0x8058518 <vTaskGenericNotifyGiveFromISR+0xe8> @ imm = #-0x2
 8058518: e7ff         	b	0x805851a <vTaskGenericNotifyGiveFromISR+0xea> @ imm = #-0x2
 805851a: 9806         	ldr	r0, [sp, #0x18]
 805851c: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8058520: f240 21a0    	movw	r1, #0x2a0
 8058524: f2c2 0100    	movt	r1, #0x2000
 8058528: 6809         	ldr	r1, [r1]
 805852a: 4288         	cmp	r0, r1
 805852c: d909         	bls	0x8058542 <vTaskGenericNotifyGiveFromISR+0x112> @ imm = #0x12
 805852e: e7ff         	b	0x8058530 <vTaskGenericNotifyGiveFromISR+0x100> @ imm = #-0x2
 8058530: 9806         	ldr	r0, [sp, #0x18]
 8058532: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 8058536: f240 21a0    	movw	r1, #0x2a0
 805853a: f2c2 0100    	movt	r1, #0x2000
 805853e: 6008         	str	r0, [r1]
 8058540: e7ff         	b	0x8058542 <vTaskGenericNotifyGiveFromISR+0x112> @ imm = #-0x2
 8058542: e7ff         	b	0x8058544 <vTaskGenericNotifyGiveFromISR+0x114> @ imm = #-0x2
 8058544: e7ff         	b	0x8058546 <vTaskGenericNotifyGiveFromISR+0x116> @ imm = #-0x2
 8058546: 9806         	ldr	r0, [sp, #0x18]
 8058548: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805854c: eb00 0080    	add.w	r0, r0, r0, lsl #2
 8058550: f240 1160    	movw	r1, #0x160
 8058554: f2c2 0100    	movt	r1, #0x2000
 8058558: eb01 0080    	add.w	r0, r1, r0, lsl #2
 805855c: 6840         	ldr	r0, [r0, #0x4]
 805855e: 9002         	str	r0, [sp, #0x8]
 8058560: 9802         	ldr	r0, [sp, #0x8]
 8058562: 9a06         	ldr	r2, [sp, #0x18]
 8058564: f8c2 0084    	str.w	r0, [r2, #0x84]
 8058568: 9802         	ldr	r0, [sp, #0x8]
 805856a: 6880         	ldr	r0, [r0, #0x8]
 805856c: 9a06         	ldr	r2, [sp, #0x18]
 805856e: f8c2 0088    	str.w	r0, [r2, #0x88]
 8058572: 9806         	ldr	r0, [sp, #0x18]
 8058574: 3080         	adds	r0, #0x80
 8058576: 9a02         	ldr	r2, [sp, #0x8]
 8058578: 6892         	ldr	r2, [r2, #0x8]
 805857a: 6050         	str	r0, [r2, #0x4]
 805857c: 9806         	ldr	r0, [sp, #0x18]
 805857e: 3080         	adds	r0, #0x80
 8058580: 9a02         	ldr	r2, [sp, #0x8]
 8058582: 6090         	str	r0, [r2, #0x8]
 8058584: 9a06         	ldr	r2, [sp, #0x18]
 8058586: f8d2 00a8    	ldr.w	r0, [r2, #0xa8]
 805858a: eb00 0080    	add.w	r0, r0, r0, lsl #2
 805858e: eb01 0080    	add.w	r0, r1, r0, lsl #2
 8058592: f8c2 0090    	str.w	r0, [r2, #0x90]
 8058596: 9806         	ldr	r0, [sp, #0x18]
 8058598: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 805859c: eb00 0280    	add.w	r2, r0, r0, lsl #2
 80585a0: f851 0022    	ldr.w	r0, [r1, r2, lsl #2]
 80585a4: 3001         	adds	r0, #0x1
 80585a6: f841 0022    	str.w	r0, [r1, r2, lsl #2]
 80585aa: e7ff         	b	0x80585ac <vTaskGenericNotifyGiveFromISR+0x17c> @ imm = #-0x2
 80585ac: e7ff         	b	0x80585ae <vTaskGenericNotifyGiveFromISR+0x17e> @ imm = #-0x2
;                 }
 80585ae: e020         	b	0x80585f2 <vTaskGenericNotifyGiveFromISR+0x1c2> @ imm = #0x40
;                     listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 80585b0: e7ff         	b	0x80585b2 <vTaskGenericNotifyGiveFromISR+0x182> @ imm = #-0x2
 80585b2: f240 1138    	movw	r1, #0x138
 80585b6: f2c2 0100    	movt	r1, #0x2000
 80585ba: 6848         	ldr	r0, [r1, #0x4]
 80585bc: 9001         	str	r0, [sp, #0x4]
 80585be: 9801         	ldr	r0, [sp, #0x4]
 80585c0: 9a06         	ldr	r2, [sp, #0x18]
 80585c2: f8c2 0098    	str.w	r0, [r2, #0x98]
 80585c6: 9801         	ldr	r0, [sp, #0x4]
 80585c8: 6880         	ldr	r0, [r0, #0x8]
 80585ca: 9a06         	ldr	r2, [sp, #0x18]
 80585cc: f8c2 009c    	str.w	r0, [r2, #0x9c]
 80585d0: 9806         	ldr	r0, [sp, #0x18]
 80585d2: 3094         	adds	r0, #0x94
 80585d4: 9a01         	ldr	r2, [sp, #0x4]
 80585d6: 6892         	ldr	r2, [r2, #0x8]
 80585d8: 6050         	str	r0, [r2, #0x4]
 80585da: 9806         	ldr	r0, [sp, #0x18]
 80585dc: 3094         	adds	r0, #0x94
 80585de: 9a01         	ldr	r2, [sp, #0x4]
 80585e0: 6090         	str	r0, [r2, #0x8]
 80585e2: 9806         	ldr	r0, [sp, #0x18]
 80585e4: f8c0 10a4    	str.w	r1, [r0, #0xa4]
 80585e8: 6808         	ldr	r0, [r1]
 80585ea: 3001         	adds	r0, #0x1
 80585ec: 6008         	str	r0, [r1]
 80585ee: e7ff         	b	0x80585f0 <vTaskGenericNotifyGiveFromISR+0x1c0> @ imm = #-0x2
 80585f0: e7ff         	b	0x80585f2 <vTaskGenericNotifyGiveFromISR+0x1c2> @ imm = #-0x2
;                     if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 80585f2: 9806         	ldr	r0, [sp, #0x18]
 80585f4: f8d0 00a8    	ldr.w	r0, [r0, #0xa8]
 80585f8: f240 1100    	movw	r1, #0x100
 80585fc: f2c2 0100    	movt	r1, #0x2000
 8058600: 6809         	ldr	r1, [r1]
 8058602: f8d1 10a8    	ldr.w	r1, [r1, #0xa8]
 8058606: 4288         	cmp	r0, r1
 8058608: d90e         	bls	0x8058628 <vTaskGenericNotifyGiveFromISR+0x1f8> @ imm = #0x1c
 805860a: e7ff         	b	0x805860c <vTaskGenericNotifyGiveFromISR+0x1dc> @ imm = #-0x2
;                         if( pxHigherPriorityTaskWoken != NULL )
 805860c: 9807         	ldr	r0, [sp, #0x1c]
 805860e: b120         	cbz	r0, 0x805861a <vTaskGenericNotifyGiveFromISR+0x1ea> @ imm = #0x8
 8058610: e7ff         	b	0x8058612 <vTaskGenericNotifyGiveFromISR+0x1e2> @ imm = #-0x2
;                             *pxHigherPriorityTaskWoken = pdTRUE;
 8058612: 9907         	ldr	r1, [sp, #0x1c]
 8058614: 2001         	movs	r0, #0x1
 8058616: 6008         	str	r0, [r1]
;                         }
 8058618: e7ff         	b	0x805861a <vTaskGenericNotifyGiveFromISR+0x1ea> @ imm = #-0x2
;                         xYieldPendings[ 0 ] = pdTRUE;
 805861a: f240 21a4    	movw	r1, #0x2a4
 805861e: f2c2 0100    	movt	r1, #0x2000
 8058622: 2001         	movs	r0, #0x1
 8058624: 6008         	str	r0, [r1]
;                     }
 8058626: e000         	b	0x805862a <vTaskGenericNotifyGiveFromISR+0x1fa> @ imm = #0x0
 8058628: e7ff         	b	0x805862a <vTaskGenericNotifyGiveFromISR+0x1fa> @ imm = #-0x2
;             }
 805862a: e7ff         	b	0x805862c <vTaskGenericNotifyGiveFromISR+0x1fc> @ imm = #-0x2
;         taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
 805862c: 9804         	ldr	r0, [sp, #0x10]
 805862e: 4906         	ldr	r1, [pc, #0x18]         @ 0x8058648 <vTaskGenericNotifyGiveFromISR+0x218>
 8058630: 4788         	blx	r1
;     }
 8058632: b00a         	add	sp, #0x28
 8058634: bc80         	pop	{r7}
 8058636: eba8 0809    	sub.w	r8, r8, r9
 805863a: f858 fd08    	ldr	pc, [r8, #-8]!
 805863e: bf00         	nop

08058640 <$d.97>:
 8058640: 1d f8 05 08  	.word	0x0805f81d
 8058644: 15 d7 05 08  	.word	0x0805d715
 8058648: 2b d7 05 08  	.word	0x0805d72b
 805864c: 15 d7 05 08  	.word	0x0805d715
 8058650: 15 d7 05 08  	.word	0x0805d715
 8058654: 15 d7 05 08  	.word	0x0805d715

08058658 <xTaskGenericNotifyStateClear>:
;     {
 8058658: f848 eb70    	str	lr, [r8], #112
 805865c: eb08 0809    	add.w	r8, r8, r9
 8058660: b480         	push	{r7}
 8058662: 466f         	mov	r7, sp
 8058664: b086         	sub	sp, #0x18
 8058666: 9005         	str	r0, [sp, #0x14]
 8058668: 9104         	str	r1, [sp, #0x10]
;         configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 805866a: 9804         	ldr	r0, [sp, #0x10]
 805866c: b120         	cbz	r0, 0x8058678 <xTaskGenericNotifyStateClear+0x20> @ imm = #0x8
 805866e: e7ff         	b	0x8058670 <xTaskGenericNotifyStateClear+0x18> @ imm = #-0x2
 8058670: 481a         	ldr	r0, [pc, #0x68]         @ 0x80586dc <xTaskGenericNotifyStateClear+0x84>
 8058672: 4780         	blx	r0
 8058674: e7ff         	b	0x8058676 <xTaskGenericNotifyStateClear+0x1e> @ imm = #-0x2
 8058676: e7fe         	b	0x8058676 <xTaskGenericNotifyStateClear+0x1e> @ imm = #-0x4
;         pxTCB = prvGetTCBFromHandle( xTask );
 8058678: 9805         	ldr	r0, [sp, #0x14]
 805867a: b938         	cbnz	r0, 0x805868c <xTaskGenericNotifyStateClear+0x34> @ imm = #0xe
 805867c: e7ff         	b	0x805867e <xTaskGenericNotifyStateClear+0x26> @ imm = #-0x2
 805867e: f240 1000    	movw	r0, #0x100
 8058682: f2c2 0000    	movt	r0, #0x2000
 8058686: 6800         	ldr	r0, [r0]
 8058688: 9001         	str	r0, [sp, #0x4]
 805868a: e002         	b	0x8058692 <xTaskGenericNotifyStateClear+0x3a> @ imm = #0x4
 805868c: 9805         	ldr	r0, [sp, #0x14]
 805868e: 9001         	str	r0, [sp, #0x4]
 8058690: e7ff         	b	0x8058692 <xTaskGenericNotifyStateClear+0x3a> @ imm = #-0x2
 8058692: 9801         	ldr	r0, [sp, #0x4]
 8058694: 9003         	str	r0, [sp, #0xc]
;         taskENTER_CRITICAL();
 8058696: 480f         	ldr	r0, [pc, #0x3c]         @ 0x80586d4 <xTaskGenericNotifyStateClear+0x7c>
 8058698: 4780         	blx	r0
;             if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
 805869a: 9803         	ldr	r0, [sp, #0xc]
 805869c: 9904         	ldr	r1, [sp, #0x10]
 805869e: 4408         	add	r0, r1
 80586a0: f890 00d4    	ldrb.w	r0, [r0, #0xd4]
 80586a4: 2802         	cmp	r0, #0x2
 80586a6: d109         	bne	0x80586bc <xTaskGenericNotifyStateClear+0x64> @ imm = #0x12
 80586a8: e7ff         	b	0x80586aa <xTaskGenericNotifyStateClear+0x52> @ imm = #-0x2
;                 pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
 80586aa: 9803         	ldr	r0, [sp, #0xc]
 80586ac: 9904         	ldr	r1, [sp, #0x10]
 80586ae: 4401         	add	r1, r0
 80586b0: 2000         	movs	r0, #0x0
 80586b2: f881 00d4    	strb.w	r0, [r1, #0xd4]
 80586b6: 2001         	movs	r0, #0x1
;                 xReturn = pdPASS;
 80586b8: 9002         	str	r0, [sp, #0x8]
;             }
 80586ba: e002         	b	0x80586c2 <xTaskGenericNotifyStateClear+0x6a> @ imm = #0x4
 80586bc: 2000         	movs	r0, #0x0
;                 xReturn = pdFAIL;
 80586be: 9002         	str	r0, [sp, #0x8]
 80586c0: e7ff         	b	0x80586c2 <xTaskGenericNotifyStateClear+0x6a> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 80586c2: 4805         	ldr	r0, [pc, #0x14]         @ 0x80586d8 <xTaskGenericNotifyStateClear+0x80>
 80586c4: 4780         	blx	r0
;         return xReturn;
 80586c6: 9802         	ldr	r0, [sp, #0x8]
 80586c8: b006         	add	sp, #0x18
 80586ca: bc80         	pop	{r7}
 80586cc: eba8 0809    	sub.w	r8, r8, r9
 80586d0: f858 fd70    	ldr	pc, [r8, #-112]!

080586d4 <$d.99>:
 80586d4: 49 cd 05 08  	.word	0x0805cd49
 80586d8: 7d cd 05 08  	.word	0x0805cd7d
 80586dc: 15 d7 05 08  	.word	0x0805d715

080586e0 <ulTaskGenericNotifyValueClear>:
;     {
 80586e0: f848 eb38    	str	lr, [r8], #56
 80586e4: eb08 0809    	add.w	r8, r8, r9
 80586e8: b480         	push	{r7}
 80586ea: 466f         	mov	r7, sp
 80586ec: b086         	sub	sp, #0x18
 80586ee: 9005         	str	r0, [sp, #0x14]
 80586f0: 9104         	str	r1, [sp, #0x10]
 80586f2: 9203         	str	r2, [sp, #0xc]
;         configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 80586f4: 9804         	ldr	r0, [sp, #0x10]
 80586f6: b120         	cbz	r0, 0x8058702 <ulTaskGenericNotifyValueClear+0x22> @ imm = #0x8
 80586f8: e7ff         	b	0x80586fa <ulTaskGenericNotifyValueClear+0x1a> @ imm = #-0x2
 80586fa: 4819         	ldr	r0, [pc, #0x64]         @ 0x8058760 <ulTaskGenericNotifyValueClear+0x80>
 80586fc: 4780         	blx	r0
 80586fe: e7ff         	b	0x8058700 <ulTaskGenericNotifyValueClear+0x20> @ imm = #-0x2
 8058700: e7fe         	b	0x8058700 <ulTaskGenericNotifyValueClear+0x20> @ imm = #-0x4
;         pxTCB = prvGetTCBFromHandle( xTask );
 8058702: 9805         	ldr	r0, [sp, #0x14]
 8058704: b938         	cbnz	r0, 0x8058716 <ulTaskGenericNotifyValueClear+0x36> @ imm = #0xe
 8058706: e7ff         	b	0x8058708 <ulTaskGenericNotifyValueClear+0x28> @ imm = #-0x2
 8058708: f240 1000    	movw	r0, #0x100
 805870c: f2c2 0000    	movt	r0, #0x2000
 8058710: 6800         	ldr	r0, [r0]
 8058712: 9000         	str	r0, [sp]
 8058714: e002         	b	0x805871c <ulTaskGenericNotifyValueClear+0x3c> @ imm = #0x4
 8058716: 9805         	ldr	r0, [sp, #0x14]
 8058718: 9000         	str	r0, [sp]
 805871a: e7ff         	b	0x805871c <ulTaskGenericNotifyValueClear+0x3c> @ imm = #-0x2
 805871c: 9800         	ldr	r0, [sp]
 805871e: 9002         	str	r0, [sp, #0x8]
;         taskENTER_CRITICAL();
 8058720: 480d         	ldr	r0, [pc, #0x34]         @ 0x8058758 <ulTaskGenericNotifyValueClear+0x78>
 8058722: 4780         	blx	r0
;             ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
 8058724: 9802         	ldr	r0, [sp, #0x8]
 8058726: 9904         	ldr	r1, [sp, #0x10]
 8058728: eb00 0081    	add.w	r0, r0, r1, lsl #2
 805872c: f8d0 00d0    	ldr.w	r0, [r0, #0xd0]
 8058730: 9001         	str	r0, [sp, #0x4]
;             pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
 8058732: 9a03         	ldr	r2, [sp, #0xc]
 8058734: 9802         	ldr	r0, [sp, #0x8]
 8058736: 9904         	ldr	r1, [sp, #0x10]
 8058738: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805873c: f8d1 00d0    	ldr.w	r0, [r1, #0xd0]
 8058740: 4390         	bics	r0, r2
 8058742: f8c1 00d0    	str.w	r0, [r1, #0xd0]
;         taskEXIT_CRITICAL();
 8058746: 4805         	ldr	r0, [pc, #0x14]         @ 0x805875c <ulTaskGenericNotifyValueClear+0x7c>
 8058748: 4780         	blx	r0
;         return ulReturn;
 805874a: 9801         	ldr	r0, [sp, #0x4]
 805874c: b006         	add	sp, #0x18
 805874e: bc80         	pop	{r7}
 8058750: eba8 0809    	sub.w	r8, r8, r9
 8058754: f858 fd38    	ldr	pc, [r8, #-56]!

08058758 <$d.101>:
 8058758: 49 cd 05 08  	.word	0x0805cd49
 805875c: 7d cd 05 08  	.word	0x0805cd7d
 8058760: 15 d7 05 08  	.word	0x0805d715

08058764 <xTaskGetMPUSettings>:
;     {
 8058764: b083         	sub	sp, #0xc
 8058766: 9002         	str	r0, [sp, #0x8]
;         pxTCB = prvGetTCBFromHandle( xTask );
 8058768: 9802         	ldr	r0, [sp, #0x8]
 805876a: b938         	cbnz	r0, 0x805877c <xTaskGetMPUSettings+0x18> @ imm = #0xe
 805876c: e7ff         	b	0x805876e <xTaskGetMPUSettings+0xa> @ imm = #-0x2
 805876e: f240 1000    	movw	r0, #0x100
 8058772: f2c2 0000    	movt	r0, #0x2000
 8058776: 6800         	ldr	r0, [r0]
 8058778: 9000         	str	r0, [sp]
 805877a: e002         	b	0x8058782 <xTaskGetMPUSettings+0x1e> @ imm = #0x4
 805877c: 9802         	ldr	r0, [sp, #0x8]
 805877e: 9000         	str	r0, [sp]
 8058780: e7ff         	b	0x8058782 <xTaskGetMPUSettings+0x1e> @ imm = #-0x2
 8058782: 9800         	ldr	r0, [sp]
 8058784: 9001         	str	r0, [sp, #0x4]
;         return &( pxTCB->xMPUSettings );
 8058786: 9801         	ldr	r0, [sp, #0x4]
 8058788: 3004         	adds	r0, #0x4
 805878a: b003         	add	sp, #0xc
 805878c: 4770         	bx	lr
 805878e: bf00         	nop

08058790 <prvInitialiseNewTask>:
; {
 8058790: f848 eb08    	str	lr, [r8], #8
 8058794: eb08 0809    	add.w	r8, r8, r9
 8058798: b4d0         	push	{r4, r6, r7}
 805879a: af02         	add	r7, sp, #0x8
 805879c: b08a         	sub	sp, #0x28
 805879e: f8d7 c014    	ldr.w	r12, [r7, #0x14]
 80587a2: f8d7 c010    	ldr.w	r12, [r7, #0x10]
 80587a6: f8d7 c00c    	ldr.w	r12, [r7, #0xc]
 80587aa: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 80587ae: 9009         	str	r0, [sp, #0x24]
 80587b0: 9108         	str	r1, [sp, #0x20]
 80587b2: 9207         	str	r2, [sp, #0x1c]
 80587b4: 9306         	str	r3, [sp, #0x18]
;         if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 80587b6: 7af8         	ldrb	r0, [r7, #0xb]
 80587b8: 0600         	lsls	r0, r0, #0x18
 80587ba: 2800         	cmp	r0, #0x0
 80587bc: d503         	bpl	0x80587c6 <prvInitialiseNewTask+0x36> @ imm = #0x6
 80587be: e7ff         	b	0x80587c0 <prvInitialiseNewTask+0x30> @ imm = #-0x2
 80587c0: 2001         	movs	r0, #0x1
;             xRunPrivileged = pdTRUE;
 80587c2: 9003         	str	r0, [sp, #0xc]
;         }
 80587c4: e002         	b	0x80587cc <prvInitialiseNewTask+0x3c> @ imm = #0x4
 80587c6: 2000         	movs	r0, #0x0
;             xRunPrivileged = pdFALSE;
 80587c8: 9003         	str	r0, [sp, #0xc]
 80587ca: e7ff         	b	0x80587cc <prvInitialiseNewTask+0x3c> @ imm = #-0x2
;         uxPriority &= ~portPRIVILEGE_BIT;
 80587cc: 68b8         	ldr	r0, [r7, #0x8]
 80587ce: f020 4000    	bic	r0, r0, #0x80000000
 80587d2: 60b8         	str	r0, [r7, #0x8]
;         ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 80587d4: 6938         	ldr	r0, [r7, #0x10]
 80587d6: f8d0 00ac    	ldr.w	r0, [r0, #0xac]
 80587da: 9907         	ldr	r1, [sp, #0x1c]
 80587dc: 008a         	lsls	r2, r1, #0x2
 80587de: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8058904 <prvInitialiseNewTask+0x174>
 80587e0: 21a5         	movs	r1, #0xa5
 80587e2: 4798         	blx	r3
;         pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 80587e4: 6938         	ldr	r0, [r7, #0x10]
 80587e6: f8d0 00ac    	ldr.w	r0, [r0, #0xac]
 80587ea: 9907         	ldr	r1, [sp, #0x1c]
 80587ec: eb00 0081    	add.w	r0, r0, r1, lsl #2
 80587f0: 3804         	subs	r0, #0x4
 80587f2: 9005         	str	r0, [sp, #0x14]
;         pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 80587f4: 9805         	ldr	r0, [sp, #0x14]
 80587f6: f020 0007    	bic	r0, r0, #0x7
 80587fa: 9005         	str	r0, [sp, #0x14]
;         configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 80587fc: f89d 0014    	ldrb.w	r0, [sp, #0x14]
 8058800: 0740         	lsls	r0, r0, #0x1d
 8058802: b120         	cbz	r0, 0x805880e <prvInitialiseNewTask+0x7e> @ imm = #0x8
 8058804: e7ff         	b	0x8058806 <prvInitialiseNewTask+0x76> @ imm = #-0x2
 8058806: 4845         	ldr	r0, [pc, #0x114]        @ 0x805891c <prvInitialiseNewTask+0x18c>
 8058808: 4780         	blx	r0
 805880a: e7ff         	b	0x805880c <prvInitialiseNewTask+0x7c> @ imm = #-0x2
 805880c: e7fe         	b	0x805880c <prvInitialiseNewTask+0x7c> @ imm = #-0x4
;     if( pcName != NULL )
 805880e: 9808         	ldr	r0, [sp, #0x20]
 8058810: b1f8         	cbz	r0, 0x8058852 <prvInitialiseNewTask+0xc2> @ imm = #0x3e
 8058812: e7ff         	b	0x8058814 <prvInitialiseNewTask+0x84> @ imm = #-0x2
 8058814: 2000         	movs	r0, #0x0
;         for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8058816: 9004         	str	r0, [sp, #0x10]
 8058818: e7ff         	b	0x805881a <prvInitialiseNewTask+0x8a> @ imm = #-0x2
 805881a: 9804         	ldr	r0, [sp, #0x10]
 805881c: 280f         	cmp	r0, #0xf
 805881e: d813         	bhi	0x8058848 <prvInitialiseNewTask+0xb8> @ imm = #0x26
 8058820: e7ff         	b	0x8058822 <prvInitialiseNewTask+0x92> @ imm = #-0x2
;             pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8058822: 9808         	ldr	r0, [sp, #0x20]
 8058824: 9a04         	ldr	r2, [sp, #0x10]
 8058826: 5c80         	ldrb	r0, [r0, r2]
 8058828: 6939         	ldr	r1, [r7, #0x10]
 805882a: 4411         	add	r1, r2
 805882c: f881 00b0    	strb.w	r0, [r1, #0xb0]
;             if( pcName[ x ] == ( char ) 0x00 )
 8058830: 9808         	ldr	r0, [sp, #0x20]
 8058832: 9904         	ldr	r1, [sp, #0x10]
 8058834: 5c40         	ldrb	r0, [r0, r1]
 8058836: b908         	cbnz	r0, 0x805883c <prvInitialiseNewTask+0xac> @ imm = #0x2
 8058838: e7ff         	b	0x805883a <prvInitialiseNewTask+0xaa> @ imm = #-0x2
;                 break;
 805883a: e005         	b	0x8058848 <prvInitialiseNewTask+0xb8> @ imm = #0xa
 805883c: e7ff         	b	0x805883e <prvInitialiseNewTask+0xae> @ imm = #-0x2
;         }
 805883e: e7ff         	b	0x8058840 <prvInitialiseNewTask+0xb0> @ imm = #-0x2
;         for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8058840: 9804         	ldr	r0, [sp, #0x10]
 8058842: 3001         	adds	r0, #0x1
 8058844: 9004         	str	r0, [sp, #0x10]
 8058846: e7e8         	b	0x805881a <prvInitialiseNewTask+0x8a> @ imm = #-0x30
;         pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8058848: 6939         	ldr	r1, [r7, #0x10]
 805884a: 2000         	movs	r0, #0x0
 805884c: f881 00bf    	strb.w	r0, [r1, #0xbf]
;     }
 8058850: e000         	b	0x8058854 <prvInitialiseNewTask+0xc4> @ imm = #0x0
 8058852: e7ff         	b	0x8058854 <prvInitialiseNewTask+0xc4> @ imm = #-0x2
;     configASSERT( uxPriority < configMAX_PRIORITIES );
 8058854: 68b8         	ldr	r0, [r7, #0x8]
 8058856: 2810         	cmp	r0, #0x10
 8058858: d304         	blo	0x8058864 <prvInitialiseNewTask+0xd4> @ imm = #0x8
 805885a: e7ff         	b	0x805885c <prvInitialiseNewTask+0xcc> @ imm = #-0x2
 805885c: 482e         	ldr	r0, [pc, #0xb8]         @ 0x8058918 <prvInitialiseNewTask+0x188>
 805885e: 4780         	blx	r0
 8058860: e7ff         	b	0x8058862 <prvInitialiseNewTask+0xd2> @ imm = #-0x2
 8058862: e7fe         	b	0x8058862 <prvInitialiseNewTask+0xd2> @ imm = #-0x4
;     if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 8058864: 68b8         	ldr	r0, [r7, #0x8]
 8058866: 2810         	cmp	r0, #0x10
 8058868: d303         	blo	0x8058872 <prvInitialiseNewTask+0xe2> @ imm = #0x6
 805886a: e7ff         	b	0x805886c <prvInitialiseNewTask+0xdc> @ imm = #-0x2
 805886c: 200f         	movs	r0, #0xf
;         uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 805886e: 60b8         	str	r0, [r7, #0x8]
;     }
 8058870: e000         	b	0x8058874 <prvInitialiseNewTask+0xe4> @ imm = #0x0
 8058872: e7ff         	b	0x8058874 <prvInitialiseNewTask+0xe4> @ imm = #-0x2
;     pxNewTCB->uxPriority = uxPriority;
 8058874: 68b8         	ldr	r0, [r7, #0x8]
 8058876: 6939         	ldr	r1, [r7, #0x10]
 8058878: f8c1 00a8    	str.w	r0, [r1, #0xa8]
;         pxNewTCB->uxBasePriority = uxPriority;
 805887c: 68b8         	ldr	r0, [r7, #0x8]
 805887e: 6939         	ldr	r1, [r7, #0x10]
 8058880: f8c1 00c8    	str.w	r0, [r1, #0xc8]
;     vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8058884: 6938         	ldr	r0, [r7, #0x10]
 8058886: 3080         	adds	r0, #0x80
 8058888: 491f         	ldr	r1, [pc, #0x7c]         @ 0x8058908 <prvInitialiseNewTask+0x178>
 805888a: 4788         	blx	r1
;     vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 805888c: 6938         	ldr	r0, [r7, #0x10]
 805888e: 3094         	adds	r0, #0x94
 8058890: 491e         	ldr	r1, [pc, #0x78]         @ 0x805890c <prvInitialiseNewTask+0x17c>
 8058892: 4788         	blx	r1
;     listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8058894: 6938         	ldr	r0, [r7, #0x10]
 8058896: f8c0 008c    	str.w	r0, [r0, #0x8c]
;     listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 805889a: 68b8         	ldr	r0, [r7, #0x8]
 805889c: f1c0 0010    	rsb.w	r0, r0, #0x10
 80588a0: 6939         	ldr	r1, [r7, #0x10]
 80588a2: f8c1 0094    	str.w	r0, [r1, #0x94]
;     listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 80588a6: 6938         	ldr	r0, [r7, #0x10]
 80588a8: f8c0 00a0    	str.w	r0, [r0, #0xa0]
;         vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
 80588ac: 693a         	ldr	r2, [r7, #0x10]
 80588ae: 1d10         	adds	r0, r2, #0x4
 80588b0: 6979         	ldr	r1, [r7, #0x14]
 80588b2: f8d2 20ac    	ldr.w	r2, [r2, #0xac]
 80588b6: 9b07         	ldr	r3, [sp, #0x1c]
 80588b8: f8df c054    	ldr.w	r12, [pc, #0x54]        @ 0x8058910 <prvInitialiseNewTask+0x180>
 80588bc: 47e0         	blx	r12
;                 pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, pxTaskCode, pvParameters, xRunPrivileged, &( pxNewTCB->xMPUSettings ) );
 80588be: 9805         	ldr	r0, [sp, #0x14]
 80588c0: f8d7 e010    	ldr.w	lr, [r7, #0x10]
 80588c4: f8de 10ac    	ldr.w	r1, [lr, #0xac]
 80588c8: 9a09         	ldr	r2, [sp, #0x24]
 80588ca: 9b06         	ldr	r3, [sp, #0x18]
 80588cc: f8dd c00c    	ldr.w	r12, [sp, #0xc]
 80588d0: f10e 0404    	add.w	r4, lr, #0x4
 80588d4: 46ee         	mov	lr, sp
 80588d6: f8ce 4004    	str.w	r4, [lr, #0x4]
 80588da: f8ce c000    	str.w	r12, [lr]
 80588de: f8df c034    	ldr.w	r12, [pc, #0x34]        @ 0x8058914 <prvInitialiseNewTask+0x184>
 80588e2: 47e0         	blx	r12
 80588e4: 6939         	ldr	r1, [r7, #0x10]
 80588e6: 6008         	str	r0, [r1]
;     if( pxCreatedTask != NULL )
 80588e8: 68f8         	ldr	r0, [r7, #0xc]
 80588ea: b120         	cbz	r0, 0x80588f6 <prvInitialiseNewTask+0x166> @ imm = #0x8
 80588ec: e7ff         	b	0x80588ee <prvInitialiseNewTask+0x15e> @ imm = #-0x2
;         *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 80588ee: 6938         	ldr	r0, [r7, #0x10]
 80588f0: 68f9         	ldr	r1, [r7, #0xc]
 80588f2: 6008         	str	r0, [r1]
;     }
 80588f4: e000         	b	0x80588f8 <prvInitialiseNewTask+0x168> @ imm = #0x0
 80588f6: e7ff         	b	0x80588f8 <prvInitialiseNewTask+0x168> @ imm = #-0x2
; }
 80588f8: b00a         	add	sp, #0x28
 80588fa: bcd0         	pop	{r4, r6, r7}
 80588fc: eba8 0809    	sub.w	r8, r8, r9
 8058900: f858 fd08    	ldr	pc, [r8, #-8]!

08058904 <$d.103>:
 8058904: ad f9 05 08  	.word	0x0805f9ad
 8058908: 61 a4 05 08  	.word	0x0805a461
 805890c: 61 a4 05 08  	.word	0x0805a461
 8058910: 61 d3 05 08  	.word	0x0805d361
 8058914: f1 ce 05 08  	.word	0x0805cef1
 8058918: 15 d7 05 08  	.word	0x0805d715
 805891c: 15 d7 05 08  	.word	0x0805d715

08058920 <prvInitialiseTaskLists>:
; {
 8058920: f848 eb44    	str	lr, [r8], #68
 8058924: eb08 0809    	add.w	r8, r8, r9
 8058928: b480         	push	{r7}
 805892a: 466f         	mov	r7, sp
 805892c: b084         	sub	sp, #0x10
 805892e: 2000         	movs	r0, #0x0
;     for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8058930: 9003         	str	r0, [sp, #0xc]
 8058932: e7ff         	b	0x8058934 <prvInitialiseTaskLists+0x14> @ imm = #-0x2
 8058934: 9803         	ldr	r0, [sp, #0xc]
 8058936: 280f         	cmp	r0, #0xf
 8058938: d810         	bhi	0x805895c <prvInitialiseTaskLists+0x3c> @ imm = #0x20
 805893a: e7ff         	b	0x805893c <prvInitialiseTaskLists+0x1c> @ imm = #-0x2
;         vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 805893c: 9803         	ldr	r0, [sp, #0xc]
 805893e: eb00 0180    	add.w	r1, r0, r0, lsl #2
 8058942: f240 1060    	movw	r0, #0x160
 8058946: f2c2 0000    	movt	r0, #0x2000
 805894a: eb00 0081    	add.w	r0, r0, r1, lsl #2
 805894e: 4921         	ldr	r1, [pc, #0x84]         @ 0x80589d4 <prvInitialiseTaskLists+0xb4>
 8058950: 4788         	blx	r1
;     }
 8058952: e7ff         	b	0x8058954 <prvInitialiseTaskLists+0x34> @ imm = #-0x2
;     for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8058954: 9803         	ldr	r0, [sp, #0xc]
 8058956: 3001         	adds	r0, #0x1
 8058958: 9003         	str	r0, [sp, #0xc]
 805895a: e7eb         	b	0x8058934 <prvInitialiseTaskLists+0x14> @ imm = #-0x2a
;     vListInitialise( &xDelayedTaskList1 );
 805895c: f240 20b8    	movw	r0, #0x2b8
 8058960: f2c2 0000    	movt	r0, #0x2000
 8058964: 9001         	str	r0, [sp, #0x4]
 8058966: 4916         	ldr	r1, [pc, #0x58]         @ 0x80589c0 <prvInitialiseTaskLists+0xa0>
 8058968: 4788         	blx	r1
;     vListInitialise( &xDelayedTaskList2 );
 805896a: f240 20cc    	movw	r0, #0x2cc
 805896e: f2c2 0000    	movt	r0, #0x2000
 8058972: 9002         	str	r0, [sp, #0x8]
 8058974: 4913         	ldr	r1, [pc, #0x4c]         @ 0x80589c4 <prvInitialiseTaskLists+0xa4>
 8058976: 4788         	blx	r1
;     vListInitialise( &xPendingReadyList );
 8058978: f240 1038    	movw	r0, #0x138
 805897c: f2c2 0000    	movt	r0, #0x2000
 8058980: 4911         	ldr	r1, [pc, #0x44]         @ 0x80589c8 <prvInitialiseTaskLists+0xa8>
 8058982: 4788         	blx	r1
;         vListInitialise( &xTasksWaitingTermination );
 8058984: f240 1008    	movw	r0, #0x108
 8058988: f2c2 0000    	movt	r0, #0x2000
 805898c: 490f         	ldr	r1, [pc, #0x3c]         @ 0x80589cc <prvInitialiseTaskLists+0xac>
 805898e: 4788         	blx	r1
;         vListInitialise( &xSuspendedTaskList );
 8058990: f240 104c    	movw	r0, #0x14c
 8058994: f2c2 0000    	movt	r0, #0x2000
 8058998: 490d         	ldr	r1, [pc, #0x34]         @ 0x80589d0 <prvInitialiseTaskLists+0xb0>
 805899a: 4788         	blx	r1
 805899c: 9901         	ldr	r1, [sp, #0x4]
 805899e: 9802         	ldr	r0, [sp, #0x8]
;     pxDelayedTaskList = &xDelayedTaskList1;
 80589a0: f240 1230    	movw	r2, #0x130
 80589a4: f2c2 0200    	movt	r2, #0x2000
 80589a8: 6011         	str	r1, [r2]
;     pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80589aa: f240 1134    	movw	r1, #0x134
 80589ae: f2c2 0100    	movt	r1, #0x2000
 80589b2: 6008         	str	r0, [r1]
; }
 80589b4: b004         	add	sp, #0x10
 80589b6: bc80         	pop	{r7}
 80589b8: eba8 0809    	sub.w	r8, r8, r9
 80589bc: f858 fd44    	ldr	pc, [r8, #-68]!

080589c0 <$d.105>:
 80589c0: 33 a4 05 08  	.word	0x0805a433
 80589c4: 33 a4 05 08  	.word	0x0805a433
 80589c8: 33 a4 05 08  	.word	0x0805a433
 80589cc: 33 a4 05 08  	.word	0x0805a433
 80589d0: 33 a4 05 08  	.word	0x0805a433
 80589d4: 33 a4 05 08  	.word	0x0805a433

080589d8 <prvIdleTask>:
; {
 80589d8: f848 eb38    	str	lr, [r8], #56
 80589dc: eb08 0809    	add.w	r8, r8, r9
 80589e0: b480         	push	{r7}
 80589e2: 466f         	mov	r7, sp
 80589e4: b082         	sub	sp, #0x8
 80589e6: 9001         	str	r0, [sp, #0x4]
;     for( ; configCONTROL_INFINITE_LOOP(); )
 80589e8: e7ff         	b	0x80589ea <prvIdleTask+0x12> @ imm = #-0x2
;         prvCheckTasksWaitingTermination();
 80589ea: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8058a08 <prvIdleTask+0x30>
 80589ec: 4780         	blx	r0
;             if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) configNUMBER_OF_CORES )
 80589ee: f240 1060    	movw	r0, #0x160
 80589f2: f2c2 0000    	movt	r0, #0x2000
 80589f6: 6800         	ldr	r0, [r0]
 80589f8: 2802         	cmp	r0, #0x2
 80589fa: d302         	blo	0x8058a02 <prvIdleTask+0x2a> @ imm = #0x4
 80589fc: e7ff         	b	0x80589fe <prvIdleTask+0x26> @ imm = #-0x2
;                 taskYIELD();
 80589fe: df07         	svc	#0x7
;             }
 8058a00: e000         	b	0x8058a04 <prvIdleTask+0x2c> @ imm = #0x0
 8058a02: e7ff         	b	0x8058a04 <prvIdleTask+0x2c> @ imm = #-0x2
;     for( ; configCONTROL_INFINITE_LOOP(); )
 8058a04: e7f1         	b	0x80589ea <prvIdleTask+0x12> @ imm = #-0x1e
 8058a06: bf00         	nop

08058a08 <$d.107>:
 8058a08: 0d 8a 05 08  	.word	0x08058a0d

08058a0c <prvCheckTasksWaitingTermination>:
; {
 8058a0c: f848 eb60    	str	lr, [r8], #96
 8058a10: eb08 0809    	add.w	r8, r8, r9
 8058a14: b480         	push	{r7}
 8058a16: 466f         	mov	r7, sp
 8058a18: b082         	sub	sp, #0x8
;         while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8058a1a: e7ff         	b	0x8058a1c <prvCheckTasksWaitingTermination+0x10> @ imm = #-0x2
 8058a1c: f240 101c    	movw	r0, #0x11c
 8058a20: f2c2 0000    	movt	r0, #0x2000
 8058a24: 6800         	ldr	r0, [r0]
 8058a26: b308         	cbz	r0, 0x8058a6c <prvCheckTasksWaitingTermination+0x60> @ imm = #0x42
 8058a28: e7ff         	b	0x8058a2a <prvCheckTasksWaitingTermination+0x1e> @ imm = #-0x2
;                 taskENTER_CRITICAL();
 8058a2a: 4813         	ldr	r0, [pc, #0x4c]         @ 0x8058a78 <prvCheckTasksWaitingTermination+0x6c>
 8058a2c: 4780         	blx	r0
;                         pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8058a2e: f240 1008    	movw	r0, #0x108
 8058a32: f2c2 0000    	movt	r0, #0x2000
 8058a36: 68c0         	ldr	r0, [r0, #0xc]
 8058a38: 68c0         	ldr	r0, [r0, #0xc]
 8058a3a: 9001         	str	r0, [sp, #0x4]
;                         ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8058a3c: 9801         	ldr	r0, [sp, #0x4]
 8058a3e: 3080         	adds	r0, #0x80
 8058a40: 490e         	ldr	r1, [pc, #0x38]         @ 0x8058a7c <prvCheckTasksWaitingTermination+0x70>
 8058a42: 4788         	blx	r1
;                         --uxCurrentNumberOfTasks;
 8058a44: f240 1120    	movw	r1, #0x120
 8058a48: f2c2 0100    	movt	r1, #0x2000
 8058a4c: 6808         	ldr	r0, [r1]
 8058a4e: 3801         	subs	r0, #0x1
 8058a50: 6008         	str	r0, [r1]
;                         --uxDeletedTasksWaitingCleanUp;
 8058a52: f240 111c    	movw	r1, #0x11c
 8058a56: f2c2 0100    	movt	r1, #0x2000
 8058a5a: 6808         	ldr	r0, [r1]
 8058a5c: 3801         	subs	r0, #0x1
 8058a5e: 6008         	str	r0, [r1]
;                 taskEXIT_CRITICAL();
 8058a60: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8058a80 <prvCheckTasksWaitingTermination+0x74>
 8058a62: 4780         	blx	r0
;                 prvDeleteTCB( pxTCB );
 8058a64: 9801         	ldr	r0, [sp, #0x4]
 8058a66: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8058a84 <prvCheckTasksWaitingTermination+0x78>
 8058a68: 4788         	blx	r1
;         while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8058a6a: e7d7         	b	0x8058a1c <prvCheckTasksWaitingTermination+0x10> @ imm = #-0x52
; }
 8058a6c: b002         	add	sp, #0x8
 8058a6e: bc80         	pop	{r7}
 8058a70: eba8 0809    	sub.w	r8, r8, r9
 8058a74: f858 fd60    	ldr	pc, [r8, #-96]!

08058a78 <$d.109>:
 8058a78: 49 cd 05 08  	.word	0x0805cd49
 8058a7c: 13 a5 05 08  	.word	0x0805a513
 8058a80: 7d cd 05 08  	.word	0x0805cd7d
 8058a84: 59 57 05 08  	.word	0x08055759

08058a88 <xTimerCreateTimerTask>:
;     {
 8058a88: f848 eb2c    	str	lr, [r8], #44
 8058a8c: eb08 0809    	add.w	r8, r8, r9
 8058a90: b480         	push	{r7}
 8058a92: 466f         	mov	r7, sp
 8058a94: b084         	sub	sp, #0x10
 8058a96: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
 8058a98: 9003         	str	r0, [sp, #0xc]
;         prvCheckForValidListAndQueue();
 8058a9a: 4819         	ldr	r0, [pc, #0x64]         @ 0x8058b00 <xTimerCreateTimerTask+0x78>
 8058a9c: 4780         	blx	r0
;         if( xTimerQueue != NULL )
 8058a9e: f240 20e0    	movw	r0, #0x2e0
 8058aa2: f2c2 0000    	movt	r0, #0x2000
 8058aa6: 6800         	ldr	r0, [r0]
 8058aa8: b1d0         	cbz	r0, 0x8058ae0 <xTimerCreateTimerTask+0x58> @ imm = #0x34
 8058aaa: e7ff         	b	0x8058aac <xTimerCreateTimerTask+0x24> @ imm = #-0x2
;                     xReturn = xTaskCreate( prvTimerTask,
 8058aac: f240 20e4    	movw	r0, #0x2e4
 8058ab0: f2c2 0000    	movt	r0, #0x2000
 8058ab4: 4669         	mov	r1, sp
 8058ab6: 6048         	str	r0, [r1, #0x4]
 8058ab8: 2002         	movs	r0, #0x2
 8058aba: f2c8 0000    	movt	r0, #0x8000
 8058abe: 6008         	str	r0, [r1]
 8058ac0: f648 30c5    	movw	r0, #0x8bc5
 8058ac4: f6c0 0005    	movt	r0, #0x805
 8058ac8: f64f 21f1    	movw	r1, #0xfaf1
 8058acc: f6c0 0105    	movt	r1, #0x805
 8058ad0: f8df c030    	ldr.w	r12, [pc, #0x30]        @ 0x8058b04 <xTimerCreateTimerTask+0x7c>
 8058ad4: f44f 7280    	mov.w	r2, #0x100
 8058ad8: 2300         	movs	r3, #0x0
 8058ada: 47e0         	blx	r12
 8058adc: 9003         	str	r0, [sp, #0xc]
;         }
 8058ade: e000         	b	0x8058ae2 <xTimerCreateTimerTask+0x5a> @ imm = #0x0
 8058ae0: e7ff         	b	0x8058ae2 <xTimerCreateTimerTask+0x5a> @ imm = #-0x2
;         configASSERT( xReturn );
 8058ae2: 9803         	ldr	r0, [sp, #0xc]
 8058ae4: b920         	cbnz	r0, 0x8058af0 <xTimerCreateTimerTask+0x68> @ imm = #0x8
 8058ae6: e7ff         	b	0x8058ae8 <xTimerCreateTimerTask+0x60> @ imm = #-0x2
 8058ae8: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8058b08 <xTimerCreateTimerTask+0x80>
 8058aea: 4780         	blx	r0
 8058aec: e7ff         	b	0x8058aee <xTimerCreateTimerTask+0x66> @ imm = #-0x2
 8058aee: e7fe         	b	0x8058aee <xTimerCreateTimerTask+0x66> @ imm = #-0x4
;         return xReturn;
 8058af0: 9803         	ldr	r0, [sp, #0xc]
 8058af2: b004         	add	sp, #0x10
 8058af4: bc80         	pop	{r7}
 8058af6: eba8 0809    	sub.w	r8, r8, r9
 8058afa: f858 fd2c    	ldr	pc, [r8, #-44]!
 8058afe: bf00         	nop

08058b00 <$d.1>:
 8058b00: 0d 8b 05 08  	.word	0x08058b0d
 8058b04: a5 54 05 08  	.word	0x080554a5
 8058b08: 15 d7 05 08  	.word	0x0805d715

08058b0c <prvCheckForValidListAndQueue>:
;     {
 8058b0c: f848 eb40    	str	lr, [r8], #64
 8058b10: eb08 0809    	add.w	r8, r8, r9
 8058b14: b480         	push	{r7}
 8058b16: 466f         	mov	r7, sp
 8058b18: b082         	sub	sp, #0x8
;         taskENTER_CRITICAL();
 8058b1a: 4824         	ldr	r0, [pc, #0x90]         @ 0x8058bac <prvCheckForValidListAndQueue+0xa0>
 8058b1c: 4780         	blx	r0
;             if( xTimerQueue == NULL )
 8058b1e: f240 20e0    	movw	r0, #0x2e0
 8058b22: f2c2 0000    	movt	r0, #0x2000
 8058b26: 6800         	ldr	r0, [r0]
 8058b28: bbb0         	cbnz	r0, 0x8058b98 <prvCheckForValidListAndQueue+0x8c> @ imm = #0x6c
 8058b2a: e7ff         	b	0x8058b2c <prvCheckForValidListAndQueue+0x20> @ imm = #-0x2
;                 vListInitialise( &xActiveTimerList1 );
 8058b2c: f240 20f4    	movw	r0, #0x2f4
 8058b30: f2c2 0000    	movt	r0, #0x2000
 8058b34: 9000         	str	r0, [sp]
 8058b36: 491e         	ldr	r1, [pc, #0x78]         @ 0x8058bb0 <prvCheckForValidListAndQueue+0xa4>
 8058b38: 4788         	blx	r1
;                 vListInitialise( &xActiveTimerList2 );
 8058b3a: f240 3008    	movw	r0, #0x308
 8058b3e: f2c2 0000    	movt	r0, #0x2000
 8058b42: 9001         	str	r0, [sp, #0x4]
 8058b44: 491b         	ldr	r1, [pc, #0x6c]         @ 0x8058bb4 <prvCheckForValidListAndQueue+0xa8>
 8058b46: 4788         	blx	r1
 8058b48: 9900         	ldr	r1, [sp]
 8058b4a: 9801         	ldr	r0, [sp, #0x4]
;                 pxCurrentTimerList = &xActiveTimerList1;
 8058b4c: f240 22e8    	movw	r2, #0x2e8
 8058b50: f2c2 0200    	movt	r2, #0x2000
 8058b54: 6011         	str	r1, [r2]
;                 pxOverflowTimerList = &xActiveTimerList2;
 8058b56: f240 21ec    	movw	r1, #0x2ec
 8058b5a: f2c2 0100    	movt	r1, #0x2000
 8058b5e: 6008         	str	r0, [r1]
;                     xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8058b60: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8058bb8 <prvCheckForValidListAndQueue+0xac>
 8058b62: 200a         	movs	r0, #0xa
 8058b64: 2110         	movs	r1, #0x10
 8058b66: 2200         	movs	r2, #0x0
 8058b68: 4798         	blx	r3
 8058b6a: 4601         	mov	r1, r0
 8058b6c: f240 20e0    	movw	r0, #0x2e0
 8058b70: f2c2 0000    	movt	r0, #0x2000
 8058b74: 6001         	str	r1, [r0]
;                     if( xTimerQueue != NULL )
 8058b76: 6800         	ldr	r0, [r0]
 8058b78: b160         	cbz	r0, 0x8058b94 <prvCheckForValidListAndQueue+0x88> @ imm = #0x18
 8058b7a: e7ff         	b	0x8058b7c <prvCheckForValidListAndQueue+0x70> @ imm = #-0x2
;                         vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 8058b7c: f240 20e0    	movw	r0, #0x2e0
 8058b80: f2c2 0000    	movt	r0, #0x2000
 8058b84: 6800         	ldr	r0, [r0]
 8058b86: f64f 21f9    	movw	r1, #0xfaf9
 8058b8a: f6c0 0105    	movt	r1, #0x805
 8058b8e: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8058bbc <prvCheckForValidListAndQueue+0xb0>
 8058b90: 4790         	blx	r2
;                     }
 8058b92: e000         	b	0x8058b96 <prvCheckForValidListAndQueue+0x8a> @ imm = #0x0
 8058b94: e7ff         	b	0x8058b96 <prvCheckForValidListAndQueue+0x8a> @ imm = #-0x2
;             }
 8058b96: e000         	b	0x8058b9a <prvCheckForValidListAndQueue+0x8e> @ imm = #0x0
 8058b98: e7ff         	b	0x8058b9a <prvCheckForValidListAndQueue+0x8e> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 8058b9a: 4809         	ldr	r0, [pc, #0x24]         @ 0x8058bc0 <prvCheckForValidListAndQueue+0xb4>
 8058b9c: 4780         	blx	r0
;     }
 8058b9e: b002         	add	sp, #0x8
 8058ba0: bc80         	pop	{r7}
 8058ba2: eba8 0809    	sub.w	r8, r8, r9
 8058ba6: f858 fd40    	ldr	pc, [r8, #-64]!
 8058baa: bf00         	nop

08058bac <$d.3>:
 8058bac: 49 cd 05 08  	.word	0x0805cd49
 8058bb0: 33 a4 05 08  	.word	0x0805a433
 8058bb4: 33 a4 05 08  	.word	0x0805a433
 8058bb8: 69 a6 05 08  	.word	0x0805a669
 8058bbc: 9d bc 05 08  	.word	0x0805bc9d
 8058bc0: 7d cd 05 08  	.word	0x0805cd7d

08058bc4 <prvTimerTask>:
;     {
 8058bc4: f848 eb24    	str	lr, [r8], #36
 8058bc8: eb08 0809    	add.w	r8, r8, r9
 8058bcc: b480         	push	{r7}
 8058bce: 466f         	mov	r7, sp
 8058bd0: b084         	sub	sp, #0x10
 8058bd2: 9003         	str	r0, [sp, #0xc]
;         for( ; configCONTROL_INFINITE_LOOP(); )
 8058bd4: e7ff         	b	0x8058bd6 <prvTimerTask+0x12> @ imm = #-0x2
;             xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 8058bd6: 4905         	ldr	r1, [pc, #0x14]         @ 0x8058bec <prvTimerTask+0x28>
 8058bd8: a801         	add	r0, sp, #0x4
 8058bda: 4788         	blx	r1
 8058bdc: 9002         	str	r0, [sp, #0x8]
;             prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 8058bde: 9802         	ldr	r0, [sp, #0x8]
 8058be0: 9901         	ldr	r1, [sp, #0x4]
 8058be2: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8058bf0 <prvTimerTask+0x2c>
 8058be4: 4790         	blx	r2
;             prvProcessReceivedCommands();
 8058be6: 4803         	ldr	r0, [pc, #0xc]          @ 0x8058bf4 <prvTimerTask+0x30>
 8058be8: 4780         	blx	r0
;         for( ; configCONTROL_INFINITE_LOOP(); )
 8058bea: e7f4         	b	0x8058bd6 <prvTimerTask+0x12> @ imm = #-0x18

08058bec <$d.5>:
 8058bec: ed 91 05 08  	.word	0x080591ed
 8058bf0: 2d 92 05 08  	.word	0x0805922d
 8058bf4: e9 92 05 08  	.word	0x080592e9

08058bf8 <xTimerCreate>:
;         {
 8058bf8: f848 eb10    	str	lr, [r8], #16
 8058bfc: eb08 0809    	add.w	r8, r8, r9
 8058c00: b4d0         	push	{r4, r6, r7}
 8058c02: af02         	add	r7, sp, #0x8
 8058c04: b088         	sub	sp, #0x20
 8058c06: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 8058c0a: 9007         	str	r0, [sp, #0x1c]
 8058c0c: 9106         	str	r1, [sp, #0x18]
 8058c0e: 9205         	str	r2, [sp, #0x14]
 8058c10: 9304         	str	r3, [sp, #0x10]
;             pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's name. */
 8058c12: 4911         	ldr	r1, [pc, #0x44]         @ 0x8058c58 <xTimerCreate+0x60>
 8058c14: 202c         	movs	r0, #0x2c
 8058c16: 4788         	blx	r1
 8058c18: 9003         	str	r0, [sp, #0xc]
;             if( pxNewTimer != NULL )
 8058c1a: 9803         	ldr	r0, [sp, #0xc]
 8058c1c: b1a0         	cbz	r0, 0x8058c48 <xTimerCreate+0x50> @ imm = #0x28
 8058c1e: e7ff         	b	0x8058c20 <xTimerCreate+0x28> @ imm = #-0x2
;                 pxNewTimer->ucStatus = 0x00;
 8058c20: 9903         	ldr	r1, [sp, #0xc]
 8058c22: 2000         	movs	r0, #0x0
 8058c24: f881 0028    	strb.w	r0, [r1, #0x28]
;                 prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, xAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
 8058c28: 9807         	ldr	r0, [sp, #0x1c]
 8058c2a: 9906         	ldr	r1, [sp, #0x18]
 8058c2c: 9a05         	ldr	r2, [sp, #0x14]
 8058c2e: 9b04         	ldr	r3, [sp, #0x10]
 8058c30: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 8058c34: 9c03         	ldr	r4, [sp, #0xc]
 8058c36: 46ee         	mov	lr, sp
 8058c38: f8ce 4004    	str.w	r4, [lr, #0x4]
 8058c3c: f8ce c000    	str.w	r12, [lr]
 8058c40: f8df c018    	ldr.w	r12, [pc, #0x18]        @ 0x8058c5c <xTimerCreate+0x64>
 8058c44: 47e0         	blx	r12
;             }
 8058c46: e7ff         	b	0x8058c48 <xTimerCreate+0x50> @ imm = #-0x2
;             return pxNewTimer;
 8058c48: 9803         	ldr	r0, [sp, #0xc]
 8058c4a: b008         	add	sp, #0x20
 8058c4c: bcd0         	pop	{r4, r6, r7}
 8058c4e: eba8 0809    	sub.w	r8, r8, r9
 8058c52: f858 fd10    	ldr	pc, [r8, #-16]!
 8058c56: bf00         	nop

08058c58 <$d.7>:
 8058c58: cd 96 05 08  	.word	0x080596cd
 8058c5c: 61 8c 05 08  	.word	0x08058c61

08058c60 <prvInitialiseNewTimer>:
;     {
 8058c60: f848 eb3c    	str	lr, [r8], #60
 8058c64: eb08 0809    	add.w	r8, r8, r9
 8058c68: b480         	push	{r7}
 8058c6a: 466f         	mov	r7, sp
 8058c6c: b084         	sub	sp, #0x10
 8058c6e: f8d7 c00c    	ldr.w	r12, [r7, #0xc]
 8058c72: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 8058c76: 9003         	str	r0, [sp, #0xc]
 8058c78: 9102         	str	r1, [sp, #0x8]
 8058c7a: 9201         	str	r2, [sp, #0x4]
 8058c7c: 9300         	str	r3, [sp]
;         configASSERT( ( xTimerPeriodInTicks > 0 ) );
 8058c7e: 9802         	ldr	r0, [sp, #0x8]
 8058c80: b920         	cbnz	r0, 0x8058c8c <prvInitialiseNewTimer+0x2c> @ imm = #0x8
 8058c82: e7ff         	b	0x8058c84 <prvInitialiseNewTimer+0x24> @ imm = #-0x2
 8058c84: 4815         	ldr	r0, [pc, #0x54]         @ 0x8058cdc <prvInitialiseNewTimer+0x7c>
 8058c86: 4780         	blx	r0
 8058c88: e7ff         	b	0x8058c8a <prvInitialiseNewTimer+0x2a> @ imm = #-0x2
 8058c8a: e7fe         	b	0x8058c8a <prvInitialiseNewTimer+0x2a> @ imm = #-0x4
;         prvCheckForValidListAndQueue();
 8058c8c: 4811         	ldr	r0, [pc, #0x44]         @ 0x8058cd4 <prvInitialiseNewTimer+0x74>
 8058c8e: 4780         	blx	r0
;         pxNewTimer->pcTimerName = pcTimerName;
 8058c90: 9803         	ldr	r0, [sp, #0xc]
 8058c92: 68f9         	ldr	r1, [r7, #0xc]
 8058c94: 6008         	str	r0, [r1]
;         pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 8058c96: 9802         	ldr	r0, [sp, #0x8]
 8058c98: 68f9         	ldr	r1, [r7, #0xc]
 8058c9a: 6188         	str	r0, [r1, #0x18]
;         pxNewTimer->pvTimerID = pvTimerID;
 8058c9c: 9800         	ldr	r0, [sp]
 8058c9e: 68f9         	ldr	r1, [r7, #0xc]
 8058ca0: 61c8         	str	r0, [r1, #0x1c]
;         pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8058ca2: 68b8         	ldr	r0, [r7, #0x8]
 8058ca4: 68f9         	ldr	r1, [r7, #0xc]
 8058ca6: 6208         	str	r0, [r1, #0x20]
;         vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8058ca8: 68f8         	ldr	r0, [r7, #0xc]
 8058caa: 3004         	adds	r0, #0x4
 8058cac: 490a         	ldr	r1, [pc, #0x28]         @ 0x8058cd8 <prvInitialiseNewTimer+0x78>
 8058cae: 4788         	blx	r1
;         if( xAutoReload != pdFALSE )
 8058cb0: 9801         	ldr	r0, [sp, #0x4]
 8058cb2: b140         	cbz	r0, 0x8058cc6 <prvInitialiseNewTimer+0x66> @ imm = #0x10
 8058cb4: e7ff         	b	0x8058cb6 <prvInitialiseNewTimer+0x56> @ imm = #-0x2
;             pxNewTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_AUTORELOAD;
 8058cb6: 68f9         	ldr	r1, [r7, #0xc]
 8058cb8: f891 0028    	ldrb.w	r0, [r1, #0x28]
 8058cbc: f040 0004    	orr	r0, r0, #0x4
 8058cc0: f881 0028    	strb.w	r0, [r1, #0x28]
;         }
 8058cc4: e7ff         	b	0x8058cc6 <prvInitialiseNewTimer+0x66> @ imm = #-0x2
;     }
 8058cc6: b004         	add	sp, #0x10
 8058cc8: bc80         	pop	{r7}
 8058cca: eba8 0809    	sub.w	r8, r8, r9
 8058cce: f858 fd3c    	ldr	pc, [r8, #-60]!
 8058cd2: bf00         	nop

08058cd4 <$d.9>:
 8058cd4: 0d 8b 05 08  	.word	0x08058b0d
 8058cd8: 61 a4 05 08  	.word	0x0805a461
 8058cdc: 15 d7 05 08  	.word	0x0805d715

08058ce0 <xTimerGenericCommandFromTask>:
;     {
 8058ce0: f848 eb44    	str	lr, [r8], #68
 8058ce4: eb08 0809    	add.w	r8, r8, r9
 8058ce8: b480         	push	{r7}
 8058cea: 466f         	mov	r7, sp
 8058cec: b08a         	sub	sp, #0x28
 8058cee: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 8058cf2: 9009         	str	r0, [sp, #0x24]
 8058cf4: 9108         	str	r1, [sp, #0x20]
 8058cf6: 9207         	str	r2, [sp, #0x1c]
 8058cf8: 9306         	str	r3, [sp, #0x18]
 8058cfa: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
 8058cfc: 9005         	str	r0, [sp, #0x14]
;         configASSERT( xTimer );
 8058cfe: 9809         	ldr	r0, [sp, #0x24]
 8058d00: b920         	cbnz	r0, 0x8058d0c <xTimerGenericCommandFromTask+0x2c> @ imm = #0x8
 8058d02: e7ff         	b	0x8058d04 <xTimerGenericCommandFromTask+0x24> @ imm = #-0x2
 8058d04: 4826         	ldr	r0, [pc, #0x98]         @ 0x8058da0 <xTimerGenericCommandFromTask+0xc0>
 8058d06: 4780         	blx	r0
 8058d08: e7ff         	b	0x8058d0a <xTimerGenericCommandFromTask+0x2a> @ imm = #-0x2
 8058d0a: e7fe         	b	0x8058d0a <xTimerGenericCommandFromTask+0x2a> @ imm = #-0x4
;         if( xTimerQueue != NULL )
 8058d0c: f240 20e0    	movw	r0, #0x2e0
 8058d10: f2c2 0000    	movt	r0, #0x2000
 8058d14: 6800         	ldr	r0, [r0]
 8058d16: b398         	cbz	r0, 0x8058d80 <xTimerGenericCommandFromTask+0xa0> @ imm = #0x66
 8058d18: e7ff         	b	0x8058d1a <xTimerGenericCommandFromTask+0x3a> @ imm = #-0x2
;             xMessage.xMessageID = xCommandID;
 8058d1a: 9808         	ldr	r0, [sp, #0x20]
 8058d1c: 9001         	str	r0, [sp, #0x4]
;             xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8058d1e: 9807         	ldr	r0, [sp, #0x1c]
 8058d20: 9002         	str	r0, [sp, #0x8]
;             xMessage.u.xTimerParameters.pxTimer = xTimer;
 8058d22: 9809         	ldr	r0, [sp, #0x24]
 8058d24: 9003         	str	r0, [sp, #0xc]
;             configASSERT( xCommandID < tmrFIRST_FROM_ISR_COMMAND );
 8058d26: 9808         	ldr	r0, [sp, #0x20]
 8058d28: 2806         	cmp	r0, #0x6
 8058d2a: db04         	blt	0x8058d36 <xTimerGenericCommandFromTask+0x56> @ imm = #0x8
 8058d2c: e7ff         	b	0x8058d2e <xTimerGenericCommandFromTask+0x4e> @ imm = #-0x2
 8058d2e: 481b         	ldr	r0, [pc, #0x6c]         @ 0x8058d9c <xTimerGenericCommandFromTask+0xbc>
 8058d30: 4780         	blx	r0
 8058d32: e7ff         	b	0x8058d34 <xTimerGenericCommandFromTask+0x54> @ imm = #-0x2
 8058d34: e7fe         	b	0x8058d34 <xTimerGenericCommandFromTask+0x54> @ imm = #-0x4
;             if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8058d36: 9808         	ldr	r0, [sp, #0x20]
 8058d38: 2805         	cmp	r0, #0x5
 8058d3a: dc20         	bgt	0x8058d7e <xTimerGenericCommandFromTask+0x9e> @ imm = #0x40
 8058d3c: e7ff         	b	0x8058d3e <xTimerGenericCommandFromTask+0x5e> @ imm = #-0x2
;                 if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8058d3e: 4814         	ldr	r0, [pc, #0x50]         @ 0x8058d90 <xTimerGenericCommandFromTask+0xb0>
 8058d40: 4780         	blx	r0
 8058d42: 2802         	cmp	r0, #0x2
 8058d44: d10d         	bne	0x8058d62 <xTimerGenericCommandFromTask+0x82> @ imm = #0x1a
 8058d46: e7ff         	b	0x8058d48 <xTimerGenericCommandFromTask+0x68> @ imm = #-0x2
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8058d48: f240 20e0    	movw	r0, #0x2e0
 8058d4c: f2c2 0000    	movt	r0, #0x2000
 8058d50: 6800         	ldr	r0, [r0]
 8058d52: 68ba         	ldr	r2, [r7, #0x8]
 8058d54: f8df c040    	ldr.w	r12, [pc, #0x40]        @ 0x8058d98 <xTimerGenericCommandFromTask+0xb8>
 8058d58: a901         	add	r1, sp, #0x4
 8058d5a: 2300         	movs	r3, #0x0
 8058d5c: 47e0         	blx	r12
 8058d5e: 9005         	str	r0, [sp, #0x14]
;                 }
 8058d60: e00c         	b	0x8058d7c <xTimerGenericCommandFromTask+0x9c> @ imm = #0x18
;                     xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8058d62: f240 20e0    	movw	r0, #0x2e0
 8058d66: f2c2 0000    	movt	r0, #0x2000
 8058d6a: 6800         	ldr	r0, [r0]
 8058d6c: f8df c024    	ldr.w	r12, [pc, #0x24]        @ 0x8058d94 <xTimerGenericCommandFromTask+0xb4>
 8058d70: a901         	add	r1, sp, #0x4
 8058d72: 2300         	movs	r3, #0x0
 8058d74: 461a         	mov	r2, r3
 8058d76: 47e0         	blx	r12
 8058d78: 9005         	str	r0, [sp, #0x14]
 8058d7a: e7ff         	b	0x8058d7c <xTimerGenericCommandFromTask+0x9c> @ imm = #-0x2
;             }
 8058d7c: e7ff         	b	0x8058d7e <xTimerGenericCommandFromTask+0x9e> @ imm = #-0x2
;         }
 8058d7e: e000         	b	0x8058d82 <xTimerGenericCommandFromTask+0xa2> @ imm = #0x0
 8058d80: e7ff         	b	0x8058d82 <xTimerGenericCommandFromTask+0xa2> @ imm = #-0x2
;         return xReturn;
 8058d82: 9805         	ldr	r0, [sp, #0x14]
 8058d84: b00a         	add	sp, #0x28
 8058d86: bc80         	pop	{r7}
 8058d88: eba8 0809    	sub.w	r8, r8, r9
 8058d8c: f858 fd44    	ldr	pc, [r8, #-68]!

08058d90 <$d.11>:
 8058d90: 0d 77 05 08  	.word	0x0805770d
 8058d94: 1d a9 05 08  	.word	0x0805a91d
 8058d98: 1d a9 05 08  	.word	0x0805a91d
 8058d9c: 15 d7 05 08  	.word	0x0805d715
 8058da0: 15 d7 05 08  	.word	0x0805d715

08058da4 <xTimerGenericCommandFromISR>:
;     {
 8058da4: f848 eb28    	str	lr, [r8], #40
 8058da8: eb08 0809    	add.w	r8, r8, r9
 8058dac: b480         	push	{r7}
 8058dae: 466f         	mov	r7, sp
 8058db0: b08a         	sub	sp, #0x28
 8058db2: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 8058db6: 9009         	str	r0, [sp, #0x24]
 8058db8: 9108         	str	r1, [sp, #0x20]
 8058dba: 9207         	str	r2, [sp, #0x1c]
 8058dbc: 9306         	str	r3, [sp, #0x18]
 8058dbe: 2000         	movs	r0, #0x0
;         BaseType_t xReturn = pdFAIL;
 8058dc0: 9005         	str	r0, [sp, #0x14]
;         configASSERT( xTimer );
 8058dc2: 9809         	ldr	r0, [sp, #0x24]
 8058dc4: b920         	cbnz	r0, 0x8058dd0 <xTimerGenericCommandFromISR+0x2c> @ imm = #0x8
 8058dc6: e7ff         	b	0x8058dc8 <xTimerGenericCommandFromISR+0x24> @ imm = #-0x2
 8058dc8: 481b         	ldr	r0, [pc, #0x6c]         @ 0x8058e38 <xTimerGenericCommandFromISR+0x94>
 8058dca: 4780         	blx	r0
 8058dcc: e7ff         	b	0x8058dce <xTimerGenericCommandFromISR+0x2a> @ imm = #-0x2
 8058dce: e7fe         	b	0x8058dce <xTimerGenericCommandFromISR+0x2a> @ imm = #-0x4
;         if( xTimerQueue != NULL )
 8058dd0: f240 20e0    	movw	r0, #0x2e0
 8058dd4: f2c2 0000    	movt	r0, #0x2000
 8058dd8: 6800         	ldr	r0, [r0]
 8058dda: b300         	cbz	r0, 0x8058e1e <xTimerGenericCommandFromISR+0x7a> @ imm = #0x40
 8058ddc: e7ff         	b	0x8058dde <xTimerGenericCommandFromISR+0x3a> @ imm = #-0x2
;             xMessage.xMessageID = xCommandID;
 8058dde: 9808         	ldr	r0, [sp, #0x20]
 8058de0: 9001         	str	r0, [sp, #0x4]
;             xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8058de2: 9807         	ldr	r0, [sp, #0x1c]
 8058de4: 9002         	str	r0, [sp, #0x8]
;             xMessage.u.xTimerParameters.pxTimer = xTimer;
 8058de6: 9809         	ldr	r0, [sp, #0x24]
 8058de8: 9003         	str	r0, [sp, #0xc]
;             configASSERT( xCommandID >= tmrFIRST_FROM_ISR_COMMAND );
 8058dea: 9808         	ldr	r0, [sp, #0x20]
 8058dec: 2805         	cmp	r0, #0x5
 8058dee: dc04         	bgt	0x8058dfa <xTimerGenericCommandFromISR+0x56> @ imm = #0x8
 8058df0: e7ff         	b	0x8058df2 <xTimerGenericCommandFromISR+0x4e> @ imm = #-0x2
 8058df2: 4810         	ldr	r0, [pc, #0x40]         @ 0x8058e34 <xTimerGenericCommandFromISR+0x90>
 8058df4: 4780         	blx	r0
 8058df6: e7ff         	b	0x8058df8 <xTimerGenericCommandFromISR+0x54> @ imm = #-0x2
 8058df8: e7fe         	b	0x8058df8 <xTimerGenericCommandFromISR+0x54> @ imm = #-0x4
;             if( xCommandID >= tmrFIRST_FROM_ISR_COMMAND )
 8058dfa: 9808         	ldr	r0, [sp, #0x20]
 8058dfc: 2806         	cmp	r0, #0x6
 8058dfe: db0d         	blt	0x8058e1c <xTimerGenericCommandFromISR+0x78> @ imm = #0x1a
 8058e00: e7ff         	b	0x8058e02 <xTimerGenericCommandFromISR+0x5e> @ imm = #-0x2
;                 xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8058e02: f240 20e0    	movw	r0, #0x2e0
 8058e06: f2c2 0000    	movt	r0, #0x2000
 8058e0a: 6800         	ldr	r0, [r0]
 8058e0c: 9a06         	ldr	r2, [sp, #0x18]
 8058e0e: f8df c020    	ldr.w	r12, [pc, #0x20]        @ 0x8058e30 <xTimerGenericCommandFromISR+0x8c>
 8058e12: a901         	add	r1, sp, #0x4
 8058e14: 2300         	movs	r3, #0x0
 8058e16: 47e0         	blx	r12
 8058e18: 9005         	str	r0, [sp, #0x14]
;             }
 8058e1a: e7ff         	b	0x8058e1c <xTimerGenericCommandFromISR+0x78> @ imm = #-0x2
;         }
 8058e1c: e000         	b	0x8058e20 <xTimerGenericCommandFromISR+0x7c> @ imm = #0x0
 8058e1e: e7ff         	b	0x8058e20 <xTimerGenericCommandFromISR+0x7c> @ imm = #-0x2
;         return xReturn;
 8058e20: 9805         	ldr	r0, [sp, #0x14]
 8058e22: b00a         	add	sp, #0x28
 8058e24: bc80         	pop	{r7}
 8058e26: eba8 0809    	sub.w	r8, r8, r9
 8058e2a: f858 fd28    	ldr	pc, [r8, #-40]!
 8058e2e: bf00         	nop

08058e30 <$d.13>:
 8058e30: b1 b0 05 08  	.word	0x0805b0b1
 8058e34: 15 d7 05 08  	.word	0x0805d715
 8058e38: 15 d7 05 08  	.word	0x0805d715

08058e3c <xTimerGetTimerDaemonTaskHandle>:
;     {
 8058e3c: f848 eb28    	str	lr, [r8], #40
 8058e40: eb08 0809    	add.w	r8, r8, r9
 8058e44: b480         	push	{r7}
 8058e46: 466f         	mov	r7, sp
;         configASSERT( ( xTimerTaskHandle != NULL ) );
 8058e48: f240 20e4    	movw	r0, #0x2e4
 8058e4c: f2c2 0000    	movt	r0, #0x2000
 8058e50: 6800         	ldr	r0, [r0]
 8058e52: b920         	cbnz	r0, 0x8058e5e <xTimerGetTimerDaemonTaskHandle+0x22> @ imm = #0x8
 8058e54: e7ff         	b	0x8058e56 <xTimerGetTimerDaemonTaskHandle+0x1a> @ imm = #-0x2
 8058e56: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8058e74 <xTimerGetTimerDaemonTaskHandle+0x38>
 8058e58: 4780         	blx	r0
 8058e5a: e7ff         	b	0x8058e5c <xTimerGetTimerDaemonTaskHandle+0x20> @ imm = #-0x2
 8058e5c: e7fe         	b	0x8058e5c <xTimerGetTimerDaemonTaskHandle+0x20> @ imm = #-0x4
;         return xTimerTaskHandle;
 8058e5e: f240 20e4    	movw	r0, #0x2e4
 8058e62: f2c2 0000    	movt	r0, #0x2000
 8058e66: 6800         	ldr	r0, [r0]
 8058e68: bc80         	pop	{r7}
 8058e6a: eba8 0809    	sub.w	r8, r8, r9
 8058e6e: f858 fd28    	ldr	pc, [r8, #-40]!
 8058e72: bf00         	nop

08058e74 <$d.15>:
 8058e74: 15 d7 05 08  	.word	0x0805d715

08058e78 <xTimerGetPeriod>:
;     {
 8058e78: f848 eb04    	str	lr, [r8], #4
 8058e7c: eb08 0809    	add.w	r8, r8, r9
 8058e80: b480         	push	{r7}
 8058e82: 466f         	mov	r7, sp
 8058e84: b082         	sub	sp, #0x8
 8058e86: 9001         	str	r0, [sp, #0x4]
;         Timer_t * pxTimer = xTimer;
 8058e88: 9801         	ldr	r0, [sp, #0x4]
 8058e8a: 9000         	str	r0, [sp]
;         configASSERT( xTimer );
 8058e8c: 9801         	ldr	r0, [sp, #0x4]
 8058e8e: b920         	cbnz	r0, 0x8058e9a <xTimerGetPeriod+0x22> @ imm = #0x8
 8058e90: e7ff         	b	0x8058e92 <xTimerGetPeriod+0x1a> @ imm = #-0x2
 8058e92: 4806         	ldr	r0, [pc, #0x18]         @ 0x8058eac <xTimerGetPeriod+0x34>
 8058e94: 4780         	blx	r0
 8058e96: e7ff         	b	0x8058e98 <xTimerGetPeriod+0x20> @ imm = #-0x2
 8058e98: e7fe         	b	0x8058e98 <xTimerGetPeriod+0x20> @ imm = #-0x4
;         return pxTimer->xTimerPeriodInTicks;
 8058e9a: 9800         	ldr	r0, [sp]
 8058e9c: 6980         	ldr	r0, [r0, #0x18]
 8058e9e: b002         	add	sp, #0x8
 8058ea0: bc80         	pop	{r7}
 8058ea2: eba8 0809    	sub.w	r8, r8, r9
 8058ea6: f858 fd04    	ldr	pc, [r8, #-4]!
 8058eaa: bf00         	nop

08058eac <$d.17>:
 8058eac: 15 d7 05 08  	.word	0x0805d715

08058eb0 <vTimerSetReloadMode>:
;     {
 8058eb0: f848 eb48    	str	lr, [r8], #72
 8058eb4: eb08 0809    	add.w	r8, r8, r9
 8058eb8: b480         	push	{r7}
 8058eba: 466f         	mov	r7, sp
 8058ebc: b084         	sub	sp, #0x10
 8058ebe: 9003         	str	r0, [sp, #0xc]
 8058ec0: 9102         	str	r1, [sp, #0x8]
;         Timer_t * pxTimer = xTimer;
 8058ec2: 9803         	ldr	r0, [sp, #0xc]
 8058ec4: 9001         	str	r0, [sp, #0x4]
;         configASSERT( xTimer );
 8058ec6: 9803         	ldr	r0, [sp, #0xc]
 8058ec8: b920         	cbnz	r0, 0x8058ed4 <vTimerSetReloadMode+0x24> @ imm = #0x8
 8058eca: e7ff         	b	0x8058ecc <vTimerSetReloadMode+0x1c> @ imm = #-0x2
 8058ecc: 4812         	ldr	r0, [pc, #0x48]         @ 0x8058f18 <vTimerSetReloadMode+0x68>
 8058ece: 4780         	blx	r0
 8058ed0: e7ff         	b	0x8058ed2 <vTimerSetReloadMode+0x22> @ imm = #-0x2
 8058ed2: e7fe         	b	0x8058ed2 <vTimerSetReloadMode+0x22> @ imm = #-0x4
;         taskENTER_CRITICAL();
 8058ed4: 480e         	ldr	r0, [pc, #0x38]         @ 0x8058f10 <vTimerSetReloadMode+0x60>
 8058ed6: 4780         	blx	r0
;             if( xAutoReload != pdFALSE )
 8058ed8: 9802         	ldr	r0, [sp, #0x8]
 8058eda: b140         	cbz	r0, 0x8058eee <vTimerSetReloadMode+0x3e> @ imm = #0x10
 8058edc: e7ff         	b	0x8058ede <vTimerSetReloadMode+0x2e> @ imm = #-0x2
;                 pxTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_AUTORELOAD;
 8058ede: 9901         	ldr	r1, [sp, #0x4]
 8058ee0: f891 0028    	ldrb.w	r0, [r1, #0x28]
 8058ee4: f040 0004    	orr	r0, r0, #0x4
 8058ee8: f881 0028    	strb.w	r0, [r1, #0x28]
;             }
 8058eec: e007         	b	0x8058efe <vTimerSetReloadMode+0x4e> @ imm = #0xe
;                 pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
 8058eee: 9901         	ldr	r1, [sp, #0x4]
 8058ef0: f891 0028    	ldrb.w	r0, [r1, #0x28]
 8058ef4: f000 00fb    	and	r0, r0, #0xfb
 8058ef8: f881 0028    	strb.w	r0, [r1, #0x28]
 8058efc: e7ff         	b	0x8058efe <vTimerSetReloadMode+0x4e> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 8058efe: 4805         	ldr	r0, [pc, #0x14]         @ 0x8058f14 <vTimerSetReloadMode+0x64>
 8058f00: 4780         	blx	r0
;     }
 8058f02: b004         	add	sp, #0x10
 8058f04: bc80         	pop	{r7}
 8058f06: eba8 0809    	sub.w	r8, r8, r9
 8058f0a: f858 fd48    	ldr	pc, [r8, #-72]!
 8058f0e: bf00         	nop

08058f10 <$d.19>:
 8058f10: 49 cd 05 08  	.word	0x0805cd49
 8058f14: 7d cd 05 08  	.word	0x0805cd7d
 8058f18: 15 d7 05 08  	.word	0x0805d715

08058f1c <xTimerGetReloadMode>:
;     {
 8058f1c: f848 eb48    	str	lr, [r8], #72
 8058f20: eb08 0809    	add.w	r8, r8, r9
 8058f24: b480         	push	{r7}
 8058f26: 466f         	mov	r7, sp
 8058f28: b084         	sub	sp, #0x10
 8058f2a: 9003         	str	r0, [sp, #0xc]
;         Timer_t * pxTimer = xTimer;
 8058f2c: 9803         	ldr	r0, [sp, #0xc]
 8058f2e: 9002         	str	r0, [sp, #0x8]
;         configASSERT( xTimer );
 8058f30: 9803         	ldr	r0, [sp, #0xc]
 8058f32: b920         	cbnz	r0, 0x8058f3e <xTimerGetReloadMode+0x22> @ imm = #0x8
 8058f34: e7ff         	b	0x8058f36 <xTimerGetReloadMode+0x1a> @ imm = #-0x2
 8058f36: 4810         	ldr	r0, [pc, #0x40]         @ 0x8058f78 <xTimerGetReloadMode+0x5c>
 8058f38: 4780         	blx	r0
 8058f3a: e7ff         	b	0x8058f3c <xTimerGetReloadMode+0x20> @ imm = #-0x2
 8058f3c: e7fe         	b	0x8058f3c <xTimerGetReloadMode+0x20> @ imm = #-0x4
;         taskENTER_CRITICAL();
 8058f3e: 480c         	ldr	r0, [pc, #0x30]         @ 0x8058f70 <xTimerGetReloadMode+0x54>
 8058f40: 4780         	blx	r0
;             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
 8058f42: 9802         	ldr	r0, [sp, #0x8]
 8058f44: f890 0028    	ldrb.w	r0, [r0, #0x28]
 8058f48: 0740         	lsls	r0, r0, #0x1d
 8058f4a: 2800         	cmp	r0, #0x0
 8058f4c: d403         	bmi	0x8058f56 <xTimerGetReloadMode+0x3a> @ imm = #0x6
 8058f4e: e7ff         	b	0x8058f50 <xTimerGetReloadMode+0x34> @ imm = #-0x2
 8058f50: 2000         	movs	r0, #0x0
;                 xReturn = pdFALSE;
 8058f52: 9001         	str	r0, [sp, #0x4]
;             }
 8058f54: e002         	b	0x8058f5c <xTimerGetReloadMode+0x40> @ imm = #0x4
 8058f56: 2001         	movs	r0, #0x1
;                 xReturn = pdTRUE;
 8058f58: 9001         	str	r0, [sp, #0x4]
 8058f5a: e7ff         	b	0x8058f5c <xTimerGetReloadMode+0x40> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 8058f5c: 4805         	ldr	r0, [pc, #0x14]         @ 0x8058f74 <xTimerGetReloadMode+0x58>
 8058f5e: 4780         	blx	r0
;         return xReturn;
 8058f60: 9801         	ldr	r0, [sp, #0x4]
 8058f62: b004         	add	sp, #0x10
 8058f64: bc80         	pop	{r7}
 8058f66: eba8 0809    	sub.w	r8, r8, r9
 8058f6a: f858 fd48    	ldr	pc, [r8, #-72]!
 8058f6e: bf00         	nop

08058f70 <$d.21>:
 8058f70: 49 cd 05 08  	.word	0x0805cd49
 8058f74: 7d cd 05 08  	.word	0x0805cd7d
 8058f78: 15 d7 05 08  	.word	0x0805d715

08058f7c <uxTimerGetReloadMode>:
;     {
 8058f7c: f848 eb5c    	str	lr, [r8], #92
 8058f80: eb08 0809    	add.w	r8, r8, r9
 8058f84: b480         	push	{r7}
 8058f86: 466f         	mov	r7, sp
 8058f88: b082         	sub	sp, #0x8
 8058f8a: 9001         	str	r0, [sp, #0x4]
;         uxReturn = ( UBaseType_t ) xTimerGetReloadMode( xTimer );
 8058f8c: 9801         	ldr	r0, [sp, #0x4]
 8058f8e: 4905         	ldr	r1, [pc, #0x14]         @ 0x8058fa4 <uxTimerGetReloadMode+0x28>
 8058f90: 4788         	blx	r1
 8058f92: 9000         	str	r0, [sp]
;         return uxReturn;
 8058f94: 9800         	ldr	r0, [sp]
 8058f96: b002         	add	sp, #0x8
 8058f98: bc80         	pop	{r7}
 8058f9a: eba8 0809    	sub.w	r8, r8, r9
 8058f9e: f858 fd5c    	ldr	pc, [r8, #-92]!
 8058fa2: bf00         	nop

08058fa4 <$d.23>:
 8058fa4: 1d 8f 05 08  	.word	0x08058f1d

08058fa8 <xTimerGetExpiryTime>:
;     {
 8058fa8: f848 eb54    	str	lr, [r8], #84
 8058fac: eb08 0809    	add.w	r8, r8, r9
 8058fb0: b480         	push	{r7}
 8058fb2: 466f         	mov	r7, sp
 8058fb4: b084         	sub	sp, #0x10
 8058fb6: 9003         	str	r0, [sp, #0xc]
;         Timer_t * pxTimer = xTimer;
 8058fb8: 9803         	ldr	r0, [sp, #0xc]
 8058fba: 9002         	str	r0, [sp, #0x8]
;         configASSERT( xTimer );
 8058fbc: 9803         	ldr	r0, [sp, #0xc]
 8058fbe: b920         	cbnz	r0, 0x8058fca <xTimerGetExpiryTime+0x22> @ imm = #0x8
 8058fc0: e7ff         	b	0x8058fc2 <xTimerGetExpiryTime+0x1a> @ imm = #-0x2
 8058fc2: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8058fe0 <xTimerGetExpiryTime+0x38>
 8058fc4: 4780         	blx	r0
 8058fc6: e7ff         	b	0x8058fc8 <xTimerGetExpiryTime+0x20> @ imm = #-0x2
 8058fc8: e7fe         	b	0x8058fc8 <xTimerGetExpiryTime+0x20> @ imm = #-0x4
;         xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
 8058fca: 9802         	ldr	r0, [sp, #0x8]
 8058fcc: 6840         	ldr	r0, [r0, #0x4]
 8058fce: 9001         	str	r0, [sp, #0x4]
;         return xReturn;
 8058fd0: 9801         	ldr	r0, [sp, #0x4]
 8058fd2: b004         	add	sp, #0x10
 8058fd4: bc80         	pop	{r7}
 8058fd6: eba8 0809    	sub.w	r8, r8, r9
 8058fda: f858 fd54    	ldr	pc, [r8, #-84]!
 8058fde: bf00         	nop

08058fe0 <$d.25>:
 8058fe0: 15 d7 05 08  	.word	0x0805d715

08058fe4 <pcTimerGetName>:
;     {
 8058fe4: f848 eb68    	str	lr, [r8], #104
 8058fe8: eb08 0809    	add.w	r8, r8, r9
 8058fec: b480         	push	{r7}
 8058fee: 466f         	mov	r7, sp
 8058ff0: b082         	sub	sp, #0x8
 8058ff2: 9001         	str	r0, [sp, #0x4]
;         Timer_t * pxTimer = xTimer;
 8058ff4: 9801         	ldr	r0, [sp, #0x4]
 8058ff6: 9000         	str	r0, [sp]
;         configASSERT( xTimer );
 8058ff8: 9801         	ldr	r0, [sp, #0x4]
 8058ffa: b920         	cbnz	r0, 0x8059006 <pcTimerGetName+0x22> @ imm = #0x8
 8058ffc: e7ff         	b	0x8058ffe <pcTimerGetName+0x1a> @ imm = #-0x2
 8058ffe: 4806         	ldr	r0, [pc, #0x18]         @ 0x8059018 <pcTimerGetName+0x34>
 8059000: 4780         	blx	r0
 8059002: e7ff         	b	0x8059004 <pcTimerGetName+0x20> @ imm = #-0x2
 8059004: e7fe         	b	0x8059004 <pcTimerGetName+0x20> @ imm = #-0x4
;         return pxTimer->pcTimerName;
 8059006: 9800         	ldr	r0, [sp]
 8059008: 6800         	ldr	r0, [r0]
 805900a: b002         	add	sp, #0x8
 805900c: bc80         	pop	{r7}
 805900e: eba8 0809    	sub.w	r8, r8, r9
 8059012: f858 fd68    	ldr	pc, [r8, #-104]!
 8059016: bf00         	nop

08059018 <$d.27>:
 8059018: 15 d7 05 08  	.word	0x0805d715

0805901c <xTimerIsTimerActive>:
;     {
 805901c: f848 eb24    	str	lr, [r8], #36
 8059020: eb08 0809    	add.w	r8, r8, r9
 8059024: b480         	push	{r7}
 8059026: 466f         	mov	r7, sp
 8059028: b084         	sub	sp, #0x10
 805902a: 9003         	str	r0, [sp, #0xc]
;         Timer_t * pxTimer = xTimer;
 805902c: 9803         	ldr	r0, [sp, #0xc]
 805902e: 9001         	str	r0, [sp, #0x4]
;         configASSERT( xTimer );
 8059030: 9803         	ldr	r0, [sp, #0xc]
 8059032: b920         	cbnz	r0, 0x805903e <xTimerIsTimerActive+0x22> @ imm = #0x8
 8059034: e7ff         	b	0x8059036 <xTimerIsTimerActive+0x1a> @ imm = #-0x2
 8059036: 480f         	ldr	r0, [pc, #0x3c]         @ 0x8059074 <xTimerIsTimerActive+0x58>
 8059038: 4780         	blx	r0
 805903a: e7ff         	b	0x805903c <xTimerIsTimerActive+0x20> @ imm = #-0x2
 805903c: e7fe         	b	0x805903c <xTimerIsTimerActive+0x20> @ imm = #-0x4
;         taskENTER_CRITICAL();
 805903e: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805906c <xTimerIsTimerActive+0x50>
 8059040: 4780         	blx	r0
;             if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
 8059042: 9801         	ldr	r0, [sp, #0x4]
 8059044: f890 0028    	ldrb.w	r0, [r0, #0x28]
 8059048: 07c0         	lsls	r0, r0, #0x1f
 805904a: b918         	cbnz	r0, 0x8059054 <xTimerIsTimerActive+0x38> @ imm = #0x6
 805904c: e7ff         	b	0x805904e <xTimerIsTimerActive+0x32> @ imm = #-0x2
 805904e: 2000         	movs	r0, #0x0
;                 xReturn = pdFALSE;
 8059050: 9002         	str	r0, [sp, #0x8]
;             }
 8059052: e002         	b	0x805905a <xTimerIsTimerActive+0x3e> @ imm = #0x4
 8059054: 2001         	movs	r0, #0x1
;                 xReturn = pdTRUE;
 8059056: 9002         	str	r0, [sp, #0x8]
 8059058: e7ff         	b	0x805905a <xTimerIsTimerActive+0x3e> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 805905a: 4805         	ldr	r0, [pc, #0x14]         @ 0x8059070 <xTimerIsTimerActive+0x54>
 805905c: 4780         	blx	r0
;         return xReturn;
 805905e: 9802         	ldr	r0, [sp, #0x8]
 8059060: b004         	add	sp, #0x10
 8059062: bc80         	pop	{r7}
 8059064: eba8 0809    	sub.w	r8, r8, r9
 8059068: f858 fd24    	ldr	pc, [r8, #-36]!

0805906c <$d.29>:
 805906c: 49 cd 05 08  	.word	0x0805cd49
 8059070: 7d cd 05 08  	.word	0x0805cd7d
 8059074: 15 d7 05 08  	.word	0x0805d715

08059078 <pvTimerGetTimerID>:
;     {
 8059078: f848 eb78    	str	lr, [r8], #120
 805907c: eb08 0809    	add.w	r8, r8, r9
 8059080: b480         	push	{r7}
 8059082: 466f         	mov	r7, sp
 8059084: b084         	sub	sp, #0x10
 8059086: 9003         	str	r0, [sp, #0xc]
;         Timer_t * const pxTimer = xTimer;
 8059088: 9803         	ldr	r0, [sp, #0xc]
 805908a: 9002         	str	r0, [sp, #0x8]
;         configASSERT( xTimer );
 805908c: 9803         	ldr	r0, [sp, #0xc]
 805908e: b920         	cbnz	r0, 0x805909a <pvTimerGetTimerID+0x22> @ imm = #0x8
 8059090: e7ff         	b	0x8059092 <pvTimerGetTimerID+0x1a> @ imm = #-0x2
 8059092: 480b         	ldr	r0, [pc, #0x2c]         @ 0x80590c0 <pvTimerGetTimerID+0x48>
 8059094: 4780         	blx	r0
 8059096: e7ff         	b	0x8059098 <pvTimerGetTimerID+0x20> @ imm = #-0x2
 8059098: e7fe         	b	0x8059098 <pvTimerGetTimerID+0x20> @ imm = #-0x4
;         taskENTER_CRITICAL();
 805909a: 4807         	ldr	r0, [pc, #0x1c]         @ 0x80590b8 <pvTimerGetTimerID+0x40>
 805909c: 4780         	blx	r0
;             pvReturn = pxTimer->pvTimerID;
 805909e: 9802         	ldr	r0, [sp, #0x8]
 80590a0: 69c0         	ldr	r0, [r0, #0x1c]
 80590a2: 9001         	str	r0, [sp, #0x4]
;         taskEXIT_CRITICAL();
 80590a4: 4805         	ldr	r0, [pc, #0x14]         @ 0x80590bc <pvTimerGetTimerID+0x44>
 80590a6: 4780         	blx	r0
;         return pvReturn;
 80590a8: 9801         	ldr	r0, [sp, #0x4]
 80590aa: b004         	add	sp, #0x10
 80590ac: bc80         	pop	{r7}
 80590ae: eba8 0809    	sub.w	r8, r8, r9
 80590b2: f858 fd78    	ldr	pc, [r8, #-120]!
 80590b6: bf00         	nop

080590b8 <$d.31>:
 80590b8: 49 cd 05 08  	.word	0x0805cd49
 80590bc: 7d cd 05 08  	.word	0x0805cd7d
 80590c0: 15 d7 05 08  	.word	0x0805d715

080590c4 <vTimerSetTimerID>:
;     {
 80590c4: f848 eb64    	str	lr, [r8], #100
 80590c8: eb08 0809    	add.w	r8, r8, r9
 80590cc: b480         	push	{r7}
 80590ce: 466f         	mov	r7, sp
 80590d0: b084         	sub	sp, #0x10
 80590d2: 9003         	str	r0, [sp, #0xc]
 80590d4: 9102         	str	r1, [sp, #0x8]
;         Timer_t * const pxTimer = xTimer;
 80590d6: 9803         	ldr	r0, [sp, #0xc]
 80590d8: 9001         	str	r0, [sp, #0x4]
;         configASSERT( xTimer );
 80590da: 9803         	ldr	r0, [sp, #0xc]
 80590dc: b920         	cbnz	r0, 0x80590e8 <vTimerSetTimerID+0x24> @ imm = #0x8
 80590de: e7ff         	b	0x80590e0 <vTimerSetTimerID+0x1c> @ imm = #-0x2
 80590e0: 480a         	ldr	r0, [pc, #0x28]         @ 0x805910c <vTimerSetTimerID+0x48>
 80590e2: 4780         	blx	r0
 80590e4: e7ff         	b	0x80590e6 <vTimerSetTimerID+0x22> @ imm = #-0x2
 80590e6: e7fe         	b	0x80590e6 <vTimerSetTimerID+0x22> @ imm = #-0x4
;         taskENTER_CRITICAL();
 80590e8: 4806         	ldr	r0, [pc, #0x18]         @ 0x8059104 <vTimerSetTimerID+0x40>
 80590ea: 4780         	blx	r0
;             pxTimer->pvTimerID = pvNewID;
 80590ec: 9802         	ldr	r0, [sp, #0x8]
 80590ee: 9901         	ldr	r1, [sp, #0x4]
 80590f0: 61c8         	str	r0, [r1, #0x1c]
;         taskEXIT_CRITICAL();
 80590f2: 4805         	ldr	r0, [pc, #0x14]         @ 0x8059108 <vTimerSetTimerID+0x44>
 80590f4: 4780         	blx	r0
;     }
 80590f6: b004         	add	sp, #0x10
 80590f8: bc80         	pop	{r7}
 80590fa: eba8 0809    	sub.w	r8, r8, r9
 80590fe: f858 fd64    	ldr	pc, [r8, #-100]!
 8059102: bf00         	nop

08059104 <$d.33>:
 8059104: 49 cd 05 08  	.word	0x0805cd49
 8059108: 7d cd 05 08  	.word	0x0805cd7d
 805910c: 15 d7 05 08  	.word	0x0805d715

08059110 <xTimerPendFunctionCallFromISR>:
;         {
 8059110: f848 eb60    	str	lr, [r8], #96
 8059114: eb08 0809    	add.w	r8, r8, r9
 8059118: b480         	push	{r7}
 805911a: 466f         	mov	r7, sp
 805911c: b08a         	sub	sp, #0x28
 805911e: 9009         	str	r0, [sp, #0x24]
 8059120: 9108         	str	r1, [sp, #0x20]
 8059122: 9207         	str	r2, [sp, #0x1c]
 8059124: 9306         	str	r3, [sp, #0x18]
 8059126: f06f 0001    	mvn	r0, #0x1
;             xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
 805912a: 9002         	str	r0, [sp, #0x8]
;             xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
 805912c: 9809         	ldr	r0, [sp, #0x24]
 805912e: 9003         	str	r0, [sp, #0xc]
;             xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
 8059130: 9808         	ldr	r0, [sp, #0x20]
 8059132: 9004         	str	r0, [sp, #0x10]
;             xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
 8059134: 9807         	ldr	r0, [sp, #0x1c]
 8059136: 9005         	str	r0, [sp, #0x14]
;             xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8059138: f240 20e0    	movw	r0, #0x2e0
 805913c: f2c2 0000    	movt	r0, #0x2000
 8059140: 6800         	ldr	r0, [r0]
 8059142: 9a06         	ldr	r2, [sp, #0x18]
 8059144: f8df c018    	ldr.w	r12, [pc, #0x18]        @ 0x8059160 <xTimerPendFunctionCallFromISR+0x50>
 8059148: a902         	add	r1, sp, #0x8
 805914a: 2300         	movs	r3, #0x0
 805914c: 47e0         	blx	r12
 805914e: 9001         	str	r0, [sp, #0x4]
;             return xReturn;
 8059150: 9801         	ldr	r0, [sp, #0x4]
 8059152: b00a         	add	sp, #0x28
 8059154: bc80         	pop	{r7}
 8059156: eba8 0809    	sub.w	r8, r8, r9
 805915a: f858 fd60    	ldr	pc, [r8, #-96]!
 805915e: bf00         	nop

08059160 <$d.35>:
 8059160: b1 b0 05 08  	.word	0x0805b0b1

08059164 <xTimerPendFunctionCall>:
;         {
 8059164: f848 eb54    	str	lr, [r8], #84
 8059168: eb08 0809    	add.w	r8, r8, r9
 805916c: b480         	push	{r7}
 805916e: 466f         	mov	r7, sp
 8059170: b08a         	sub	sp, #0x28
 8059172: 9009         	str	r0, [sp, #0x24]
 8059174: 9108         	str	r1, [sp, #0x20]
 8059176: 9207         	str	r2, [sp, #0x1c]
 8059178: 9306         	str	r3, [sp, #0x18]
;             configASSERT( xTimerQueue );
 805917a: f240 20e0    	movw	r0, #0x2e0
 805917e: f2c2 0000    	movt	r0, #0x2000
 8059182: 6800         	ldr	r0, [r0]
 8059184: b920         	cbnz	r0, 0x8059190 <xTimerPendFunctionCall+0x2c> @ imm = #0x8
 8059186: e7ff         	b	0x8059188 <xTimerPendFunctionCall+0x24> @ imm = #-0x2
 8059188: 4810         	ldr	r0, [pc, #0x40]         @ 0x80591cc <xTimerPendFunctionCall+0x68>
 805918a: 4780         	blx	r0
 805918c: e7ff         	b	0x805918e <xTimerPendFunctionCall+0x2a> @ imm = #-0x2
 805918e: e7fe         	b	0x805918e <xTimerPendFunctionCall+0x2a> @ imm = #-0x4
 8059190: f04f 30ff    	mov.w	r0, #0xffffffff
;             xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
 8059194: 9002         	str	r0, [sp, #0x8]
;             xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
 8059196: 9809         	ldr	r0, [sp, #0x24]
 8059198: 9003         	str	r0, [sp, #0xc]
;             xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
 805919a: 9808         	ldr	r0, [sp, #0x20]
 805919c: 9004         	str	r0, [sp, #0x10]
;             xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
 805919e: 9807         	ldr	r0, [sp, #0x1c]
 80591a0: 9005         	str	r0, [sp, #0x14]
;             xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 80591a2: f240 20e0    	movw	r0, #0x2e0
 80591a6: f2c2 0000    	movt	r0, #0x2000
 80591aa: 6800         	ldr	r0, [r0]
 80591ac: 9a06         	ldr	r2, [sp, #0x18]
 80591ae: f8df c018    	ldr.w	r12, [pc, #0x18]        @ 0x80591c8 <xTimerPendFunctionCall+0x64>
 80591b2: a902         	add	r1, sp, #0x8
 80591b4: 2300         	movs	r3, #0x0
 80591b6: 47e0         	blx	r12
 80591b8: 9001         	str	r0, [sp, #0x4]
;             return xReturn;
 80591ba: 9801         	ldr	r0, [sp, #0x4]
 80591bc: b00a         	add	sp, #0x28
 80591be: bc80         	pop	{r7}
 80591c0: eba8 0809    	sub.w	r8, r8, r9
 80591c4: f858 fd54    	ldr	pc, [r8, #-84]!

080591c8 <$d.37>:
 80591c8: 1d a9 05 08  	.word	0x0805a91d
 80591cc: 15 d7 05 08  	.word	0x0805d715

080591d0 <uxTimerGetTimerNumber>:
;         {
 80591d0: b081         	sub	sp, #0x4
 80591d2: 9000         	str	r0, [sp]
;             return ( ( Timer_t * ) xTimer )->uxTimerNumber;
 80591d4: 9800         	ldr	r0, [sp]
 80591d6: 6a40         	ldr	r0, [r0, #0x24]
 80591d8: b001         	add	sp, #0x4
 80591da: 4770         	bx	lr

080591dc <vTimerSetTimerNumber>:
;         {
 80591dc: b082         	sub	sp, #0x8
 80591de: 9001         	str	r0, [sp, #0x4]
 80591e0: 9100         	str	r1, [sp]
;             ( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
 80591e2: 9800         	ldr	r0, [sp]
 80591e4: 9901         	ldr	r1, [sp, #0x4]
 80591e6: 6248         	str	r0, [r1, #0x24]
;         }
 80591e8: b002         	add	sp, #0x8
 80591ea: 4770         	bx	lr

080591ec <prvGetNextExpireTime>:
;     {
 80591ec: b082         	sub	sp, #0x8
 80591ee: 9001         	str	r0, [sp, #0x4]
;         *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 80591f0: f240 20e8    	movw	r0, #0x2e8
 80591f4: f2c2 0000    	movt	r0, #0x2000
 80591f8: 6800         	ldr	r0, [r0]
 80591fa: 6800         	ldr	r0, [r0]
 80591fc: fab0 f080    	clz	r0, r0
 8059200: 0940         	lsrs	r0, r0, #0x5
 8059202: 9901         	ldr	r1, [sp, #0x4]
 8059204: 6008         	str	r0, [r1]
;         if( *pxListWasEmpty == pdFALSE )
 8059206: 9801         	ldr	r0, [sp, #0x4]
 8059208: 6800         	ldr	r0, [r0]
 805920a: b948         	cbnz	r0, 0x8059220 <prvGetNextExpireTime+0x34> @ imm = #0x12
 805920c: e7ff         	b	0x805920e <prvGetNextExpireTime+0x22> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 805920e: f240 20e8    	movw	r0, #0x2e8
 8059212: f2c2 0000    	movt	r0, #0x2000
 8059216: 6800         	ldr	r0, [r0]
 8059218: 68c0         	ldr	r0, [r0, #0xc]
 805921a: 6800         	ldr	r0, [r0]
 805921c: 9000         	str	r0, [sp]
;         }
 805921e: e002         	b	0x8059226 <prvGetNextExpireTime+0x3a> @ imm = #0x4
 8059220: 2000         	movs	r0, #0x0
;             xNextExpireTime = ( TickType_t ) 0U;
 8059222: 9000         	str	r0, [sp]
 8059224: e7ff         	b	0x8059226 <prvGetNextExpireTime+0x3a> @ imm = #-0x2
;         return xNextExpireTime;
 8059226: 9800         	ldr	r0, [sp]
 8059228: b002         	add	sp, #0x8
 805922a: 4770         	bx	lr

0805922c <prvProcessTimerOrBlockTask>:
;     {
 805922c: f848 eb64    	str	lr, [r8], #100
 8059230: eb08 0809    	add.w	r8, r8, r9
 8059234: b480         	push	{r7}
 8059236: 466f         	mov	r7, sp
 8059238: b084         	sub	sp, #0x10
 805923a: 9003         	str	r0, [sp, #0xc]
 805923c: 9102         	str	r1, [sp, #0x8]
;         vTaskSuspendAll();
 805923e: 4822         	ldr	r0, [pc, #0x88]         @ 0x80592c8 <prvProcessTimerOrBlockTask+0x9c>
 8059240: 4780         	blx	r0
;             xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8059242: 4922         	ldr	r1, [pc, #0x88]         @ 0x80592cc <prvProcessTimerOrBlockTask+0xa0>
 8059244: 4668         	mov	r0, sp
 8059246: 4788         	blx	r1
 8059248: 9001         	str	r0, [sp, #0x4]
;             if( xTimerListsWereSwitched == pdFALSE )
 805924a: 9800         	ldr	r0, [sp]
 805924c: bb90         	cbnz	r0, 0x80592b4 <prvProcessTimerOrBlockTask+0x88> @ imm = #0x64
 805924e: e7ff         	b	0x8059250 <prvProcessTimerOrBlockTask+0x24> @ imm = #-0x2
;                 if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8059250: 9802         	ldr	r0, [sp, #0x8]
 8059252: b960         	cbnz	r0, 0x805926e <prvProcessTimerOrBlockTask+0x42> @ imm = #0x18
 8059254: e7ff         	b	0x8059256 <prvProcessTimerOrBlockTask+0x2a> @ imm = #-0x2
 8059256: 9803         	ldr	r0, [sp, #0xc]
 8059258: 9901         	ldr	r1, [sp, #0x4]
 805925a: 4288         	cmp	r0, r1
 805925c: d807         	bhi	0x805926e <prvProcessTimerOrBlockTask+0x42> @ imm = #0xe
 805925e: e7ff         	b	0x8059260 <prvProcessTimerOrBlockTask+0x34> @ imm = #-0x2
;                     ( void ) xTaskResumeAll();
 8059260: 481f         	ldr	r0, [pc, #0x7c]         @ 0x80592e0 <prvProcessTimerOrBlockTask+0xb4>
 8059262: 4780         	blx	r0
;                     prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 8059264: 9803         	ldr	r0, [sp, #0xc]
 8059266: 9901         	ldr	r1, [sp, #0x4]
 8059268: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x80592e4 <prvProcessTimerOrBlockTask+0xb8>
 805926a: 4790         	blx	r2
;                 }
 805926c: e021         	b	0x80592b2 <prvProcessTimerOrBlockTask+0x86> @ imm = #0x42
;                     if( xListWasEmpty != pdFALSE )
 805926e: 9802         	ldr	r0, [sp, #0x8]
 8059270: b158         	cbz	r0, 0x805928a <prvProcessTimerOrBlockTask+0x5e> @ imm = #0x16
 8059272: e7ff         	b	0x8059274 <prvProcessTimerOrBlockTask+0x48> @ imm = #-0x2
;                         xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8059274: f240 20ec    	movw	r0, #0x2ec
 8059278: f2c2 0000    	movt	r0, #0x2000
 805927c: 6800         	ldr	r0, [r0]
 805927e: 6800         	ldr	r0, [r0]
 8059280: fab0 f080    	clz	r0, r0
 8059284: 0940         	lsrs	r0, r0, #0x5
 8059286: 9002         	str	r0, [sp, #0x8]
;                     }
 8059288: e7ff         	b	0x805928a <prvProcessTimerOrBlockTask+0x5e> @ imm = #-0x2
;                     vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 805928a: f240 20e0    	movw	r0, #0x2e0
 805928e: f2c2 0000    	movt	r0, #0x2000
 8059292: 6800         	ldr	r0, [r0]
 8059294: 9903         	ldr	r1, [sp, #0xc]
 8059296: 9a01         	ldr	r2, [sp, #0x4]
 8059298: 1a89         	subs	r1, r1, r2
 805929a: 9a02         	ldr	r2, [sp, #0x8]
 805929c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80592d4 <prvProcessTimerOrBlockTask+0xa8>
 805929e: 4798         	blx	r3
;                     if( xTaskResumeAll() == pdFALSE )
 80592a0: 480d         	ldr	r0, [pc, #0x34]         @ 0x80592d8 <prvProcessTimerOrBlockTask+0xac>
 80592a2: 4780         	blx	r0
 80592a4: b918         	cbnz	r0, 0x80592ae <prvProcessTimerOrBlockTask+0x82> @ imm = #0x6
 80592a6: e7ff         	b	0x80592a8 <prvProcessTimerOrBlockTask+0x7c> @ imm = #-0x2
;                         taskYIELD_WITHIN_API();
 80592a8: 480c         	ldr	r0, [pc, #0x30]         @ 0x80592dc <prvProcessTimerOrBlockTask+0xb0>
 80592aa: 4780         	blx	r0
;                     }
 80592ac: e000         	b	0x80592b0 <prvProcessTimerOrBlockTask+0x84> @ imm = #0x0
 80592ae: e7ff         	b	0x80592b0 <prvProcessTimerOrBlockTask+0x84> @ imm = #-0x2
 80592b0: e7ff         	b	0x80592b2 <prvProcessTimerOrBlockTask+0x86> @ imm = #-0x2
;             }
 80592b2: e002         	b	0x80592ba <prvProcessTimerOrBlockTask+0x8e> @ imm = #0x4
;                 ( void ) xTaskResumeAll();
 80592b4: 4806         	ldr	r0, [pc, #0x18]         @ 0x80592d0 <prvProcessTimerOrBlockTask+0xa4>
 80592b6: 4780         	blx	r0
 80592b8: e7ff         	b	0x80592ba <prvProcessTimerOrBlockTask+0x8e> @ imm = #-0x2
;     }
 80592ba: b004         	add	sp, #0x10
 80592bc: bc80         	pop	{r7}
 80592be: eba8 0809    	sub.w	r8, r8, r9
 80592c2: f858 fd64    	ldr	pc, [r8, #-100]!
 80592c6: bf00         	nop

080592c8 <$d.39>:
 80592c8: d9 58 05 08  	.word	0x080558d9
 80592cc: a9 94 05 08  	.word	0x080594a9
 80592d0: 0d 5a 05 08  	.word	0x08055a0d
 80592d4: d5 bd 05 08  	.word	0x0805bdd5
 80592d8: 0d 5a 05 08  	.word	0x08055a0d
 80592dc: 2f cd 05 08  	.word	0x0805cd2f
 80592e0: 0d 5a 05 08  	.word	0x08055a0d
 80592e4: 09 95 05 08  	.word	0x08059509

080592e8 <prvProcessReceivedCommands>:
;     {
 80592e8: f848 eb64    	str	lr, [r8], #100
 80592ec: eb08 0809    	add.w	r8, r8, r9
 80592f0: b480         	push	{r7}
 80592f2: 466f         	mov	r7, sp
 80592f4: b08a         	sub	sp, #0x28
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 80592f6: e7ff         	b	0x80592f8 <prvProcessReceivedCommands+0x10> @ imm = #-0x2
 80592f8: f240 20e0    	movw	r0, #0x2e0
 80592fc: f2c2 0000    	movt	r0, #0x2000
 8059300: 6800         	ldr	r0, [r0]
 8059302: 4b60         	ldr	r3, [pc, #0x180]        @ 0x8059484 <prvProcessReceivedCommands+0x19c>
 8059304: a906         	add	r1, sp, #0x18
 8059306: 2200         	movs	r2, #0x0
 8059308: 4798         	blx	r3
 805930a: 2800         	cmp	r0, #0x0
 805930c: f000 80b3    	beq.w	0x8059476 <prvProcessReceivedCommands+0x18e> @ imm = #0x166
 8059310: e7ff         	b	0x8059312 <prvProcessReceivedCommands+0x2a> @ imm = #-0x2
;                 if( xMessage.xMessageID < ( BaseType_t ) 0 )
 8059312: 9806         	ldr	r0, [sp, #0x18]
 8059314: f1b0 3fff    	cmp.w	r0, #0xffffffff
 8059318: dc10         	bgt	0x805933c <prvProcessReceivedCommands+0x54> @ imm = #0x20
 805931a: e7ff         	b	0x805931c <prvProcessReceivedCommands+0x34> @ imm = #-0x2
 805931c: a806         	add	r0, sp, #0x18
;                     const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
 805931e: 3004         	adds	r0, #0x4
 8059320: 9002         	str	r0, [sp, #0x8]
;                     configASSERT( pxCallback );
 8059322: 9802         	ldr	r0, [sp, #0x8]
 8059324: b920         	cbnz	r0, 0x8059330 <prvProcessReceivedCommands+0x48> @ imm = #0x8
 8059326: e7ff         	b	0x8059328 <prvProcessReceivedCommands+0x40> @ imm = #-0x2
 8059328: 485e         	ldr	r0, [pc, #0x178]        @ 0x80594a4 <prvProcessReceivedCommands+0x1bc>
 805932a: 4780         	blx	r0
 805932c: e7ff         	b	0x805932e <prvProcessReceivedCommands+0x46> @ imm = #-0x2
 805932e: e7fe         	b	0x805932e <prvProcessReceivedCommands+0x46> @ imm = #-0x4
;                     pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 8059330: 9902         	ldr	r1, [sp, #0x8]
 8059332: 680a         	ldr	r2, [r1]
 8059334: 6848         	ldr	r0, [r1, #0x4]
 8059336: 6889         	ldr	r1, [r1, #0x8]
 8059338: 4790         	blx	r2
;                 }
 805933a: e000         	b	0x805933e <prvProcessReceivedCommands+0x56> @ imm = #0x0
 805933c: e7ff         	b	0x805933e <prvProcessReceivedCommands+0x56> @ imm = #-0x2
;             if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 805933e: 9806         	ldr	r0, [sp, #0x18]
 8059340: 2800         	cmp	r0, #0x0
 8059342: f100 8097    	bmi.w	0x8059474 <prvProcessReceivedCommands+0x18c> @ imm = #0x12e
 8059346: e7ff         	b	0x8059348 <prvProcessReceivedCommands+0x60> @ imm = #-0x2
;                 pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8059348: 9808         	ldr	r0, [sp, #0x20]
 805934a: 9005         	str	r0, [sp, #0x14]
;                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 805934c: 9805         	ldr	r0, [sp, #0x14]
 805934e: 6940         	ldr	r0, [r0, #0x14]
 8059350: b128         	cbz	r0, 0x805935e <prvProcessReceivedCommands+0x76> @ imm = #0xa
 8059352: e7ff         	b	0x8059354 <prvProcessReceivedCommands+0x6c> @ imm = #-0x2
;                     ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8059354: 9805         	ldr	r0, [sp, #0x14]
 8059356: 3004         	adds	r0, #0x4
 8059358: 494b         	ldr	r1, [pc, #0x12c]        @ 0x8059488 <prvProcessReceivedCommands+0x1a0>
 805935a: 4788         	blx	r1
;                 }
 805935c: e000         	b	0x8059360 <prvProcessReceivedCommands+0x78> @ imm = #0x0
 805935e: e7ff         	b	0x8059360 <prvProcessReceivedCommands+0x78> @ imm = #-0x2
;                 xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8059360: 494a         	ldr	r1, [pc, #0x128]        @ 0x805948c <prvProcessReceivedCommands+0x1a4>
 8059362: a804         	add	r0, sp, #0x10
 8059364: 4788         	blx	r1
 8059366: 9003         	str	r0, [sp, #0xc]
;                 switch( xMessage.xMessageID )
 8059368: 9806         	ldr	r0, [sp, #0x18]
 805936a: 9001         	str	r0, [sp, #0x4]
 805936c: 3801         	subs	r0, #0x1
 805936e: 2802         	cmp	r0, #0x2
 8059370: d319         	blo	0x80593a6 <prvProcessReceivedCommands+0xbe> @ imm = #0x32
 8059372: e7ff         	b	0x8059374 <prvProcessReceivedCommands+0x8c> @ imm = #-0x2
 8059374: 9801         	ldr	r0, [sp, #0x4]
 8059376: 2803         	cmp	r0, #0x3
 8059378: d043         	beq	0x8059402 <prvProcessReceivedCommands+0x11a> @ imm = #0x86
 805937a: e7ff         	b	0x805937c <prvProcessReceivedCommands+0x94> @ imm = #-0x2
 805937c: 9801         	ldr	r0, [sp, #0x4]
 805937e: 2804         	cmp	r0, #0x4
 8059380: d047         	beq	0x8059412 <prvProcessReceivedCommands+0x12a> @ imm = #0x8e
 8059382: e7ff         	b	0x8059384 <prvProcessReceivedCommands+0x9c> @ imm = #-0x2
 8059384: 9801         	ldr	r0, [sp, #0x4]
 8059386: 2805         	cmp	r0, #0x5
 8059388: d05e         	beq	0x8059448 <prvProcessReceivedCommands+0x160> @ imm = #0xbc
 805938a: e7ff         	b	0x805938c <prvProcessReceivedCommands+0xa4> @ imm = #-0x2
 805938c: 9801         	ldr	r0, [sp, #0x4]
 805938e: 3806         	subs	r0, #0x6
 8059390: 2802         	cmp	r0, #0x2
 8059392: d308         	blo	0x80593a6 <prvProcessReceivedCommands+0xbe> @ imm = #0x10
 8059394: e7ff         	b	0x8059396 <prvProcessReceivedCommands+0xae> @ imm = #-0x2
 8059396: 9801         	ldr	r0, [sp, #0x4]
 8059398: 2808         	cmp	r0, #0x8
 805939a: d032         	beq	0x8059402 <prvProcessReceivedCommands+0x11a> @ imm = #0x64
 805939c: e7ff         	b	0x805939e <prvProcessReceivedCommands+0xb6> @ imm = #-0x2
 805939e: 9801         	ldr	r0, [sp, #0x4]
 80593a0: 2809         	cmp	r0, #0x9
 80593a2: d036         	beq	0x8059412 <prvProcessReceivedCommands+0x12a> @ imm = #0x6c
 80593a4: e064         	b	0x8059470 <prvProcessReceivedCommands+0x188> @ imm = #0xc8
;                         pxTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_ACTIVE;
 80593a6: 9905         	ldr	r1, [sp, #0x14]
 80593a8: f891 0028    	ldrb.w	r0, [r1, #0x28]
 80593ac: f040 0001    	orr	r0, r0, #0x1
 80593b0: f881 0028    	strb.w	r0, [r1, #0x28]
;                         if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 80593b4: 9805         	ldr	r0, [sp, #0x14]
 80593b6: 9b07         	ldr	r3, [sp, #0x1c]
 80593b8: 6981         	ldr	r1, [r0, #0x18]
 80593ba: 4419         	add	r1, r3
 80593bc: 9a03         	ldr	r2, [sp, #0xc]
 80593be: f8df c0dc    	ldr.w	r12, [pc, #0xdc]        @ 0x805949c <prvProcessReceivedCommands+0x1b4>
 80593c2: 47e0         	blx	r12
 80593c4: b1d8         	cbz	r0, 0x80593fe <prvProcessReceivedCommands+0x116> @ imm = #0x36
 80593c6: e7ff         	b	0x80593c8 <prvProcessReceivedCommands+0xe0> @ imm = #-0x2
;                             if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 80593c8: 9805         	ldr	r0, [sp, #0x14]
 80593ca: f890 0028    	ldrb.w	r0, [r0, #0x28]
 80593ce: 0740         	lsls	r0, r0, #0x1d
 80593d0: 2800         	cmp	r0, #0x0
 80593d2: d508         	bpl	0x80593e6 <prvProcessReceivedCommands+0xfe> @ imm = #0x10
 80593d4: e7ff         	b	0x80593d6 <prvProcessReceivedCommands+0xee> @ imm = #-0x2
;                                 prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
 80593d6: 9805         	ldr	r0, [sp, #0x14]
 80593d8: 9907         	ldr	r1, [sp, #0x1c]
 80593da: 6982         	ldr	r2, [r0, #0x18]
 80593dc: 4411         	add	r1, r2
 80593de: 9a03         	ldr	r2, [sp, #0xc]
 80593e0: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x80594a0 <prvProcessReceivedCommands+0x1b8>
 80593e2: 4798         	blx	r3
;                             }
 80593e4: e007         	b	0x80593f6 <prvProcessReceivedCommands+0x10e> @ imm = #0xe
;                                 pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 80593e6: 9905         	ldr	r1, [sp, #0x14]
 80593e8: f891 0028    	ldrb.w	r0, [r1, #0x28]
 80593ec: f000 00fe    	and	r0, r0, #0xfe
 80593f0: f881 0028    	strb.w	r0, [r1, #0x28]
 80593f4: e7ff         	b	0x80593f6 <prvProcessReceivedCommands+0x10e> @ imm = #-0x2
;                             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 80593f6: 9805         	ldr	r0, [sp, #0x14]
 80593f8: 6a01         	ldr	r1, [r0, #0x20]
 80593fa: 4788         	blx	r1
;                         }
 80593fc: e000         	b	0x8059400 <prvProcessReceivedCommands+0x118> @ imm = #0x0
 80593fe: e7ff         	b	0x8059400 <prvProcessReceivedCommands+0x118> @ imm = #-0x2
;                         break;
 8059400: e037         	b	0x8059472 <prvProcessReceivedCommands+0x18a> @ imm = #0x6e
;                         pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 8059402: 9905         	ldr	r1, [sp, #0x14]
 8059404: f891 0028    	ldrb.w	r0, [r1, #0x28]
 8059408: f000 00fe    	and	r0, r0, #0xfe
 805940c: f881 0028    	strb.w	r0, [r1, #0x28]
;                         break;
 8059410: e02f         	b	0x8059472 <prvProcessReceivedCommands+0x18a> @ imm = #0x5e
;                         pxTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_ACTIVE;
 8059412: 9905         	ldr	r1, [sp, #0x14]
 8059414: f891 0028    	ldrb.w	r0, [r1, #0x28]
 8059418: f040 0001    	orr	r0, r0, #0x1
 805941c: f881 0028    	strb.w	r0, [r1, #0x28]
;                         pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8059420: 9807         	ldr	r0, [sp, #0x1c]
 8059422: 9905         	ldr	r1, [sp, #0x14]
 8059424: 6188         	str	r0, [r1, #0x18]
;                         configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8059426: 9805         	ldr	r0, [sp, #0x14]
 8059428: 6980         	ldr	r0, [r0, #0x18]
 805942a: b920         	cbnz	r0, 0x8059436 <prvProcessReceivedCommands+0x14e> @ imm = #0x8
 805942c: e7ff         	b	0x805942e <prvProcessReceivedCommands+0x146> @ imm = #-0x2
 805942e: 481a         	ldr	r0, [pc, #0x68]         @ 0x8059498 <prvProcessReceivedCommands+0x1b0>
 8059430: 4780         	blx	r0
 8059432: e7ff         	b	0x8059434 <prvProcessReceivedCommands+0x14c> @ imm = #-0x2
 8059434: e7fe         	b	0x8059434 <prvProcessReceivedCommands+0x14c> @ imm = #-0x4
;                         ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8059436: 9805         	ldr	r0, [sp, #0x14]
 8059438: 9b03         	ldr	r3, [sp, #0xc]
 805943a: 6981         	ldr	r1, [r0, #0x18]
 805943c: 4419         	add	r1, r3
 805943e: f8df c054    	ldr.w	r12, [pc, #0x54]        @ 0x8059494 <prvProcessReceivedCommands+0x1ac>
 8059442: 461a         	mov	r2, r3
 8059444: 47e0         	blx	r12
;                         break;
 8059446: e014         	b	0x8059472 <prvProcessReceivedCommands+0x18a> @ imm = #0x28
;                             if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 8059448: 9805         	ldr	r0, [sp, #0x14]
 805944a: f890 0028    	ldrb.w	r0, [r0, #0x28]
 805944e: 0780         	lsls	r0, r0, #0x1e
 8059450: 2800         	cmp	r0, #0x0
 8059452: d404         	bmi	0x805945e <prvProcessReceivedCommands+0x176> @ imm = #0x8
 8059454: e7ff         	b	0x8059456 <prvProcessReceivedCommands+0x16e> @ imm = #-0x2
;                                 vPortFree( pxTimer );
 8059456: 9805         	ldr	r0, [sp, #0x14]
 8059458: 490d         	ldr	r1, [pc, #0x34]         @ 0x8059490 <prvProcessReceivedCommands+0x1a8>
 805945a: 4788         	blx	r1
;                             }
 805945c: e007         	b	0x805946e <prvProcessReceivedCommands+0x186> @ imm = #0xe
;                                 pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 805945e: 9905         	ldr	r1, [sp, #0x14]
 8059460: f891 0028    	ldrb.w	r0, [r1, #0x28]
 8059464: f000 00fe    	and	r0, r0, #0xfe
 8059468: f881 0028    	strb.w	r0, [r1, #0x28]
 805946c: e7ff         	b	0x805946e <prvProcessReceivedCommands+0x186> @ imm = #-0x2
;                         break;
 805946e: e000         	b	0x8059472 <prvProcessReceivedCommands+0x18a> @ imm = #0x0
;                         break;
 8059470: e7ff         	b	0x8059472 <prvProcessReceivedCommands+0x18a> @ imm = #-0x2
;             }
 8059472: e7ff         	b	0x8059474 <prvProcessReceivedCommands+0x18c> @ imm = #-0x2
;         while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8059474: e740         	b	0x80592f8 <prvProcessReceivedCommands+0x10> @ imm = #-0x180
;     }
 8059476: b00a         	add	sp, #0x28
 8059478: bc80         	pop	{r7}
 805947a: eba8 0809    	sub.w	r8, r8, r9
 805947e: f858 fd64    	ldr	pc, [r8, #-100]!
 8059482: bf00         	nop

08059484 <$d.41>:
 8059484: 5d b3 05 08  	.word	0x0805b35d
 8059488: 13 a5 05 08  	.word	0x0805a513
 805948c: a9 94 05 08  	.word	0x080594a9
 8059490: 61 9a 05 08  	.word	0x08059a61
 8059494: 2d 96 05 08  	.word	0x0805962d
 8059498: 15 d7 05 08  	.word	0x0805d715
 805949c: 2d 96 05 08  	.word	0x0805962d
 80594a0: e1 95 05 08  	.word	0x080595e1
 80594a4: 15 d7 05 08  	.word	0x0805d715

080594a8 <prvSampleTimeNow>:
;     {
 80594a8: f848 eb10    	str	lr, [r8], #16
 80594ac: eb08 0809    	add.w	r8, r8, r9
 80594b0: b480         	push	{r7}
 80594b2: 466f         	mov	r7, sp
 80594b4: b082         	sub	sp, #0x8
 80594b6: 9001         	str	r0, [sp, #0x4]
;         xTimeNow = xTaskGetTickCount();
 80594b8: 4811         	ldr	r0, [pc, #0x44]         @ 0x8059500 <prvSampleTimeNow+0x58>
 80594ba: 4780         	blx	r0
 80594bc: 9000         	str	r0, [sp]
;         if( xTimeNow < xLastTime )
 80594be: 9800         	ldr	r0, [sp]
 80594c0: f240 21f0    	movw	r1, #0x2f0
 80594c4: f2c2 0100    	movt	r1, #0x2000
 80594c8: 6809         	ldr	r1, [r1]
 80594ca: 4288         	cmp	r0, r1
 80594cc: d206         	bhs	0x80594dc <prvSampleTimeNow+0x34> @ imm = #0xc
 80594ce: e7ff         	b	0x80594d0 <prvSampleTimeNow+0x28> @ imm = #-0x2
;             prvSwitchTimerLists();
 80594d0: 480c         	ldr	r0, [pc, #0x30]         @ 0x8059504 <prvSampleTimeNow+0x5c>
 80594d2: 4780         	blx	r0
;             *pxTimerListsWereSwitched = pdTRUE;
 80594d4: 9901         	ldr	r1, [sp, #0x4]
 80594d6: 2001         	movs	r0, #0x1
 80594d8: 6008         	str	r0, [r1]
;         }
 80594da: e003         	b	0x80594e4 <prvSampleTimeNow+0x3c> @ imm = #0x6
;             *pxTimerListsWereSwitched = pdFALSE;
 80594dc: 9901         	ldr	r1, [sp, #0x4]
 80594de: 2000         	movs	r0, #0x0
 80594e0: 6008         	str	r0, [r1]
 80594e2: e7ff         	b	0x80594e4 <prvSampleTimeNow+0x3c> @ imm = #-0x2
;         xLastTime = xTimeNow;
 80594e4: 9800         	ldr	r0, [sp]
 80594e6: f240 21f0    	movw	r1, #0x2f0
 80594ea: f2c2 0100    	movt	r1, #0x2000
 80594ee: 6008         	str	r0, [r1]
;         return xTimeNow;
 80594f0: 9800         	ldr	r0, [sp]
 80594f2: b002         	add	sp, #0x8
 80594f4: bc80         	pop	{r7}
 80594f6: eba8 0809    	sub.w	r8, r8, r9
 80594fa: f858 fd10    	ldr	pc, [r8, #-16]!
 80594fe: bf00         	nop

08059500 <$d.43>:
 8059500: f5 6a 05 08  	.word	0x08056af5
 8059504: 79 95 05 08  	.word	0x08059579

08059508 <prvProcessExpiredTimer>:
;     {
 8059508: f848 eb30    	str	lr, [r8], #48
 805950c: eb08 0809    	add.w	r8, r8, r9
 8059510: b480         	push	{r7}
 8059512: 466f         	mov	r7, sp
 8059514: b084         	sub	sp, #0x10
 8059516: 9003         	str	r0, [sp, #0xc]
 8059518: 9102         	str	r1, [sp, #0x8]
;         Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 805951a: f240 20e8    	movw	r0, #0x2e8
 805951e: f2c2 0000    	movt	r0, #0x2000
 8059522: 6800         	ldr	r0, [r0]
 8059524: 68c0         	ldr	r0, [r0, #0xc]
 8059526: 68c0         	ldr	r0, [r0, #0xc]
 8059528: 9001         	str	r0, [sp, #0x4]
;         ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 805952a: 9801         	ldr	r0, [sp, #0x4]
 805952c: 3004         	adds	r0, #0x4
 805952e: 4910         	ldr	r1, [pc, #0x40]         @ 0x8059570 <prvProcessExpiredTimer+0x68>
 8059530: 4788         	blx	r1
;         if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8059532: 9801         	ldr	r0, [sp, #0x4]
 8059534: f890 0028    	ldrb.w	r0, [r0, #0x28]
 8059538: 0740         	lsls	r0, r0, #0x1d
 805953a: 2800         	cmp	r0, #0x0
 805953c: d506         	bpl	0x805954c <prvProcessExpiredTimer+0x44> @ imm = #0xc
 805953e: e7ff         	b	0x8059540 <prvProcessExpiredTimer+0x38> @ imm = #-0x2
;             prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
 8059540: 9801         	ldr	r0, [sp, #0x4]
 8059542: 9903         	ldr	r1, [sp, #0xc]
 8059544: 9a02         	ldr	r2, [sp, #0x8]
 8059546: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8059574 <prvProcessExpiredTimer+0x6c>
 8059548: 4798         	blx	r3
;         }
 805954a: e007         	b	0x805955c <prvProcessExpiredTimer+0x54> @ imm = #0xe
;             pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 805954c: 9901         	ldr	r1, [sp, #0x4]
 805954e: f891 0028    	ldrb.w	r0, [r1, #0x28]
 8059552: f000 00fe    	and	r0, r0, #0xfe
 8059556: f881 0028    	strb.w	r0, [r1, #0x28]
 805955a: e7ff         	b	0x805955c <prvProcessExpiredTimer+0x54> @ imm = #-0x2
;         pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 805955c: 9801         	ldr	r0, [sp, #0x4]
 805955e: 6a01         	ldr	r1, [r0, #0x20]
 8059560: 4788         	blx	r1
;     }
 8059562: b004         	add	sp, #0x10
 8059564: bc80         	pop	{r7}
 8059566: eba8 0809    	sub.w	r8, r8, r9
 805956a: f858 fd30    	ldr	pc, [r8, #-48]!
 805956e: bf00         	nop

08059570 <$d.45>:
 8059570: 13 a5 05 08  	.word	0x0805a513
 8059574: e1 95 05 08  	.word	0x080595e1

08059578 <prvSwitchTimerLists>:
;     {
 8059578: f848 eb2c    	str	lr, [r8], #44
 805957c: eb08 0809    	add.w	r8, r8, r9
 8059580: b480         	push	{r7}
 8059582: 466f         	mov	r7, sp
 8059584: b082         	sub	sp, #0x8
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8059586: e7ff         	b	0x8059588 <prvSwitchTimerLists+0x10> @ imm = #-0x2
 8059588: f240 20e8    	movw	r0, #0x2e8
 805958c: f2c2 0000    	movt	r0, #0x2000
 8059590: 6800         	ldr	r0, [r0]
 8059592: 6800         	ldr	r0, [r0]
 8059594: b170         	cbz	r0, 0x80595b4 <prvSwitchTimerLists+0x3c> @ imm = #0x1c
 8059596: e7ff         	b	0x8059598 <prvSwitchTimerLists+0x20> @ imm = #-0x2
;             xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8059598: f240 20e8    	movw	r0, #0x2e8
 805959c: f2c2 0000    	movt	r0, #0x2000
 80595a0: 6800         	ldr	r0, [r0]
 80595a2: 68c0         	ldr	r0, [r0, #0xc]
 80595a4: 6800         	ldr	r0, [r0]
 80595a6: 9001         	str	r0, [sp, #0x4]
;             prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
 80595a8: 9801         	ldr	r0, [sp, #0x4]
 80595aa: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x80595dc <prvSwitchTimerLists+0x64>
 80595ac: f04f 31ff    	mov.w	r1, #0xffffffff
 80595b0: 4790         	blx	r2
;         while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 80595b2: e7e9         	b	0x8059588 <prvSwitchTimerLists+0x10> @ imm = #-0x2e
;         pxTemp = pxCurrentTimerList;
 80595b4: f240 22e8    	movw	r2, #0x2e8
 80595b8: f2c2 0200    	movt	r2, #0x2000
 80595bc: 6810         	ldr	r0, [r2]
 80595be: 9000         	str	r0, [sp]
;         pxCurrentTimerList = pxOverflowTimerList;
 80595c0: f240 21ec    	movw	r1, #0x2ec
 80595c4: f2c2 0100    	movt	r1, #0x2000
 80595c8: 6808         	ldr	r0, [r1]
 80595ca: 6010         	str	r0, [r2]
;         pxOverflowTimerList = pxTemp;
 80595cc: 9800         	ldr	r0, [sp]
 80595ce: 6008         	str	r0, [r1]
;     }
 80595d0: b002         	add	sp, #0x8
 80595d2: bc80         	pop	{r7}
 80595d4: eba8 0809    	sub.w	r8, r8, r9
 80595d8: f858 fd2c    	ldr	pc, [r8, #-44]!

080595dc <$d.47>:
 80595dc: 09 95 05 08  	.word	0x08059509

080595e0 <prvReloadTimer>:
;     {
 80595e0: f848 eb18    	str	lr, [r8], #24
 80595e4: eb08 0809    	add.w	r8, r8, r9
 80595e8: b480         	push	{r7}
 80595ea: 466f         	mov	r7, sp
 80595ec: b084         	sub	sp, #0x10
 80595ee: 9003         	str	r0, [sp, #0xc]
 80595f0: 9102         	str	r1, [sp, #0x8]
 80595f2: 9201         	str	r2, [sp, #0x4]
;         while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 80595f4: e7ff         	b	0x80595f6 <prvReloadTimer+0x16> @ imm = #-0x2
 80595f6: 9803         	ldr	r0, [sp, #0xc]
 80595f8: 9b02         	ldr	r3, [sp, #0x8]
 80595fa: 6981         	ldr	r1, [r0, #0x18]
 80595fc: 4419         	add	r1, r3
 80595fe: 9a01         	ldr	r2, [sp, #0x4]
 8059600: f8df c024    	ldr.w	r12, [pc, #0x24]        @ 0x8059628 <prvReloadTimer+0x48>
 8059604: 47e0         	blx	r12
 8059606: b148         	cbz	r0, 0x805961c <prvReloadTimer+0x3c> @ imm = #0x12
 8059608: e7ff         	b	0x805960a <prvReloadTimer+0x2a> @ imm = #-0x2
;             xExpiredTime += pxTimer->xTimerPeriodInTicks;
 805960a: 9803         	ldr	r0, [sp, #0xc]
 805960c: 6981         	ldr	r1, [r0, #0x18]
 805960e: 9802         	ldr	r0, [sp, #0x8]
 8059610: 4408         	add	r0, r1
 8059612: 9002         	str	r0, [sp, #0x8]
;             pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8059614: 9803         	ldr	r0, [sp, #0xc]
 8059616: 6a01         	ldr	r1, [r0, #0x20]
 8059618: 4788         	blx	r1
;         while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 805961a: e7ec         	b	0x80595f6 <prvReloadTimer+0x16> @ imm = #-0x28
;     }
 805961c: b004         	add	sp, #0x10
 805961e: bc80         	pop	{r7}
 8059620: eba8 0809    	sub.w	r8, r8, r9
 8059624: f858 fd18    	ldr	pc, [r8, #-24]!

08059628 <$d.49>:
 8059628: 2d 96 05 08  	.word	0x0805962d

0805962c <prvInsertTimerInActiveList>:
;     {
 805962c: f848 eb04    	str	lr, [r8], #4
 8059630: eb08 0809    	add.w	r8, r8, r9
 8059634: b480         	push	{r7}
 8059636: 466f         	mov	r7, sp
 8059638: b086         	sub	sp, #0x18
 805963a: 9005         	str	r0, [sp, #0x14]
 805963c: 9104         	str	r1, [sp, #0x10]
 805963e: 9203         	str	r2, [sp, #0xc]
 8059640: 9302         	str	r3, [sp, #0x8]
 8059642: 2000         	movs	r0, #0x0
;         BaseType_t xProcessTimerNow = pdFALSE;
 8059644: 9001         	str	r0, [sp, #0x4]
;         listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8059646: 9804         	ldr	r0, [sp, #0x10]
 8059648: 9905         	ldr	r1, [sp, #0x14]
 805964a: 6048         	str	r0, [r1, #0x4]
;         listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 805964c: 9805         	ldr	r0, [sp, #0x14]
 805964e: 6100         	str	r0, [r0, #0x10]
;         if( xNextExpiryTime <= xTimeNow )
 8059650: 9804         	ldr	r0, [sp, #0x10]
 8059652: 9903         	ldr	r1, [sp, #0xc]
 8059654: 4288         	cmp	r0, r1
 8059656: d816         	bhi	0x8059686 <prvInsertTimerInActiveList+0x5a> @ imm = #0x2c
 8059658: e7ff         	b	0x805965a <prvInsertTimerInActiveList+0x2e> @ imm = #-0x2
;             if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 805965a: 9803         	ldr	r0, [sp, #0xc]
 805965c: 9902         	ldr	r1, [sp, #0x8]
 805965e: 1a40         	subs	r0, r0, r1
 8059660: 9905         	ldr	r1, [sp, #0x14]
 8059662: 6989         	ldr	r1, [r1, #0x18]
 8059664: 4288         	cmp	r0, r1
 8059666: d303         	blo	0x8059670 <prvInsertTimerInActiveList+0x44> @ imm = #0x6
 8059668: e7ff         	b	0x805966a <prvInsertTimerInActiveList+0x3e> @ imm = #-0x2
 805966a: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
 805966c: 9001         	str	r0, [sp, #0x4]
;             }
 805966e: e009         	b	0x8059684 <prvInsertTimerInActiveList+0x58> @ imm = #0x12
;                 vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8059670: f240 20ec    	movw	r0, #0x2ec
 8059674: f2c2 0000    	movt	r0, #0x2000
 8059678: 6800         	ldr	r0, [r0]
 805967a: 9905         	ldr	r1, [sp, #0x14]
 805967c: 3104         	adds	r1, #0x4
 805967e: 4a12         	ldr	r2, [pc, #0x48]         @ 0x80596c8 <prvInsertTimerInActiveList+0x9c>
 8059680: 4790         	blx	r2
 8059682: e7ff         	b	0x8059684 <prvInsertTimerInActiveList+0x58> @ imm = #-0x2
;         }
 8059684: e017         	b	0x80596b6 <prvInsertTimerInActiveList+0x8a> @ imm = #0x2e
;             if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8059686: 9803         	ldr	r0, [sp, #0xc]
 8059688: 9902         	ldr	r1, [sp, #0x8]
 805968a: 4288         	cmp	r0, r1
 805968c: d208         	bhs	0x80596a0 <prvInsertTimerInActiveList+0x74> @ imm = #0x10
 805968e: e7ff         	b	0x8059690 <prvInsertTimerInActiveList+0x64> @ imm = #-0x2
 8059690: 9804         	ldr	r0, [sp, #0x10]
 8059692: 9902         	ldr	r1, [sp, #0x8]
 8059694: 4288         	cmp	r0, r1
 8059696: d303         	blo	0x80596a0 <prvInsertTimerInActiveList+0x74> @ imm = #0x6
 8059698: e7ff         	b	0x805969a <prvInsertTimerInActiveList+0x6e> @ imm = #-0x2
 805969a: 2001         	movs	r0, #0x1
;                 xProcessTimerNow = pdTRUE;
 805969c: 9001         	str	r0, [sp, #0x4]
;             }
 805969e: e009         	b	0x80596b4 <prvInsertTimerInActiveList+0x88> @ imm = #0x12
;                 vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80596a0: f240 20e8    	movw	r0, #0x2e8
 80596a4: f2c2 0000    	movt	r0, #0x2000
 80596a8: 6800         	ldr	r0, [r0]
 80596aa: 9905         	ldr	r1, [sp, #0x14]
 80596ac: 3104         	adds	r1, #0x4
 80596ae: 4a05         	ldr	r2, [pc, #0x14]         @ 0x80596c4 <prvInsertTimerInActiveList+0x98>
 80596b0: 4790         	blx	r2
 80596b2: e7ff         	b	0x80596b4 <prvInsertTimerInActiveList+0x88> @ imm = #-0x2
 80596b4: e7ff         	b	0x80596b6 <prvInsertTimerInActiveList+0x8a> @ imm = #-0x2
;         return xProcessTimerNow;
 80596b6: 9801         	ldr	r0, [sp, #0x4]
 80596b8: b006         	add	sp, #0x18
 80596ba: bc80         	pop	{r7}
 80596bc: eba8 0809    	sub.w	r8, r8, r9
 80596c0: f858 fd04    	ldr	pc, [r8, #-4]!

080596c4 <$d.51>:
 80596c4: a9 a4 05 08  	.word	0x0805a4a9
 80596c8: a9 a4 05 08  	.word	0x0805a4a9

080596cc <pvPortMalloc>:
; {
 80596cc: f848 eb30    	str	lr, [r8], #48
 80596d0: eb08 0809    	add.w	r8, r8, r9
 80596d4: b480         	push	{r7}
 80596d6: 466f         	mov	r7, sp
 80596d8: b08a         	sub	sp, #0x28
 80596da: 9009         	str	r0, [sp, #0x24]
 80596dc: 2000         	movs	r0, #0x0
;     void * pvReturn = NULL;
 80596de: 9005         	str	r0, [sp, #0x14]
;     if( xWantedSize > 0 )
 80596e0: 9809         	ldr	r0, [sp, #0x24]
 80596e2: b340         	cbz	r0, 0x8059736 <pvPortMalloc+0x6a> @ imm = #0x50
 80596e4: e7ff         	b	0x80596e6 <pvPortMalloc+0x1a> @ imm = #-0x2
;         if( heapADD_WILL_OVERFLOW( xWantedSize, xHeapStructSize ) == 0 )
 80596e6: 9809         	ldr	r0, [sp, #0x24]
 80596e8: f110 0f09    	cmn.w	r0, #0x9
 80596ec: d81f         	bhi	0x805972e <pvPortMalloc+0x62> @ imm = #0x3e
 80596ee: e7ff         	b	0x80596f0 <pvPortMalloc+0x24> @ imm = #-0x2
;             xWantedSize += xHeapStructSize;
 80596f0: 9809         	ldr	r0, [sp, #0x24]
 80596f2: 3008         	adds	r0, #0x8
 80596f4: 9009         	str	r0, [sp, #0x24]
;             if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 80596f6: f89d 0024    	ldrb.w	r0, [sp, #0x24]
 80596fa: 0740         	lsls	r0, r0, #0x1d
 80596fc: b1a8         	cbz	r0, 0x805972a <pvPortMalloc+0x5e> @ imm = #0x2a
 80596fe: e7ff         	b	0x8059700 <pvPortMalloc+0x34> @ imm = #-0x2
;                 xAdditionalRequiredSize = portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK );
 8059700: 9809         	ldr	r0, [sp, #0x24]
 8059702: f000 0007    	and	r0, r0, #0x7
 8059706: f1c0 0008    	rsb.w	r0, r0, #0x8
 805970a: 9004         	str	r0, [sp, #0x10]
;                 if( heapADD_WILL_OVERFLOW( xWantedSize, xAdditionalRequiredSize ) == 0 )
 805970c: 9809         	ldr	r0, [sp, #0x24]
 805970e: 9904         	ldr	r1, [sp, #0x10]
 8059710: 43c9         	mvns	r1, r1
 8059712: 4288         	cmp	r0, r1
 8059714: d805         	bhi	0x8059722 <pvPortMalloc+0x56> @ imm = #0xa
 8059716: e7ff         	b	0x8059718 <pvPortMalloc+0x4c> @ imm = #-0x2
;                     xWantedSize += xAdditionalRequiredSize;
 8059718: 9904         	ldr	r1, [sp, #0x10]
 805971a: 9809         	ldr	r0, [sp, #0x24]
 805971c: 4408         	add	r0, r1
 805971e: 9009         	str	r0, [sp, #0x24]
;                 }
 8059720: e002         	b	0x8059728 <pvPortMalloc+0x5c> @ imm = #0x4
 8059722: 2000         	movs	r0, #0x0
;                     xWantedSize = 0;
 8059724: 9009         	str	r0, [sp, #0x24]
 8059726: e7ff         	b	0x8059728 <pvPortMalloc+0x5c> @ imm = #-0x2
;             }
 8059728: e000         	b	0x805972c <pvPortMalloc+0x60> @ imm = #0x0
 805972a: e7ff         	b	0x805972c <pvPortMalloc+0x60> @ imm = #-0x2
;         }
 805972c: e002         	b	0x8059734 <pvPortMalloc+0x68> @ imm = #0x4
 805972e: 2000         	movs	r0, #0x0
;             xWantedSize = 0;
 8059730: 9009         	str	r0, [sp, #0x24]
 8059732: e7ff         	b	0x8059734 <pvPortMalloc+0x68> @ imm = #-0x2
;     }
 8059734: e000         	b	0x8059738 <pvPortMalloc+0x6c> @ imm = #0x0
 8059736: e7ff         	b	0x8059738 <pvPortMalloc+0x6c> @ imm = #-0x2
;     vTaskSuspendAll();
 8059738: 4895         	ldr	r0, [pc, #0x254]        @ 0x8059990 <pvPortMalloc+0x2c4>
 805973a: 4780         	blx	r0
;         if( pxEnd == NULL )
 805973c: f240 301c    	movw	r0, #0x31c
 8059740: f2c2 0000    	movt	r0, #0x2000
 8059744: 6800         	ldr	r0, [r0]
 8059746: b918         	cbnz	r0, 0x8059750 <pvPortMalloc+0x84> @ imm = #0x6
 8059748: e7ff         	b	0x805974a <pvPortMalloc+0x7e> @ imm = #-0x2
;             prvHeapInit();
 805974a: 4892         	ldr	r0, [pc, #0x248]        @ 0x8059994 <pvPortMalloc+0x2c8>
 805974c: 4780         	blx	r0
;         }
 805974e: e000         	b	0x8059752 <pvPortMalloc+0x86> @ imm = #0x0
 8059750: e7ff         	b	0x8059752 <pvPortMalloc+0x86> @ imm = #-0x2
;         if( heapBLOCK_SIZE_IS_VALID( xWantedSize ) != 0 )
 8059752: f89d 0027    	ldrb.w	r0, [sp, #0x27]
 8059756: 0600         	lsls	r0, r0, #0x18
 8059758: 2800         	cmp	r0, #0x0
 805975a: f100 8105    	bmi.w	0x8059968 <pvPortMalloc+0x29c> @ imm = #0x20a
 805975e: e7ff         	b	0x8059760 <pvPortMalloc+0x94> @ imm = #-0x2
;             if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8059760: 9809         	ldr	r0, [sp, #0x24]
 8059762: 2800         	cmp	r0, #0x0
 8059764: f000 80fe    	beq.w	0x8059964 <pvPortMalloc+0x298> @ imm = #0x1fc
 8059768: e7ff         	b	0x805976a <pvPortMalloc+0x9e> @ imm = #-0x2
 805976a: 9809         	ldr	r0, [sp, #0x24]
 805976c: f240 3120    	movw	r1, #0x320
 8059770: f2c2 0100    	movt	r1, #0x2000
 8059774: 6809         	ldr	r1, [r1]
 8059776: 4288         	cmp	r0, r1
 8059778: f200 80f4    	bhi.w	0x8059964 <pvPortMalloc+0x298> @ imm = #0x1e8
 805977c: e7ff         	b	0x805977e <pvPortMalloc+0xb2> @ imm = #-0x2
;                 pxPreviousBlock = &xStart;
 805977e: f240 3024    	movw	r0, #0x324
 8059782: f2c2 0000    	movt	r0, #0x2000
 8059786: 9007         	str	r0, [sp, #0x1c]
;                 pxBlock = heapPROTECT_BLOCK_POINTER( xStart.pxNextFreeBlock );
 8059788: 6800         	ldr	r0, [r0]
 805978a: 9008         	str	r0, [sp, #0x20]
;                 heapVALIDATE_BLOCK_POINTER( pxBlock );
 805978c: 9908         	ldr	r1, [sp, #0x20]
 805978e: 2000         	movs	r0, #0x0
 8059790: f240 322c    	movw	r2, #0x32c
 8059794: f2c2 0200    	movt	r2, #0x2000
 8059798: 4291         	cmp	r1, r2
 805979a: 9003         	str	r0, [sp, #0xc]
 805979c: d30e         	blo	0x80597bc <pvPortMalloc+0xf0> @ imm = #0x1c
 805979e: e7ff         	b	0x80597a0 <pvPortMalloc+0xd4> @ imm = #-0x2
 80597a0: 9908         	ldr	r1, [sp, #0x20]
 80597a2: f240 302c    	movw	r0, #0x32c
 80597a6: f2c2 0000    	movt	r0, #0x2000
 80597aa: f641 72ff    	movw	r2, #0x1fff
 80597ae: 4402         	add	r2, r0
 80597b0: 2000         	movs	r0, #0x0
 80597b2: 4291         	cmp	r1, r2
 80597b4: bf98         	it	ls
 80597b6: 2001         	movls	r0, #0x1
 80597b8: 9003         	str	r0, [sp, #0xc]
 80597ba: e7ff         	b	0x80597bc <pvPortMalloc+0xf0> @ imm = #-0x2
 80597bc: 9803         	ldr	r0, [sp, #0xc]
;                 heapVALIDATE_BLOCK_POINTER( pxBlock );
 80597be: 07c0         	lsls	r0, r0, #0x1f
 80597c0: b920         	cbnz	r0, 0x80597cc <pvPortMalloc+0x100> @ imm = #0x8
 80597c2: e7ff         	b	0x80597c4 <pvPortMalloc+0xf8> @ imm = #-0x2
 80597c4: 487a         	ldr	r0, [pc, #0x1e8]        @ 0x80599b0 <pvPortMalloc+0x2e4>
 80597c6: 4780         	blx	r0
 80597c8: e7ff         	b	0x80597ca <pvPortMalloc+0xfe> @ imm = #-0x2
 80597ca: e7fe         	b	0x80597ca <pvPortMalloc+0xfe> @ imm = #-0x4
;                 while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
 80597cc: e7ff         	b	0x80597ce <pvPortMalloc+0x102> @ imm = #-0x2
 80597ce: 9808         	ldr	r0, [sp, #0x20]
 80597d0: 6841         	ldr	r1, [r0, #0x4]
 80597d2: 9a09         	ldr	r2, [sp, #0x24]
 80597d4: 2000         	movs	r0, #0x0
 80597d6: 4291         	cmp	r1, r2
 80597d8: 9002         	str	r0, [sp, #0x8]
 80597da: d207         	bhs	0x80597ec <pvPortMalloc+0x120> @ imm = #0xe
 80597dc: e7ff         	b	0x80597de <pvPortMalloc+0x112> @ imm = #-0x2
 80597de: 9808         	ldr	r0, [sp, #0x20]
 80597e0: 6800         	ldr	r0, [r0]
 80597e2: 2800         	cmp	r0, #0x0
 80597e4: bf18         	it	ne
 80597e6: 2001         	movne	r0, #0x1
 80597e8: 9002         	str	r0, [sp, #0x8]
 80597ea: e7ff         	b	0x80597ec <pvPortMalloc+0x120> @ imm = #-0x2
 80597ec: 9802         	ldr	r0, [sp, #0x8]
;                 while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
 80597ee: 07c0         	lsls	r0, r0, #0x1f
 80597f0: b330         	cbz	r0, 0x8059840 <pvPortMalloc+0x174> @ imm = #0x4c
 80597f2: e7ff         	b	0x80597f4 <pvPortMalloc+0x128> @ imm = #-0x2
;                     pxPreviousBlock = pxBlock;
 80597f4: 9808         	ldr	r0, [sp, #0x20]
 80597f6: 9007         	str	r0, [sp, #0x1c]
;                     pxBlock = heapPROTECT_BLOCK_POINTER( pxBlock->pxNextFreeBlock );
 80597f8: 9808         	ldr	r0, [sp, #0x20]
 80597fa: 6800         	ldr	r0, [r0]
 80597fc: 9008         	str	r0, [sp, #0x20]
;                     heapVALIDATE_BLOCK_POINTER( pxBlock );
 80597fe: 9908         	ldr	r1, [sp, #0x20]
 8059800: 2000         	movs	r0, #0x0
 8059802: f240 322c    	movw	r2, #0x32c
 8059806: f2c2 0200    	movt	r2, #0x2000
 805980a: 4291         	cmp	r1, r2
 805980c: 9001         	str	r0, [sp, #0x4]
 805980e: d30e         	blo	0x805982e <pvPortMalloc+0x162> @ imm = #0x1c
 8059810: e7ff         	b	0x8059812 <pvPortMalloc+0x146> @ imm = #-0x2
 8059812: 9908         	ldr	r1, [sp, #0x20]
 8059814: f240 302c    	movw	r0, #0x32c
 8059818: f2c2 0000    	movt	r0, #0x2000
 805981c: f641 72ff    	movw	r2, #0x1fff
 8059820: 4402         	add	r2, r0
 8059822: 2000         	movs	r0, #0x0
 8059824: 4291         	cmp	r1, r2
 8059826: bf98         	it	ls
 8059828: 2001         	movls	r0, #0x1
 805982a: 9001         	str	r0, [sp, #0x4]
 805982c: e7ff         	b	0x805982e <pvPortMalloc+0x162> @ imm = #-0x2
 805982e: 9801         	ldr	r0, [sp, #0x4]
;                     heapVALIDATE_BLOCK_POINTER( pxBlock );
 8059830: 07c0         	lsls	r0, r0, #0x1f
 8059832: b920         	cbnz	r0, 0x805983e <pvPortMalloc+0x172> @ imm = #0x8
 8059834: e7ff         	b	0x8059836 <pvPortMalloc+0x16a> @ imm = #-0x2
 8059836: 485d         	ldr	r0, [pc, #0x174]        @ 0x80599ac <pvPortMalloc+0x2e0>
 8059838: 4780         	blx	r0
 805983a: e7ff         	b	0x805983c <pvPortMalloc+0x170> @ imm = #-0x2
 805983c: e7fe         	b	0x805983c <pvPortMalloc+0x170> @ imm = #-0x4
;                 while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
 805983e: e7c6         	b	0x80597ce <pvPortMalloc+0x102> @ imm = #-0x74
;                 if( pxBlock != pxEnd )
 8059840: 9808         	ldr	r0, [sp, #0x20]
 8059842: f240 311c    	movw	r1, #0x31c
 8059846: f2c2 0100    	movt	r1, #0x2000
 805984a: 6809         	ldr	r1, [r1]
 805984c: 4288         	cmp	r0, r1
 805984e: f000 8087    	beq.w	0x8059960 <pvPortMalloc+0x294> @ imm = #0x10e
 8059852: e7ff         	b	0x8059854 <pvPortMalloc+0x188> @ imm = #-0x2
;                     pvReturn = ( void * ) ( ( ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxPreviousBlock->pxNextFreeBlock ) ) + xHeapStructSize );
 8059854: 9807         	ldr	r0, [sp, #0x1c]
 8059856: 6800         	ldr	r0, [r0]
 8059858: 3008         	adds	r0, #0x8
 805985a: 9005         	str	r0, [sp, #0x14]
;                     heapVALIDATE_BLOCK_POINTER( pvReturn );
 805985c: 9905         	ldr	r1, [sp, #0x14]
 805985e: 2000         	movs	r0, #0x0
 8059860: f240 322c    	movw	r2, #0x32c
 8059864: f2c2 0200    	movt	r2, #0x2000
 8059868: 4291         	cmp	r1, r2
 805986a: 9000         	str	r0, [sp]
 805986c: d30e         	blo	0x805988c <pvPortMalloc+0x1c0> @ imm = #0x1c
 805986e: e7ff         	b	0x8059870 <pvPortMalloc+0x1a4> @ imm = #-0x2
 8059870: 9905         	ldr	r1, [sp, #0x14]
 8059872: f240 302c    	movw	r0, #0x32c
 8059876: f2c2 0000    	movt	r0, #0x2000
 805987a: f641 72ff    	movw	r2, #0x1fff
 805987e: 4402         	add	r2, r0
 8059880: 2000         	movs	r0, #0x0
 8059882: 4291         	cmp	r1, r2
 8059884: bf98         	it	ls
 8059886: 2001         	movls	r0, #0x1
 8059888: 9000         	str	r0, [sp]
 805988a: e7ff         	b	0x805988c <pvPortMalloc+0x1c0> @ imm = #-0x2
 805988c: 9800         	ldr	r0, [sp]
;                     heapVALIDATE_BLOCK_POINTER( pvReturn );
 805988e: 07c0         	lsls	r0, r0, #0x1f
 8059890: b920         	cbnz	r0, 0x805989c <pvPortMalloc+0x1d0> @ imm = #0x8
 8059892: e7ff         	b	0x8059894 <pvPortMalloc+0x1c8> @ imm = #-0x2
 8059894: 4844         	ldr	r0, [pc, #0x110]        @ 0x80599a8 <pvPortMalloc+0x2dc>
 8059896: 4780         	blx	r0
 8059898: e7ff         	b	0x805989a <pvPortMalloc+0x1ce> @ imm = #-0x2
 805989a: e7fe         	b	0x805989a <pvPortMalloc+0x1ce> @ imm = #-0x4
;                     pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 805989c: 9808         	ldr	r0, [sp, #0x20]
 805989e: 6800         	ldr	r0, [r0]
 80598a0: 9907         	ldr	r1, [sp, #0x1c]
 80598a2: 6008         	str	r0, [r1]
;                     configASSERT( heapSUBTRACT_WILL_UNDERFLOW( pxBlock->xBlockSize, xWantedSize ) == 0 );
 80598a4: 9808         	ldr	r0, [sp, #0x20]
 80598a6: 6840         	ldr	r0, [r0, #0x4]
 80598a8: 9909         	ldr	r1, [sp, #0x24]
 80598aa: 4288         	cmp	r0, r1
 80598ac: d204         	bhs	0x80598b8 <pvPortMalloc+0x1ec> @ imm = #0x8
 80598ae: e7ff         	b	0x80598b0 <pvPortMalloc+0x1e4> @ imm = #-0x2
 80598b0: 483c         	ldr	r0, [pc, #0xf0]         @ 0x80599a4 <pvPortMalloc+0x2d8>
 80598b2: 4780         	blx	r0
 80598b4: e7ff         	b	0x80598b6 <pvPortMalloc+0x1ea> @ imm = #-0x2
 80598b6: e7fe         	b	0x80598b6 <pvPortMalloc+0x1ea> @ imm = #-0x4
;                     if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80598b8: 9808         	ldr	r0, [sp, #0x20]
 80598ba: 6840         	ldr	r0, [r0, #0x4]
 80598bc: 9909         	ldr	r1, [sp, #0x24]
 80598be: 1a40         	subs	r0, r0, r1
 80598c0: 2811         	cmp	r0, #0x11
 80598c2: d31e         	blo	0x8059902 <pvPortMalloc+0x236> @ imm = #0x3c
 80598c4: e7ff         	b	0x80598c6 <pvPortMalloc+0x1fa> @ imm = #-0x2
;                         pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 80598c6: 9808         	ldr	r0, [sp, #0x20]
 80598c8: 9909         	ldr	r1, [sp, #0x24]
 80598ca: 4408         	add	r0, r1
 80598cc: 9006         	str	r0, [sp, #0x18]
;                         configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 80598ce: f89d 0018    	ldrb.w	r0, [sp, #0x18]
 80598d2: 0740         	lsls	r0, r0, #0x1d
 80598d4: b120         	cbz	r0, 0x80598e0 <pvPortMalloc+0x214> @ imm = #0x8
 80598d6: e7ff         	b	0x80598d8 <pvPortMalloc+0x20c> @ imm = #-0x2
 80598d8: 4831         	ldr	r0, [pc, #0xc4]         @ 0x80599a0 <pvPortMalloc+0x2d4>
 80598da: 4780         	blx	r0
 80598dc: e7ff         	b	0x80598de <pvPortMalloc+0x212> @ imm = #-0x2
 80598de: e7fe         	b	0x80598de <pvPortMalloc+0x212> @ imm = #-0x4
;                         pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 80598e0: 9808         	ldr	r0, [sp, #0x20]
 80598e2: 6840         	ldr	r0, [r0, #0x4]
 80598e4: 9909         	ldr	r1, [sp, #0x24]
 80598e6: 1a40         	subs	r0, r0, r1
 80598e8: 9906         	ldr	r1, [sp, #0x18]
 80598ea: 6048         	str	r0, [r1, #0x4]
;                         pxBlock->xBlockSize = xWantedSize;
 80598ec: 9809         	ldr	r0, [sp, #0x24]
 80598ee: 9908         	ldr	r1, [sp, #0x20]
 80598f0: 6048         	str	r0, [r1, #0x4]
;                         pxNewBlockLink->pxNextFreeBlock = pxPreviousBlock->pxNextFreeBlock;
 80598f2: 9807         	ldr	r0, [sp, #0x1c]
 80598f4: 6800         	ldr	r0, [r0]
 80598f6: 9906         	ldr	r1, [sp, #0x18]
 80598f8: 6008         	str	r0, [r1]
;                         pxPreviousBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxNewBlockLink );
 80598fa: 9806         	ldr	r0, [sp, #0x18]
 80598fc: 9907         	ldr	r1, [sp, #0x1c]
 80598fe: 6008         	str	r0, [r1]
;                     }
 8059900: e000         	b	0x8059904 <pvPortMalloc+0x238> @ imm = #0x0
 8059902: e7ff         	b	0x8059904 <pvPortMalloc+0x238> @ imm = #-0x2
;                     xFreeBytesRemaining -= pxBlock->xBlockSize;
 8059904: 9808         	ldr	r0, [sp, #0x20]
 8059906: 6842         	ldr	r2, [r0, #0x4]
 8059908: f240 3020    	movw	r0, #0x320
 805990c: f2c2 0000    	movt	r0, #0x2000
 8059910: 6801         	ldr	r1, [r0]
 8059912: 1a89         	subs	r1, r1, r2
 8059914: 6001         	str	r1, [r0]
;                     if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8059916: 6800         	ldr	r0, [r0]
 8059918: f242 312c    	movw	r1, #0x232c
 805991c: f2c2 0100    	movt	r1, #0x2000
 8059920: 6809         	ldr	r1, [r1]
 8059922: 4288         	cmp	r0, r1
 8059924: d20b         	bhs	0x805993e <pvPortMalloc+0x272> @ imm = #0x16
 8059926: e7ff         	b	0x8059928 <pvPortMalloc+0x25c> @ imm = #-0x2
;                         xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8059928: f240 3020    	movw	r0, #0x320
 805992c: f2c2 0000    	movt	r0, #0x2000
 8059930: 6800         	ldr	r0, [r0]
 8059932: f242 312c    	movw	r1, #0x232c
 8059936: f2c2 0100    	movt	r1, #0x2000
 805993a: 6008         	str	r0, [r1]
;                     }
 805993c: e000         	b	0x8059940 <pvPortMalloc+0x274> @ imm = #0x0
 805993e: e7ff         	b	0x8059940 <pvPortMalloc+0x274> @ imm = #-0x2
;                     heapALLOCATE_BLOCK( pxBlock );
 8059940: 9908         	ldr	r1, [sp, #0x20]
 8059942: 6848         	ldr	r0, [r1, #0x4]
 8059944: f040 4000    	orr	r0, r0, #0x80000000
 8059948: 6048         	str	r0, [r1, #0x4]
;                     pxBlock->pxNextFreeBlock = NULL;
 805994a: 9908         	ldr	r1, [sp, #0x20]
 805994c: 2000         	movs	r0, #0x0
 805994e: 6008         	str	r0, [r1]
;                     xNumberOfSuccessfulAllocations++;
 8059950: f242 3130    	movw	r1, #0x2330
 8059954: f2c2 0100    	movt	r1, #0x2000
 8059958: 6808         	ldr	r0, [r1]
 805995a: 3001         	adds	r0, #0x1
 805995c: 6008         	str	r0, [r1]
;                 }
 805995e: e000         	b	0x8059962 <pvPortMalloc+0x296> @ imm = #0x0
 8059960: e7ff         	b	0x8059962 <pvPortMalloc+0x296> @ imm = #-0x2
;             }
 8059962: e000         	b	0x8059966 <pvPortMalloc+0x29a> @ imm = #0x0
 8059964: e7ff         	b	0x8059966 <pvPortMalloc+0x29a> @ imm = #-0x2
;         }
 8059966: e000         	b	0x805996a <pvPortMalloc+0x29e> @ imm = #0x0
 8059968: e7ff         	b	0x805996a <pvPortMalloc+0x29e> @ imm = #-0x2
;     ( void ) xTaskResumeAll();
 805996a: 480b         	ldr	r0, [pc, #0x2c]         @ 0x8059998 <pvPortMalloc+0x2cc>
 805996c: 4780         	blx	r0
;     configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 805996e: f89d 0014    	ldrb.w	r0, [sp, #0x14]
 8059972: 0740         	lsls	r0, r0, #0x1d
 8059974: b120         	cbz	r0, 0x8059980 <pvPortMalloc+0x2b4> @ imm = #0x8
 8059976: e7ff         	b	0x8059978 <pvPortMalloc+0x2ac> @ imm = #-0x2
 8059978: 4808         	ldr	r0, [pc, #0x20]         @ 0x805999c <pvPortMalloc+0x2d0>
 805997a: 4780         	blx	r0
 805997c: e7ff         	b	0x805997e <pvPortMalloc+0x2b2> @ imm = #-0x2
 805997e: e7fe         	b	0x805997e <pvPortMalloc+0x2b2> @ imm = #-0x4
;     return pvReturn;
 8059980: 9805         	ldr	r0, [sp, #0x14]
 8059982: b00a         	add	sp, #0x28
 8059984: bc80         	pop	{r7}
 8059986: eba8 0809    	sub.w	r8, r8, r9
 805998a: f858 fd30    	ldr	pc, [r8, #-48]!
 805998e: bf00         	nop

08059990 <$d.1>:
 8059990: d9 58 05 08  	.word	0x080558d9
 8059994: b5 99 05 08  	.word	0x080599b5
 8059998: 0d 5a 05 08  	.word	0x08055a0d
 805999c: 15 d7 05 08  	.word	0x0805d715
 80599a0: 15 d7 05 08  	.word	0x0805d715
 80599a4: 15 d7 05 08  	.word	0x0805d715
 80599a8: 15 d7 05 08  	.word	0x0805d715
 80599ac: 15 d7 05 08  	.word	0x0805d715
 80599b0: 15 d7 05 08  	.word	0x0805d715

080599b4 <prvHeapInit>:
; {
 80599b4: b084         	sub	sp, #0x10
 80599b6: f44f 5000    	mov.w	r0, #0x2000
;     size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 80599ba: 9000         	str	r0, [sp]
;     uxStartAddress = ( portPOINTER_SIZE_TYPE ) ucHeap;
 80599bc: f240 302c    	movw	r0, #0x32c
 80599c0: f2c2 0000    	movt	r0, #0x2000
 80599c4: 9002         	str	r0, [sp, #0x8]
;     if( ( uxStartAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 80599c6: f89d 0008    	ldrb.w	r0, [sp, #0x8]
 80599ca: 0740         	lsls	r0, r0, #0x1d
 80599cc: b188         	cbz	r0, 0x80599f2 <prvHeapInit+0x3e> @ imm = #0x22
 80599ce: e7ff         	b	0x80599d0 <prvHeapInit+0x1c> @ imm = #-0x2
;         uxStartAddress += ( portBYTE_ALIGNMENT - 1 );
 80599d0: 9802         	ldr	r0, [sp, #0x8]
 80599d2: 3007         	adds	r0, #0x7
 80599d4: 9002         	str	r0, [sp, #0x8]
;         uxStartAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
 80599d6: 9802         	ldr	r0, [sp, #0x8]
 80599d8: f020 0007    	bic	r0, r0, #0x7
 80599dc: 9002         	str	r0, [sp, #0x8]
;         xTotalHeapSize -= ( size_t ) ( uxStartAddress - ( portPOINTER_SIZE_TYPE ) ucHeap );
 80599de: 9a02         	ldr	r2, [sp, #0x8]
 80599e0: f240 312c    	movw	r1, #0x32c
 80599e4: f2c2 0100    	movt	r1, #0x2000
 80599e8: 9800         	ldr	r0, [sp]
 80599ea: 1a89         	subs	r1, r1, r2
 80599ec: 4408         	add	r0, r1
 80599ee: 9000         	str	r0, [sp]
;     }
 80599f0: e7ff         	b	0x80599f2 <prvHeapInit+0x3e> @ imm = #-0x2
;     xStart.pxNextFreeBlock = ( void * ) heapPROTECT_BLOCK_POINTER( uxStartAddress );
 80599f2: 9902         	ldr	r1, [sp, #0x8]
 80599f4: f240 3024    	movw	r0, #0x324
 80599f8: f2c2 0000    	movt	r0, #0x2000
 80599fc: 6001         	str	r1, [r0]
 80599fe: 2100         	movs	r1, #0x0
;     xStart.xBlockSize = ( size_t ) 0;
 8059a00: 6041         	str	r1, [r0, #0x4]
;     uxEndAddress = uxStartAddress + ( portPOINTER_SIZE_TYPE ) xTotalHeapSize;
 8059a02: 9802         	ldr	r0, [sp, #0x8]
 8059a04: 9a00         	ldr	r2, [sp]
 8059a06: 4410         	add	r0, r2
 8059a08: 9001         	str	r0, [sp, #0x4]
;     uxEndAddress -= ( portPOINTER_SIZE_TYPE ) xHeapStructSize;
 8059a0a: 9801         	ldr	r0, [sp, #0x4]
 8059a0c: 3808         	subs	r0, #0x8
 8059a0e: 9001         	str	r0, [sp, #0x4]
;     uxEndAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
 8059a10: 9801         	ldr	r0, [sp, #0x4]
 8059a12: f020 0007    	bic	r0, r0, #0x7
 8059a16: 9001         	str	r0, [sp, #0x4]
;     pxEnd = ( BlockLink_t * ) uxEndAddress;
 8059a18: 9a01         	ldr	r2, [sp, #0x4]
 8059a1a: f240 301c    	movw	r0, #0x31c
 8059a1e: f2c2 0000    	movt	r0, #0x2000
 8059a22: 6002         	str	r2, [r0]
;     pxEnd->xBlockSize = 0;
 8059a24: 6802         	ldr	r2, [r0]
 8059a26: 6051         	str	r1, [r2, #0x4]
;     pxEnd->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( NULL );
 8059a28: 6802         	ldr	r2, [r0]
 8059a2a: 6011         	str	r1, [r2]
;     pxFirstFreeBlock = ( BlockLink_t * ) uxStartAddress;
 8059a2c: 9902         	ldr	r1, [sp, #0x8]
 8059a2e: 9103         	str	r1, [sp, #0xc]
;     pxFirstFreeBlock->xBlockSize = ( size_t ) ( uxEndAddress - ( portPOINTER_SIZE_TYPE ) pxFirstFreeBlock );
 8059a30: 9901         	ldr	r1, [sp, #0x4]
 8059a32: 9a03         	ldr	r2, [sp, #0xc]
 8059a34: 1a89         	subs	r1, r1, r2
 8059a36: 6051         	str	r1, [r2, #0x4]
;     pxFirstFreeBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxEnd );
 8059a38: 6800         	ldr	r0, [r0]
 8059a3a: 9903         	ldr	r1, [sp, #0xc]
 8059a3c: 6008         	str	r0, [r1]
;     xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8059a3e: 9803         	ldr	r0, [sp, #0xc]
 8059a40: 6840         	ldr	r0, [r0, #0x4]
 8059a42: f242 312c    	movw	r1, #0x232c
 8059a46: f2c2 0100    	movt	r1, #0x2000
 8059a4a: 6008         	str	r0, [r1]
;     xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8059a4c: 9803         	ldr	r0, [sp, #0xc]
 8059a4e: 6840         	ldr	r0, [r0, #0x4]
 8059a50: f240 3120    	movw	r1, #0x320
 8059a54: f2c2 0100    	movt	r1, #0x2000
 8059a58: 6008         	str	r0, [r1]
; }
 8059a5a: b004         	add	sp, #0x10
 8059a5c: 4770         	bx	lr
 8059a5e: bf00         	nop

08059a60 <vPortFree>:
; {
 8059a60: f848 eb20    	str	lr, [r8], #32
 8059a64: eb08 0809    	add.w	r8, r8, r9
 8059a68: b480         	push	{r7}
 8059a6a: 466f         	mov	r7, sp
 8059a6c: b084         	sub	sp, #0x10
 8059a6e: 9003         	str	r0, [sp, #0xc]
;     uint8_t * puc = ( uint8_t * ) pv;
 8059a70: 9803         	ldr	r0, [sp, #0xc]
 8059a72: 9002         	str	r0, [sp, #0x8]
;     if( pv != NULL )
 8059a74: 9803         	ldr	r0, [sp, #0xc]
 8059a76: 2800         	cmp	r0, #0x0
 8059a78: d064         	beq	0x8059b44 <vPortFree+0xe4> @ imm = #0xc8
 8059a7a: e7ff         	b	0x8059a7c <vPortFree+0x1c> @ imm = #-0x2
;         puc -= xHeapStructSize;
 8059a7c: 9802         	ldr	r0, [sp, #0x8]
 8059a7e: 3808         	subs	r0, #0x8
 8059a80: 9002         	str	r0, [sp, #0x8]
;         pxLink = ( void * ) puc;
 8059a82: 9802         	ldr	r0, [sp, #0x8]
 8059a84: 9001         	str	r0, [sp, #0x4]
;         heapVALIDATE_BLOCK_POINTER( pxLink );
 8059a86: 9901         	ldr	r1, [sp, #0x4]
 8059a88: 2000         	movs	r0, #0x0
 8059a8a: f240 322c    	movw	r2, #0x32c
 8059a8e: f2c2 0200    	movt	r2, #0x2000
 8059a92: 4291         	cmp	r1, r2
 8059a94: 9000         	str	r0, [sp]
 8059a96: d30e         	blo	0x8059ab6 <vPortFree+0x56> @ imm = #0x1c
 8059a98: e7ff         	b	0x8059a9a <vPortFree+0x3a> @ imm = #-0x2
 8059a9a: 9901         	ldr	r1, [sp, #0x4]
 8059a9c: f240 302c    	movw	r0, #0x32c
 8059aa0: f2c2 0000    	movt	r0, #0x2000
 8059aa4: f641 72ff    	movw	r2, #0x1fff
 8059aa8: 4402         	add	r2, r0
 8059aaa: 2000         	movs	r0, #0x0
 8059aac: 4291         	cmp	r1, r2
 8059aae: bf98         	it	ls
 8059ab0: 2001         	movls	r0, #0x1
 8059ab2: 9000         	str	r0, [sp]
 8059ab4: e7ff         	b	0x8059ab6 <vPortFree+0x56> @ imm = #-0x2
 8059ab6: 9800         	ldr	r0, [sp]
;         heapVALIDATE_BLOCK_POINTER( pxLink );
 8059ab8: 07c0         	lsls	r0, r0, #0x1f
 8059aba: b920         	cbnz	r0, 0x8059ac6 <vPortFree+0x66> @ imm = #0x8
 8059abc: e7ff         	b	0x8059abe <vPortFree+0x5e> @ imm = #-0x2
 8059abe: 4829         	ldr	r0, [pc, #0xa4]         @ 0x8059b64 <vPortFree+0x104>
 8059ac0: 4780         	blx	r0
 8059ac2: e7ff         	b	0x8059ac4 <vPortFree+0x64> @ imm = #-0x2
 8059ac4: e7fe         	b	0x8059ac4 <vPortFree+0x64> @ imm = #-0x4
;         configASSERT( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 );
 8059ac6: 9801         	ldr	r0, [sp, #0x4]
 8059ac8: 79c1         	ldrb	r1, [r0, #0x7]
 8059aca: 2000         	movs	r0, #0x0
 8059acc: ebb0 1fd1    	cmp.w	r0, r1, lsr #7
 8059ad0: d104         	bne	0x8059adc <vPortFree+0x7c> @ imm = #0x8
 8059ad2: e7ff         	b	0x8059ad4 <vPortFree+0x74> @ imm = #-0x2
 8059ad4: 4822         	ldr	r0, [pc, #0x88]         @ 0x8059b60 <vPortFree+0x100>
 8059ad6: 4780         	blx	r0
 8059ad8: e7ff         	b	0x8059ada <vPortFree+0x7a> @ imm = #-0x2
 8059ada: e7fe         	b	0x8059ada <vPortFree+0x7a> @ imm = #-0x4
;         configASSERT( pxLink->pxNextFreeBlock == NULL );
 8059adc: 9801         	ldr	r0, [sp, #0x4]
 8059ade: 6800         	ldr	r0, [r0]
 8059ae0: b120         	cbz	r0, 0x8059aec <vPortFree+0x8c> @ imm = #0x8
 8059ae2: e7ff         	b	0x8059ae4 <vPortFree+0x84> @ imm = #-0x2
 8059ae4: 481d         	ldr	r0, [pc, #0x74]         @ 0x8059b5c <vPortFree+0xfc>
 8059ae6: 4780         	blx	r0
 8059ae8: e7ff         	b	0x8059aea <vPortFree+0x8a> @ imm = #-0x2
 8059aea: e7fe         	b	0x8059aea <vPortFree+0x8a> @ imm = #-0x4
;         if( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 )
 8059aec: 9801         	ldr	r0, [sp, #0x4]
 8059aee: 79c1         	ldrb	r1, [r0, #0x7]
 8059af0: 2000         	movs	r0, #0x0
 8059af2: ebb0 1fd1    	cmp.w	r0, r1, lsr #7
 8059af6: d023         	beq	0x8059b40 <vPortFree+0xe0> @ imm = #0x46
 8059af8: e7ff         	b	0x8059afa <vPortFree+0x9a> @ imm = #-0x2
;             if( pxLink->pxNextFreeBlock == NULL )
 8059afa: 9801         	ldr	r0, [sp, #0x4]
 8059afc: 6800         	ldr	r0, [r0]
 8059afe: b9e8         	cbnz	r0, 0x8059b3c <vPortFree+0xdc> @ imm = #0x3a
 8059b00: e7ff         	b	0x8059b02 <vPortFree+0xa2> @ imm = #-0x2
;                 heapFREE_BLOCK( pxLink );
 8059b02: 9901         	ldr	r1, [sp, #0x4]
 8059b04: 6848         	ldr	r0, [r1, #0x4]
 8059b06: f020 4000    	bic	r0, r0, #0x80000000
 8059b0a: 6048         	str	r0, [r1, #0x4]
;                 vTaskSuspendAll();
 8059b0c: 4810         	ldr	r0, [pc, #0x40]         @ 0x8059b50 <vPortFree+0xf0>
 8059b0e: 4780         	blx	r0
;                     xFreeBytesRemaining += pxLink->xBlockSize;
 8059b10: 9801         	ldr	r0, [sp, #0x4]
 8059b12: 6842         	ldr	r2, [r0, #0x4]
 8059b14: f240 3120    	movw	r1, #0x320
 8059b18: f2c2 0100    	movt	r1, #0x2000
 8059b1c: 6808         	ldr	r0, [r1]
 8059b1e: 4410         	add	r0, r2
 8059b20: 6008         	str	r0, [r1]
;                     prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8059b22: 9801         	ldr	r0, [sp, #0x4]
 8059b24: 490b         	ldr	r1, [pc, #0x2c]         @ 0x8059b54 <vPortFree+0xf4>
 8059b26: 4788         	blx	r1
;                     xNumberOfSuccessfulFrees++;
 8059b28: f242 3134    	movw	r1, #0x2334
 8059b2c: f2c2 0100    	movt	r1, #0x2000
 8059b30: 6808         	ldr	r0, [r1]
 8059b32: 3001         	adds	r0, #0x1
 8059b34: 6008         	str	r0, [r1]
;                 ( void ) xTaskResumeAll();
 8059b36: 4808         	ldr	r0, [pc, #0x20]         @ 0x8059b58 <vPortFree+0xf8>
 8059b38: 4780         	blx	r0
;             }
 8059b3a: e000         	b	0x8059b3e <vPortFree+0xde> @ imm = #0x0
 8059b3c: e7ff         	b	0x8059b3e <vPortFree+0xde> @ imm = #-0x2
;         }
 8059b3e: e000         	b	0x8059b42 <vPortFree+0xe2> @ imm = #0x0
 8059b40: e7ff         	b	0x8059b42 <vPortFree+0xe2> @ imm = #-0x2
;     }
 8059b42: e7ff         	b	0x8059b44 <vPortFree+0xe4> @ imm = #-0x2
; }
 8059b44: b004         	add	sp, #0x10
 8059b46: bc80         	pop	{r7}
 8059b48: eba8 0809    	sub.w	r8, r8, r9
 8059b4c: f858 fd20    	ldr	pc, [r8, #-32]!

08059b50 <$d.3>:
 8059b50: d9 58 05 08  	.word	0x080558d9
 8059b54: 69 9b 05 08  	.word	0x08059b69
 8059b58: 0d 5a 05 08  	.word	0x08055a0d
 8059b5c: 15 d7 05 08  	.word	0x0805d715
 8059b60: 15 d7 05 08  	.word	0x0805d715
 8059b64: 15 d7 05 08  	.word	0x0805d715

08059b68 <prvInsertBlockIntoFreeList>:
; {
 8059b68: f848 eb04    	str	lr, [r8], #4
 8059b6c: eb08 0809    	add.w	r8, r8, r9
 8059b70: b480         	push	{r7}
 8059b72: 466f         	mov	r7, sp
 8059b74: b084         	sub	sp, #0x10
 8059b76: 9003         	str	r0, [sp, #0xc]
;     for( pxIterator = &xStart; heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) < pxBlockToInsert; pxIterator = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
 8059b78: f240 3024    	movw	r0, #0x324
 8059b7c: f2c2 0000    	movt	r0, #0x2000
 8059b80: 9002         	str	r0, [sp, #0x8]
 8059b82: e7ff         	b	0x8059b84 <prvInsertBlockIntoFreeList+0x1c> @ imm = #-0x2
 8059b84: 9802         	ldr	r0, [sp, #0x8]
 8059b86: 6800         	ldr	r0, [r0]
 8059b88: 9903         	ldr	r1, [sp, #0xc]
 8059b8a: 4288         	cmp	r0, r1
 8059b8c: d205         	bhs	0x8059b9a <prvInsertBlockIntoFreeList+0x32> @ imm = #0xa
 8059b8e: e7ff         	b	0x8059b90 <prvInsertBlockIntoFreeList+0x28> @ imm = #-0x2
;     }
 8059b90: e7ff         	b	0x8059b92 <prvInsertBlockIntoFreeList+0x2a> @ imm = #-0x2
;     for( pxIterator = &xStart; heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) < pxBlockToInsert; pxIterator = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
 8059b92: 9802         	ldr	r0, [sp, #0x8]
 8059b94: 6800         	ldr	r0, [r0]
 8059b96: 9002         	str	r0, [sp, #0x8]
 8059b98: e7f4         	b	0x8059b84 <prvInsertBlockIntoFreeList+0x1c> @ imm = #-0x18
;     if( pxIterator != &xStart )
 8059b9a: 9802         	ldr	r0, [sp, #0x8]
 8059b9c: f240 3124    	movw	r1, #0x324
 8059ba0: f2c2 0100    	movt	r1, #0x2000
 8059ba4: 4288         	cmp	r0, r1
 8059ba6: d021         	beq	0x8059bec <prvInsertBlockIntoFreeList+0x84> @ imm = #0x42
 8059ba8: e7ff         	b	0x8059baa <prvInsertBlockIntoFreeList+0x42> @ imm = #-0x2
;         heapVALIDATE_BLOCK_POINTER( pxIterator );
 8059baa: 9902         	ldr	r1, [sp, #0x8]
 8059bac: 2000         	movs	r0, #0x0
 8059bae: f240 322c    	movw	r2, #0x32c
 8059bb2: f2c2 0200    	movt	r2, #0x2000
 8059bb6: 4291         	cmp	r1, r2
 8059bb8: 9000         	str	r0, [sp]
 8059bba: d30e         	blo	0x8059bda <prvInsertBlockIntoFreeList+0x72> @ imm = #0x1c
 8059bbc: e7ff         	b	0x8059bbe <prvInsertBlockIntoFreeList+0x56> @ imm = #-0x2
 8059bbe: 9902         	ldr	r1, [sp, #0x8]
 8059bc0: f240 302c    	movw	r0, #0x32c
 8059bc4: f2c2 0000    	movt	r0, #0x2000
 8059bc8: f641 72ff    	movw	r2, #0x1fff
 8059bcc: 4402         	add	r2, r0
 8059bce: 2000         	movs	r0, #0x0
 8059bd0: 4291         	cmp	r1, r2
 8059bd2: bf98         	it	ls
 8059bd4: 2001         	movls	r0, #0x1
 8059bd6: 9000         	str	r0, [sp]
 8059bd8: e7ff         	b	0x8059bda <prvInsertBlockIntoFreeList+0x72> @ imm = #-0x2
 8059bda: 9800         	ldr	r0, [sp]
;         heapVALIDATE_BLOCK_POINTER( pxIterator );
 8059bdc: 07c0         	lsls	r0, r0, #0x1f
 8059bde: b920         	cbnz	r0, 0x8059bea <prvInsertBlockIntoFreeList+0x82> @ imm = #0x8
 8059be0: e7ff         	b	0x8059be2 <prvInsertBlockIntoFreeList+0x7a> @ imm = #-0x2
 8059be2: 482c         	ldr	r0, [pc, #0xb0]         @ 0x8059c94 <prvInsertBlockIntoFreeList+0x12c>
 8059be4: 4780         	blx	r0
 8059be6: e7ff         	b	0x8059be8 <prvInsertBlockIntoFreeList+0x80> @ imm = #-0x2
 8059be8: e7fe         	b	0x8059be8 <prvInsertBlockIntoFreeList+0x80> @ imm = #-0x4
;     }
 8059bea: e7ff         	b	0x8059bec <prvInsertBlockIntoFreeList+0x84> @ imm = #-0x2
;     puc = ( uint8_t * ) pxIterator;
 8059bec: 9802         	ldr	r0, [sp, #0x8]
 8059bee: 9001         	str	r0, [sp, #0x4]
;     if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8059bf0: 9801         	ldr	r0, [sp, #0x4]
 8059bf2: 9902         	ldr	r1, [sp, #0x8]
 8059bf4: 6849         	ldr	r1, [r1, #0x4]
 8059bf6: 4408         	add	r0, r1
 8059bf8: 9903         	ldr	r1, [sp, #0xc]
 8059bfa: 4288         	cmp	r0, r1
 8059bfc: d109         	bne	0x8059c12 <prvInsertBlockIntoFreeList+0xaa> @ imm = #0x12
 8059bfe: e7ff         	b	0x8059c00 <prvInsertBlockIntoFreeList+0x98> @ imm = #-0x2
;         pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8059c00: 9803         	ldr	r0, [sp, #0xc]
 8059c02: 6842         	ldr	r2, [r0, #0x4]
 8059c04: 9902         	ldr	r1, [sp, #0x8]
 8059c06: 6848         	ldr	r0, [r1, #0x4]
 8059c08: 4410         	add	r0, r2
 8059c0a: 6048         	str	r0, [r1, #0x4]
;         pxBlockToInsert = pxIterator;
 8059c0c: 9802         	ldr	r0, [sp, #0x8]
 8059c0e: 9003         	str	r0, [sp, #0xc]
;     }
 8059c10: e000         	b	0x8059c14 <prvInsertBlockIntoFreeList+0xac> @ imm = #0x0
 8059c12: e7ff         	b	0x8059c14 <prvInsertBlockIntoFreeList+0xac> @ imm = #-0x2
;     puc = ( uint8_t * ) pxBlockToInsert;
 8059c14: 9803         	ldr	r0, [sp, #0xc]
 8059c16: 9001         	str	r0, [sp, #0x4]
;     if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
 8059c18: 9801         	ldr	r0, [sp, #0x4]
 8059c1a: 9903         	ldr	r1, [sp, #0xc]
 8059c1c: 6849         	ldr	r1, [r1, #0x4]
 8059c1e: 4408         	add	r0, r1
 8059c20: 9902         	ldr	r1, [sp, #0x8]
 8059c22: 6809         	ldr	r1, [r1]
 8059c24: 4288         	cmp	r0, r1
 8059c26: d120         	bne	0x8059c6a <prvInsertBlockIntoFreeList+0x102> @ imm = #0x40
 8059c28: e7ff         	b	0x8059c2a <prvInsertBlockIntoFreeList+0xc2> @ imm = #-0x2
;         if( heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) != pxEnd )
 8059c2a: 9802         	ldr	r0, [sp, #0x8]
 8059c2c: 6800         	ldr	r0, [r0]
 8059c2e: f240 311c    	movw	r1, #0x31c
 8059c32: f2c2 0100    	movt	r1, #0x2000
 8059c36: 6809         	ldr	r1, [r1]
 8059c38: 4288         	cmp	r0, r1
 8059c3a: d00d         	beq	0x8059c58 <prvInsertBlockIntoFreeList+0xf0> @ imm = #0x1a
 8059c3c: e7ff         	b	0x8059c3e <prvInsertBlockIntoFreeList+0xd6> @ imm = #-0x2
;             pxBlockToInsert->xBlockSize += heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->xBlockSize;
 8059c3e: 9802         	ldr	r0, [sp, #0x8]
 8059c40: 6800         	ldr	r0, [r0]
 8059c42: 6842         	ldr	r2, [r0, #0x4]
 8059c44: 9903         	ldr	r1, [sp, #0xc]
 8059c46: 6848         	ldr	r0, [r1, #0x4]
 8059c48: 4410         	add	r0, r2
 8059c4a: 6048         	str	r0, [r1, #0x4]
;             pxBlockToInsert->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->pxNextFreeBlock;
 8059c4c: 9802         	ldr	r0, [sp, #0x8]
 8059c4e: 6800         	ldr	r0, [r0]
 8059c50: 6800         	ldr	r0, [r0]
 8059c52: 9903         	ldr	r1, [sp, #0xc]
 8059c54: 6008         	str	r0, [r1]
;         }
 8059c56: e007         	b	0x8059c68 <prvInsertBlockIntoFreeList+0x100> @ imm = #0xe
;             pxBlockToInsert->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxEnd );
 8059c58: f240 301c    	movw	r0, #0x31c
 8059c5c: f2c2 0000    	movt	r0, #0x2000
 8059c60: 6800         	ldr	r0, [r0]
 8059c62: 9903         	ldr	r1, [sp, #0xc]
 8059c64: 6008         	str	r0, [r1]
 8059c66: e7ff         	b	0x8059c68 <prvInsertBlockIntoFreeList+0x100> @ imm = #-0x2
;     }
 8059c68: e004         	b	0x8059c74 <prvInsertBlockIntoFreeList+0x10c> @ imm = #0x8
;         pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8059c6a: 9802         	ldr	r0, [sp, #0x8]
 8059c6c: 6800         	ldr	r0, [r0]
 8059c6e: 9903         	ldr	r1, [sp, #0xc]
 8059c70: 6008         	str	r0, [r1]
 8059c72: e7ff         	b	0x8059c74 <prvInsertBlockIntoFreeList+0x10c> @ imm = #-0x2
;     if( pxIterator != pxBlockToInsert )
 8059c74: 9802         	ldr	r0, [sp, #0x8]
 8059c76: 9903         	ldr	r1, [sp, #0xc]
 8059c78: 4288         	cmp	r0, r1
 8059c7a: d004         	beq	0x8059c86 <prvInsertBlockIntoFreeList+0x11e> @ imm = #0x8
 8059c7c: e7ff         	b	0x8059c7e <prvInsertBlockIntoFreeList+0x116> @ imm = #-0x2
;         pxIterator->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxBlockToInsert );
 8059c7e: 9803         	ldr	r0, [sp, #0xc]
 8059c80: 9902         	ldr	r1, [sp, #0x8]
 8059c82: 6008         	str	r0, [r1]
;     }
 8059c84: e000         	b	0x8059c88 <prvInsertBlockIntoFreeList+0x120> @ imm = #0x0
 8059c86: e7ff         	b	0x8059c88 <prvInsertBlockIntoFreeList+0x120> @ imm = #-0x2
; }
 8059c88: b004         	add	sp, #0x10
 8059c8a: bc80         	pop	{r7}
 8059c8c: eba8 0809    	sub.w	r8, r8, r9
 8059c90: f858 fd04    	ldr	pc, [r8, #-4]!

08059c94 <$d.5>:
 8059c94: 15 d7 05 08  	.word	0x0805d715

08059c98 <xPortGetFreeHeapSize>:
;     return xFreeBytesRemaining;
 8059c98: f240 3020    	movw	r0, #0x320
 8059c9c: f2c2 0000    	movt	r0, #0x2000
 8059ca0: 6800         	ldr	r0, [r0]
 8059ca2: 4770         	bx	lr

08059ca4 <xPortGetMinimumEverFreeHeapSize>:
;     return xMinimumEverFreeBytesRemaining;
 8059ca4: f242 302c    	movw	r0, #0x232c
 8059ca8: f2c2 0000    	movt	r0, #0x2000
 8059cac: 6800         	ldr	r0, [r0]
 8059cae: 4770         	bx	lr

08059cb0 <vPortInitialiseBlocks>:
; }
 8059cb0: 4770         	bx	lr
 8059cb2: bf00         	nop

08059cb4 <pvPortCalloc>:
; {
 8059cb4: f848 eb64    	str	lr, [r8], #100
 8059cb8: eb08 0809    	add.w	r8, r8, r9
 8059cbc: b480         	push	{r7}
 8059cbe: 466f         	mov	r7, sp
 8059cc0: b084         	sub	sp, #0x10
 8059cc2: 9003         	str	r0, [sp, #0xc]
 8059cc4: 9102         	str	r1, [sp, #0x8]
 8059cc6: 2000         	movs	r0, #0x0
;     void * pv = NULL;
 8059cc8: 9001         	str	r0, [sp, #0x4]
;     if( heapMULTIPLY_WILL_OVERFLOW( xNum, xSize ) == 0 )
 8059cca: 9903         	ldr	r1, [sp, #0xc]
 8059ccc: 9000         	str	r0, [sp]
 8059cce: b161         	cbz	r1, 0x8059cea <pvPortCalloc+0x36> @ imm = #0x18
 8059cd0: e7ff         	b	0x8059cd2 <pvPortCalloc+0x1e> @ imm = #-0x2
 8059cd2: 9902         	ldr	r1, [sp, #0x8]
 8059cd4: 9a03         	ldr	r2, [sp, #0xc]
 8059cd6: f04f 30ff    	mov.w	r0, #0xffffffff
 8059cda: fbb0 f2f2    	udiv	r2, r0, r2
 8059cde: 2000         	movs	r0, #0x0
 8059ce0: 4291         	cmp	r1, r2
 8059ce2: bf88         	it	hi
 8059ce4: 2001         	movhi	r0, #0x1
 8059ce6: 9000         	str	r0, [sp]
 8059ce8: e7ff         	b	0x8059cea <pvPortCalloc+0x36> @ imm = #-0x2
 8059cea: 9800         	ldr	r0, [sp]
;     if( heapMULTIPLY_WILL_OVERFLOW( xNum, xSize ) == 0 )
 8059cec: 07c0         	lsls	r0, r0, #0x1f
 8059cee: b990         	cbnz	r0, 0x8059d16 <pvPortCalloc+0x62> @ imm = #0x24
 8059cf0: e7ff         	b	0x8059cf2 <pvPortCalloc+0x3e> @ imm = #-0x2
;         pv = pvPortMalloc( xNum * xSize );
 8059cf2: 9803         	ldr	r0, [sp, #0xc]
 8059cf4: 9902         	ldr	r1, [sp, #0x8]
 8059cf6: 4348         	muls	r0, r1, r0
 8059cf8: 490a         	ldr	r1, [pc, #0x28]         @ 0x8059d24 <pvPortCalloc+0x70>
 8059cfa: 4788         	blx	r1
 8059cfc: 9001         	str	r0, [sp, #0x4]
;         if( pv != NULL )
 8059cfe: 9801         	ldr	r0, [sp, #0x4]
 8059d00: b140         	cbz	r0, 0x8059d14 <pvPortCalloc+0x60> @ imm = #0x10
 8059d02: e7ff         	b	0x8059d04 <pvPortCalloc+0x50> @ imm = #-0x2
;             ( void ) memset( pv, 0, xNum * xSize );
 8059d04: 9801         	ldr	r0, [sp, #0x4]
 8059d06: 9903         	ldr	r1, [sp, #0xc]
 8059d08: 9a02         	ldr	r2, [sp, #0x8]
 8059d0a: 434a         	muls	r2, r1, r2
 8059d0c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8059d28 <pvPortCalloc+0x74>
 8059d0e: 2100         	movs	r1, #0x0
 8059d10: 4798         	blx	r3
;         }
 8059d12: e7ff         	b	0x8059d14 <pvPortCalloc+0x60> @ imm = #-0x2
;     }
 8059d14: e7ff         	b	0x8059d16 <pvPortCalloc+0x62> @ imm = #-0x2
;     return pv;
 8059d16: 9801         	ldr	r0, [sp, #0x4]
 8059d18: b004         	add	sp, #0x10
 8059d1a: bc80         	pop	{r7}
 8059d1c: eba8 0809    	sub.w	r8, r8, r9
 8059d20: f858 fd64    	ldr	pc, [r8, #-100]!

08059d24 <$d.7>:
 8059d24: cd 96 05 08  	.word	0x080596cd
 8059d28: ad f9 05 08  	.word	0x0805f9ad

08059d2c <xEventGroupCreate>:
;     {
 8059d2c: f848 eb7c    	str	lr, [r8], #124
 8059d30: eb08 0809    	add.w	r8, r8, r9
 8059d34: b480         	push	{r7}
 8059d36: 466f         	mov	r7, sp
 8059d38: b082         	sub	sp, #0x8
;         pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
 8059d3a: 490b         	ldr	r1, [pc, #0x2c]         @ 0x8059d68 <xEventGroupCreate+0x3c>
 8059d3c: 201c         	movs	r0, #0x1c
 8059d3e: 4788         	blx	r1
 8059d40: 9001         	str	r0, [sp, #0x4]
;         if( pxEventBits != NULL )
 8059d42: 9801         	ldr	r0, [sp, #0x4]
 8059d44: b140         	cbz	r0, 0x8059d58 <xEventGroupCreate+0x2c> @ imm = #0x10
 8059d46: e7ff         	b	0x8059d48 <xEventGroupCreate+0x1c> @ imm = #-0x2
;             pxEventBits->uxEventBits = 0;
 8059d48: 9901         	ldr	r1, [sp, #0x4]
 8059d4a: 2000         	movs	r0, #0x0
 8059d4c: 6008         	str	r0, [r1]
;             vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 8059d4e: 9801         	ldr	r0, [sp, #0x4]
 8059d50: 3004         	adds	r0, #0x4
 8059d52: 4906         	ldr	r1, [pc, #0x18]         @ 0x8059d6c <xEventGroupCreate+0x40>
 8059d54: 4788         	blx	r1
;         }
 8059d56: e000         	b	0x8059d5a <xEventGroupCreate+0x2e> @ imm = #0x0
 8059d58: e7ff         	b	0x8059d5a <xEventGroupCreate+0x2e> @ imm = #-0x2
;         return pxEventBits;
 8059d5a: 9801         	ldr	r0, [sp, #0x4]
 8059d5c: b002         	add	sp, #0x8
 8059d5e: bc80         	pop	{r7}
 8059d60: eba8 0809    	sub.w	r8, r8, r9
 8059d64: f858 fd7c    	ldr	pc, [r8, #-124]!

08059d68 <$d.1>:
 8059d68: cd 96 05 08  	.word	0x080596cd
 8059d6c: 33 a4 05 08  	.word	0x0805a433

08059d70 <xEventGroupSync>:
; {
 8059d70: f848 eb50    	str	lr, [r8], #80
 8059d74: eb08 0809    	add.w	r8, r8, r9
 8059d78: b480         	push	{r7}
 8059d7a: 466f         	mov	r7, sp
 8059d7c: b08a         	sub	sp, #0x28
 8059d7e: 9009         	str	r0, [sp, #0x24]
 8059d80: 9108         	str	r1, [sp, #0x20]
 8059d82: 9207         	str	r2, [sp, #0x1c]
 8059d84: 9306         	str	r3, [sp, #0x18]
;     EventGroup_t * pxEventBits = xEventGroup;
 8059d86: 9809         	ldr	r0, [sp, #0x24]
 8059d88: 9003         	str	r0, [sp, #0xc]
 8059d8a: 2000         	movs	r0, #0x0
;     BaseType_t xTimeoutOccurred = pdFALSE;
 8059d8c: 9001         	str	r0, [sp, #0x4]
;     configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8059d8e: f89d 001f    	ldrb.w	r0, [sp, #0x1f]
 8059d92: b120         	cbz	r0, 0x8059d9e <xEventGroupSync+0x2e> @ imm = #0x8
 8059d94: e7ff         	b	0x8059d96 <xEventGroupSync+0x26> @ imm = #-0x2
 8059d96: 4851         	ldr	r0, [pc, #0x144]        @ 0x8059edc <xEventGroupSync+0x16c>
 8059d98: 4780         	blx	r0
 8059d9a: e7ff         	b	0x8059d9c <xEventGroupSync+0x2c> @ imm = #-0x2
 8059d9c: e7fe         	b	0x8059d9c <xEventGroupSync+0x2c> @ imm = #-0x4
;     configASSERT( uxBitsToWaitFor != 0 );
 8059d9e: 9807         	ldr	r0, [sp, #0x1c]
 8059da0: b920         	cbnz	r0, 0x8059dac <xEventGroupSync+0x3c> @ imm = #0x8
 8059da2: e7ff         	b	0x8059da4 <xEventGroupSync+0x34> @ imm = #-0x2
 8059da4: 484c         	ldr	r0, [pc, #0x130]        @ 0x8059ed8 <xEventGroupSync+0x168>
 8059da6: 4780         	blx	r0
 8059da8: e7ff         	b	0x8059daa <xEventGroupSync+0x3a> @ imm = #-0x2
 8059daa: e7fe         	b	0x8059daa <xEventGroupSync+0x3a> @ imm = #-0x4
;         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8059dac: 4840         	ldr	r0, [pc, #0x100]        @ 0x8059eb0 <xEventGroupSync+0x140>
 8059dae: 4780         	blx	r0
 8059db0: 4601         	mov	r1, r0
 8059db2: 2000         	movs	r0, #0x0
 8059db4: 9000         	str	r0, [sp]
 8059db6: b931         	cbnz	r1, 0x8059dc6 <xEventGroupSync+0x56> @ imm = #0xc
 8059db8: e7ff         	b	0x8059dba <xEventGroupSync+0x4a> @ imm = #-0x2
 8059dba: 9806         	ldr	r0, [sp, #0x18]
 8059dbc: 2800         	cmp	r0, #0x0
 8059dbe: bf18         	it	ne
 8059dc0: 2001         	movne	r0, #0x1
 8059dc2: 9000         	str	r0, [sp]
 8059dc4: e7ff         	b	0x8059dc6 <xEventGroupSync+0x56> @ imm = #-0x2
 8059dc6: 9800         	ldr	r0, [sp]
;         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8059dc8: 07c0         	lsls	r0, r0, #0x1f
 8059dca: b120         	cbz	r0, 0x8059dd6 <xEventGroupSync+0x66> @ imm = #0x8
 8059dcc: e7ff         	b	0x8059dce <xEventGroupSync+0x5e> @ imm = #-0x2
 8059dce: 4841         	ldr	r0, [pc, #0x104]        @ 0x8059ed4 <xEventGroupSync+0x164>
 8059dd0: 4780         	blx	r0
 8059dd2: e7ff         	b	0x8059dd4 <xEventGroupSync+0x64> @ imm = #-0x2
 8059dd4: e7fe         	b	0x8059dd4 <xEventGroupSync+0x64> @ imm = #-0x4
;     vTaskSuspendAll();
 8059dd6: 4837         	ldr	r0, [pc, #0xdc]         @ 0x8059eb4 <xEventGroupSync+0x144>
 8059dd8: 4780         	blx	r0
;         uxOriginalBitValue = pxEventBits->uxEventBits;
 8059dda: 9803         	ldr	r0, [sp, #0xc]
 8059ddc: 6800         	ldr	r0, [r0]
 8059dde: 9005         	str	r0, [sp, #0x14]
;         ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 8059de0: 9809         	ldr	r0, [sp, #0x24]
 8059de2: 9908         	ldr	r1, [sp, #0x20]
 8059de4: 4a34         	ldr	r2, [pc, #0xd0]         @ 0x8059eb8 <xEventGroupSync+0x148>
 8059de6: 4790         	blx	r2
;         if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 8059de8: 9805         	ldr	r0, [sp, #0x14]
 8059dea: 9908         	ldr	r1, [sp, #0x20]
 8059dec: 4308         	orrs	r0, r1
 8059dee: 9907         	ldr	r1, [sp, #0x1c]
 8059df0: 4008         	ands	r0, r1
 8059df2: 4288         	cmp	r0, r1
 8059df4: d10c         	bne	0x8059e10 <xEventGroupSync+0xa0> @ imm = #0x18
 8059df6: e7ff         	b	0x8059df8 <xEventGroupSync+0x88> @ imm = #-0x2
;             uxReturn = ( uxOriginalBitValue | uxBitsToSet );
 8059df8: 9805         	ldr	r0, [sp, #0x14]
 8059dfa: 9908         	ldr	r1, [sp, #0x20]
 8059dfc: 4308         	orrs	r0, r1
 8059dfe: 9004         	str	r0, [sp, #0x10]
;             pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 8059e00: 9a07         	ldr	r2, [sp, #0x1c]
 8059e02: 9903         	ldr	r1, [sp, #0xc]
 8059e04: 6808         	ldr	r0, [r1]
 8059e06: 4390         	bics	r0, r2
 8059e08: 6008         	str	r0, [r1]
 8059e0a: 2000         	movs	r0, #0x0
;             xTicksToWait = 0;
 8059e0c: 9006         	str	r0, [sp, #0x18]
;         }
 8059e0e: e014         	b	0x8059e3a <xEventGroupSync+0xca> @ imm = #0x28
;             if( xTicksToWait != ( TickType_t ) 0 )
 8059e10: 9806         	ldr	r0, [sp, #0x18]
 8059e12: b158         	cbz	r0, 0x8059e2c <xEventGroupSync+0xbc> @ imm = #0x16
 8059e14: e7ff         	b	0x8059e16 <xEventGroupSync+0xa6> @ imm = #-0x2
;                 vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
 8059e16: 9803         	ldr	r0, [sp, #0xc]
 8059e18: 3004         	adds	r0, #0x4
 8059e1a: 9907         	ldr	r1, [sp, #0x1c]
 8059e1c: f041 61a0    	orr	r1, r1, #0x5000000
 8059e20: 9a06         	ldr	r2, [sp, #0x18]
 8059e22: 4b26         	ldr	r3, [pc, #0x98]         @ 0x8059ebc <xEventGroupSync+0x14c>
 8059e24: 4798         	blx	r3
 8059e26: 2000         	movs	r0, #0x0
;                 uxReturn = 0;
 8059e28: 9004         	str	r0, [sp, #0x10]
;             }
 8059e2a: e005         	b	0x8059e38 <xEventGroupSync+0xc8> @ imm = #0xa
;                 uxReturn = pxEventBits->uxEventBits;
 8059e2c: 9803         	ldr	r0, [sp, #0xc]
 8059e2e: 6800         	ldr	r0, [r0]
 8059e30: 9004         	str	r0, [sp, #0x10]
 8059e32: 2001         	movs	r0, #0x1
;                 xTimeoutOccurred = pdTRUE;
 8059e34: 9001         	str	r0, [sp, #0x4]
 8059e36: e7ff         	b	0x8059e38 <xEventGroupSync+0xc8> @ imm = #-0x2
 8059e38: e7ff         	b	0x8059e3a <xEventGroupSync+0xca> @ imm = #-0x2
;     xAlreadyYielded = xTaskResumeAll();
 8059e3a: 4821         	ldr	r0, [pc, #0x84]         @ 0x8059ec0 <xEventGroupSync+0x150>
 8059e3c: 4780         	blx	r0
 8059e3e: 9002         	str	r0, [sp, #0x8]
;     if( xTicksToWait != ( TickType_t ) 0 )
 8059e40: 9806         	ldr	r0, [sp, #0x18]
 8059e42: b368         	cbz	r0, 0x8059ea0 <xEventGroupSync+0x130> @ imm = #0x5a
 8059e44: e7ff         	b	0x8059e46 <xEventGroupSync+0xd6> @ imm = #-0x2
;         if( xAlreadyYielded == pdFALSE )
 8059e46: 9802         	ldr	r0, [sp, #0x8]
 8059e48: b918         	cbnz	r0, 0x8059e52 <xEventGroupSync+0xe2> @ imm = #0x6
 8059e4a: e7ff         	b	0x8059e4c <xEventGroupSync+0xdc> @ imm = #-0x2
;             taskYIELD_WITHIN_API();
 8059e4c: 481d         	ldr	r0, [pc, #0x74]         @ 0x8059ec4 <xEventGroupSync+0x154>
 8059e4e: 4780         	blx	r0
;         }
 8059e50: e000         	b	0x8059e54 <xEventGroupSync+0xe4> @ imm = #0x0
 8059e52: e7ff         	b	0x8059e54 <xEventGroupSync+0xe4> @ imm = #-0x2
;         uxReturn = uxTaskResetEventItemValue();
 8059e54: 481c         	ldr	r0, [pc, #0x70]         @ 0x8059ec8 <xEventGroupSync+0x158>
 8059e56: 4780         	blx	r0
 8059e58: 9004         	str	r0, [sp, #0x10]
;         if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 8059e5a: f89d 0013    	ldrb.w	r0, [sp, #0x13]
 8059e5e: 0780         	lsls	r0, r0, #0x1e
 8059e60: 2800         	cmp	r0, #0x0
 8059e62: d417         	bmi	0x8059e94 <xEventGroupSync+0x124> @ imm = #0x2e
 8059e64: e7ff         	b	0x8059e66 <xEventGroupSync+0xf6> @ imm = #-0x2
;             taskENTER_CRITICAL();
 8059e66: 4819         	ldr	r0, [pc, #0x64]         @ 0x8059ecc <xEventGroupSync+0x15c>
 8059e68: 4780         	blx	r0
;                 uxReturn = pxEventBits->uxEventBits;
 8059e6a: 9803         	ldr	r0, [sp, #0xc]
 8059e6c: 6800         	ldr	r0, [r0]
 8059e6e: 9004         	str	r0, [sp, #0x10]
;                 if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
 8059e70: 9804         	ldr	r0, [sp, #0x10]
 8059e72: 9907         	ldr	r1, [sp, #0x1c]
 8059e74: 4008         	ands	r0, r1
 8059e76: 4288         	cmp	r0, r1
 8059e78: d106         	bne	0x8059e88 <xEventGroupSync+0x118> @ imm = #0xc
 8059e7a: e7ff         	b	0x8059e7c <xEventGroupSync+0x10c> @ imm = #-0x2
;                     pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 8059e7c: 9a07         	ldr	r2, [sp, #0x1c]
 8059e7e: 9903         	ldr	r1, [sp, #0xc]
 8059e80: 6808         	ldr	r0, [r1]
 8059e82: 4390         	bics	r0, r2
 8059e84: 6008         	str	r0, [r1]
;                 }
 8059e86: e000         	b	0x8059e8a <xEventGroupSync+0x11a> @ imm = #0x0
 8059e88: e7ff         	b	0x8059e8a <xEventGroupSync+0x11a> @ imm = #-0x2
;             taskEXIT_CRITICAL();
 8059e8a: 4811         	ldr	r0, [pc, #0x44]         @ 0x8059ed0 <xEventGroupSync+0x160>
 8059e8c: 4780         	blx	r0
 8059e8e: 2001         	movs	r0, #0x1
;             xTimeoutOccurred = pdTRUE;
 8059e90: 9001         	str	r0, [sp, #0x4]
;         }
 8059e92: e000         	b	0x8059e96 <xEventGroupSync+0x126> @ imm = #0x0
 8059e94: e7ff         	b	0x8059e96 <xEventGroupSync+0x126> @ imm = #-0x2
;         uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 8059e96: 9804         	ldr	r0, [sp, #0x10]
 8059e98: f020 407f    	bic	r0, r0, #0xff000000
 8059e9c: 9004         	str	r0, [sp, #0x10]
;     }
 8059e9e: e7ff         	b	0x8059ea0 <xEventGroupSync+0x130> @ imm = #-0x2
;     return uxReturn;
 8059ea0: 9804         	ldr	r0, [sp, #0x10]
 8059ea2: b00a         	add	sp, #0x28
 8059ea4: bc80         	pop	{r7}
 8059ea6: eba8 0809    	sub.w	r8, r8, r9
 8059eaa: f858 fd50    	ldr	pc, [r8, #-80]!
 8059eae: bf00         	nop

08059eb0 <$d.3>:
 8059eb0: 0d 77 05 08  	.word	0x0805770d
 8059eb4: d9 58 05 08  	.word	0x080558d9
 8059eb8: e1 9e 05 08  	.word	0x08059ee1
 8059ebc: 61 6e 05 08  	.word	0x08056e61
 8059ec0: 0d 5a 05 08  	.word	0x08055a0d
 8059ec4: 2f cd 05 08  	.word	0x0805cd2f
 8059ec8: e9 7b 05 08  	.word	0x08057be9
 8059ecc: 49 cd 05 08  	.word	0x0805cd49
 8059ed0: 7d cd 05 08  	.word	0x0805cd7d
 8059ed4: 15 d7 05 08  	.word	0x0805d715
 8059ed8: 15 d7 05 08  	.word	0x0805d715
 8059edc: 15 d7 05 08  	.word	0x0805d715

08059ee0 <xEventGroupSetBits>:
; {
 8059ee0: f848 eb68    	str	lr, [r8], #104
 8059ee4: eb08 0809    	add.w	r8, r8, r9
 8059ee8: b480         	push	{r7}
 8059eea: 466f         	mov	r7, sp
 8059eec: b08c         	sub	sp, #0x30
 8059eee: 900b         	str	r0, [sp, #0x2c]
 8059ef0: 910a         	str	r1, [sp, #0x28]
 8059ef2: 2000         	movs	r0, #0x0
;     EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 8059ef4: 9005         	str	r0, [sp, #0x14]
;     EventGroup_t * pxEventBits = xEventGroup;
 8059ef6: 990b         	ldr	r1, [sp, #0x2c]
 8059ef8: 9102         	str	r1, [sp, #0x8]
;     BaseType_t xMatchFound = pdFALSE;
 8059efa: 9001         	str	r0, [sp, #0x4]
;     configASSERT( xEventGroup );
 8059efc: 980b         	ldr	r0, [sp, #0x2c]
 8059efe: b920         	cbnz	r0, 0x8059f0a <xEventGroupSetBits+0x2a> @ imm = #0x8
 8059f00: e7ff         	b	0x8059f02 <xEventGroupSetBits+0x22> @ imm = #-0x2
 8059f02: 483f         	ldr	r0, [pc, #0xfc]         @ 0x805a000 <xEventGroupSetBits+0x120>
 8059f04: 4780         	blx	r0
 8059f06: e7ff         	b	0x8059f08 <xEventGroupSetBits+0x28> @ imm = #-0x2
 8059f08: e7fe         	b	0x8059f08 <xEventGroupSetBits+0x28> @ imm = #-0x4
;     configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8059f0a: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
 8059f0e: b120         	cbz	r0, 0x8059f1a <xEventGroupSetBits+0x3a> @ imm = #0x8
 8059f10: e7ff         	b	0x8059f12 <xEventGroupSetBits+0x32> @ imm = #-0x2
 8059f12: 483a         	ldr	r0, [pc, #0xe8]         @ 0x8059ffc <xEventGroupSetBits+0x11c>
 8059f14: 4780         	blx	r0
 8059f16: e7ff         	b	0x8059f18 <xEventGroupSetBits+0x38> @ imm = #-0x2
 8059f18: e7fe         	b	0x8059f18 <xEventGroupSetBits+0x38> @ imm = #-0x4
;     pxList = &( pxEventBits->xTasksWaitingForBits );
 8059f1a: 9802         	ldr	r0, [sp, #0x8]
 8059f1c: 3004         	adds	r0, #0x4
 8059f1e: 9006         	str	r0, [sp, #0x18]
;     pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8059f20: 9806         	ldr	r0, [sp, #0x18]
 8059f22: 3008         	adds	r0, #0x8
 8059f24: 9007         	str	r0, [sp, #0x1c]
;     vTaskSuspendAll();
 8059f26: 4832         	ldr	r0, [pc, #0xc8]         @ 0x8059ff0 <xEventGroupSetBits+0x110>
 8059f28: 4780         	blx	r0
;         pxListItem = listGET_HEAD_ENTRY( pxList );
 8059f2a: 9806         	ldr	r0, [sp, #0x18]
 8059f2c: 68c0         	ldr	r0, [r0, #0xc]
 8059f2e: 9009         	str	r0, [sp, #0x24]
;         pxEventBits->uxEventBits |= uxBitsToSet;
 8059f30: 9a0a         	ldr	r2, [sp, #0x28]
 8059f32: 9902         	ldr	r1, [sp, #0x8]
 8059f34: 6808         	ldr	r0, [r1]
 8059f36: 4310         	orrs	r0, r2
 8059f38: 6008         	str	r0, [r1]
;         while( pxListItem != pxListEnd )
 8059f3a: e7ff         	b	0x8059f3c <xEventGroupSetBits+0x5c> @ imm = #-0x2
 8059f3c: 9809         	ldr	r0, [sp, #0x24]
 8059f3e: 9907         	ldr	r1, [sp, #0x1c]
 8059f40: 4288         	cmp	r0, r1
 8059f42: d046         	beq	0x8059fd2 <xEventGroupSetBits+0xf2> @ imm = #0x8c
 8059f44: e7ff         	b	0x8059f46 <xEventGroupSetBits+0x66> @ imm = #-0x2
;             pxNext = listGET_NEXT( pxListItem );
 8059f46: 9809         	ldr	r0, [sp, #0x24]
 8059f48: 6840         	ldr	r0, [r0, #0x4]
 8059f4a: 9008         	str	r0, [sp, #0x20]
;             uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 8059f4c: 9809         	ldr	r0, [sp, #0x24]
 8059f4e: 6800         	ldr	r0, [r0]
 8059f50: 9004         	str	r0, [sp, #0x10]
 8059f52: 2000         	movs	r0, #0x0
;             xMatchFound = pdFALSE;
 8059f54: 9001         	str	r0, [sp, #0x4]
;             uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
 8059f56: f89d 0013    	ldrb.w	r0, [sp, #0x13]
 8059f5a: 0600         	lsls	r0, r0, #0x18
 8059f5c: 9003         	str	r0, [sp, #0xc]
;             uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 8059f5e: 9804         	ldr	r0, [sp, #0x10]
 8059f60: f020 407f    	bic	r0, r0, #0xff000000
 8059f64: 9004         	str	r0, [sp, #0x10]
;             if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 8059f66: f89d 000f    	ldrb.w	r0, [sp, #0xf]
 8059f6a: 0740         	lsls	r0, r0, #0x1d
 8059f6c: 2800         	cmp	r0, #0x0
 8059f6e: d40b         	bmi	0x8059f88 <xEventGroupSetBits+0xa8> @ imm = #0x16
 8059f70: e7ff         	b	0x8059f72 <xEventGroupSetBits+0x92> @ imm = #-0x2
;                 if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 8059f72: 9804         	ldr	r0, [sp, #0x10]
 8059f74: 9902         	ldr	r1, [sp, #0x8]
 8059f76: 6809         	ldr	r1, [r1]
 8059f78: 4208         	tst	r0, r1
 8059f7a: d003         	beq	0x8059f84 <xEventGroupSetBits+0xa4> @ imm = #0x6
 8059f7c: e7ff         	b	0x8059f7e <xEventGroupSetBits+0x9e> @ imm = #-0x2
 8059f7e: 2001         	movs	r0, #0x1
;                     xMatchFound = pdTRUE;
 8059f80: 9001         	str	r0, [sp, #0x4]
;                 }
 8059f82: e000         	b	0x8059f86 <xEventGroupSetBits+0xa6> @ imm = #0x0
 8059f84: e7ff         	b	0x8059f86 <xEventGroupSetBits+0xa6> @ imm = #-0x2
;             }
 8059f86: e00b         	b	0x8059fa0 <xEventGroupSetBits+0xc0> @ imm = #0x16
;             else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 8059f88: 9904         	ldr	r1, [sp, #0x10]
 8059f8a: 9802         	ldr	r0, [sp, #0x8]
 8059f8c: 6800         	ldr	r0, [r0]
 8059f8e: 4008         	ands	r0, r1
 8059f90: 4288         	cmp	r0, r1
 8059f92: d103         	bne	0x8059f9c <xEventGroupSetBits+0xbc> @ imm = #0x6
 8059f94: e7ff         	b	0x8059f96 <xEventGroupSetBits+0xb6> @ imm = #-0x2
 8059f96: 2001         	movs	r0, #0x1
;                 xMatchFound = pdTRUE;
 8059f98: 9001         	str	r0, [sp, #0x4]
;             }
 8059f9a: e000         	b	0x8059f9e <xEventGroupSetBits+0xbe> @ imm = #0x0
 8059f9c: e7ff         	b	0x8059f9e <xEventGroupSetBits+0xbe> @ imm = #-0x2
 8059f9e: e7ff         	b	0x8059fa0 <xEventGroupSetBits+0xc0> @ imm = #-0x2
;             if( xMatchFound != pdFALSE )
 8059fa0: 9801         	ldr	r0, [sp, #0x4]
 8059fa2: b198         	cbz	r0, 0x8059fcc <xEventGroupSetBits+0xec> @ imm = #0x26
 8059fa4: e7ff         	b	0x8059fa6 <xEventGroupSetBits+0xc6> @ imm = #-0x2
;                 if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 8059fa6: f89d 000f    	ldrb.w	r0, [sp, #0xf]
 8059faa: 07c0         	lsls	r0, r0, #0x1f
 8059fac: b128         	cbz	r0, 0x8059fba <xEventGroupSetBits+0xda> @ imm = #0xa
 8059fae: e7ff         	b	0x8059fb0 <xEventGroupSetBits+0xd0> @ imm = #-0x2
;                     uxBitsToClear |= uxBitsWaitedFor;
 8059fb0: 9904         	ldr	r1, [sp, #0x10]
 8059fb2: 9805         	ldr	r0, [sp, #0x14]
 8059fb4: 4308         	orrs	r0, r1
 8059fb6: 9005         	str	r0, [sp, #0x14]
;                 }
 8059fb8: e000         	b	0x8059fbc <xEventGroupSetBits+0xdc> @ imm = #0x0
 8059fba: e7ff         	b	0x8059fbc <xEventGroupSetBits+0xdc> @ imm = #-0x2
;                 vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 8059fbc: 9809         	ldr	r0, [sp, #0x24]
 8059fbe: 9902         	ldr	r1, [sp, #0x8]
 8059fc0: 6809         	ldr	r1, [r1]
 8059fc2: f041 7100    	orr	r1, r1, #0x2000000
 8059fc6: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8059ff8 <xEventGroupSetBits+0x118>
 8059fc8: 4790         	blx	r2
;             }
 8059fca: e7ff         	b	0x8059fcc <xEventGroupSetBits+0xec> @ imm = #-0x2
;             pxListItem = pxNext;
 8059fcc: 9808         	ldr	r0, [sp, #0x20]
 8059fce: 9009         	str	r0, [sp, #0x24]
;         while( pxListItem != pxListEnd )
 8059fd0: e7b4         	b	0x8059f3c <xEventGroupSetBits+0x5c> @ imm = #-0x98
;         pxEventBits->uxEventBits &= ~uxBitsToClear;
 8059fd2: 9a05         	ldr	r2, [sp, #0x14]
 8059fd4: 9902         	ldr	r1, [sp, #0x8]
 8059fd6: 6808         	ldr	r0, [r1]
 8059fd8: 4390         	bics	r0, r2
 8059fda: 6008         	str	r0, [r1]
;     ( void ) xTaskResumeAll();
 8059fdc: 4805         	ldr	r0, [pc, #0x14]         @ 0x8059ff4 <xEventGroupSetBits+0x114>
 8059fde: 4780         	blx	r0
;     return pxEventBits->uxEventBits;
 8059fe0: 9802         	ldr	r0, [sp, #0x8]
 8059fe2: 6800         	ldr	r0, [r0]
 8059fe4: b00c         	add	sp, #0x30
 8059fe6: bc80         	pop	{r7}
 8059fe8: eba8 0809    	sub.w	r8, r8, r9
 8059fec: f858 fd68    	ldr	pc, [r8, #-104]!

08059ff0 <$d.5>:
 8059ff0: d9 58 05 08  	.word	0x080558d9
 8059ff4: 0d 5a 05 08  	.word	0x08055a0d
 8059ff8: 99 71 05 08  	.word	0x08057199
 8059ffc: 15 d7 05 08  	.word	0x0805d715
 805a000: 15 d7 05 08  	.word	0x0805d715

0805a004 <xEventGroupWaitBits>:
; {
 805a004: f848 eb64    	str	lr, [r8], #100
 805a008: eb08 0809    	add.w	r8, r8, r9
 805a00c: b480         	push	{r7}
 805a00e: 466f         	mov	r7, sp
 805a010: b08c         	sub	sp, #0x30
 805a012: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805a016: 900b         	str	r0, [sp, #0x2c]
 805a018: 910a         	str	r1, [sp, #0x28]
 805a01a: 9209         	str	r2, [sp, #0x24]
 805a01c: 9308         	str	r3, [sp, #0x20]
;     EventGroup_t * pxEventBits = xEventGroup;
 805a01e: 980b         	ldr	r0, [sp, #0x2c]
 805a020: 9007         	str	r0, [sp, #0x1c]
 805a022: 2000         	movs	r0, #0x0
;     EventBits_t uxReturn, uxControlBits = 0;
 805a024: 9005         	str	r0, [sp, #0x14]
;     BaseType_t xTimeoutOccurred = pdFALSE;
 805a026: 9002         	str	r0, [sp, #0x8]
;     configASSERT( xEventGroup );
 805a028: 980b         	ldr	r0, [sp, #0x2c]
 805a02a: b920         	cbnz	r0, 0x805a036 <xEventGroupWaitBits+0x32> @ imm = #0x8
 805a02c: e7ff         	b	0x805a02e <xEventGroupWaitBits+0x2a> @ imm = #-0x2
 805a02e: 4862         	ldr	r0, [pc, #0x188]        @ 0x805a1b8 <xEventGroupWaitBits+0x1b4>
 805a030: 4780         	blx	r0
 805a032: e7ff         	b	0x805a034 <xEventGroupWaitBits+0x30> @ imm = #-0x2
 805a034: e7fe         	b	0x805a034 <xEventGroupWaitBits+0x30> @ imm = #-0x4
;     configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 805a036: f89d 002b    	ldrb.w	r0, [sp, #0x2b]
 805a03a: b120         	cbz	r0, 0x805a046 <xEventGroupWaitBits+0x42> @ imm = #0x8
 805a03c: e7ff         	b	0x805a03e <xEventGroupWaitBits+0x3a> @ imm = #-0x2
 805a03e: 485d         	ldr	r0, [pc, #0x174]        @ 0x805a1b4 <xEventGroupWaitBits+0x1b0>
 805a040: 4780         	blx	r0
 805a042: e7ff         	b	0x805a044 <xEventGroupWaitBits+0x40> @ imm = #-0x2
 805a044: e7fe         	b	0x805a044 <xEventGroupWaitBits+0x40> @ imm = #-0x4
;     configASSERT( uxBitsToWaitFor != 0 );
 805a046: 980a         	ldr	r0, [sp, #0x28]
 805a048: b920         	cbnz	r0, 0x805a054 <xEventGroupWaitBits+0x50> @ imm = #0x8
 805a04a: e7ff         	b	0x805a04c <xEventGroupWaitBits+0x48> @ imm = #-0x2
 805a04c: 4858         	ldr	r0, [pc, #0x160]        @ 0x805a1b0 <xEventGroupWaitBits+0x1ac>
 805a04e: 4780         	blx	r0
 805a050: e7ff         	b	0x805a052 <xEventGroupWaitBits+0x4e> @ imm = #-0x2
 805a052: e7fe         	b	0x805a052 <xEventGroupWaitBits+0x4e> @ imm = #-0x4
;         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 805a054: 484b         	ldr	r0, [pc, #0x12c]        @ 0x805a184 <xEventGroupWaitBits+0x180>
 805a056: 4780         	blx	r0
 805a058: 4601         	mov	r1, r0
 805a05a: 2000         	movs	r0, #0x0
 805a05c: 9000         	str	r0, [sp]
 805a05e: b931         	cbnz	r1, 0x805a06e <xEventGroupWaitBits+0x6a> @ imm = #0xc
 805a060: e7ff         	b	0x805a062 <xEventGroupWaitBits+0x5e> @ imm = #-0x2
 805a062: 68b8         	ldr	r0, [r7, #0x8]
 805a064: 2800         	cmp	r0, #0x0
 805a066: bf18         	it	ne
 805a068: 2001         	movne	r0, #0x1
 805a06a: 9000         	str	r0, [sp]
 805a06c: e7ff         	b	0x805a06e <xEventGroupWaitBits+0x6a> @ imm = #-0x2
 805a06e: 9800         	ldr	r0, [sp]
;         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 805a070: 07c0         	lsls	r0, r0, #0x1f
 805a072: b120         	cbz	r0, 0x805a07e <xEventGroupWaitBits+0x7a> @ imm = #0x8
 805a074: e7ff         	b	0x805a076 <xEventGroupWaitBits+0x72> @ imm = #-0x2
 805a076: 484d         	ldr	r0, [pc, #0x134]        @ 0x805a1ac <xEventGroupWaitBits+0x1a8>
 805a078: 4780         	blx	r0
 805a07a: e7ff         	b	0x805a07c <xEventGroupWaitBits+0x78> @ imm = #-0x2
 805a07c: e7fe         	b	0x805a07c <xEventGroupWaitBits+0x78> @ imm = #-0x4
;     vTaskSuspendAll();
 805a07e: 4842         	ldr	r0, [pc, #0x108]        @ 0x805a188 <xEventGroupWaitBits+0x184>
 805a080: 4780         	blx	r0
;         const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 805a082: 9807         	ldr	r0, [sp, #0x1c]
 805a084: 6800         	ldr	r0, [r0]
 805a086: 9001         	str	r0, [sp, #0x4]
;         xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
 805a088: 9801         	ldr	r0, [sp, #0x4]
 805a08a: 990a         	ldr	r1, [sp, #0x28]
 805a08c: 9a08         	ldr	r2, [sp, #0x20]
 805a08e: 4b3f         	ldr	r3, [pc, #0xfc]         @ 0x805a18c <xEventGroupWaitBits+0x188>
 805a090: 4798         	blx	r3
 805a092: 9004         	str	r0, [sp, #0x10]
;         if( xWaitConditionMet != pdFALSE )
 805a094: 9804         	ldr	r0, [sp, #0x10]
 805a096: b178         	cbz	r0, 0x805a0b8 <xEventGroupWaitBits+0xb4> @ imm = #0x1e
 805a098: e7ff         	b	0x805a09a <xEventGroupWaitBits+0x96> @ imm = #-0x2
;             uxReturn = uxCurrentEventBits;
 805a09a: 9801         	ldr	r0, [sp, #0x4]
 805a09c: 9006         	str	r0, [sp, #0x18]
 805a09e: 2000         	movs	r0, #0x0
;             xTicksToWait = ( TickType_t ) 0;
 805a0a0: 60b8         	str	r0, [r7, #0x8]
;             if( xClearOnExit != pdFALSE )
 805a0a2: 9809         	ldr	r0, [sp, #0x24]
 805a0a4: b130         	cbz	r0, 0x805a0b4 <xEventGroupWaitBits+0xb0> @ imm = #0xc
 805a0a6: e7ff         	b	0x805a0a8 <xEventGroupWaitBits+0xa4> @ imm = #-0x2
;                 pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 805a0a8: 9a0a         	ldr	r2, [sp, #0x28]
 805a0aa: 9907         	ldr	r1, [sp, #0x1c]
 805a0ac: 6808         	ldr	r0, [r1]
 805a0ae: 4390         	bics	r0, r2
 805a0b0: 6008         	str	r0, [r1]
;             }
 805a0b2: e000         	b	0x805a0b6 <xEventGroupWaitBits+0xb2> @ imm = #0x0
 805a0b4: e7ff         	b	0x805a0b6 <xEventGroupWaitBits+0xb2> @ imm = #-0x2
;         }
 805a0b6: e025         	b	0x805a104 <xEventGroupWaitBits+0x100> @ imm = #0x4a
;         else if( xTicksToWait == ( TickType_t ) 0 )
 805a0b8: 68b8         	ldr	r0, [r7, #0x8]
 805a0ba: b928         	cbnz	r0, 0x805a0c8 <xEventGroupWaitBits+0xc4> @ imm = #0xa
 805a0bc: e7ff         	b	0x805a0be <xEventGroupWaitBits+0xba> @ imm = #-0x2
;             uxReturn = uxCurrentEventBits;
 805a0be: 9801         	ldr	r0, [sp, #0x4]
 805a0c0: 9006         	str	r0, [sp, #0x18]
 805a0c2: 2001         	movs	r0, #0x1
;             xTimeoutOccurred = pdTRUE;
 805a0c4: 9002         	str	r0, [sp, #0x8]
;         }
 805a0c6: e01c         	b	0x805a102 <xEventGroupWaitBits+0xfe> @ imm = #0x38
;             if( xClearOnExit != pdFALSE )
 805a0c8: 9809         	ldr	r0, [sp, #0x24]
 805a0ca: b128         	cbz	r0, 0x805a0d8 <xEventGroupWaitBits+0xd4> @ imm = #0xa
 805a0cc: e7ff         	b	0x805a0ce <xEventGroupWaitBits+0xca> @ imm = #-0x2
;                 uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 805a0ce: 9805         	ldr	r0, [sp, #0x14]
 805a0d0: f040 7080    	orr	r0, r0, #0x1000000
 805a0d4: 9005         	str	r0, [sp, #0x14]
;             }
 805a0d6: e000         	b	0x805a0da <xEventGroupWaitBits+0xd6> @ imm = #0x0
 805a0d8: e7ff         	b	0x805a0da <xEventGroupWaitBits+0xd6> @ imm = #-0x2
;             if( xWaitForAllBits != pdFALSE )
 805a0da: 9808         	ldr	r0, [sp, #0x20]
 805a0dc: b128         	cbz	r0, 0x805a0ea <xEventGroupWaitBits+0xe6> @ imm = #0xa
 805a0de: e7ff         	b	0x805a0e0 <xEventGroupWaitBits+0xdc> @ imm = #-0x2
;                 uxControlBits |= eventWAIT_FOR_ALL_BITS;
 805a0e0: 9805         	ldr	r0, [sp, #0x14]
 805a0e2: f040 6080    	orr	r0, r0, #0x4000000
 805a0e6: 9005         	str	r0, [sp, #0x14]
;             }
 805a0e8: e000         	b	0x805a0ec <xEventGroupWaitBits+0xe8> @ imm = #0x0
 805a0ea: e7ff         	b	0x805a0ec <xEventGroupWaitBits+0xe8> @ imm = #-0x2
;             vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 805a0ec: 9807         	ldr	r0, [sp, #0x1c]
 805a0ee: 3004         	adds	r0, #0x4
 805a0f0: 990a         	ldr	r1, [sp, #0x28]
 805a0f2: 9a05         	ldr	r2, [sp, #0x14]
 805a0f4: 4311         	orrs	r1, r2
 805a0f6: 68ba         	ldr	r2, [r7, #0x8]
 805a0f8: 4b25         	ldr	r3, [pc, #0x94]         @ 0x805a190 <xEventGroupWaitBits+0x18c>
 805a0fa: 4798         	blx	r3
 805a0fc: 2000         	movs	r0, #0x0
;             uxReturn = 0;
 805a0fe: 9006         	str	r0, [sp, #0x18]
 805a100: e7ff         	b	0x805a102 <xEventGroupWaitBits+0xfe> @ imm = #-0x2
 805a102: e7ff         	b	0x805a104 <xEventGroupWaitBits+0x100> @ imm = #-0x2
;     xAlreadyYielded = xTaskResumeAll();
 805a104: 4823         	ldr	r0, [pc, #0x8c]         @ 0x805a194 <xEventGroupWaitBits+0x190>
 805a106: 4780         	blx	r0
 805a108: 9003         	str	r0, [sp, #0xc]
;     if( xTicksToWait != ( TickType_t ) 0 )
 805a10a: 68b8         	ldr	r0, [r7, #0x8]
 805a10c: b398         	cbz	r0, 0x805a176 <xEventGroupWaitBits+0x172> @ imm = #0x66
 805a10e: e7ff         	b	0x805a110 <xEventGroupWaitBits+0x10c> @ imm = #-0x2
;         if( xAlreadyYielded == pdFALSE )
 805a110: 9803         	ldr	r0, [sp, #0xc]
 805a112: b918         	cbnz	r0, 0x805a11c <xEventGroupWaitBits+0x118> @ imm = #0x6
 805a114: e7ff         	b	0x805a116 <xEventGroupWaitBits+0x112> @ imm = #-0x2
;             taskYIELD_WITHIN_API();
 805a116: 4820         	ldr	r0, [pc, #0x80]         @ 0x805a198 <xEventGroupWaitBits+0x194>
 805a118: 4780         	blx	r0
;         }
 805a11a: e000         	b	0x805a11e <xEventGroupWaitBits+0x11a> @ imm = #0x0
 805a11c: e7ff         	b	0x805a11e <xEventGroupWaitBits+0x11a> @ imm = #-0x2
;         uxReturn = uxTaskResetEventItemValue();
 805a11e: 481f         	ldr	r0, [pc, #0x7c]         @ 0x805a19c <xEventGroupWaitBits+0x198>
 805a120: 4780         	blx	r0
 805a122: 9006         	str	r0, [sp, #0x18]
;         if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 805a124: f89d 001b    	ldrb.w	r0, [sp, #0x1b]
 805a128: 0780         	lsls	r0, r0, #0x1e
 805a12a: 2800         	cmp	r0, #0x0
 805a12c: d41d         	bmi	0x805a16a <xEventGroupWaitBits+0x166> @ imm = #0x3a
 805a12e: e7ff         	b	0x805a130 <xEventGroupWaitBits+0x12c> @ imm = #-0x2
;             taskENTER_CRITICAL();
 805a130: 481b         	ldr	r0, [pc, #0x6c]         @ 0x805a1a0 <xEventGroupWaitBits+0x19c>
 805a132: 4780         	blx	r0
;                 uxReturn = pxEventBits->uxEventBits;
 805a134: 9807         	ldr	r0, [sp, #0x1c]
 805a136: 6800         	ldr	r0, [r0]
 805a138: 9006         	str	r0, [sp, #0x18]
;                 if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
 805a13a: 9806         	ldr	r0, [sp, #0x18]
 805a13c: 990a         	ldr	r1, [sp, #0x28]
 805a13e: 9a08         	ldr	r2, [sp, #0x20]
 805a140: 4b18         	ldr	r3, [pc, #0x60]         @ 0x805a1a4 <xEventGroupWaitBits+0x1a0>
 805a142: 4798         	blx	r3
 805a144: b158         	cbz	r0, 0x805a15e <xEventGroupWaitBits+0x15a> @ imm = #0x16
 805a146: e7ff         	b	0x805a148 <xEventGroupWaitBits+0x144> @ imm = #-0x2
;                     if( xClearOnExit != pdFALSE )
 805a148: 9809         	ldr	r0, [sp, #0x24]
 805a14a: b130         	cbz	r0, 0x805a15a <xEventGroupWaitBits+0x156> @ imm = #0xc
 805a14c: e7ff         	b	0x805a14e <xEventGroupWaitBits+0x14a> @ imm = #-0x2
;                         pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 805a14e: 9a0a         	ldr	r2, [sp, #0x28]
 805a150: 9907         	ldr	r1, [sp, #0x1c]
 805a152: 6808         	ldr	r0, [r1]
 805a154: 4390         	bics	r0, r2
 805a156: 6008         	str	r0, [r1]
;                     }
 805a158: e000         	b	0x805a15c <xEventGroupWaitBits+0x158> @ imm = #0x0
 805a15a: e7ff         	b	0x805a15c <xEventGroupWaitBits+0x158> @ imm = #-0x2
;                 }
 805a15c: e000         	b	0x805a160 <xEventGroupWaitBits+0x15c> @ imm = #0x0
 805a15e: e7ff         	b	0x805a160 <xEventGroupWaitBits+0x15c> @ imm = #-0x2
 805a160: 2001         	movs	r0, #0x1
;                 xTimeoutOccurred = pdTRUE;
 805a162: 9002         	str	r0, [sp, #0x8]
;             taskEXIT_CRITICAL();
 805a164: 4810         	ldr	r0, [pc, #0x40]         @ 0x805a1a8 <xEventGroupWaitBits+0x1a4>
 805a166: 4780         	blx	r0
;         }
 805a168: e000         	b	0x805a16c <xEventGroupWaitBits+0x168> @ imm = #0x0
 805a16a: e7ff         	b	0x805a16c <xEventGroupWaitBits+0x168> @ imm = #-0x2
;         uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 805a16c: 9806         	ldr	r0, [sp, #0x18]
 805a16e: f020 407f    	bic	r0, r0, #0xff000000
 805a172: 9006         	str	r0, [sp, #0x18]
;     }
 805a174: e7ff         	b	0x805a176 <xEventGroupWaitBits+0x172> @ imm = #-0x2
;     return uxReturn;
 805a176: 9806         	ldr	r0, [sp, #0x18]
 805a178: b00c         	add	sp, #0x30
 805a17a: bc80         	pop	{r7}
 805a17c: eba8 0809    	sub.w	r8, r8, r9
 805a180: f858 fd64    	ldr	pc, [r8, #-100]!

0805a184 <$d.7>:
 805a184: 0d 77 05 08  	.word	0x0805770d
 805a188: d9 58 05 08  	.word	0x080558d9
 805a18c: bd a1 05 08  	.word	0x0805a1bd
 805a190: 61 6e 05 08  	.word	0x08056e61
 805a194: 0d 5a 05 08  	.word	0x08055a0d
 805a198: 2f cd 05 08  	.word	0x0805cd2f
 805a19c: e9 7b 05 08  	.word	0x08057be9
 805a1a0: 49 cd 05 08  	.word	0x0805cd49
 805a1a4: bd a1 05 08  	.word	0x0805a1bd
 805a1a8: 7d cd 05 08  	.word	0x0805cd7d
 805a1ac: 15 d7 05 08  	.word	0x0805d715
 805a1b0: 15 d7 05 08  	.word	0x0805d715
 805a1b4: 15 d7 05 08  	.word	0x0805d715
 805a1b8: 15 d7 05 08  	.word	0x0805d715

0805a1bc <prvTestWaitCondition>:
; {
 805a1bc: b084         	sub	sp, #0x10
 805a1be: 9003         	str	r0, [sp, #0xc]
 805a1c0: 9102         	str	r1, [sp, #0x8]
 805a1c2: 9201         	str	r2, [sp, #0x4]
 805a1c4: 2000         	movs	r0, #0x0
;     BaseType_t xWaitConditionMet = pdFALSE;
 805a1c6: 9000         	str	r0, [sp]
;     if( xWaitForAllBits == pdFALSE )
 805a1c8: 9801         	ldr	r0, [sp, #0x4]
 805a1ca: b950         	cbnz	r0, 0x805a1e2 <prvTestWaitCondition+0x26> @ imm = #0x14
 805a1cc: e7ff         	b	0x805a1ce <prvTestWaitCondition+0x12> @ imm = #-0x2
;         if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 805a1ce: 9803         	ldr	r0, [sp, #0xc]
 805a1d0: 9902         	ldr	r1, [sp, #0x8]
 805a1d2: 4208         	tst	r0, r1
 805a1d4: d003         	beq	0x805a1de <prvTestWaitCondition+0x22> @ imm = #0x6
 805a1d6: e7ff         	b	0x805a1d8 <prvTestWaitCondition+0x1c> @ imm = #-0x2
 805a1d8: 2001         	movs	r0, #0x1
;             xWaitConditionMet = pdTRUE;
 805a1da: 9000         	str	r0, [sp]
;         }
 805a1dc: e000         	b	0x805a1e0 <prvTestWaitCondition+0x24> @ imm = #0x0
 805a1de: e7ff         	b	0x805a1e0 <prvTestWaitCondition+0x24> @ imm = #-0x2
;     }
 805a1e0: e00a         	b	0x805a1f8 <prvTestWaitCondition+0x3c> @ imm = #0x14
;         if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 805a1e2: 9803         	ldr	r0, [sp, #0xc]
 805a1e4: 9902         	ldr	r1, [sp, #0x8]
 805a1e6: 4008         	ands	r0, r1
 805a1e8: 4288         	cmp	r0, r1
 805a1ea: d103         	bne	0x805a1f4 <prvTestWaitCondition+0x38> @ imm = #0x6
 805a1ec: e7ff         	b	0x805a1ee <prvTestWaitCondition+0x32> @ imm = #-0x2
 805a1ee: 2001         	movs	r0, #0x1
;             xWaitConditionMet = pdTRUE;
 805a1f0: 9000         	str	r0, [sp]
;         }
 805a1f2: e000         	b	0x805a1f6 <prvTestWaitCondition+0x3a> @ imm = #0x0
 805a1f4: e7ff         	b	0x805a1f6 <prvTestWaitCondition+0x3a> @ imm = #-0x2
 805a1f6: e7ff         	b	0x805a1f8 <prvTestWaitCondition+0x3c> @ imm = #-0x2
;     return xWaitConditionMet;
 805a1f8: 9800         	ldr	r0, [sp]
 805a1fa: b004         	add	sp, #0x10
 805a1fc: 4770         	bx	lr
 805a1fe: bf00         	nop

0805a200 <xEventGroupClearBits>:
; {
 805a200: f848 eb60    	str	lr, [r8], #96
 805a204: eb08 0809    	add.w	r8, r8, r9
 805a208: b480         	push	{r7}
 805a20a: 466f         	mov	r7, sp
 805a20c: b084         	sub	sp, #0x10
 805a20e: 9003         	str	r0, [sp, #0xc]
 805a210: 9102         	str	r1, [sp, #0x8]
;     EventGroup_t * pxEventBits = xEventGroup;
 805a212: 9803         	ldr	r0, [sp, #0xc]
 805a214: 9001         	str	r0, [sp, #0x4]
;     configASSERT( xEventGroup );
 805a216: 9803         	ldr	r0, [sp, #0xc]
 805a218: b920         	cbnz	r0, 0x805a224 <xEventGroupClearBits+0x24> @ imm = #0x8
 805a21a: e7ff         	b	0x805a21c <xEventGroupClearBits+0x1c> @ imm = #-0x2
 805a21c: 4812         	ldr	r0, [pc, #0x48]         @ 0x805a268 <xEventGroupClearBits+0x68>
 805a21e: 4780         	blx	r0
 805a220: e7ff         	b	0x805a222 <xEventGroupClearBits+0x22> @ imm = #-0x2
 805a222: e7fe         	b	0x805a222 <xEventGroupClearBits+0x22> @ imm = #-0x4
;     configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 805a224: f89d 000b    	ldrb.w	r0, [sp, #0xb]
 805a228: b120         	cbz	r0, 0x805a234 <xEventGroupClearBits+0x34> @ imm = #0x8
 805a22a: e7ff         	b	0x805a22c <xEventGroupClearBits+0x2c> @ imm = #-0x2
 805a22c: 480d         	ldr	r0, [pc, #0x34]         @ 0x805a264 <xEventGroupClearBits+0x64>
 805a22e: 4780         	blx	r0
 805a230: e7ff         	b	0x805a232 <xEventGroupClearBits+0x32> @ imm = #-0x2
 805a232: e7fe         	b	0x805a232 <xEventGroupClearBits+0x32> @ imm = #-0x4
;     taskENTER_CRITICAL();
 805a234: 4809         	ldr	r0, [pc, #0x24]         @ 0x805a25c <xEventGroupClearBits+0x5c>
 805a236: 4780         	blx	r0
;         uxReturn = pxEventBits->uxEventBits;
 805a238: 9801         	ldr	r0, [sp, #0x4]
 805a23a: 6800         	ldr	r0, [r0]
 805a23c: 9000         	str	r0, [sp]
;         pxEventBits->uxEventBits &= ~uxBitsToClear;
 805a23e: 9a02         	ldr	r2, [sp, #0x8]
 805a240: 9901         	ldr	r1, [sp, #0x4]
 805a242: 6808         	ldr	r0, [r1]
 805a244: 4390         	bics	r0, r2
 805a246: 6008         	str	r0, [r1]
;     taskEXIT_CRITICAL();
 805a248: 4805         	ldr	r0, [pc, #0x14]         @ 0x805a260 <xEventGroupClearBits+0x60>
 805a24a: 4780         	blx	r0
;     return uxReturn;
 805a24c: 9800         	ldr	r0, [sp]
 805a24e: b004         	add	sp, #0x10
 805a250: bc80         	pop	{r7}
 805a252: eba8 0809    	sub.w	r8, r8, r9
 805a256: f858 fd60    	ldr	pc, [r8, #-96]!
 805a25a: bf00         	nop

0805a25c <$d.9>:
 805a25c: 49 cd 05 08  	.word	0x0805cd49
 805a260: 7d cd 05 08  	.word	0x0805cd7d
 805a264: 15 d7 05 08  	.word	0x0805d715
 805a268: 15 d7 05 08  	.word	0x0805d715

0805a26c <xEventGroupClearBitsFromISR>:
;     {
 805a26c: f848 eb1c    	str	lr, [r8], #28
 805a270: eb08 0809    	add.w	r8, r8, r9
 805a274: b480         	push	{r7}
 805a276: 466f         	mov	r7, sp
 805a278: b084         	sub	sp, #0x10
 805a27a: 9003         	str	r0, [sp, #0xc]
 805a27c: 9102         	str	r1, [sp, #0x8]
;         xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL ); /*lint !e9087 Can't avoid cast to void* as a generic callback function not specific to this use case. Callback casts back to original type so safe. */
 805a27e: 9903         	ldr	r1, [sp, #0xc]
 805a280: 9a02         	ldr	r2, [sp, #0x8]
 805a282: f24a 20a9    	movw	r0, #0xa2a9
 805a286: f6c0 0005    	movt	r0, #0x805
 805a28a: f8df c018    	ldr.w	r12, [pc, #0x18]        @ 0x805a2a4 <xEventGroupClearBitsFromISR+0x38>
 805a28e: 2300         	movs	r3, #0x0
 805a290: 47e0         	blx	r12
 805a292: 9001         	str	r0, [sp, #0x4]
;         return xReturn;
 805a294: 9801         	ldr	r0, [sp, #0x4]
 805a296: b004         	add	sp, #0x10
 805a298: bc80         	pop	{r7}
 805a29a: eba8 0809    	sub.w	r8, r8, r9
 805a29e: f858 fd1c    	ldr	pc, [r8, #-28]!
 805a2a2: bf00         	nop

0805a2a4 <$d.11>:
 805a2a4: 11 91 05 08  	.word	0x08059111

0805a2a8 <vEventGroupClearBitsCallback>:
; {
 805a2a8: f848 eb48    	str	lr, [r8], #72
 805a2ac: eb08 0809    	add.w	r8, r8, r9
 805a2b0: b480         	push	{r7}
 805a2b2: 466f         	mov	r7, sp
 805a2b4: b082         	sub	sp, #0x8
 805a2b6: 9001         	str	r0, [sp, #0x4]
 805a2b8: 9100         	str	r1, [sp]
;     ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 805a2ba: 9801         	ldr	r0, [sp, #0x4]
 805a2bc: 9900         	ldr	r1, [sp]
 805a2be: 4a04         	ldr	r2, [pc, #0x10]         @ 0x805a2d0 <vEventGroupClearBitsCallback+0x28>
 805a2c0: 4790         	blx	r2
; }
 805a2c2: b002         	add	sp, #0x8
 805a2c4: bc80         	pop	{r7}
 805a2c6: eba8 0809    	sub.w	r8, r8, r9
 805a2ca: f858 fd48    	ldr	pc, [r8, #-72]!
 805a2ce: bf00         	nop

0805a2d0 <$d.13>:
 805a2d0: 01 a2 05 08  	.word	0x0805a201

0805a2d4 <xEventGroupGetBitsFromISR>:
; {
 805a2d4: f848 eb18    	str	lr, [r8], #24
 805a2d8: eb08 0809    	add.w	r8, r8, r9
 805a2dc: b480         	push	{r7}
 805a2de: 466f         	mov	r7, sp
 805a2e0: b084         	sub	sp, #0x10
 805a2e2: 9003         	str	r0, [sp, #0xc]
;     EventGroup_t const * const pxEventBits = xEventGroup;
 805a2e4: 9803         	ldr	r0, [sp, #0xc]
 805a2e6: 9001         	str	r0, [sp, #0x4]
;     uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
 805a2e8: 4807         	ldr	r0, [pc, #0x1c]         @ 0x805a308 <xEventGroupGetBitsFromISR+0x34>
 805a2ea: 4780         	blx	r0
 805a2ec: 9002         	str	r0, [sp, #0x8]
;         uxReturn = pxEventBits->uxEventBits;
 805a2ee: 9801         	ldr	r0, [sp, #0x4]
 805a2f0: 6800         	ldr	r0, [r0]
 805a2f2: 9000         	str	r0, [sp]
;     taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
 805a2f4: 9802         	ldr	r0, [sp, #0x8]
 805a2f6: 4905         	ldr	r1, [pc, #0x14]         @ 0x805a30c <xEventGroupGetBitsFromISR+0x38>
 805a2f8: 4788         	blx	r1
;     return uxReturn;
 805a2fa: 9800         	ldr	r0, [sp]
 805a2fc: b004         	add	sp, #0x10
 805a2fe: bc80         	pop	{r7}
 805a300: eba8 0809    	sub.w	r8, r8, r9
 805a304: f858 fd18    	ldr	pc, [r8, #-24]!

0805a308 <$d.15>:
 805a308: 15 d7 05 08  	.word	0x0805d715
 805a30c: 2b d7 05 08  	.word	0x0805d72b

0805a310 <vEventGroupDelete>:
; {
 805a310: f848 eb54    	str	lr, [r8], #84
 805a314: eb08 0809    	add.w	r8, r8, r9
 805a318: b480         	push	{r7}
 805a31a: 466f         	mov	r7, sp
 805a31c: b084         	sub	sp, #0x10
 805a31e: 9003         	str	r0, [sp, #0xc]
;     EventGroup_t * pxEventBits = xEventGroup;
 805a320: 9803         	ldr	r0, [sp, #0xc]
 805a322: 9002         	str	r0, [sp, #0x8]
;     configASSERT( pxEventBits );
 805a324: 9802         	ldr	r0, [sp, #0x8]
 805a326: b920         	cbnz	r0, 0x805a332 <vEventGroupDelete+0x22> @ imm = #0x8
 805a328: e7ff         	b	0x805a32a <vEventGroupDelete+0x1a> @ imm = #-0x2
 805a32a: 481a         	ldr	r0, [pc, #0x68]         @ 0x805a394 <vEventGroupDelete+0x84>
 805a32c: 4780         	blx	r0
 805a32e: e7ff         	b	0x805a330 <vEventGroupDelete+0x20> @ imm = #-0x2
 805a330: e7fe         	b	0x805a330 <vEventGroupDelete+0x20> @ imm = #-0x4
;     pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
 805a332: 9802         	ldr	r0, [sp, #0x8]
 805a334: 3004         	adds	r0, #0x4
 805a336: 9001         	str	r0, [sp, #0x4]
;     vTaskSuspendAll();
 805a338: 4811         	ldr	r0, [pc, #0x44]         @ 0x805a380 <vEventGroupDelete+0x70>
 805a33a: 4780         	blx	r0
;         while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 805a33c: e7ff         	b	0x805a33e <vEventGroupDelete+0x2e> @ imm = #-0x2
 805a33e: 9801         	ldr	r0, [sp, #0x4]
 805a340: 6800         	ldr	r0, [r0]
 805a342: b190         	cbz	r0, 0x805a36a <vEventGroupDelete+0x5a> @ imm = #0x24
 805a344: e7ff         	b	0x805a346 <vEventGroupDelete+0x36> @ imm = #-0x2
;             configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 805a346: 9801         	ldr	r0, [sp, #0x4]
 805a348: f100 0108    	add.w	r1, r0, #0x8
 805a34c: 68c0         	ldr	r0, [r0, #0xc]
 805a34e: 4288         	cmp	r0, r1
 805a350: d104         	bne	0x805a35c <vEventGroupDelete+0x4c> @ imm = #0x8
 805a352: e7ff         	b	0x805a354 <vEventGroupDelete+0x44> @ imm = #-0x2
 805a354: 480e         	ldr	r0, [pc, #0x38]         @ 0x805a390 <vEventGroupDelete+0x80>
 805a356: 4780         	blx	r0
 805a358: e7ff         	b	0x805a35a <vEventGroupDelete+0x4a> @ imm = #-0x2
 805a35a: e7fe         	b	0x805a35a <vEventGroupDelete+0x4a> @ imm = #-0x4
;             vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 805a35c: 9801         	ldr	r0, [sp, #0x4]
 805a35e: 68c0         	ldr	r0, [r0, #0xc]
 805a360: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x805a38c <vEventGroupDelete+0x7c>
 805a362: f04f 7100    	mov.w	r1, #0x2000000
 805a366: 4790         	blx	r2
;         while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 805a368: e7e9         	b	0x805a33e <vEventGroupDelete+0x2e> @ imm = #-0x2e
;     ( void ) xTaskResumeAll();
 805a36a: 4806         	ldr	r0, [pc, #0x18]         @ 0x805a384 <vEventGroupDelete+0x74>
 805a36c: 4780         	blx	r0
;         vPortFree( pxEventBits );
 805a36e: 9802         	ldr	r0, [sp, #0x8]
 805a370: 4905         	ldr	r1, [pc, #0x14]         @ 0x805a388 <vEventGroupDelete+0x78>
 805a372: 4788         	blx	r1
; }
 805a374: b004         	add	sp, #0x10
 805a376: bc80         	pop	{r7}
 805a378: eba8 0809    	sub.w	r8, r8, r9
 805a37c: f858 fd54    	ldr	pc, [r8, #-84]!

0805a380 <$d.17>:
 805a380: d9 58 05 08  	.word	0x080558d9
 805a384: 0d 5a 05 08  	.word	0x08055a0d
 805a388: 61 9a 05 08  	.word	0x08059a61
 805a38c: 99 71 05 08  	.word	0x08057199
 805a390: 15 d7 05 08  	.word	0x0805d715
 805a394: 15 d7 05 08  	.word	0x0805d715

0805a398 <vEventGroupSetBitsCallback>:
; {
 805a398: f848 eb38    	str	lr, [r8], #56
 805a39c: eb08 0809    	add.w	r8, r8, r9
 805a3a0: b480         	push	{r7}
 805a3a2: 466f         	mov	r7, sp
 805a3a4: b082         	sub	sp, #0x8
 805a3a6: 9001         	str	r0, [sp, #0x4]
 805a3a8: 9100         	str	r1, [sp]
;     ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
 805a3aa: 9801         	ldr	r0, [sp, #0x4]
 805a3ac: 9900         	ldr	r1, [sp]
 805a3ae: 4a04         	ldr	r2, [pc, #0x10]         @ 0x805a3c0 <vEventGroupSetBitsCallback+0x28>
 805a3b0: 4790         	blx	r2
; }
 805a3b2: b002         	add	sp, #0x8
 805a3b4: bc80         	pop	{r7}
 805a3b6: eba8 0809    	sub.w	r8, r8, r9
 805a3ba: f858 fd38    	ldr	pc, [r8, #-56]!
 805a3be: bf00         	nop

0805a3c0 <$d.19>:
 805a3c0: e1 9e 05 08  	.word	0x08059ee1

0805a3c4 <xEventGroupSetBitsFromISR>:
;     {
 805a3c4: f848 eb58    	str	lr, [r8], #88
 805a3c8: eb08 0809    	add.w	r8, r8, r9
 805a3cc: b480         	push	{r7}
 805a3ce: 466f         	mov	r7, sp
 805a3d0: b084         	sub	sp, #0x10
 805a3d2: 9003         	str	r0, [sp, #0xc]
 805a3d4: 9102         	str	r1, [sp, #0x8]
 805a3d6: 9201         	str	r2, [sp, #0x4]
;         xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken ); /*lint !e9087 Can't avoid cast to void* as a generic callback function not specific to this use case. Callback casts back to original type so safe. */
 805a3d8: 9903         	ldr	r1, [sp, #0xc]
 805a3da: 9a02         	ldr	r2, [sp, #0x8]
 805a3dc: 9b01         	ldr	r3, [sp, #0x4]
 805a3de: f24a 3099    	movw	r0, #0xa399
 805a3e2: f6c0 0005    	movt	r0, #0x805
 805a3e6: f8df c014    	ldr.w	r12, [pc, #0x14]        @ 0x805a3fc <xEventGroupSetBitsFromISR+0x38>
 805a3ea: 47e0         	blx	r12
 805a3ec: 9000         	str	r0, [sp]
;         return xReturn;
 805a3ee: 9800         	ldr	r0, [sp]
 805a3f0: b004         	add	sp, #0x10
 805a3f2: bc80         	pop	{r7}
 805a3f4: eba8 0809    	sub.w	r8, r8, r9
 805a3f8: f858 fd58    	ldr	pc, [r8, #-88]!

0805a3fc <$d.21>:
 805a3fc: 11 91 05 08  	.word	0x08059111

0805a400 <uxEventGroupGetNumber>:
;     {
 805a400: b083         	sub	sp, #0xc
 805a402: 9002         	str	r0, [sp, #0x8]
;         EventGroup_t const * pxEventBits = ( EventGroup_t * ) xEventGroup; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
 805a404: 9802         	ldr	r0, [sp, #0x8]
 805a406: 9000         	str	r0, [sp]
;         if( xEventGroup == NULL )
 805a408: 9802         	ldr	r0, [sp, #0x8]
 805a40a: b918         	cbnz	r0, 0x805a414 <uxEventGroupGetNumber+0x14> @ imm = #0x6
 805a40c: e7ff         	b	0x805a40e <uxEventGroupGetNumber+0xe> @ imm = #-0x2
 805a40e: 2000         	movs	r0, #0x0
;             xReturn = 0;
 805a410: 9001         	str	r0, [sp, #0x4]
;         }
 805a412: e003         	b	0x805a41c <uxEventGroupGetNumber+0x1c> @ imm = #0x6
;             xReturn = pxEventBits->uxEventGroupNumber;
 805a414: 9800         	ldr	r0, [sp]
 805a416: 6980         	ldr	r0, [r0, #0x18]
 805a418: 9001         	str	r0, [sp, #0x4]
 805a41a: e7ff         	b	0x805a41c <uxEventGroupGetNumber+0x1c> @ imm = #-0x2
;         return xReturn;
 805a41c: 9801         	ldr	r0, [sp, #0x4]
 805a41e: b003         	add	sp, #0xc
 805a420: 4770         	bx	lr

0805a422 <vEventGroupSetNumber>:
;     {
 805a422: b082         	sub	sp, #0x8
 805a424: 9001         	str	r0, [sp, #0x4]
 805a426: 9100         	str	r1, [sp]
;         ( ( EventGroup_t * ) xEventGroup )->uxEventGroupNumber = uxEventGroupNumber; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
 805a428: 9800         	ldr	r0, [sp]
 805a42a: 9901         	ldr	r1, [sp, #0x4]
 805a42c: 6188         	str	r0, [r1, #0x18]
;     }
 805a42e: b002         	add	sp, #0x8
 805a430: 4770         	bx	lr

0805a432 <vListInitialise>:
; {
 805a432: b081         	sub	sp, #0x4
 805a434: 9000         	str	r0, [sp]
;     pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 805a436: 9900         	ldr	r1, [sp]
 805a438: f101 0008    	add.w	r0, r1, #0x8
 805a43c: 6048         	str	r0, [r1, #0x4]
;     pxList->xListEnd.xItemValue = portMAX_DELAY;
 805a43e: 9900         	ldr	r1, [sp]
 805a440: f04f 30ff    	mov.w	r0, #0xffffffff
 805a444: 6088         	str	r0, [r1, #0x8]
;     pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 805a446: 9900         	ldr	r1, [sp]
 805a448: f101 0008    	add.w	r0, r1, #0x8
 805a44c: 60c8         	str	r0, [r1, #0xc]
;     pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 805a44e: 9900         	ldr	r1, [sp]
 805a450: f101 0008    	add.w	r0, r1, #0x8
 805a454: 6108         	str	r0, [r1, #0x10]
;     pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 805a456: 9900         	ldr	r1, [sp]
 805a458: 2000         	movs	r0, #0x0
 805a45a: 6008         	str	r0, [r1]
; }
 805a45c: b001         	add	sp, #0x4
 805a45e: 4770         	bx	lr

0805a460 <vListInitialiseItem>:
; {
 805a460: b081         	sub	sp, #0x4
 805a462: 9000         	str	r0, [sp]
;     pxItem->pxContainer = NULL;
 805a464: 9900         	ldr	r1, [sp]
 805a466: 2000         	movs	r0, #0x0
 805a468: 6108         	str	r0, [r1, #0x10]
; }
 805a46a: b001         	add	sp, #0x4
 805a46c: 4770         	bx	lr

0805a46e <vListInsertEnd>:
; {
 805a46e: b083         	sub	sp, #0xc
 805a470: 9002         	str	r0, [sp, #0x8]
 805a472: 9101         	str	r1, [sp, #0x4]
;     ListItem_t * const pxIndex = pxList->pxIndex;
 805a474: 9802         	ldr	r0, [sp, #0x8]
 805a476: 6840         	ldr	r0, [r0, #0x4]
 805a478: 9000         	str	r0, [sp]
;     pxNewListItem->pxNext = pxIndex;
 805a47a: 9800         	ldr	r0, [sp]
 805a47c: 9901         	ldr	r1, [sp, #0x4]
 805a47e: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 805a480: 9800         	ldr	r0, [sp]
 805a482: 6880         	ldr	r0, [r0, #0x8]
 805a484: 9901         	ldr	r1, [sp, #0x4]
 805a486: 6088         	str	r0, [r1, #0x8]
;     pxIndex->pxPrevious->pxNext = pxNewListItem;
 805a488: 9801         	ldr	r0, [sp, #0x4]
 805a48a: 9900         	ldr	r1, [sp]
 805a48c: 6889         	ldr	r1, [r1, #0x8]
 805a48e: 6048         	str	r0, [r1, #0x4]
;     pxIndex->pxPrevious = pxNewListItem;
 805a490: 9801         	ldr	r0, [sp, #0x4]
 805a492: 9900         	ldr	r1, [sp]
 805a494: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxContainer = pxList;
 805a496: 9802         	ldr	r0, [sp, #0x8]
 805a498: 9901         	ldr	r1, [sp, #0x4]
 805a49a: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
 805a49c: 9902         	ldr	r1, [sp, #0x8]
 805a49e: 6808         	ldr	r0, [r1]
 805a4a0: 3001         	adds	r0, #0x1
 805a4a2: 6008         	str	r0, [r1]
; }
 805a4a4: b003         	add	sp, #0xc
 805a4a6: 4770         	bx	lr

0805a4a8 <vListInsert>:
; {
 805a4a8: b084         	sub	sp, #0x10
 805a4aa: 9003         	str	r0, [sp, #0xc]
 805a4ac: 9102         	str	r1, [sp, #0x8]
;     const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 805a4ae: 9802         	ldr	r0, [sp, #0x8]
 805a4b0: 6800         	ldr	r0, [r0]
 805a4b2: 9000         	str	r0, [sp]
;     if( xValueOfInsertion == portMAX_DELAY )
 805a4b4: 9800         	ldr	r0, [sp]
 805a4b6: 3001         	adds	r0, #0x1
 805a4b8: b920         	cbnz	r0, 0x805a4c4 <vListInsert+0x1c> @ imm = #0x8
 805a4ba: e7ff         	b	0x805a4bc <vListInsert+0x14> @ imm = #-0x2
;         pxIterator = pxList->xListEnd.pxPrevious;
 805a4bc: 9803         	ldr	r0, [sp, #0xc]
 805a4be: 6900         	ldr	r0, [r0, #0x10]
 805a4c0: 9001         	str	r0, [sp, #0x4]
;     }
 805a4c2: e010         	b	0x805a4e6 <vListInsert+0x3e> @ imm = #0x20
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 805a4c4: 9803         	ldr	r0, [sp, #0xc]
 805a4c6: 3008         	adds	r0, #0x8
 805a4c8: 9001         	str	r0, [sp, #0x4]
 805a4ca: e7ff         	b	0x805a4cc <vListInsert+0x24> @ imm = #-0x2
 805a4cc: 9801         	ldr	r0, [sp, #0x4]
 805a4ce: 6840         	ldr	r0, [r0, #0x4]
 805a4d0: 6800         	ldr	r0, [r0]
 805a4d2: 9900         	ldr	r1, [sp]
 805a4d4: 4288         	cmp	r0, r1
 805a4d6: d805         	bhi	0x805a4e4 <vListInsert+0x3c> @ imm = #0xa
 805a4d8: e7ff         	b	0x805a4da <vListInsert+0x32> @ imm = #-0x2
;         }
 805a4da: e7ff         	b	0x805a4dc <vListInsert+0x34> @ imm = #-0x2
;         for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 805a4dc: 9801         	ldr	r0, [sp, #0x4]
 805a4de: 6840         	ldr	r0, [r0, #0x4]
 805a4e0: 9001         	str	r0, [sp, #0x4]
 805a4e2: e7f3         	b	0x805a4cc <vListInsert+0x24> @ imm = #-0x1a
 805a4e4: e7ff         	b	0x805a4e6 <vListInsert+0x3e> @ imm = #-0x2
;     pxNewListItem->pxNext = pxIterator->pxNext;
 805a4e6: 9801         	ldr	r0, [sp, #0x4]
 805a4e8: 6840         	ldr	r0, [r0, #0x4]
 805a4ea: 9902         	ldr	r1, [sp, #0x8]
 805a4ec: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 805a4ee: 9802         	ldr	r0, [sp, #0x8]
 805a4f0: 6841         	ldr	r1, [r0, #0x4]
 805a4f2: 6088         	str	r0, [r1, #0x8]
;     pxNewListItem->pxPrevious = pxIterator;
 805a4f4: 9801         	ldr	r0, [sp, #0x4]
 805a4f6: 9902         	ldr	r1, [sp, #0x8]
 805a4f8: 6088         	str	r0, [r1, #0x8]
;     pxIterator->pxNext = pxNewListItem;
 805a4fa: 9802         	ldr	r0, [sp, #0x8]
 805a4fc: 9901         	ldr	r1, [sp, #0x4]
 805a4fe: 6048         	str	r0, [r1, #0x4]
;     pxNewListItem->pxContainer = pxList;
 805a500: 9803         	ldr	r0, [sp, #0xc]
 805a502: 9902         	ldr	r1, [sp, #0x8]
 805a504: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )++;
 805a506: 9903         	ldr	r1, [sp, #0xc]
 805a508: 6808         	ldr	r0, [r1]
 805a50a: 3001         	adds	r0, #0x1
 805a50c: 6008         	str	r0, [r1]
; }
 805a50e: b004         	add	sp, #0x10
 805a510: 4770         	bx	lr

0805a512 <uxListRemove>:
; {
 805a512: b082         	sub	sp, #0x8
 805a514: 9001         	str	r0, [sp, #0x4]
;     List_t * const pxList = pxItemToRemove->pxContainer;
 805a516: 9801         	ldr	r0, [sp, #0x4]
 805a518: 6900         	ldr	r0, [r0, #0x10]
 805a51a: 9000         	str	r0, [sp]
;     pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 805a51c: 9801         	ldr	r0, [sp, #0x4]
 805a51e: 6841         	ldr	r1, [r0, #0x4]
 805a520: 6880         	ldr	r0, [r0, #0x8]
 805a522: 6088         	str	r0, [r1, #0x8]
;     pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 805a524: 9901         	ldr	r1, [sp, #0x4]
 805a526: 6848         	ldr	r0, [r1, #0x4]
 805a528: 6889         	ldr	r1, [r1, #0x8]
 805a52a: 6048         	str	r0, [r1, #0x4]
;     if( pxList->pxIndex == pxItemToRemove )
 805a52c: 9800         	ldr	r0, [sp]
 805a52e: 6840         	ldr	r0, [r0, #0x4]
 805a530: 9901         	ldr	r1, [sp, #0x4]
 805a532: 4288         	cmp	r0, r1
 805a534: d105         	bne	0x805a542 <uxListRemove+0x30> @ imm = #0xa
 805a536: e7ff         	b	0x805a538 <uxListRemove+0x26> @ imm = #-0x2
;         pxList->pxIndex = pxItemToRemove->pxPrevious;
 805a538: 9801         	ldr	r0, [sp, #0x4]
 805a53a: 6880         	ldr	r0, [r0, #0x8]
 805a53c: 9900         	ldr	r1, [sp]
 805a53e: 6048         	str	r0, [r1, #0x4]
;     }
 805a540: e000         	b	0x805a544 <uxListRemove+0x32> @ imm = #0x0
 805a542: e7ff         	b	0x805a544 <uxListRemove+0x32> @ imm = #-0x2
;     pxItemToRemove->pxContainer = NULL;
 805a544: 9901         	ldr	r1, [sp, #0x4]
 805a546: 2000         	movs	r0, #0x0
 805a548: 6108         	str	r0, [r1, #0x10]
;     ( pxList->uxNumberOfItems )--;
 805a54a: 9900         	ldr	r1, [sp]
 805a54c: 6808         	ldr	r0, [r1]
 805a54e: 3801         	subs	r0, #0x1
 805a550: 6008         	str	r0, [r1]
;     return pxList->uxNumberOfItems;
 805a552: 9800         	ldr	r0, [sp]
 805a554: 6800         	ldr	r0, [r0]
 805a556: b002         	add	sp, #0x8
 805a558: 4770         	bx	lr
 805a55a: 0000         	movs	r0, r0

0805a55c <xQueueGenericReset>:
; {
 805a55c: f848 eb34    	str	lr, [r8], #52
 805a560: eb08 0809    	add.w	r8, r8, r9
 805a564: b480         	push	{r7}
 805a566: 466f         	mov	r7, sp
 805a568: b084         	sub	sp, #0x10
 805a56a: 9003         	str	r0, [sp, #0xc]
 805a56c: 9102         	str	r1, [sp, #0x8]
 805a56e: 2001         	movs	r0, #0x1
;     BaseType_t xReturn = pdPASS;
 805a570: 9001         	str	r0, [sp, #0x4]
;     Queue_t * const pxQueue = xQueue;
 805a572: 9803         	ldr	r0, [sp, #0xc]
 805a574: 9000         	str	r0, [sp]
;     configASSERT( pxQueue );
 805a576: 9800         	ldr	r0, [sp]
 805a578: b920         	cbnz	r0, 0x805a584 <xQueueGenericReset+0x28> @ imm = #0x8
 805a57a: e7ff         	b	0x805a57c <xQueueGenericReset+0x20> @ imm = #-0x2
 805a57c: 4839         	ldr	r0, [pc, #0xe4]         @ 0x805a664 <xQueueGenericReset+0x108>
 805a57e: 4780         	blx	r0
 805a580: e7ff         	b	0x805a582 <xQueueGenericReset+0x26> @ imm = #-0x2
 805a582: e7fe         	b	0x805a582 <xQueueGenericReset+0x26> @ imm = #-0x4
;     if( ( pxQueue != NULL ) &&
 805a584: 9800         	ldr	r0, [sp]
 805a586: 2800         	cmp	r0, #0x0
 805a588: d04d         	beq	0x805a626 <xQueueGenericReset+0xca> @ imm = #0x9a
 805a58a: e7ff         	b	0x805a58c <xQueueGenericReset+0x30> @ imm = #-0x2
;         ( pxQueue->uxLength >= 1U ) &&
 805a58c: 9800         	ldr	r0, [sp]
 805a58e: 6bc0         	ldr	r0, [r0, #0x3c]
 805a590: 2800         	cmp	r0, #0x0
 805a592: d048         	beq	0x805a626 <xQueueGenericReset+0xca> @ imm = #0x90
 805a594: e7ff         	b	0x805a596 <xQueueGenericReset+0x3a> @ imm = #-0x2
;         ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
 805a596: 9800         	ldr	r0, [sp]
 805a598: 6bc2         	ldr	r2, [r0, #0x3c]
 805a59a: 6c01         	ldr	r1, [r0, #0x40]
 805a59c: f04f 30ff    	mov.w	r0, #0xffffffff
 805a5a0: fbb0 f0f2    	udiv	r0, r0, r2
;     if( ( pxQueue != NULL ) &&
 805a5a4: 4288         	cmp	r0, r1
 805a5a6: d33e         	blo	0x805a626 <xQueueGenericReset+0xca> @ imm = #0x7c
 805a5a8: e7ff         	b	0x805a5aa <xQueueGenericReset+0x4e> @ imm = #-0x2
;         taskENTER_CRITICAL();
 805a5aa: 4827         	ldr	r0, [pc, #0x9c]         @ 0x805a648 <xQueueGenericReset+0xec>
 805a5ac: 4780         	blx	r0
;             pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 805a5ae: 9900         	ldr	r1, [sp]
 805a5b0: 680b         	ldr	r3, [r1]
 805a5b2: 6bc8         	ldr	r0, [r1, #0x3c]
 805a5b4: 6c0a         	ldr	r2, [r1, #0x40]
 805a5b6: fb00 3002    	mla	r0, r0, r2, r3
 805a5ba: 6088         	str	r0, [r1, #0x8]
;             pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 805a5bc: 9900         	ldr	r1, [sp]
 805a5be: 2000         	movs	r0, #0x0
 805a5c0: 6388         	str	r0, [r1, #0x38]
;             pxQueue->pcWriteTo = pxQueue->pcHead;
 805a5c2: 9900         	ldr	r1, [sp]
 805a5c4: 6808         	ldr	r0, [r1]
 805a5c6: 6048         	str	r0, [r1, #0x4]
;             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 805a5c8: 9900         	ldr	r1, [sp]
 805a5ca: 680b         	ldr	r3, [r1]
 805a5cc: 6bc8         	ldr	r0, [r1, #0x3c]
 805a5ce: 6c0a         	ldr	r2, [r1, #0x40]
 805a5d0: 3801         	subs	r0, #0x1
 805a5d2: fb00 3002    	mla	r0, r0, r2, r3
 805a5d6: 60c8         	str	r0, [r1, #0xc]
;             pxQueue->cRxLock = queueUNLOCKED;
 805a5d8: 9900         	ldr	r1, [sp]
 805a5da: 20ff         	movs	r0, #0xff
 805a5dc: f881 0044    	strb.w	r0, [r1, #0x44]
;             pxQueue->cTxLock = queueUNLOCKED;
 805a5e0: 9900         	ldr	r1, [sp]
 805a5e2: f881 0045    	strb.w	r0, [r1, #0x45]
;             if( xNewQueue == pdFALSE )
 805a5e6: 9802         	ldr	r0, [sp, #0x8]
 805a5e8: b988         	cbnz	r0, 0x805a60e <xQueueGenericReset+0xb2> @ imm = #0x22
 805a5ea: e7ff         	b	0x805a5ec <xQueueGenericReset+0x90> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 805a5ec: 9800         	ldr	r0, [sp]
 805a5ee: 6900         	ldr	r0, [r0, #0x10]
 805a5f0: b158         	cbz	r0, 0x805a60a <xQueueGenericReset+0xae> @ imm = #0x16
 805a5f2: e7ff         	b	0x805a5f4 <xQueueGenericReset+0x98> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 805a5f4: 9800         	ldr	r0, [sp]
 805a5f6: 3010         	adds	r0, #0x10
 805a5f8: 4916         	ldr	r1, [pc, #0x58]         @ 0x805a654 <xQueueGenericReset+0xf8>
 805a5fa: 4788         	blx	r1
 805a5fc: b118         	cbz	r0, 0x805a606 <xQueueGenericReset+0xaa> @ imm = #0x6
 805a5fe: e7ff         	b	0x805a600 <xQueueGenericReset+0xa4> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
 805a600: 4815         	ldr	r0, [pc, #0x54]         @ 0x805a658 <xQueueGenericReset+0xfc>
 805a602: 4780         	blx	r0
;                     }
 805a604: e000         	b	0x805a608 <xQueueGenericReset+0xac> @ imm = #0x0
 805a606: e7ff         	b	0x805a608 <xQueueGenericReset+0xac> @ imm = #-0x2
;                 }
 805a608: e000         	b	0x805a60c <xQueueGenericReset+0xb0> @ imm = #0x0
 805a60a: e7ff         	b	0x805a60c <xQueueGenericReset+0xb0> @ imm = #-0x2
;             }
 805a60c: e008         	b	0x805a620 <xQueueGenericReset+0xc4> @ imm = #0x10
;                 vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 805a60e: 9800         	ldr	r0, [sp]
 805a610: 3010         	adds	r0, #0x10
 805a612: 490e         	ldr	r1, [pc, #0x38]         @ 0x805a64c <xQueueGenericReset+0xf0>
 805a614: 4788         	blx	r1
;                 vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 805a616: 9800         	ldr	r0, [sp]
 805a618: 3024         	adds	r0, #0x24
 805a61a: 490d         	ldr	r1, [pc, #0x34]         @ 0x805a650 <xQueueGenericReset+0xf4>
 805a61c: 4788         	blx	r1
 805a61e: e7ff         	b	0x805a620 <xQueueGenericReset+0xc4> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 805a620: 480e         	ldr	r0, [pc, #0x38]         @ 0x805a65c <xQueueGenericReset+0x100>
 805a622: 4780         	blx	r0
;     }
 805a624: e002         	b	0x805a62c <xQueueGenericReset+0xd0> @ imm = #0x4
 805a626: 2000         	movs	r0, #0x0
;         xReturn = pdFAIL;
 805a628: 9001         	str	r0, [sp, #0x4]
 805a62a: e7ff         	b	0x805a62c <xQueueGenericReset+0xd0> @ imm = #-0x2
;     configASSERT( xReturn != pdFAIL );
 805a62c: 9801         	ldr	r0, [sp, #0x4]
 805a62e: b920         	cbnz	r0, 0x805a63a <xQueueGenericReset+0xde> @ imm = #0x8
 805a630: e7ff         	b	0x805a632 <xQueueGenericReset+0xd6> @ imm = #-0x2
 805a632: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805a660 <xQueueGenericReset+0x104>
 805a634: 4780         	blx	r0
 805a636: e7ff         	b	0x805a638 <xQueueGenericReset+0xdc> @ imm = #-0x2
 805a638: e7fe         	b	0x805a638 <xQueueGenericReset+0xdc> @ imm = #-0x4
;     return xReturn;
 805a63a: 9801         	ldr	r0, [sp, #0x4]
 805a63c: b004         	add	sp, #0x10
 805a63e: bc80         	pop	{r7}
 805a640: eba8 0809    	sub.w	r8, r8, r9
 805a644: f858 fd34    	ldr	pc, [r8, #-52]!

0805a648 <$d.1>:
 805a648: 49 cd 05 08  	.word	0x0805cd49
 805a64c: 33 a4 05 08  	.word	0x0805a433
 805a650: 33 a4 05 08  	.word	0x0805a433
 805a654: a9 6f 05 08  	.word	0x08056fa9
 805a658: 2f cd 05 08  	.word	0x0805cd2f
 805a65c: 7d cd 05 08  	.word	0x0805cd7d
 805a660: 15 d7 05 08  	.word	0x0805d715
 805a664: 15 d7 05 08  	.word	0x0805d715

0805a668 <xQueueGenericCreate>:
;     {
 805a668: f848 eb3c    	str	lr, [r8], #60
 805a66c: eb08 0809    	add.w	r8, r8, r9
 805a670: b480         	push	{r7}
 805a672: 466f         	mov	r7, sp
 805a674: b088         	sub	sp, #0x20
 805a676: 9007         	str	r0, [sp, #0x1c]
 805a678: 9106         	str	r1, [sp, #0x18]
 805a67a: f807 2c09    	strb	r2, [r7, #-9]
 805a67e: 2000         	movs	r0, #0x0
;         Queue_t * pxNewQueue = NULL;
 805a680: 9004         	str	r0, [sp, #0x10]
;         if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 805a682: 9807         	ldr	r0, [sp, #0x1c]
 805a684: b388         	cbz	r0, 0x805a6ea <xQueueGenericCreate+0x82> @ imm = #0x62
 805a686: e7ff         	b	0x805a688 <xQueueGenericCreate+0x20> @ imm = #-0x2
;             ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 805a688: 9907         	ldr	r1, [sp, #0x1c]
 805a68a: f04f 30ff    	mov.w	r0, #0xffffffff
 805a68e: fbb0 f0f1    	udiv	r0, r0, r1
 805a692: 9906         	ldr	r1, [sp, #0x18]
 805a694: 4288         	cmp	r0, r1
 805a696: d328         	blo	0x805a6ea <xQueueGenericCreate+0x82> @ imm = #0x50
 805a698: e7ff         	b	0x805a69a <xQueueGenericCreate+0x32> @ imm = #-0x2
;             ( ( UBaseType_t ) ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
 805a69a: 9807         	ldr	r0, [sp, #0x1c]
 805a69c: 9906         	ldr	r1, [sp, #0x18]
 805a69e: 4348         	muls	r0, r1, r0
;         if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 805a6a0: f110 0f51    	cmn.w	r0, #0x51
 805a6a4: d821         	bhi	0x805a6ea <xQueueGenericCreate+0x82> @ imm = #0x42
 805a6a6: e7ff         	b	0x805a6a8 <xQueueGenericCreate+0x40> @ imm = #-0x2
;             xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 805a6a8: 9807         	ldr	r0, [sp, #0x1c]
 805a6aa: 9906         	ldr	r1, [sp, #0x18]
 805a6ac: 4348         	muls	r0, r1, r0
 805a6ae: 9003         	str	r0, [sp, #0xc]
;             pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 805a6b0: 9803         	ldr	r0, [sp, #0xc]
 805a6b2: 3050         	adds	r0, #0x50
 805a6b4: 4915         	ldr	r1, [pc, #0x54]         @ 0x805a70c <xQueueGenericCreate+0xa4>
 805a6b6: 4788         	blx	r1
 805a6b8: 9004         	str	r0, [sp, #0x10]
;             if( pxNewQueue != NULL )
 805a6ba: 9804         	ldr	r0, [sp, #0x10]
 805a6bc: b198         	cbz	r0, 0x805a6e6 <xQueueGenericCreate+0x7e> @ imm = #0x26
 805a6be: e7ff         	b	0x805a6c0 <xQueueGenericCreate+0x58> @ imm = #-0x2
;                 pucQueueStorage = ( uint8_t * ) pxNewQueue;
 805a6c0: 9804         	ldr	r0, [sp, #0x10]
 805a6c2: 9002         	str	r0, [sp, #0x8]
;                 pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 805a6c4: 9802         	ldr	r0, [sp, #0x8]
 805a6c6: 3050         	adds	r0, #0x50
 805a6c8: 9002         	str	r0, [sp, #0x8]
;                 prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 805a6ca: 9807         	ldr	r0, [sp, #0x1c]
 805a6cc: 9906         	ldr	r1, [sp, #0x18]
 805a6ce: 9a02         	ldr	r2, [sp, #0x8]
 805a6d0: f817 3c09    	ldrb	r3, [r7, #-9]
 805a6d4: f8dd c010    	ldr.w	r12, [sp, #0x10]
 805a6d8: 46ee         	mov	lr, sp
 805a6da: f8ce c000    	str.w	r12, [lr]
 805a6de: f8df c030    	ldr.w	r12, [pc, #0x30]        @ 0x805a710 <xQueueGenericCreate+0xa8>
 805a6e2: 47e0         	blx	r12
;             }
 805a6e4: e000         	b	0x805a6e8 <xQueueGenericCreate+0x80> @ imm = #0x0
 805a6e6: e7ff         	b	0x805a6e8 <xQueueGenericCreate+0x80> @ imm = #-0x2
;         }
 805a6e8: e007         	b	0x805a6fa <xQueueGenericCreate+0x92> @ imm = #0xe
;             configASSERT( pxNewQueue );
 805a6ea: 9804         	ldr	r0, [sp, #0x10]
 805a6ec: b920         	cbnz	r0, 0x805a6f8 <xQueueGenericCreate+0x90> @ imm = #0x8
 805a6ee: e7ff         	b	0x805a6f0 <xQueueGenericCreate+0x88> @ imm = #-0x2
 805a6f0: 4805         	ldr	r0, [pc, #0x14]         @ 0x805a708 <xQueueGenericCreate+0xa0>
 805a6f2: 4780         	blx	r0
 805a6f4: e7ff         	b	0x805a6f6 <xQueueGenericCreate+0x8e> @ imm = #-0x2
 805a6f6: e7fe         	b	0x805a6f6 <xQueueGenericCreate+0x8e> @ imm = #-0x4
 805a6f8: e7ff         	b	0x805a6fa <xQueueGenericCreate+0x92> @ imm = #-0x2
;         return pxNewQueue;
 805a6fa: 9804         	ldr	r0, [sp, #0x10]
 805a6fc: b008         	add	sp, #0x20
 805a6fe: bc80         	pop	{r7}
 805a700: eba8 0809    	sub.w	r8, r8, r9
 805a704: f858 fd3c    	ldr	pc, [r8, #-60]!

0805a708 <$d.3>:
 805a708: 15 d7 05 08  	.word	0x0805d715
 805a70c: cd 96 05 08  	.word	0x080596cd
 805a710: 15 a7 05 08  	.word	0x0805a715

0805a714 <prvInitialiseNewQueue>:
; {
 805a714: f848 eb68    	str	lr, [r8], #104
 805a718: eb08 0809    	add.w	r8, r8, r9
 805a71c: b480         	push	{r7}
 805a71e: 466f         	mov	r7, sp
 805a720: b084         	sub	sp, #0x10
 805a722: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805a726: 9003         	str	r0, [sp, #0xc]
 805a728: 9102         	str	r1, [sp, #0x8]
 805a72a: 9201         	str	r2, [sp, #0x4]
 805a72c: f807 3c0d    	strb	r3, [r7, #-13]
;     if( uxItemSize == ( UBaseType_t ) 0 )
 805a730: 9802         	ldr	r0, [sp, #0x8]
 805a732: b918         	cbnz	r0, 0x805a73c <prvInitialiseNewQueue+0x28> @ imm = #0x6
 805a734: e7ff         	b	0x805a736 <prvInitialiseNewQueue+0x22> @ imm = #-0x2
;         pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 805a736: 68b8         	ldr	r0, [r7, #0x8]
 805a738: 6000         	str	r0, [r0]
;     }
 805a73a: e003         	b	0x805a744 <prvInitialiseNewQueue+0x30> @ imm = #0x6
;         pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 805a73c: 9801         	ldr	r0, [sp, #0x4]
 805a73e: 68b9         	ldr	r1, [r7, #0x8]
 805a740: 6008         	str	r0, [r1]
 805a742: e7ff         	b	0x805a744 <prvInitialiseNewQueue+0x30> @ imm = #-0x2
;     pxNewQueue->uxLength = uxQueueLength;
 805a744: 9803         	ldr	r0, [sp, #0xc]
 805a746: 68b9         	ldr	r1, [r7, #0x8]
 805a748: 63c8         	str	r0, [r1, #0x3c]
;     pxNewQueue->uxItemSize = uxItemSize;
 805a74a: 9802         	ldr	r0, [sp, #0x8]
 805a74c: 68b9         	ldr	r1, [r7, #0x8]
 805a74e: 6408         	str	r0, [r1, #0x40]
;     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 805a750: 68b8         	ldr	r0, [r7, #0x8]
 805a752: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x805a770 <prvInitialiseNewQueue+0x5c>
 805a754: 2101         	movs	r1, #0x1
 805a756: 4790         	blx	r2
;         pxNewQueue->ucQueueType = ucQueueType;
 805a758: f817 0c0d    	ldrb	r0, [r7, #-13]
 805a75c: 68b9         	ldr	r1, [r7, #0x8]
 805a75e: f881 004c    	strb.w	r0, [r1, #0x4c]
; }
 805a762: b004         	add	sp, #0x10
 805a764: bc80         	pop	{r7}
 805a766: eba8 0809    	sub.w	r8, r8, r9
 805a76a: f858 fd68    	ldr	pc, [r8, #-104]!
 805a76e: bf00         	nop

0805a770 <$d.5>:
 805a770: 5d a5 05 08  	.word	0x0805a55d

0805a774 <xQueueCreateMutex>:
;     {
 805a774: f848 eb04    	str	lr, [r8], #4
 805a778: eb08 0809    	add.w	r8, r8, r9
 805a77c: b480         	push	{r7}
 805a77e: 466f         	mov	r7, sp
 805a780: b084         	sub	sp, #0x10
 805a782: f807 0c01    	strb	r0, [r7, #-1]
 805a786: 2001         	movs	r0, #0x1
;         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 805a788: 9001         	str	r0, [sp, #0x4]
 805a78a: 2100         	movs	r1, #0x0
 805a78c: 9100         	str	r1, [sp]
;         xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 805a78e: f817 2c01    	ldrb	r2, [r7, #-1]
 805a792: 4b06         	ldr	r3, [pc, #0x18]         @ 0x805a7ac <xQueueCreateMutex+0x38>
 805a794: 4798         	blx	r3
 805a796: 9002         	str	r0, [sp, #0x8]
;         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 805a798: 9802         	ldr	r0, [sp, #0x8]
 805a79a: 4905         	ldr	r1, [pc, #0x14]         @ 0x805a7b0 <xQueueCreateMutex+0x3c>
 805a79c: 4788         	blx	r1
;         return xNewQueue;
 805a79e: 9802         	ldr	r0, [sp, #0x8]
 805a7a0: b004         	add	sp, #0x10
 805a7a2: bc80         	pop	{r7}
 805a7a4: eba8 0809    	sub.w	r8, r8, r9
 805a7a8: f858 fd04    	ldr	pc, [r8, #-4]!

0805a7ac <$d.7>:
 805a7ac: 69 a6 05 08  	.word	0x0805a669
 805a7b0: b5 a7 05 08  	.word	0x0805a7b5

0805a7b4 <prvInitialiseMutex>:
;     {
 805a7b4: f848 eb54    	str	lr, [r8], #84
 805a7b8: eb08 0809    	add.w	r8, r8, r9
 805a7bc: b480         	push	{r7}
 805a7be: 466f         	mov	r7, sp
 805a7c0: b082         	sub	sp, #0x8
 805a7c2: 9001         	str	r0, [sp, #0x4]
;         if( pxNewQueue != NULL )
 805a7c4: 9801         	ldr	r0, [sp, #0x4]
 805a7c6: b170         	cbz	r0, 0x805a7e6 <prvInitialiseMutex+0x32> @ imm = #0x1c
 805a7c8: e7ff         	b	0x805a7ca <prvInitialiseMutex+0x16> @ imm = #-0x2
;             pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 805a7ca: 9801         	ldr	r0, [sp, #0x4]
 805a7cc: 2300         	movs	r3, #0x0
 805a7ce: 6083         	str	r3, [r0, #0x8]
;             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 805a7d0: 9801         	ldr	r0, [sp, #0x4]
 805a7d2: 6003         	str	r3, [r0]
;             pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 805a7d4: 9801         	ldr	r0, [sp, #0x4]
 805a7d6: 60c3         	str	r3, [r0, #0xc]
;             ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 805a7d8: 9801         	ldr	r0, [sp, #0x4]
 805a7da: f8df c018    	ldr.w	r12, [pc, #0x18]        @ 0x805a7f4 <prvInitialiseMutex+0x40>
 805a7de: 4619         	mov	r1, r3
 805a7e0: 461a         	mov	r2, r3
 805a7e2: 47e0         	blx	r12
;         }
 805a7e4: e000         	b	0x805a7e8 <prvInitialiseMutex+0x34> @ imm = #0x0
 805a7e6: e7ff         	b	0x805a7e8 <prvInitialiseMutex+0x34> @ imm = #-0x2
;     }
 805a7e8: b002         	add	sp, #0x8
 805a7ea: bc80         	pop	{r7}
 805a7ec: eba8 0809    	sub.w	r8, r8, r9
 805a7f0: f858 fd54    	ldr	pc, [r8, #-84]!

0805a7f4 <$d.9>:
 805a7f4: 1d a9 05 08  	.word	0x0805a91d

0805a7f8 <xQueueGetMutexHolder>:
;     {
 805a7f8: f848 eb70    	str	lr, [r8], #112
 805a7fc: eb08 0809    	add.w	r8, r8, r9
 805a800: b480         	push	{r7}
 805a802: 466f         	mov	r7, sp
 805a804: b084         	sub	sp, #0x10
 805a806: 9003         	str	r0, [sp, #0xc]
;         Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 805a808: 9803         	ldr	r0, [sp, #0xc]
 805a80a: 9001         	str	r0, [sp, #0x4]
;         configASSERT( xSemaphore );
 805a80c: 9803         	ldr	r0, [sp, #0xc]
 805a80e: b920         	cbnz	r0, 0x805a81a <xQueueGetMutexHolder+0x22> @ imm = #0x8
 805a810: e7ff         	b	0x805a812 <xQueueGetMutexHolder+0x1a> @ imm = #-0x2
 805a812: 480f         	ldr	r0, [pc, #0x3c]         @ 0x805a850 <xQueueGetMutexHolder+0x58>
 805a814: 4780         	blx	r0
 805a816: e7ff         	b	0x805a818 <xQueueGetMutexHolder+0x20> @ imm = #-0x2
 805a818: e7fe         	b	0x805a818 <xQueueGetMutexHolder+0x20> @ imm = #-0x4
;         taskENTER_CRITICAL();
 805a81a: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805a848 <xQueueGetMutexHolder+0x50>
 805a81c: 4780         	blx	r0
;             if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 805a81e: 9801         	ldr	r0, [sp, #0x4]
 805a820: 6800         	ldr	r0, [r0]
 805a822: b920         	cbnz	r0, 0x805a82e <xQueueGetMutexHolder+0x36> @ imm = #0x8
 805a824: e7ff         	b	0x805a826 <xQueueGetMutexHolder+0x2e> @ imm = #-0x2
;                 pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 805a826: 9801         	ldr	r0, [sp, #0x4]
 805a828: 6880         	ldr	r0, [r0, #0x8]
 805a82a: 9002         	str	r0, [sp, #0x8]
;             }
 805a82c: e002         	b	0x805a834 <xQueueGetMutexHolder+0x3c> @ imm = #0x4
 805a82e: 2000         	movs	r0, #0x0
;                 pxReturn = NULL;
 805a830: 9002         	str	r0, [sp, #0x8]
 805a832: e7ff         	b	0x805a834 <xQueueGetMutexHolder+0x3c> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 805a834: 4805         	ldr	r0, [pc, #0x14]         @ 0x805a84c <xQueueGetMutexHolder+0x54>
 805a836: 4780         	blx	r0
;         return pxReturn;
 805a838: 9802         	ldr	r0, [sp, #0x8]
 805a83a: b004         	add	sp, #0x10
 805a83c: bc80         	pop	{r7}
 805a83e: eba8 0809    	sub.w	r8, r8, r9
 805a842: f858 fd70    	ldr	pc, [r8, #-112]!
 805a846: bf00         	nop

0805a848 <$d.11>:
 805a848: 49 cd 05 08  	.word	0x0805cd49
 805a84c: 7d cd 05 08  	.word	0x0805cd7d
 805a850: 15 d7 05 08  	.word	0x0805d715

0805a854 <xQueueGetMutexHolderFromISR>:
;     {
 805a854: f848 eb50    	str	lr, [r8], #80
 805a858: eb08 0809    	add.w	r8, r8, r9
 805a85c: b480         	push	{r7}
 805a85e: 466f         	mov	r7, sp
 805a860: b082         	sub	sp, #0x8
 805a862: 9001         	str	r0, [sp, #0x4]
;         configASSERT( xSemaphore );
 805a864: 9801         	ldr	r0, [sp, #0x4]
 805a866: b920         	cbnz	r0, 0x805a872 <xQueueGetMutexHolderFromISR+0x1e> @ imm = #0x8
 805a868: e7ff         	b	0x805a86a <xQueueGetMutexHolderFromISR+0x16> @ imm = #-0x2
 805a86a: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805a898 <xQueueGetMutexHolderFromISR+0x44>
 805a86c: 4780         	blx	r0
 805a86e: e7ff         	b	0x805a870 <xQueueGetMutexHolderFromISR+0x1c> @ imm = #-0x2
 805a870: e7fe         	b	0x805a870 <xQueueGetMutexHolderFromISR+0x1c> @ imm = #-0x4
;         if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 805a872: 9801         	ldr	r0, [sp, #0x4]
 805a874: 6800         	ldr	r0, [r0]
 805a876: b920         	cbnz	r0, 0x805a882 <xQueueGetMutexHolderFromISR+0x2e> @ imm = #0x8
 805a878: e7ff         	b	0x805a87a <xQueueGetMutexHolderFromISR+0x26> @ imm = #-0x2
;             pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 805a87a: 9801         	ldr	r0, [sp, #0x4]
 805a87c: 6880         	ldr	r0, [r0, #0x8]
 805a87e: 9000         	str	r0, [sp]
;         }
 805a880: e002         	b	0x805a888 <xQueueGetMutexHolderFromISR+0x34> @ imm = #0x4
 805a882: 2000         	movs	r0, #0x0
;             pxReturn = NULL;
 805a884: 9000         	str	r0, [sp]
 805a886: e7ff         	b	0x805a888 <xQueueGetMutexHolderFromISR+0x34> @ imm = #-0x2
;         return pxReturn;
 805a888: 9800         	ldr	r0, [sp]
 805a88a: b002         	add	sp, #0x8
 805a88c: bc80         	pop	{r7}
 805a88e: eba8 0809    	sub.w	r8, r8, r9
 805a892: f858 fd50    	ldr	pc, [r8, #-80]!
 805a896: bf00         	nop

0805a898 <$d.13>:
 805a898: 15 d7 05 08  	.word	0x0805d715

0805a89c <xQueueGiveMutexRecursive>:
;     {
 805a89c: f848 eb70    	str	lr, [r8], #112
 805a8a0: eb08 0809    	add.w	r8, r8, r9
 805a8a4: b480         	push	{r7}
 805a8a6: 466f         	mov	r7, sp
 805a8a8: b084         	sub	sp, #0x10
 805a8aa: 9003         	str	r0, [sp, #0xc]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 805a8ac: 9803         	ldr	r0, [sp, #0xc]
 805a8ae: 9001         	str	r0, [sp, #0x4]
;         configASSERT( pxMutex );
 805a8b0: 9801         	ldr	r0, [sp, #0x4]
 805a8b2: b920         	cbnz	r0, 0x805a8be <xQueueGiveMutexRecursive+0x22> @ imm = #0x8
 805a8b4: e7ff         	b	0x805a8b6 <xQueueGiveMutexRecursive+0x1a> @ imm = #-0x2
 805a8b6: 4818         	ldr	r0, [pc, #0x60]         @ 0x805a918 <xQueueGiveMutexRecursive+0x7c>
 805a8b8: 4780         	blx	r0
 805a8ba: e7ff         	b	0x805a8bc <xQueueGiveMutexRecursive+0x20> @ imm = #-0x2
 805a8bc: e7fe         	b	0x805a8bc <xQueueGiveMutexRecursive+0x20> @ imm = #-0x4
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 805a8be: 9801         	ldr	r0, [sp, #0x4]
 805a8c0: 6880         	ldr	r0, [r0, #0x8]
 805a8c2: 9000         	str	r0, [sp]
 805a8c4: 4812         	ldr	r0, [pc, #0x48]         @ 0x805a910 <xQueueGiveMutexRecursive+0x74>
 805a8c6: 4780         	blx	r0
 805a8c8: 4601         	mov	r1, r0
 805a8ca: 9800         	ldr	r0, [sp]
 805a8cc: 4288         	cmp	r0, r1
 805a8ce: d114         	bne	0x805a8fa <xQueueGiveMutexRecursive+0x5e> @ imm = #0x28
 805a8d0: e7ff         	b	0x805a8d2 <xQueueGiveMutexRecursive+0x36> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 805a8d2: 9901         	ldr	r1, [sp, #0x4]
 805a8d4: 68c8         	ldr	r0, [r1, #0xc]
 805a8d6: 3801         	subs	r0, #0x1
 805a8d8: 60c8         	str	r0, [r1, #0xc]
;             if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 805a8da: 9801         	ldr	r0, [sp, #0x4]
 805a8dc: 68c0         	ldr	r0, [r0, #0xc]
 805a8de: b940         	cbnz	r0, 0x805a8f2 <xQueueGiveMutexRecursive+0x56> @ imm = #0x10
 805a8e0: e7ff         	b	0x805a8e2 <xQueueGiveMutexRecursive+0x46> @ imm = #-0x2
;                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 805a8e2: 9801         	ldr	r0, [sp, #0x4]
 805a8e4: f8df c02c    	ldr.w	r12, [pc, #0x2c]        @ 0x805a914 <xQueueGiveMutexRecursive+0x78>
 805a8e8: 2300         	movs	r3, #0x0
 805a8ea: 4619         	mov	r1, r3
 805a8ec: 461a         	mov	r2, r3
 805a8ee: 47e0         	blx	r12
;             }
 805a8f0: e000         	b	0x805a8f4 <xQueueGiveMutexRecursive+0x58> @ imm = #0x0
 805a8f2: e7ff         	b	0x805a8f4 <xQueueGiveMutexRecursive+0x58> @ imm = #-0x2
 805a8f4: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
 805a8f6: 9002         	str	r0, [sp, #0x8]
;         }
 805a8f8: e002         	b	0x805a900 <xQueueGiveMutexRecursive+0x64> @ imm = #0x4
 805a8fa: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
 805a8fc: 9002         	str	r0, [sp, #0x8]
 805a8fe: e7ff         	b	0x805a900 <xQueueGiveMutexRecursive+0x64> @ imm = #-0x2
;         return xReturn;
 805a900: 9802         	ldr	r0, [sp, #0x8]
 805a902: b004         	add	sp, #0x10
 805a904: bc80         	pop	{r7}
 805a906: eba8 0809    	sub.w	r8, r8, r9
 805a90a: f858 fd70    	ldr	pc, [r8, #-112]!
 805a90e: bf00         	nop

0805a910 <$d.15>:
 805a910: f9 76 05 08  	.word	0x080576f9
 805a914: 1d a9 05 08  	.word	0x0805a91d
 805a918: 15 d7 05 08  	.word	0x0805d715

0805a91c <xQueueGenericSend>:
; {
 805a91c: f848 eb58    	str	lr, [r8], #88
 805a920: eb08 0809    	add.w	r8, r8, r9
 805a924: b480         	push	{r7}
 805a926: 466f         	mov	r7, sp
 805a928: b08e         	sub	sp, #0x38
 805a92a: 900c         	str	r0, [sp, #0x30]
 805a92c: 910b         	str	r1, [sp, #0x2c]
 805a92e: 920a         	str	r2, [sp, #0x28]
 805a930: 9309         	str	r3, [sp, #0x24]
 805a932: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 805a934: 9008         	str	r0, [sp, #0x20]
;     Queue_t * const pxQueue = xQueue;
 805a936: 980c         	ldr	r0, [sp, #0x30]
 805a938: 9004         	str	r0, [sp, #0x10]
;     configASSERT( pxQueue );
 805a93a: 9804         	ldr	r0, [sp, #0x10]
 805a93c: b920         	cbnz	r0, 0x805a948 <xQueueGenericSend+0x2c> @ imm = #0x8
 805a93e: e7ff         	b	0x805a940 <xQueueGenericSend+0x24> @ imm = #-0x2
 805a940: 4884         	ldr	r0, [pc, #0x210]        @ 0x805ab54 <xQueueGenericSend+0x238>
 805a942: 4780         	blx	r0
 805a944: e7ff         	b	0x805a946 <xQueueGenericSend+0x2a> @ imm = #-0x2
 805a946: e7fe         	b	0x805a946 <xQueueGenericSend+0x2a> @ imm = #-0x4
;     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 805a948: 990b         	ldr	r1, [sp, #0x2c]
 805a94a: 2000         	movs	r0, #0x0
 805a94c: 9003         	str	r0, [sp, #0xc]
 805a94e: b939         	cbnz	r1, 0x805a960 <xQueueGenericSend+0x44> @ imm = #0xe
 805a950: e7ff         	b	0x805a952 <xQueueGenericSend+0x36> @ imm = #-0x2
 805a952: 9804         	ldr	r0, [sp, #0x10]
 805a954: 6c00         	ldr	r0, [r0, #0x40]
 805a956: 2800         	cmp	r0, #0x0
 805a958: bf18         	it	ne
 805a95a: 2001         	movne	r0, #0x1
 805a95c: 9003         	str	r0, [sp, #0xc]
 805a95e: e7ff         	b	0x805a960 <xQueueGenericSend+0x44> @ imm = #-0x2
 805a960: 9803         	ldr	r0, [sp, #0xc]
;     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 805a962: 07c0         	lsls	r0, r0, #0x1f
 805a964: b120         	cbz	r0, 0x805a970 <xQueueGenericSend+0x54> @ imm = #0x8
 805a966: e7ff         	b	0x805a968 <xQueueGenericSend+0x4c> @ imm = #-0x2
 805a968: 4879         	ldr	r0, [pc, #0x1e4]        @ 0x805ab50 <xQueueGenericSend+0x234>
 805a96a: 4780         	blx	r0
 805a96c: e7ff         	b	0x805a96e <xQueueGenericSend+0x52> @ imm = #-0x2
 805a96e: e7fe         	b	0x805a96e <xQueueGenericSend+0x52> @ imm = #-0x4
;     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 805a970: 9909         	ldr	r1, [sp, #0x24]
 805a972: 2000         	movs	r0, #0x0
 805a974: 2902         	cmp	r1, #0x2
 805a976: 9002         	str	r0, [sp, #0x8]
 805a978: d107         	bne	0x805a98a <xQueueGenericSend+0x6e> @ imm = #0xe
 805a97a: e7ff         	b	0x805a97c <xQueueGenericSend+0x60> @ imm = #-0x2
 805a97c: 9804         	ldr	r0, [sp, #0x10]
 805a97e: 6bc0         	ldr	r0, [r0, #0x3c]
 805a980: 3801         	subs	r0, #0x1
 805a982: bf18         	it	ne
 805a984: 2001         	movne	r0, #0x1
 805a986: 9002         	str	r0, [sp, #0x8]
 805a988: e7ff         	b	0x805a98a <xQueueGenericSend+0x6e> @ imm = #-0x2
 805a98a: 9802         	ldr	r0, [sp, #0x8]
;     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 805a98c: 07c0         	lsls	r0, r0, #0x1f
 805a98e: b120         	cbz	r0, 0x805a99a <xQueueGenericSend+0x7e> @ imm = #0x8
 805a990: e7ff         	b	0x805a992 <xQueueGenericSend+0x76> @ imm = #-0x2
 805a992: 486e         	ldr	r0, [pc, #0x1b8]        @ 0x805ab4c <xQueueGenericSend+0x230>
 805a994: 4780         	blx	r0
 805a996: e7ff         	b	0x805a998 <xQueueGenericSend+0x7c> @ imm = #-0x2
 805a998: e7fe         	b	0x805a998 <xQueueGenericSend+0x7c> @ imm = #-0x4
;         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 805a99a: 4854         	ldr	r0, [pc, #0x150]        @ 0x805aaec <xQueueGenericSend+0x1d0>
 805a99c: 4780         	blx	r0
 805a99e: 4601         	mov	r1, r0
 805a9a0: 2000         	movs	r0, #0x0
 805a9a2: 9001         	str	r0, [sp, #0x4]
 805a9a4: b931         	cbnz	r1, 0x805a9b4 <xQueueGenericSend+0x98> @ imm = #0xc
 805a9a6: e7ff         	b	0x805a9a8 <xQueueGenericSend+0x8c> @ imm = #-0x2
 805a9a8: 980a         	ldr	r0, [sp, #0x28]
 805a9aa: 2800         	cmp	r0, #0x0
 805a9ac: bf18         	it	ne
 805a9ae: 2001         	movne	r0, #0x1
 805a9b0: 9001         	str	r0, [sp, #0x4]
 805a9b2: e7ff         	b	0x805a9b4 <xQueueGenericSend+0x98> @ imm = #-0x2
 805a9b4: 9801         	ldr	r0, [sp, #0x4]
;         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 805a9b6: 07c0         	lsls	r0, r0, #0x1f
 805a9b8: b120         	cbz	r0, 0x805a9c4 <xQueueGenericSend+0xa8> @ imm = #0x8
 805a9ba: e7ff         	b	0x805a9bc <xQueueGenericSend+0xa0> @ imm = #-0x2
 805a9bc: 4862         	ldr	r0, [pc, #0x188]        @ 0x805ab48 <xQueueGenericSend+0x22c>
 805a9be: 4780         	blx	r0
 805a9c0: e7ff         	b	0x805a9c2 <xQueueGenericSend+0xa6> @ imm = #-0x2
 805a9c2: e7fe         	b	0x805a9c2 <xQueueGenericSend+0xa6> @ imm = #-0x4
;     for( ; ; )
 805a9c4: e7ff         	b	0x805a9c6 <xQueueGenericSend+0xaa> @ imm = #-0x2
;         taskENTER_CRITICAL();
 805a9c6: 484a         	ldr	r0, [pc, #0x128]        @ 0x805aaf0 <xQueueGenericSend+0x1d4>
 805a9c8: 4780         	blx	r0
;             if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 805a9ca: 9804         	ldr	r0, [sp, #0x10]
 805a9cc: 6b80         	ldr	r0, [r0, #0x38]
 805a9ce: 9904         	ldr	r1, [sp, #0x10]
 805a9d0: 6bc9         	ldr	r1, [r1, #0x3c]
 805a9d2: 4288         	cmp	r0, r1
 805a9d4: d304         	blo	0x805a9e0 <xQueueGenericSend+0xc4> @ imm = #0x8
 805a9d6: e7ff         	b	0x805a9d8 <xQueueGenericSend+0xbc> @ imm = #-0x2
 805a9d8: 9809         	ldr	r0, [sp, #0x24]
 805a9da: 2802         	cmp	r0, #0x2
 805a9dc: d122         	bne	0x805aa24 <xQueueGenericSend+0x108> @ imm = #0x44
 805a9de: e7ff         	b	0x805a9e0 <xQueueGenericSend+0xc4> @ imm = #-0x2
;                     xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 805a9e0: 9804         	ldr	r0, [sp, #0x10]
 805a9e2: 990b         	ldr	r1, [sp, #0x2c]
 805a9e4: 9a09         	ldr	r2, [sp, #0x24]
 805a9e6: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x805ab34 <xQueueGenericSend+0x218>
 805a9e8: 4798         	blx	r3
 805a9ea: 9007         	str	r0, [sp, #0x1c]
;                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 805a9ec: 9804         	ldr	r0, [sp, #0x10]
 805a9ee: 6a40         	ldr	r0, [r0, #0x24]
 805a9f0: b158         	cbz	r0, 0x805aa0a <xQueueGenericSend+0xee> @ imm = #0x16
 805a9f2: e7ff         	b	0x805a9f4 <xQueueGenericSend+0xd8> @ imm = #-0x2
;                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 805a9f4: 9804         	ldr	r0, [sp, #0x10]
 805a9f6: 3024         	adds	r0, #0x24
 805a9f8: 4950         	ldr	r1, [pc, #0x140]        @ 0x805ab3c <xQueueGenericSend+0x220>
 805a9fa: 4788         	blx	r1
 805a9fc: b118         	cbz	r0, 0x805aa06 <xQueueGenericSend+0xea> @ imm = #0x6
 805a9fe: e7ff         	b	0x805aa00 <xQueueGenericSend+0xe4> @ imm = #-0x2
;                             queueYIELD_IF_USING_PREEMPTION();
 805aa00: 484f         	ldr	r0, [pc, #0x13c]        @ 0x805ab40 <xQueueGenericSend+0x224>
 805aa02: 4780         	blx	r0
;                         }
 805aa04: e000         	b	0x805aa08 <xQueueGenericSend+0xec> @ imm = #0x0
 805aa06: e7ff         	b	0x805aa08 <xQueueGenericSend+0xec> @ imm = #-0x2
;                     }
 805aa08: e007         	b	0x805aa1a <xQueueGenericSend+0xfe> @ imm = #0xe
;                     else if( xYieldRequired != pdFALSE )
 805aa0a: 9807         	ldr	r0, [sp, #0x1c]
 805aa0c: b118         	cbz	r0, 0x805aa16 <xQueueGenericSend+0xfa> @ imm = #0x6
 805aa0e: e7ff         	b	0x805aa10 <xQueueGenericSend+0xf4> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
 805aa10: 4849         	ldr	r0, [pc, #0x124]        @ 0x805ab38 <xQueueGenericSend+0x21c>
 805aa12: 4780         	blx	r0
;                     }
 805aa14: e000         	b	0x805aa18 <xQueueGenericSend+0xfc> @ imm = #0x0
 805aa16: e7ff         	b	0x805aa18 <xQueueGenericSend+0xfc> @ imm = #-0x2
 805aa18: e7ff         	b	0x805aa1a <xQueueGenericSend+0xfe> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
 805aa1a: 484a         	ldr	r0, [pc, #0x128]        @ 0x805ab44 <xQueueGenericSend+0x228>
 805aa1c: 4780         	blx	r0
 805aa1e: 2001         	movs	r0, #0x1
;                 return pdPASS;
 805aa20: 900d         	str	r0, [sp, #0x34]
 805aa22: e05c         	b	0x805aade <xQueueGenericSend+0x1c2> @ imm = #0xb8
;                 if( xTicksToWait == ( TickType_t ) 0 )
 805aa24: 980a         	ldr	r0, [sp, #0x28]
 805aa26: b928         	cbnz	r0, 0x805aa34 <xQueueGenericSend+0x118> @ imm = #0xa
 805aa28: e7ff         	b	0x805aa2a <xQueueGenericSend+0x10e> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
 805aa2a: 4841         	ldr	r0, [pc, #0x104]        @ 0x805ab30 <xQueueGenericSend+0x214>
 805aa2c: 4780         	blx	r0
 805aa2e: 2000         	movs	r0, #0x0
;                     return errQUEUE_FULL;
 805aa30: 900d         	str	r0, [sp, #0x34]
 805aa32: e054         	b	0x805aade <xQueueGenericSend+0x1c2> @ imm = #0xa8
;                 else if( xEntryTimeSet == pdFALSE )
 805aa34: 9808         	ldr	r0, [sp, #0x20]
 805aa36: b930         	cbnz	r0, 0x805aa46 <xQueueGenericSend+0x12a> @ imm = #0xc
 805aa38: e7ff         	b	0x805aa3a <xQueueGenericSend+0x11e> @ imm = #-0x2
;                     vTaskInternalSetTimeOutState( &xTimeOut );
 805aa3a: 492e         	ldr	r1, [pc, #0xb8]         @ 0x805aaf4 <xQueueGenericSend+0x1d8>
 805aa3c: a805         	add	r0, sp, #0x14
 805aa3e: 4788         	blx	r1
 805aa40: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
 805aa42: 9008         	str	r0, [sp, #0x20]
;                 }
 805aa44: e000         	b	0x805aa48 <xQueueGenericSend+0x12c> @ imm = #0x0
 805aa46: e7ff         	b	0x805aa48 <xQueueGenericSend+0x12c> @ imm = #-0x2
 805aa48: e7ff         	b	0x805aa4a <xQueueGenericSend+0x12e> @ imm = #-0x2
 805aa4a: e7ff         	b	0x805aa4c <xQueueGenericSend+0x130> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 805aa4c: 482a         	ldr	r0, [pc, #0xa8]         @ 0x805aaf8 <xQueueGenericSend+0x1dc>
 805aa4e: 4780         	blx	r0
;         vTaskSuspendAll();
 805aa50: 482a         	ldr	r0, [pc, #0xa8]         @ 0x805aafc <xQueueGenericSend+0x1e0>
 805aa52: 4780         	blx	r0
;         prvLockQueue( pxQueue );
 805aa54: 482a         	ldr	r0, [pc, #0xa8]         @ 0x805ab00 <xQueueGenericSend+0x1e4>
 805aa56: 4780         	blx	r0
 805aa58: 9804         	ldr	r0, [sp, #0x10]
 805aa5a: f990 0044    	ldrsb.w	r0, [r0, #0x44]
 805aa5e: 3001         	adds	r0, #0x1
 805aa60: b928         	cbnz	r0, 0x805aa6e <xQueueGenericSend+0x152> @ imm = #0xa
 805aa62: e7ff         	b	0x805aa64 <xQueueGenericSend+0x148> @ imm = #-0x2
 805aa64: 9904         	ldr	r1, [sp, #0x10]
 805aa66: 2000         	movs	r0, #0x0
 805aa68: f881 0044    	strb.w	r0, [r1, #0x44]
 805aa6c: e7ff         	b	0x805aa6e <xQueueGenericSend+0x152> @ imm = #-0x2
 805aa6e: 9804         	ldr	r0, [sp, #0x10]
 805aa70: f990 0045    	ldrsb.w	r0, [r0, #0x45]
 805aa74: 3001         	adds	r0, #0x1
 805aa76: b928         	cbnz	r0, 0x805aa84 <xQueueGenericSend+0x168> @ imm = #0xa
 805aa78: e7ff         	b	0x805aa7a <xQueueGenericSend+0x15e> @ imm = #-0x2
 805aa7a: 9904         	ldr	r1, [sp, #0x10]
 805aa7c: 2000         	movs	r0, #0x0
 805aa7e: f881 0045    	strb.w	r0, [r1, #0x45]
 805aa82: e7ff         	b	0x805aa84 <xQueueGenericSend+0x168> @ imm = #-0x2
 805aa84: 481f         	ldr	r0, [pc, #0x7c]         @ 0x805ab04 <xQueueGenericSend+0x1e8>
 805aa86: 4780         	blx	r0
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 805aa88: 4a1f         	ldr	r2, [pc, #0x7c]         @ 0x805ab08 <xQueueGenericSend+0x1ec>
 805aa8a: a805         	add	r0, sp, #0x14
 805aa8c: a90a         	add	r1, sp, #0x28
 805aa8e: 4790         	blx	r2
 805aa90: b9e0         	cbnz	r0, 0x805aacc <xQueueGenericSend+0x1b0> @ imm = #0x38
 805aa92: e7ff         	b	0x805aa94 <xQueueGenericSend+0x178> @ imm = #-0x2
;             if( prvIsQueueFull( pxQueue ) != pdFALSE )
 805aa94: 9804         	ldr	r0, [sp, #0x10]
 805aa96: 491f         	ldr	r1, [pc, #0x7c]         @ 0x805ab14 <xQueueGenericSend+0x1f8>
 805aa98: 4788         	blx	r1
 805aa9a: b180         	cbz	r0, 0x805aabe <xQueueGenericSend+0x1a2> @ imm = #0x20
 805aa9c: e7ff         	b	0x805aa9e <xQueueGenericSend+0x182> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 805aa9e: 9804         	ldr	r0, [sp, #0x10]
 805aaa0: 3010         	adds	r0, #0x10
 805aaa2: 990a         	ldr	r1, [sp, #0x28]
 805aaa4: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x805ab20 <xQueueGenericSend+0x204>
 805aaa6: 4790         	blx	r2
;                 prvUnlockQueue( pxQueue );
 805aaa8: 9804         	ldr	r0, [sp, #0x10]
 805aaaa: 491e         	ldr	r1, [pc, #0x78]         @ 0x805ab24 <xQueueGenericSend+0x208>
 805aaac: 4788         	blx	r1
;                 if( xTaskResumeAll() == pdFALSE )
 805aaae: 481e         	ldr	r0, [pc, #0x78]         @ 0x805ab28 <xQueueGenericSend+0x20c>
 805aab0: 4780         	blx	r0
 805aab2: b918         	cbnz	r0, 0x805aabc <xQueueGenericSend+0x1a0> @ imm = #0x6
 805aab4: e7ff         	b	0x805aab6 <xQueueGenericSend+0x19a> @ imm = #-0x2
;                     taskYIELD_WITHIN_API();
 805aab6: 481d         	ldr	r0, [pc, #0x74]         @ 0x805ab2c <xQueueGenericSend+0x210>
 805aab8: 4780         	blx	r0
;                 }
 805aaba: e7ff         	b	0x805aabc <xQueueGenericSend+0x1a0> @ imm = #-0x2
;             }
 805aabc: e005         	b	0x805aaca <xQueueGenericSend+0x1ae> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
 805aabe: 9804         	ldr	r0, [sp, #0x10]
 805aac0: 4915         	ldr	r1, [pc, #0x54]         @ 0x805ab18 <xQueueGenericSend+0x1fc>
 805aac2: 4788         	blx	r1
;                 ( void ) xTaskResumeAll();
 805aac4: 4815         	ldr	r0, [pc, #0x54]         @ 0x805ab1c <xQueueGenericSend+0x200>
 805aac6: 4780         	blx	r0
 805aac8: e7ff         	b	0x805aaca <xQueueGenericSend+0x1ae> @ imm = #-0x2
;         }
 805aaca: e007         	b	0x805aadc <xQueueGenericSend+0x1c0> @ imm = #0xe
;             prvUnlockQueue( pxQueue );
 805aacc: 9804         	ldr	r0, [sp, #0x10]
 805aace: 490f         	ldr	r1, [pc, #0x3c]         @ 0x805ab0c <xQueueGenericSend+0x1f0>
 805aad0: 4788         	blx	r1
;             ( void ) xTaskResumeAll();
 805aad2: 480f         	ldr	r0, [pc, #0x3c]         @ 0x805ab10 <xQueueGenericSend+0x1f4>
 805aad4: 4780         	blx	r0
 805aad6: 2000         	movs	r0, #0x0
;             return errQUEUE_FULL;
 805aad8: 900d         	str	r0, [sp, #0x34]
 805aada: e000         	b	0x805aade <xQueueGenericSend+0x1c2> @ imm = #0x0
;     for( ; ; )
 805aadc: e773         	b	0x805a9c6 <xQueueGenericSend+0xaa> @ imm = #-0x11a
; }
 805aade: 980d         	ldr	r0, [sp, #0x34]
 805aae0: b00e         	add	sp, #0x38
 805aae2: bc80         	pop	{r7}
 805aae4: eba8 0809    	sub.w	r8, r8, r9
 805aae8: f858 fd58    	ldr	pc, [r8, #-88]!

0805aaec <$d.17>:
 805aaec: 0d 77 05 08  	.word	0x0805770d
 805aaf0: 49 cd 05 08  	.word	0x0805cd49
 805aaf4: 9d 73 05 08  	.word	0x0805739d
 805aaf8: 7d cd 05 08  	.word	0x0805cd7d
 805aafc: d9 58 05 08  	.word	0x080558d9
 805ab00: 49 cd 05 08  	.word	0x0805cd49
 805ab04: 7d cd 05 08  	.word	0x0805cd7d
 805ab08: c1 73 05 08  	.word	0x080573c1
 805ab0c: d1 af 05 08  	.word	0x0805afd1
 805ab10: 0d 5a 05 08  	.word	0x08055a0d
 805ab14: 89 af 05 08  	.word	0x0805af89
 805ab18: d1 af 05 08  	.word	0x0805afd1
 805ab1c: 0d 5a 05 08  	.word	0x08055a0d
 805ab20: 0d 6e 05 08  	.word	0x08056e0d
 805ab24: d1 af 05 08  	.word	0x0805afd1
 805ab28: 0d 5a 05 08  	.word	0x08055a0d
 805ab2c: 2f cd 05 08  	.word	0x0805cd2f
 805ab30: 7d cd 05 08  	.word	0x0805cd7d
 805ab34: 9d ae 05 08  	.word	0x0805ae9d
 805ab38: 2f cd 05 08  	.word	0x0805cd2f
 805ab3c: a9 6f 05 08  	.word	0x08056fa9
 805ab40: 2f cd 05 08  	.word	0x0805cd2f
 805ab44: 7d cd 05 08  	.word	0x0805cd7d
 805ab48: 15 d7 05 08  	.word	0x0805d715
 805ab4c: 15 d7 05 08  	.word	0x0805d715
 805ab50: 15 d7 05 08  	.word	0x0805d715
 805ab54: 15 d7 05 08  	.word	0x0805d715

0805ab58 <xQueueTakeMutexRecursive>:
;     {
 805ab58: f848 eb40    	str	lr, [r8], #64
 805ab5c: eb08 0809    	add.w	r8, r8, r9
 805ab60: b480         	push	{r7}
 805ab62: 466f         	mov	r7, sp
 805ab64: b086         	sub	sp, #0x18
 805ab66: 9005         	str	r0, [sp, #0x14]
 805ab68: 9104         	str	r1, [sp, #0x10]
;         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 805ab6a: 9805         	ldr	r0, [sp, #0x14]
 805ab6c: 9002         	str	r0, [sp, #0x8]
;         configASSERT( pxMutex );
 805ab6e: 9802         	ldr	r0, [sp, #0x8]
 805ab70: b920         	cbnz	r0, 0x805ab7c <xQueueTakeMutexRecursive+0x24> @ imm = #0x8
 805ab72: e7ff         	b	0x805ab74 <xQueueTakeMutexRecursive+0x1c> @ imm = #-0x2
 805ab74: 4817         	ldr	r0, [pc, #0x5c]         @ 0x805abd4 <xQueueTakeMutexRecursive+0x7c>
 805ab76: 4780         	blx	r0
 805ab78: e7ff         	b	0x805ab7a <xQueueTakeMutexRecursive+0x22> @ imm = #-0x2
 805ab7a: e7fe         	b	0x805ab7a <xQueueTakeMutexRecursive+0x22> @ imm = #-0x4
;         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 805ab7c: 9802         	ldr	r0, [sp, #0x8]
 805ab7e: 6880         	ldr	r0, [r0, #0x8]
 805ab80: 9001         	str	r0, [sp, #0x4]
 805ab82: 4812         	ldr	r0, [pc, #0x48]         @ 0x805abcc <xQueueTakeMutexRecursive+0x74>
 805ab84: 4780         	blx	r0
 805ab86: 4601         	mov	r1, r0
 805ab88: 9801         	ldr	r0, [sp, #0x4]
 805ab8a: 4288         	cmp	r0, r1
 805ab8c: d107         	bne	0x805ab9e <xQueueTakeMutexRecursive+0x46> @ imm = #0xe
 805ab8e: e7ff         	b	0x805ab90 <xQueueTakeMutexRecursive+0x38> @ imm = #-0x2
;             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 805ab90: 9902         	ldr	r1, [sp, #0x8]
 805ab92: 68c8         	ldr	r0, [r1, #0xc]
 805ab94: 3001         	adds	r0, #0x1
 805ab96: 60c8         	str	r0, [r1, #0xc]
 805ab98: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
 805ab9a: 9003         	str	r0, [sp, #0xc]
;         }
 805ab9c: e00e         	b	0x805abbc <xQueueTakeMutexRecursive+0x64> @ imm = #0x1c
;             xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 805ab9e: 9802         	ldr	r0, [sp, #0x8]
 805aba0: 9904         	ldr	r1, [sp, #0x10]
 805aba2: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x805abd0 <xQueueTakeMutexRecursive+0x78>
 805aba4: 4790         	blx	r2
 805aba6: 9003         	str	r0, [sp, #0xc]
;             if( xReturn != pdFAIL )
 805aba8: 9803         	ldr	r0, [sp, #0xc]
 805abaa: b128         	cbz	r0, 0x805abb8 <xQueueTakeMutexRecursive+0x60> @ imm = #0xa
 805abac: e7ff         	b	0x805abae <xQueueTakeMutexRecursive+0x56> @ imm = #-0x2
;                 ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 805abae: 9902         	ldr	r1, [sp, #0x8]
 805abb0: 68c8         	ldr	r0, [r1, #0xc]
 805abb2: 3001         	adds	r0, #0x1
 805abb4: 60c8         	str	r0, [r1, #0xc]
;             }
 805abb6: e000         	b	0x805abba <xQueueTakeMutexRecursive+0x62> @ imm = #0x0
 805abb8: e7ff         	b	0x805abba <xQueueTakeMutexRecursive+0x62> @ imm = #-0x2
 805abba: e7ff         	b	0x805abbc <xQueueTakeMutexRecursive+0x64> @ imm = #-0x2
;         return xReturn;
 805abbc: 9803         	ldr	r0, [sp, #0xc]
 805abbe: b006         	add	sp, #0x18
 805abc0: bc80         	pop	{r7}
 805abc2: eba8 0809    	sub.w	r8, r8, r9
 805abc6: f858 fd40    	ldr	pc, [r8, #-64]!
 805abca: bf00         	nop

0805abcc <$d.19>:
 805abcc: f9 76 05 08  	.word	0x080576f9
 805abd0: d9 ab 05 08  	.word	0x0805abd9
 805abd4: 15 d7 05 08  	.word	0x0805d715

0805abd8 <xQueueSemaphoreTake>:
; {
 805abd8: f848 eb04    	str	lr, [r8], #4
 805abdc: eb08 0809    	add.w	r8, r8, r9
 805abe0: b480         	push	{r7}
 805abe2: 466f         	mov	r7, sp
 805abe4: b08c         	sub	sp, #0x30
 805abe6: 900a         	str	r0, [sp, #0x28]
 805abe8: 9109         	str	r1, [sp, #0x24]
 805abea: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
 805abec: 9008         	str	r0, [sp, #0x20]
;     Queue_t * const pxQueue = xQueue;
 805abee: 990a         	ldr	r1, [sp, #0x28]
 805abf0: 9105         	str	r1, [sp, #0x14]
;         BaseType_t xInheritanceOccurred = pdFALSE;
 805abf2: 9004         	str	r0, [sp, #0x10]
;     configASSERT( ( pxQueue ) );
 805abf4: 9805         	ldr	r0, [sp, #0x14]
 805abf6: b920         	cbnz	r0, 0x805ac02 <xQueueSemaphoreTake+0x2a> @ imm = #0x8
 805abf8: e7ff         	b	0x805abfa <xQueueSemaphoreTake+0x22> @ imm = #-0x2
 805abfa: 488c         	ldr	r0, [pc, #0x230]        @ 0x805ae2c <xQueueSemaphoreTake+0x254>
 805abfc: 4780         	blx	r0
 805abfe: e7ff         	b	0x805ac00 <xQueueSemaphoreTake+0x28> @ imm = #-0x2
 805ac00: e7fe         	b	0x805ac00 <xQueueSemaphoreTake+0x28> @ imm = #-0x4
;     configASSERT( pxQueue->uxItemSize == 0 );
 805ac02: 9805         	ldr	r0, [sp, #0x14]
 805ac04: 6c00         	ldr	r0, [r0, #0x40]
 805ac06: b120         	cbz	r0, 0x805ac12 <xQueueSemaphoreTake+0x3a> @ imm = #0x8
 805ac08: e7ff         	b	0x805ac0a <xQueueSemaphoreTake+0x32> @ imm = #-0x2
 805ac0a: 4887         	ldr	r0, [pc, #0x21c]        @ 0x805ae28 <xQueueSemaphoreTake+0x250>
 805ac0c: 4780         	blx	r0
 805ac0e: e7ff         	b	0x805ac10 <xQueueSemaphoreTake+0x38> @ imm = #-0x2
 805ac10: e7fe         	b	0x805ac10 <xQueueSemaphoreTake+0x38> @ imm = #-0x4
;         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 805ac12: 4866         	ldr	r0, [pc, #0x198]        @ 0x805adac <xQueueSemaphoreTake+0x1d4>
 805ac14: 4780         	blx	r0
 805ac16: 4601         	mov	r1, r0
 805ac18: 2000         	movs	r0, #0x0
 805ac1a: 9001         	str	r0, [sp, #0x4]
 805ac1c: b931         	cbnz	r1, 0x805ac2c <xQueueSemaphoreTake+0x54> @ imm = #0xc
 805ac1e: e7ff         	b	0x805ac20 <xQueueSemaphoreTake+0x48> @ imm = #-0x2
 805ac20: 9809         	ldr	r0, [sp, #0x24]
 805ac22: 2800         	cmp	r0, #0x0
 805ac24: bf18         	it	ne
 805ac26: 2001         	movne	r0, #0x1
 805ac28: 9001         	str	r0, [sp, #0x4]
 805ac2a: e7ff         	b	0x805ac2c <xQueueSemaphoreTake+0x54> @ imm = #-0x2
 805ac2c: 9801         	ldr	r0, [sp, #0x4]
;         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 805ac2e: 07c0         	lsls	r0, r0, #0x1f
 805ac30: b120         	cbz	r0, 0x805ac3c <xQueueSemaphoreTake+0x64> @ imm = #0x8
 805ac32: e7ff         	b	0x805ac34 <xQueueSemaphoreTake+0x5c> @ imm = #-0x2
 805ac34: 487b         	ldr	r0, [pc, #0x1ec]        @ 0x805ae24 <xQueueSemaphoreTake+0x24c>
 805ac36: 4780         	blx	r0
 805ac38: e7ff         	b	0x805ac3a <xQueueSemaphoreTake+0x62> @ imm = #-0x2
 805ac3a: e7fe         	b	0x805ac3a <xQueueSemaphoreTake+0x62> @ imm = #-0x4
;     for( ; ; )
 805ac3c: e7ff         	b	0x805ac3e <xQueueSemaphoreTake+0x66> @ imm = #-0x2
;         taskENTER_CRITICAL();
 805ac3e: 485c         	ldr	r0, [pc, #0x170]        @ 0x805adb0 <xQueueSemaphoreTake+0x1d8>
 805ac40: 4780         	blx	r0
;             const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 805ac42: 9805         	ldr	r0, [sp, #0x14]
 805ac44: 6b80         	ldr	r0, [r0, #0x38]
 805ac46: 9003         	str	r0, [sp, #0xc]
;             if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 805ac48: 9803         	ldr	r0, [sp, #0xc]
 805ac4a: b318         	cbz	r0, 0x805ac94 <xQueueSemaphoreTake+0xbc> @ imm = #0x46
 805ac4c: e7ff         	b	0x805ac4e <xQueueSemaphoreTake+0x76> @ imm = #-0x2
;                 pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxSemaphoreCount - ( UBaseType_t ) 1 );
 805ac4e: 9803         	ldr	r0, [sp, #0xc]
 805ac50: 3801         	subs	r0, #0x1
 805ac52: 9905         	ldr	r1, [sp, #0x14]
 805ac54: 6388         	str	r0, [r1, #0x38]
;                     if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 805ac56: 9805         	ldr	r0, [sp, #0x14]
 805ac58: 6800         	ldr	r0, [r0]
 805ac5a: b928         	cbnz	r0, 0x805ac68 <xQueueSemaphoreTake+0x90> @ imm = #0xa
 805ac5c: e7ff         	b	0x805ac5e <xQueueSemaphoreTake+0x86> @ imm = #-0x2
;                         pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 805ac5e: 486d         	ldr	r0, [pc, #0x1b4]        @ 0x805ae14 <xQueueSemaphoreTake+0x23c>
 805ac60: 4780         	blx	r0
 805ac62: 9905         	ldr	r1, [sp, #0x14]
 805ac64: 6088         	str	r0, [r1, #0x8]
;                     }
 805ac66: e000         	b	0x805ac6a <xQueueSemaphoreTake+0x92> @ imm = #0x0
 805ac68: e7ff         	b	0x805ac6a <xQueueSemaphoreTake+0x92> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 805ac6a: 9805         	ldr	r0, [sp, #0x14]
 805ac6c: 6900         	ldr	r0, [r0, #0x10]
 805ac6e: b158         	cbz	r0, 0x805ac88 <xQueueSemaphoreTake+0xb0> @ imm = #0x16
 805ac70: e7ff         	b	0x805ac72 <xQueueSemaphoreTake+0x9a> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 805ac72: 9805         	ldr	r0, [sp, #0x14]
 805ac74: 3010         	adds	r0, #0x10
 805ac76: 4968         	ldr	r1, [pc, #0x1a0]        @ 0x805ae18 <xQueueSemaphoreTake+0x240>
 805ac78: 4788         	blx	r1
 805ac7a: b118         	cbz	r0, 0x805ac84 <xQueueSemaphoreTake+0xac> @ imm = #0x6
 805ac7c: e7ff         	b	0x805ac7e <xQueueSemaphoreTake+0xa6> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
 805ac7e: 4867         	ldr	r0, [pc, #0x19c]        @ 0x805ae1c <xQueueSemaphoreTake+0x244>
 805ac80: 4780         	blx	r0
;                     }
 805ac82: e000         	b	0x805ac86 <xQueueSemaphoreTake+0xae> @ imm = #0x0
 805ac84: e7ff         	b	0x805ac86 <xQueueSemaphoreTake+0xae> @ imm = #-0x2
;                 }
 805ac86: e000         	b	0x805ac8a <xQueueSemaphoreTake+0xb2> @ imm = #0x0
 805ac88: e7ff         	b	0x805ac8a <xQueueSemaphoreTake+0xb2> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
 805ac8a: 4865         	ldr	r0, [pc, #0x194]        @ 0x805ae20 <xQueueSemaphoreTake+0x248>
 805ac8c: 4780         	blx	r0
 805ac8e: 2001         	movs	r0, #0x1
;                 return pdPASS;
 805ac90: 900b         	str	r0, [sp, #0x2c]
 805ac92: e084         	b	0x805ad9e <xQueueSemaphoreTake+0x1c6> @ imm = #0x108
;                 if( xTicksToWait == ( TickType_t ) 0 )
 805ac94: 9809         	ldr	r0, [sp, #0x24]
 805ac96: b928         	cbnz	r0, 0x805aca4 <xQueueSemaphoreTake+0xcc> @ imm = #0xa
 805ac98: e7ff         	b	0x805ac9a <xQueueSemaphoreTake+0xc2> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
 805ac9a: 485d         	ldr	r0, [pc, #0x174]        @ 0x805ae10 <xQueueSemaphoreTake+0x238>
 805ac9c: 4780         	blx	r0
 805ac9e: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
 805aca0: 900b         	str	r0, [sp, #0x2c]
 805aca2: e07c         	b	0x805ad9e <xQueueSemaphoreTake+0x1c6> @ imm = #0xf8
;                 else if( xEntryTimeSet == pdFALSE )
 805aca4: 9808         	ldr	r0, [sp, #0x20]
 805aca6: b930         	cbnz	r0, 0x805acb6 <xQueueSemaphoreTake+0xde> @ imm = #0xc
 805aca8: e7ff         	b	0x805acaa <xQueueSemaphoreTake+0xd2> @ imm = #-0x2
;                     vTaskInternalSetTimeOutState( &xTimeOut );
 805acaa: 4942         	ldr	r1, [pc, #0x108]        @ 0x805adb4 <xQueueSemaphoreTake+0x1dc>
 805acac: a806         	add	r0, sp, #0x18
 805acae: 4788         	blx	r1
 805acb0: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
 805acb2: 9008         	str	r0, [sp, #0x20]
;                 }
 805acb4: e000         	b	0x805acb8 <xQueueSemaphoreTake+0xe0> @ imm = #0x0
 805acb6: e7ff         	b	0x805acb8 <xQueueSemaphoreTake+0xe0> @ imm = #-0x2
 805acb8: e7ff         	b	0x805acba <xQueueSemaphoreTake+0xe2> @ imm = #-0x2
 805acba: e7ff         	b	0x805acbc <xQueueSemaphoreTake+0xe4> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 805acbc: 483e         	ldr	r0, [pc, #0xf8]         @ 0x805adb8 <xQueueSemaphoreTake+0x1e0>
 805acbe: 4780         	blx	r0
;         vTaskSuspendAll();
 805acc0: 483e         	ldr	r0, [pc, #0xf8]         @ 0x805adbc <xQueueSemaphoreTake+0x1e4>
 805acc2: 4780         	blx	r0
;         prvLockQueue( pxQueue );
 805acc4: 483e         	ldr	r0, [pc, #0xf8]         @ 0x805adc0 <xQueueSemaphoreTake+0x1e8>
 805acc6: 4780         	blx	r0
 805acc8: 9805         	ldr	r0, [sp, #0x14]
 805acca: f990 0044    	ldrsb.w	r0, [r0, #0x44]
 805acce: 3001         	adds	r0, #0x1
 805acd0: b928         	cbnz	r0, 0x805acde <xQueueSemaphoreTake+0x106> @ imm = #0xa
 805acd2: e7ff         	b	0x805acd4 <xQueueSemaphoreTake+0xfc> @ imm = #-0x2
 805acd4: 9905         	ldr	r1, [sp, #0x14]
 805acd6: 2000         	movs	r0, #0x0
 805acd8: f881 0044    	strb.w	r0, [r1, #0x44]
 805acdc: e7ff         	b	0x805acde <xQueueSemaphoreTake+0x106> @ imm = #-0x2
 805acde: 9805         	ldr	r0, [sp, #0x14]
 805ace0: f990 0045    	ldrsb.w	r0, [r0, #0x45]
 805ace4: 3001         	adds	r0, #0x1
 805ace6: b928         	cbnz	r0, 0x805acf4 <xQueueSemaphoreTake+0x11c> @ imm = #0xa
 805ace8: e7ff         	b	0x805acea <xQueueSemaphoreTake+0x112> @ imm = #-0x2
 805acea: 9905         	ldr	r1, [sp, #0x14]
 805acec: 2000         	movs	r0, #0x0
 805acee: f881 0045    	strb.w	r0, [r1, #0x45]
 805acf2: e7ff         	b	0x805acf4 <xQueueSemaphoreTake+0x11c> @ imm = #-0x2
 805acf4: 4833         	ldr	r0, [pc, #0xcc]         @ 0x805adc4 <xQueueSemaphoreTake+0x1ec>
 805acf6: 4780         	blx	r0
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 805acf8: 4a33         	ldr	r2, [pc, #0xcc]         @ 0x805adc8 <xQueueSemaphoreTake+0x1f0>
 805acfa: a806         	add	r0, sp, #0x18
 805acfc: a909         	add	r1, sp, #0x24
 805acfe: 4790         	blx	r2
 805ad00: bb60         	cbnz	r0, 0x805ad5c <xQueueSemaphoreTake+0x184> @ imm = #0x58
 805ad02: e7ff         	b	0x805ad04 <xQueueSemaphoreTake+0x12c> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 805ad04: 9805         	ldr	r0, [sp, #0x14]
 805ad06: 4938         	ldr	r1, [pc, #0xe0]         @ 0x805ade8 <xQueueSemaphoreTake+0x210>
 805ad08: 4788         	blx	r1
 805ad0a: b300         	cbz	r0, 0x805ad4e <xQueueSemaphoreTake+0x176> @ imm = #0x40
 805ad0c: e7ff         	b	0x805ad0e <xQueueSemaphoreTake+0x136> @ imm = #-0x2
;                     if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 805ad0e: 9805         	ldr	r0, [sp, #0x14]
 805ad10: 6800         	ldr	r0, [r0]
 805ad12: b950         	cbnz	r0, 0x805ad2a <xQueueSemaphoreTake+0x152> @ imm = #0x14
 805ad14: e7ff         	b	0x805ad16 <xQueueSemaphoreTake+0x13e> @ imm = #-0x2
;                         taskENTER_CRITICAL();
 805ad16: 4837         	ldr	r0, [pc, #0xdc]         @ 0x805adf4 <xQueueSemaphoreTake+0x21c>
 805ad18: 4780         	blx	r0
;                             xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 805ad1a: 9805         	ldr	r0, [sp, #0x14]
 805ad1c: 6880         	ldr	r0, [r0, #0x8]
 805ad1e: 4936         	ldr	r1, [pc, #0xd8]         @ 0x805adf8 <xQueueSemaphoreTake+0x220>
 805ad20: 4788         	blx	r1
 805ad22: 9004         	str	r0, [sp, #0x10]
;                         taskEXIT_CRITICAL();
 805ad24: 4835         	ldr	r0, [pc, #0xd4]         @ 0x805adfc <xQueueSemaphoreTake+0x224>
 805ad26: 4780         	blx	r0
;                     }
 805ad28: e000         	b	0x805ad2c <xQueueSemaphoreTake+0x154> @ imm = #0x0
 805ad2a: e7ff         	b	0x805ad2c <xQueueSemaphoreTake+0x154> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 805ad2c: 9805         	ldr	r0, [sp, #0x14]
 805ad2e: 3024         	adds	r0, #0x24
 805ad30: 9909         	ldr	r1, [sp, #0x24]
 805ad32: 4a33         	ldr	r2, [pc, #0xcc]         @ 0x805ae00 <xQueueSemaphoreTake+0x228>
 805ad34: 4790         	blx	r2
;                 prvUnlockQueue( pxQueue );
 805ad36: 9805         	ldr	r0, [sp, #0x14]
 805ad38: 4932         	ldr	r1, [pc, #0xc8]         @ 0x805ae04 <xQueueSemaphoreTake+0x22c>
 805ad3a: 4788         	blx	r1
;                 if( xTaskResumeAll() == pdFALSE )
 805ad3c: 4832         	ldr	r0, [pc, #0xc8]         @ 0x805ae08 <xQueueSemaphoreTake+0x230>
 805ad3e: 4780         	blx	r0
 805ad40: b918         	cbnz	r0, 0x805ad4a <xQueueSemaphoreTake+0x172> @ imm = #0x6
 805ad42: e7ff         	b	0x805ad44 <xQueueSemaphoreTake+0x16c> @ imm = #-0x2
;                     taskYIELD_WITHIN_API();
 805ad44: 4831         	ldr	r0, [pc, #0xc4]         @ 0x805ae0c <xQueueSemaphoreTake+0x234>
 805ad46: 4780         	blx	r0
;                 }
 805ad48: e000         	b	0x805ad4c <xQueueSemaphoreTake+0x174> @ imm = #0x0
 805ad4a: e7ff         	b	0x805ad4c <xQueueSemaphoreTake+0x174> @ imm = #-0x2
;             }
 805ad4c: e005         	b	0x805ad5a <xQueueSemaphoreTake+0x182> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
 805ad4e: 9805         	ldr	r0, [sp, #0x14]
 805ad50: 4926         	ldr	r1, [pc, #0x98]         @ 0x805adec <xQueueSemaphoreTake+0x214>
 805ad52: 4788         	blx	r1
;                 ( void ) xTaskResumeAll();
 805ad54: 4826         	ldr	r0, [pc, #0x98]         @ 0x805adf0 <xQueueSemaphoreTake+0x218>
 805ad56: 4780         	blx	r0
 805ad58: e7ff         	b	0x805ad5a <xQueueSemaphoreTake+0x182> @ imm = #-0x2
;         }
 805ad5a: e01f         	b	0x805ad9c <xQueueSemaphoreTake+0x1c4> @ imm = #0x3e
;             prvUnlockQueue( pxQueue );
 805ad5c: 9805         	ldr	r0, [sp, #0x14]
 805ad5e: 491b         	ldr	r1, [pc, #0x6c]         @ 0x805adcc <xQueueSemaphoreTake+0x1f4>
 805ad60: 4788         	blx	r1
;             ( void ) xTaskResumeAll();
 805ad62: 481b         	ldr	r0, [pc, #0x6c]         @ 0x805add0 <xQueueSemaphoreTake+0x1f8>
 805ad64: 4780         	blx	r0
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 805ad66: 9805         	ldr	r0, [sp, #0x14]
 805ad68: 491a         	ldr	r1, [pc, #0x68]         @ 0x805add4 <xQueueSemaphoreTake+0x1fc>
 805ad6a: 4788         	blx	r1
 805ad6c: b1a0         	cbz	r0, 0x805ad98 <xQueueSemaphoreTake+0x1c0> @ imm = #0x28
 805ad6e: e7ff         	b	0x805ad70 <xQueueSemaphoreTake+0x198> @ imm = #-0x2
;                     if( xInheritanceOccurred != pdFALSE )
 805ad70: 9804         	ldr	r0, [sp, #0x10]
 805ad72: b170         	cbz	r0, 0x805ad92 <xQueueSemaphoreTake+0x1ba> @ imm = #0x1c
 805ad74: e7ff         	b	0x805ad76 <xQueueSemaphoreTake+0x19e> @ imm = #-0x2
;                         taskENTER_CRITICAL();
 805ad76: 4818         	ldr	r0, [pc, #0x60]         @ 0x805add8 <xQueueSemaphoreTake+0x200>
 805ad78: 4780         	blx	r0
;                             uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 805ad7a: 9805         	ldr	r0, [sp, #0x14]
 805ad7c: 4917         	ldr	r1, [pc, #0x5c]         @ 0x805addc <xQueueSemaphoreTake+0x204>
 805ad7e: 4788         	blx	r1
 805ad80: 9002         	str	r0, [sp, #0x8]
;                             vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 805ad82: 9805         	ldr	r0, [sp, #0x14]
 805ad84: 6880         	ldr	r0, [r0, #0x8]
 805ad86: 9902         	ldr	r1, [sp, #0x8]
 805ad88: 4a15         	ldr	r2, [pc, #0x54]         @ 0x805ade0 <xQueueSemaphoreTake+0x208>
 805ad8a: 4790         	blx	r2
;                         taskEXIT_CRITICAL();
 805ad8c: 4815         	ldr	r0, [pc, #0x54]         @ 0x805ade4 <xQueueSemaphoreTake+0x20c>
 805ad8e: 4780         	blx	r0
;                     }
 805ad90: e7ff         	b	0x805ad92 <xQueueSemaphoreTake+0x1ba> @ imm = #-0x2
 805ad92: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
 805ad94: 900b         	str	r0, [sp, #0x2c]
 805ad96: e002         	b	0x805ad9e <xQueueSemaphoreTake+0x1c6> @ imm = #0x4
 805ad98: e7ff         	b	0x805ad9a <xQueueSemaphoreTake+0x1c2> @ imm = #-0x2
 805ad9a: e7ff         	b	0x805ad9c <xQueueSemaphoreTake+0x1c4> @ imm = #-0x2
;     for( ; ; )
 805ad9c: e74f         	b	0x805ac3e <xQueueSemaphoreTake+0x66> @ imm = #-0x162
; }
 805ad9e: 980b         	ldr	r0, [sp, #0x2c]
 805ada0: b00c         	add	sp, #0x30
 805ada2: bc80         	pop	{r7}
 805ada4: eba8 0809    	sub.w	r8, r8, r9
 805ada8: f858 fd04    	ldr	pc, [r8, #-4]!

0805adac <$d.21>:
 805adac: 0d 77 05 08  	.word	0x0805770d
 805adb0: 49 cd 05 08  	.word	0x0805cd49
 805adb4: 9d 73 05 08  	.word	0x0805739d
 805adb8: 7d cd 05 08  	.word	0x0805cd7d
 805adbc: d9 58 05 08  	.word	0x080558d9
 805adc0: 49 cd 05 08  	.word	0x0805cd49
 805adc4: 7d cd 05 08  	.word	0x0805cd7d
 805adc8: c1 73 05 08  	.word	0x080573c1
 805adcc: d1 af 05 08  	.word	0x0805afd1
 805add0: 0d 5a 05 08  	.word	0x08055a0d
 805add4: bd b5 05 08  	.word	0x0805b5bd
 805add8: 49 cd 05 08  	.word	0x0805cd49
 805addc: 01 b6 05 08  	.word	0x0805b601
 805ade0: 41 7a 05 08  	.word	0x08057a41
 805ade4: 7d cd 05 08  	.word	0x0805cd7d
 805ade8: bd b5 05 08  	.word	0x0805b5bd
 805adec: d1 af 05 08  	.word	0x0805afd1
 805adf0: 0d 5a 05 08  	.word	0x08055a0d
 805adf4: 49 cd 05 08  	.word	0x0805cd49
 805adf8: 45 77 05 08  	.word	0x08057745
 805adfc: 7d cd 05 08  	.word	0x0805cd7d
 805ae00: 0d 6e 05 08  	.word	0x08056e0d
 805ae04: d1 af 05 08  	.word	0x0805afd1
 805ae08: 0d 5a 05 08  	.word	0x08055a0d
 805ae0c: 2f cd 05 08  	.word	0x0805cd2f
 805ae10: 7d cd 05 08  	.word	0x0805cd7d
 805ae14: 11 7c 05 08  	.word	0x08057c11
 805ae18: a9 6f 05 08  	.word	0x08056fa9
 805ae1c: 2f cd 05 08  	.word	0x0805cd2f
 805ae20: 7d cd 05 08  	.word	0x0805cd7d
 805ae24: 15 d7 05 08  	.word	0x0805d715
 805ae28: 15 d7 05 08  	.word	0x0805d715
 805ae2c: 15 d7 05 08  	.word	0x0805d715

0805ae30 <xQueueCreateCountingSemaphore>:
;     {
 805ae30: f848 eb58    	str	lr, [r8], #88
 805ae34: eb08 0809    	add.w	r8, r8, r9
 805ae38: b480         	push	{r7}
 805ae3a: 466f         	mov	r7, sp
 805ae3c: b084         	sub	sp, #0x10
 805ae3e: 9003         	str	r0, [sp, #0xc]
 805ae40: 9102         	str	r1, [sp, #0x8]
 805ae42: 2000         	movs	r0, #0x0
;         QueueHandle_t xHandle = NULL;
 805ae44: 9001         	str	r0, [sp, #0x4]
;         if( ( uxMaxCount != 0 ) &&
 805ae46: 9803         	ldr	r0, [sp, #0xc]
 805ae48: b1a0         	cbz	r0, 0x805ae74 <xQueueCreateCountingSemaphore+0x44> @ imm = #0x28
 805ae4a: e7ff         	b	0x805ae4c <xQueueCreateCountingSemaphore+0x1c> @ imm = #-0x2
;             ( uxInitialCount <= uxMaxCount ) )
 805ae4c: 9802         	ldr	r0, [sp, #0x8]
 805ae4e: 9903         	ldr	r1, [sp, #0xc]
;         if( ( uxMaxCount != 0 ) &&
 805ae50: 4288         	cmp	r0, r1
 805ae52: d80f         	bhi	0x805ae74 <xQueueCreateCountingSemaphore+0x44> @ imm = #0x1e
 805ae54: e7ff         	b	0x805ae56 <xQueueCreateCountingSemaphore+0x26> @ imm = #-0x2
;             xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 805ae56: 9803         	ldr	r0, [sp, #0xc]
 805ae58: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x805ae98 <xQueueCreateCountingSemaphore+0x68>
 805ae5a: 2100         	movs	r1, #0x0
 805ae5c: 2202         	movs	r2, #0x2
 805ae5e: 4798         	blx	r3
 805ae60: 9001         	str	r0, [sp, #0x4]
;             if( xHandle != NULL )
 805ae62: 9801         	ldr	r0, [sp, #0x4]
 805ae64: b120         	cbz	r0, 0x805ae70 <xQueueCreateCountingSemaphore+0x40> @ imm = #0x8
 805ae66: e7ff         	b	0x805ae68 <xQueueCreateCountingSemaphore+0x38> @ imm = #-0x2
;                 ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 805ae68: 9802         	ldr	r0, [sp, #0x8]
 805ae6a: 9901         	ldr	r1, [sp, #0x4]
 805ae6c: 6388         	str	r0, [r1, #0x38]
;             }
 805ae6e: e000         	b	0x805ae72 <xQueueCreateCountingSemaphore+0x42> @ imm = #0x0
 805ae70: e7ff         	b	0x805ae72 <xQueueCreateCountingSemaphore+0x42> @ imm = #-0x2
;         }
 805ae72: e007         	b	0x805ae84 <xQueueCreateCountingSemaphore+0x54> @ imm = #0xe
;             configASSERT( xHandle );
 805ae74: 9801         	ldr	r0, [sp, #0x4]
 805ae76: b920         	cbnz	r0, 0x805ae82 <xQueueCreateCountingSemaphore+0x52> @ imm = #0x8
 805ae78: e7ff         	b	0x805ae7a <xQueueCreateCountingSemaphore+0x4a> @ imm = #-0x2
 805ae7a: 4806         	ldr	r0, [pc, #0x18]         @ 0x805ae94 <xQueueCreateCountingSemaphore+0x64>
 805ae7c: 4780         	blx	r0
 805ae7e: e7ff         	b	0x805ae80 <xQueueCreateCountingSemaphore+0x50> @ imm = #-0x2
 805ae80: e7fe         	b	0x805ae80 <xQueueCreateCountingSemaphore+0x50> @ imm = #-0x4
 805ae82: e7ff         	b	0x805ae84 <xQueueCreateCountingSemaphore+0x54> @ imm = #-0x2
;         return xHandle;
 805ae84: 9801         	ldr	r0, [sp, #0x4]
 805ae86: b004         	add	sp, #0x10
 805ae88: bc80         	pop	{r7}
 805ae8a: eba8 0809    	sub.w	r8, r8, r9
 805ae8e: f858 fd58    	ldr	pc, [r8, #-88]!
 805ae92: bf00         	nop

0805ae94 <$d.23>:
 805ae94: 15 d7 05 08  	.word	0x0805d715
 805ae98: 69 a6 05 08  	.word	0x0805a669

0805ae9c <prvCopyDataToQueue>:
; {
 805ae9c: f848 eb3c    	str	lr, [r8], #60
 805aea0: eb08 0809    	add.w	r8, r8, r9
 805aea4: b480         	push	{r7}
 805aea6: 466f         	mov	r7, sp
 805aea8: b086         	sub	sp, #0x18
 805aeaa: 9005         	str	r0, [sp, #0x14]
 805aeac: 9104         	str	r1, [sp, #0x10]
 805aeae: 9203         	str	r2, [sp, #0xc]
 805aeb0: 2000         	movs	r0, #0x0
;     BaseType_t xReturn = pdFALSE;
 805aeb2: 9002         	str	r0, [sp, #0x8]
;     uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 805aeb4: 9805         	ldr	r0, [sp, #0x14]
 805aeb6: 6b80         	ldr	r0, [r0, #0x38]
 805aeb8: 9001         	str	r0, [sp, #0x4]
;     if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 805aeba: 9805         	ldr	r0, [sp, #0x14]
 805aebc: 6c00         	ldr	r0, [r0, #0x40]
 805aebe: b978         	cbnz	r0, 0x805aee0 <prvCopyDataToQueue+0x44> @ imm = #0x1e
 805aec0: e7ff         	b	0x805aec2 <prvCopyDataToQueue+0x26> @ imm = #-0x2
;             if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 805aec2: 9805         	ldr	r0, [sp, #0x14]
 805aec4: 6800         	ldr	r0, [r0]
 805aec6: b948         	cbnz	r0, 0x805aedc <prvCopyDataToQueue+0x40> @ imm = #0x12
 805aec8: e7ff         	b	0x805aeca <prvCopyDataToQueue+0x2e> @ imm = #-0x2
;                 xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 805aeca: 9805         	ldr	r0, [sp, #0x14]
 805aecc: 6880         	ldr	r0, [r0, #0x8]
 805aece: 492d         	ldr	r1, [pc, #0xb4]         @ 0x805af84 <prvCopyDataToQueue+0xe8>
 805aed0: 4788         	blx	r1
 805aed2: 9002         	str	r0, [sp, #0x8]
;                 pxQueue->u.xSemaphore.xMutexHolder = NULL;
 805aed4: 9905         	ldr	r1, [sp, #0x14]
 805aed6: 2000         	movs	r0, #0x0
 805aed8: 6088         	str	r0, [r1, #0x8]
;             }
 805aeda: e000         	b	0x805aede <prvCopyDataToQueue+0x42> @ imm = #0x0
 805aedc: e7ff         	b	0x805aede <prvCopyDataToQueue+0x42> @ imm = #-0x2
;     }
 805aede: e041         	b	0x805af64 <prvCopyDataToQueue+0xc8> @ imm = #0x82
;     else if( xPosition == queueSEND_TO_BACK )
 805aee0: 9803         	ldr	r0, [sp, #0xc]
 805aee2: b9b8         	cbnz	r0, 0x805af14 <prvCopyDataToQueue+0x78> @ imm = #0x2e
 805aee4: e7ff         	b	0x805aee6 <prvCopyDataToQueue+0x4a> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 805aee6: 9a05         	ldr	r2, [sp, #0x14]
 805aee8: 9904         	ldr	r1, [sp, #0x10]
 805aeea: 6850         	ldr	r0, [r2, #0x4]
 805aeec: 6c12         	ldr	r2, [r2, #0x40]
 805aeee: 4b24         	ldr	r3, [pc, #0x90]         @ 0x805af80 <prvCopyDataToQueue+0xe4>
 805aef0: 4798         	blx	r3
;         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 805aef2: 9905         	ldr	r1, [sp, #0x14]
 805aef4: 6848         	ldr	r0, [r1, #0x4]
 805aef6: 6c0a         	ldr	r2, [r1, #0x40]
 805aef8: 4410         	add	r0, r2
 805aefa: 6048         	str	r0, [r1, #0x4]
;         if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 805aefc: 9905         	ldr	r1, [sp, #0x14]
 805aefe: 6848         	ldr	r0, [r1, #0x4]
 805af00: 6889         	ldr	r1, [r1, #0x8]
 805af02: 4288         	cmp	r0, r1
 805af04: d304         	blo	0x805af10 <prvCopyDataToQueue+0x74> @ imm = #0x8
 805af06: e7ff         	b	0x805af08 <prvCopyDataToQueue+0x6c> @ imm = #-0x2
;             pxQueue->pcWriteTo = pxQueue->pcHead;
 805af08: 9905         	ldr	r1, [sp, #0x14]
 805af0a: 6808         	ldr	r0, [r1]
 805af0c: 6048         	str	r0, [r1, #0x4]
;         }
 805af0e: e000         	b	0x805af12 <prvCopyDataToQueue+0x76> @ imm = #0x0
 805af10: e7ff         	b	0x805af12 <prvCopyDataToQueue+0x76> @ imm = #-0x2
;     }
 805af12: e026         	b	0x805af62 <prvCopyDataToQueue+0xc6> @ imm = #0x4c
;         ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 805af14: 9a05         	ldr	r2, [sp, #0x14]
 805af16: 9904         	ldr	r1, [sp, #0x10]
 805af18: 68d0         	ldr	r0, [r2, #0xc]
 805af1a: 6c12         	ldr	r2, [r2, #0x40]
 805af1c: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x805af7c <prvCopyDataToQueue+0xe0>
 805af1e: 4798         	blx	r3
;         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 805af20: 9905         	ldr	r1, [sp, #0x14]
 805af22: 68c8         	ldr	r0, [r1, #0xc]
 805af24: 6c0a         	ldr	r2, [r1, #0x40]
 805af26: 1a80         	subs	r0, r0, r2
 805af28: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 805af2a: 9805         	ldr	r0, [sp, #0x14]
 805af2c: 6801         	ldr	r1, [r0]
 805af2e: 68c0         	ldr	r0, [r0, #0xc]
 805af30: 4288         	cmp	r0, r1
 805af32: d206         	bhs	0x805af42 <prvCopyDataToQueue+0xa6> @ imm = #0xc
 805af34: e7ff         	b	0x805af36 <prvCopyDataToQueue+0x9a> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 805af36: 9905         	ldr	r1, [sp, #0x14]
 805af38: 6888         	ldr	r0, [r1, #0x8]
 805af3a: 6c0a         	ldr	r2, [r1, #0x40]
 805af3c: 1a80         	subs	r0, r0, r2
 805af3e: 60c8         	str	r0, [r1, #0xc]
;         }
 805af40: e000         	b	0x805af44 <prvCopyDataToQueue+0xa8> @ imm = #0x0
 805af42: e7ff         	b	0x805af44 <prvCopyDataToQueue+0xa8> @ imm = #-0x2
;         if( xPosition == queueOVERWRITE )
 805af44: 9803         	ldr	r0, [sp, #0xc]
 805af46: 2802         	cmp	r0, #0x2
 805af48: d109         	bne	0x805af5e <prvCopyDataToQueue+0xc2> @ imm = #0x12
 805af4a: e7ff         	b	0x805af4c <prvCopyDataToQueue+0xb0> @ imm = #-0x2
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 805af4c: 9801         	ldr	r0, [sp, #0x4]
 805af4e: b120         	cbz	r0, 0x805af5a <prvCopyDataToQueue+0xbe> @ imm = #0x8
 805af50: e7ff         	b	0x805af52 <prvCopyDataToQueue+0xb6> @ imm = #-0x2
;                 --uxMessagesWaiting;
 805af52: 9801         	ldr	r0, [sp, #0x4]
 805af54: 3801         	subs	r0, #0x1
 805af56: 9001         	str	r0, [sp, #0x4]
;             }
 805af58: e000         	b	0x805af5c <prvCopyDataToQueue+0xc0> @ imm = #0x0
 805af5a: e7ff         	b	0x805af5c <prvCopyDataToQueue+0xc0> @ imm = #-0x2
;         }
 805af5c: e000         	b	0x805af60 <prvCopyDataToQueue+0xc4> @ imm = #0x0
 805af5e: e7ff         	b	0x805af60 <prvCopyDataToQueue+0xc4> @ imm = #-0x2
 805af60: e7ff         	b	0x805af62 <prvCopyDataToQueue+0xc6> @ imm = #-0x2
 805af62: e7ff         	b	0x805af64 <prvCopyDataToQueue+0xc8> @ imm = #-0x2
;     pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );
 805af64: 9801         	ldr	r0, [sp, #0x4]
 805af66: 3001         	adds	r0, #0x1
 805af68: 9905         	ldr	r1, [sp, #0x14]
 805af6a: 6388         	str	r0, [r1, #0x38]
;     return xReturn;
 805af6c: 9802         	ldr	r0, [sp, #0x8]
 805af6e: b006         	add	sp, #0x18
 805af70: bc80         	pop	{r7}
 805af72: eba8 0809    	sub.w	r8, r8, r9
 805af76: f858 fd3c    	ldr	pc, [r8, #-60]!
 805af7a: bf00         	nop

0805af7c <$d.25>:
 805af7c: c1 f8 05 08  	.word	0x0805f8c1
 805af80: c1 f8 05 08  	.word	0x0805f8c1
 805af84: e1 78 05 08  	.word	0x080578e1

0805af88 <prvIsQueueFull>:
; {
 805af88: f848 eb4c    	str	lr, [r8], #76
 805af8c: eb08 0809    	add.w	r8, r8, r9
 805af90: b480         	push	{r7}
 805af92: 466f         	mov	r7, sp
 805af94: b082         	sub	sp, #0x8
 805af96: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
 805af98: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805afc8 <prvIsQueueFull+0x40>
 805af9a: 4780         	blx	r0
;         if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 805af9c: 9801         	ldr	r0, [sp, #0x4]
 805af9e: 6b80         	ldr	r0, [r0, #0x38]
 805afa0: 9901         	ldr	r1, [sp, #0x4]
 805afa2: 6bc9         	ldr	r1, [r1, #0x3c]
 805afa4: 4288         	cmp	r0, r1
 805afa6: d103         	bne	0x805afb0 <prvIsQueueFull+0x28> @ imm = #0x6
 805afa8: e7ff         	b	0x805afaa <prvIsQueueFull+0x22> @ imm = #-0x2
 805afaa: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
 805afac: 9000         	str	r0, [sp]
;         }
 805afae: e002         	b	0x805afb6 <prvIsQueueFull+0x2e> @ imm = #0x4
 805afb0: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
 805afb2: 9000         	str	r0, [sp]
 805afb4: e7ff         	b	0x805afb6 <prvIsQueueFull+0x2e> @ imm = #-0x2
;     taskEXIT_CRITICAL();
 805afb6: 4805         	ldr	r0, [pc, #0x14]         @ 0x805afcc <prvIsQueueFull+0x44>
 805afb8: 4780         	blx	r0
;     return xReturn;
 805afba: 9800         	ldr	r0, [sp]
 805afbc: b002         	add	sp, #0x8
 805afbe: bc80         	pop	{r7}
 805afc0: eba8 0809    	sub.w	r8, r8, r9
 805afc4: f858 fd4c    	ldr	pc, [r8, #-76]!

0805afc8 <$d.27>:
 805afc8: 49 cd 05 08  	.word	0x0805cd49
 805afcc: 7d cd 05 08  	.word	0x0805cd7d

0805afd0 <prvUnlockQueue>:
; {
 805afd0: f848 eb08    	str	lr, [r8], #8
 805afd4: eb08 0809    	add.w	r8, r8, r9
 805afd8: b480         	push	{r7}
 805afda: 466f         	mov	r7, sp
 805afdc: b082         	sub	sp, #0x8
 805afde: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
 805afe0: 482b         	ldr	r0, [pc, #0xac]         @ 0x805b090 <prvUnlockQueue+0xc0>
 805afe2: 4780         	blx	r0
;         int8_t cTxLock = pxQueue->cTxLock;
 805afe4: 9801         	ldr	r0, [sp, #0x4]
 805afe6: f890 0045    	ldrb.w	r0, [r0, #0x45]
 805afea: f807 0c05    	strb	r0, [r7, #-5]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
 805afee: e7ff         	b	0x805aff0 <prvUnlockQueue+0x20> @ imm = #-0x2
 805aff0: f917 0c05    	ldrsb	r0, [r7, #-5]
 805aff4: 2801         	cmp	r0, #0x1
 805aff6: db16         	blt	0x805b026 <prvUnlockQueue+0x56> @ imm = #0x2c
 805aff8: e7ff         	b	0x805affa <prvUnlockQueue+0x2a> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 805affa: 9801         	ldr	r0, [sp, #0x4]
 805affc: 6a40         	ldr	r0, [r0, #0x24]
 805affe: b158         	cbz	r0, 0x805b018 <prvUnlockQueue+0x48> @ imm = #0x16
 805b000: e7ff         	b	0x805b002 <prvUnlockQueue+0x32> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 805b002: 9801         	ldr	r0, [sp, #0x4]
 805b004: 3024         	adds	r0, #0x24
 805b006: 4928         	ldr	r1, [pc, #0xa0]         @ 0x805b0a8 <prvUnlockQueue+0xd8>
 805b008: 4788         	blx	r1
 805b00a: b118         	cbz	r0, 0x805b014 <prvUnlockQueue+0x44> @ imm = #0x6
 805b00c: e7ff         	b	0x805b00e <prvUnlockQueue+0x3e> @ imm = #-0x2
;                         vTaskMissedYield();
 805b00e: 4827         	ldr	r0, [pc, #0x9c]         @ 0x805b0ac <prvUnlockQueue+0xdc>
 805b010: 4780         	blx	r0
;                     }
 805b012: e000         	b	0x805b016 <prvUnlockQueue+0x46> @ imm = #0x0
 805b014: e7ff         	b	0x805b016 <prvUnlockQueue+0x46> @ imm = #-0x2
;                 }
 805b016: e000         	b	0x805b01a <prvUnlockQueue+0x4a> @ imm = #0x0
;                     break;
 805b018: e005         	b	0x805b026 <prvUnlockQueue+0x56> @ imm = #0xa
;             --cTxLock;
 805b01a: f817 0c05    	ldrb	r0, [r7, #-5]
 805b01e: 3801         	subs	r0, #0x1
 805b020: f807 0c05    	strb	r0, [r7, #-5]
;         while( cTxLock > queueLOCKED_UNMODIFIED )
 805b024: e7e4         	b	0x805aff0 <prvUnlockQueue+0x20> @ imm = #-0x38
;         pxQueue->cTxLock = queueUNLOCKED;
 805b026: 9901         	ldr	r1, [sp, #0x4]
 805b028: 20ff         	movs	r0, #0xff
 805b02a: f881 0045    	strb.w	r0, [r1, #0x45]
;     taskEXIT_CRITICAL();
 805b02e: 4819         	ldr	r0, [pc, #0x64]         @ 0x805b094 <prvUnlockQueue+0xc4>
 805b030: 4780         	blx	r0
;     taskENTER_CRITICAL();
 805b032: 4819         	ldr	r0, [pc, #0x64]         @ 0x805b098 <prvUnlockQueue+0xc8>
 805b034: 4780         	blx	r0
;         int8_t cRxLock = pxQueue->cRxLock;
 805b036: 9801         	ldr	r0, [sp, #0x4]
 805b038: f890 0044    	ldrb.w	r0, [r0, #0x44]
 805b03c: f807 0c06    	strb	r0, [r7, #-6]
;         while( cRxLock > queueLOCKED_UNMODIFIED )
 805b040: e7ff         	b	0x805b042 <prvUnlockQueue+0x72> @ imm = #-0x2
 805b042: f917 0c06    	ldrsb	r0, [r7, #-6]
 805b046: 2801         	cmp	r0, #0x1
 805b048: db16         	blt	0x805b078 <prvUnlockQueue+0xa8> @ imm = #0x2c
 805b04a: e7ff         	b	0x805b04c <prvUnlockQueue+0x7c> @ imm = #-0x2
;             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 805b04c: 9801         	ldr	r0, [sp, #0x4]
 805b04e: 6900         	ldr	r0, [r0, #0x10]
 805b050: b180         	cbz	r0, 0x805b074 <prvUnlockQueue+0xa4> @ imm = #0x20
 805b052: e7ff         	b	0x805b054 <prvUnlockQueue+0x84> @ imm = #-0x2
;                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 805b054: 9801         	ldr	r0, [sp, #0x4]
 805b056: 3010         	adds	r0, #0x10
 805b058: 4911         	ldr	r1, [pc, #0x44]         @ 0x805b0a0 <prvUnlockQueue+0xd0>
 805b05a: 4788         	blx	r1
 805b05c: b118         	cbz	r0, 0x805b066 <prvUnlockQueue+0x96> @ imm = #0x6
 805b05e: e7ff         	b	0x805b060 <prvUnlockQueue+0x90> @ imm = #-0x2
;                     vTaskMissedYield();
 805b060: 4810         	ldr	r0, [pc, #0x40]         @ 0x805b0a4 <prvUnlockQueue+0xd4>
 805b062: 4780         	blx	r0
;                 }
 805b064: e000         	b	0x805b068 <prvUnlockQueue+0x98> @ imm = #0x0
 805b066: e7ff         	b	0x805b068 <prvUnlockQueue+0x98> @ imm = #-0x2
;                 --cRxLock;
 805b068: f817 0c06    	ldrb	r0, [r7, #-6]
 805b06c: 3801         	subs	r0, #0x1
 805b06e: f807 0c06    	strb	r0, [r7, #-6]
;             }
 805b072: e000         	b	0x805b076 <prvUnlockQueue+0xa6> @ imm = #0x0
;                 break;
 805b074: e000         	b	0x805b078 <prvUnlockQueue+0xa8> @ imm = #0x0
;         while( cRxLock > queueLOCKED_UNMODIFIED )
 805b076: e7e4         	b	0x805b042 <prvUnlockQueue+0x72> @ imm = #-0x38
;         pxQueue->cRxLock = queueUNLOCKED;
 805b078: 9901         	ldr	r1, [sp, #0x4]
 805b07a: 20ff         	movs	r0, #0xff
 805b07c: f881 0044    	strb.w	r0, [r1, #0x44]
;     taskEXIT_CRITICAL();
 805b080: 4806         	ldr	r0, [pc, #0x18]         @ 0x805b09c <prvUnlockQueue+0xcc>
 805b082: 4780         	blx	r0
; }
 805b084: b002         	add	sp, #0x8
 805b086: bc80         	pop	{r7}
 805b088: eba8 0809    	sub.w	r8, r8, r9
 805b08c: f858 fd08    	ldr	pc, [r8, #-8]!

0805b090 <$d.29>:
 805b090: 49 cd 05 08  	.word	0x0805cd49
 805b094: 7d cd 05 08  	.word	0x0805cd7d
 805b098: 49 cd 05 08  	.word	0x0805cd49
 805b09c: 7d cd 05 08  	.word	0x0805cd7d
 805b0a0: a9 6f 05 08  	.word	0x08056fa9
 805b0a4: 9d 74 05 08  	.word	0x0805749d
 805b0a8: a9 6f 05 08  	.word	0x08056fa9
 805b0ac: 9d 74 05 08  	.word	0x0805749d

0805b0b0 <xQueueGenericSendFromISR>:
; {
 805b0b0: f848 eb70    	str	lr, [r8], #112
 805b0b4: eb08 0809    	add.w	r8, r8, r9
 805b0b8: b480         	push	{r7}
 805b0ba: 466f         	mov	r7, sp
 805b0bc: b08c         	sub	sp, #0x30
 805b0be: 900b         	str	r0, [sp, #0x2c]
 805b0c0: 910a         	str	r1, [sp, #0x28]
 805b0c2: 9209         	str	r2, [sp, #0x24]
 805b0c4: 9308         	str	r3, [sp, #0x20]
;     Queue_t * const pxQueue = xQueue;
 805b0c6: 980b         	ldr	r0, [sp, #0x2c]
 805b0c8: 9005         	str	r0, [sp, #0x14]
;     configASSERT( pxQueue );
 805b0ca: 9805         	ldr	r0, [sp, #0x14]
 805b0cc: b920         	cbnz	r0, 0x805b0d8 <xQueueGenericSendFromISR+0x28> @ imm = #0x8
 805b0ce: e7ff         	b	0x805b0d0 <xQueueGenericSendFromISR+0x20> @ imm = #-0x2
 805b0d0: 4851         	ldr	r0, [pc, #0x144]        @ 0x805b218 <xQueueGenericSendFromISR+0x168>
 805b0d2: 4780         	blx	r0
 805b0d4: e7ff         	b	0x805b0d6 <xQueueGenericSendFromISR+0x26> @ imm = #-0x2
 805b0d6: e7fe         	b	0x805b0d6 <xQueueGenericSendFromISR+0x26> @ imm = #-0x4
;     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 805b0d8: 990a         	ldr	r1, [sp, #0x28]
 805b0da: 2000         	movs	r0, #0x0
 805b0dc: 9001         	str	r0, [sp, #0x4]
 805b0de: b939         	cbnz	r1, 0x805b0f0 <xQueueGenericSendFromISR+0x40> @ imm = #0xe
 805b0e0: e7ff         	b	0x805b0e2 <xQueueGenericSendFromISR+0x32> @ imm = #-0x2
 805b0e2: 9805         	ldr	r0, [sp, #0x14]
 805b0e4: 6c00         	ldr	r0, [r0, #0x40]
 805b0e6: 2800         	cmp	r0, #0x0
 805b0e8: bf18         	it	ne
 805b0ea: 2001         	movne	r0, #0x1
 805b0ec: 9001         	str	r0, [sp, #0x4]
 805b0ee: e7ff         	b	0x805b0f0 <xQueueGenericSendFromISR+0x40> @ imm = #-0x2
 805b0f0: 9801         	ldr	r0, [sp, #0x4]
;     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 805b0f2: 07c0         	lsls	r0, r0, #0x1f
 805b0f4: b120         	cbz	r0, 0x805b100 <xQueueGenericSendFromISR+0x50> @ imm = #0x8
 805b0f6: e7ff         	b	0x805b0f8 <xQueueGenericSendFromISR+0x48> @ imm = #-0x2
 805b0f8: 4846         	ldr	r0, [pc, #0x118]        @ 0x805b214 <xQueueGenericSendFromISR+0x164>
 805b0fa: 4780         	blx	r0
 805b0fc: e7ff         	b	0x805b0fe <xQueueGenericSendFromISR+0x4e> @ imm = #-0x2
 805b0fe: e7fe         	b	0x805b0fe <xQueueGenericSendFromISR+0x4e> @ imm = #-0x4
;     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 805b100: 9908         	ldr	r1, [sp, #0x20]
 805b102: 2000         	movs	r0, #0x0
 805b104: 2902         	cmp	r1, #0x2
 805b106: 9000         	str	r0, [sp]
 805b108: d107         	bne	0x805b11a <xQueueGenericSendFromISR+0x6a> @ imm = #0xe
 805b10a: e7ff         	b	0x805b10c <xQueueGenericSendFromISR+0x5c> @ imm = #-0x2
 805b10c: 9805         	ldr	r0, [sp, #0x14]
 805b10e: 6bc0         	ldr	r0, [r0, #0x3c]
 805b110: 3801         	subs	r0, #0x1
 805b112: bf18         	it	ne
 805b114: 2001         	movne	r0, #0x1
 805b116: 9000         	str	r0, [sp]
 805b118: e7ff         	b	0x805b11a <xQueueGenericSendFromISR+0x6a> @ imm = #-0x2
 805b11a: 9800         	ldr	r0, [sp]
;     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 805b11c: 07c0         	lsls	r0, r0, #0x1f
 805b11e: b120         	cbz	r0, 0x805b12a <xQueueGenericSendFromISR+0x7a> @ imm = #0x8
 805b120: e7ff         	b	0x805b122 <xQueueGenericSendFromISR+0x72> @ imm = #-0x2
 805b122: 483b         	ldr	r0, [pc, #0xec]         @ 0x805b210 <xQueueGenericSendFromISR+0x160>
 805b124: 4780         	blx	r0
 805b126: e7ff         	b	0x805b128 <xQueueGenericSendFromISR+0x78> @ imm = #-0x2
 805b128: e7fe         	b	0x805b128 <xQueueGenericSendFromISR+0x78> @ imm = #-0x4
;     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 805b12a: 4832         	ldr	r0, [pc, #0xc8]         @ 0x805b1f4 <xQueueGenericSendFromISR+0x144>
 805b12c: 4780         	blx	r0
;     uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
 805b12e: 4832         	ldr	r0, [pc, #0xc8]         @ 0x805b1f8 <xQueueGenericSendFromISR+0x148>
 805b130: 4780         	blx	r0
 805b132: 9006         	str	r0, [sp, #0x18]
;         if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 805b134: 9805         	ldr	r0, [sp, #0x14]
 805b136: 6b80         	ldr	r0, [r0, #0x38]
 805b138: 9905         	ldr	r1, [sp, #0x14]
 805b13a: 6bc9         	ldr	r1, [r1, #0x3c]
 805b13c: 4288         	cmp	r0, r1
 805b13e: d304         	blo	0x805b14a <xQueueGenericSendFromISR+0x9a> @ imm = #0x8
 805b140: e7ff         	b	0x805b142 <xQueueGenericSendFromISR+0x92> @ imm = #-0x2
 805b142: 9808         	ldr	r0, [sp, #0x20]
 805b144: 2802         	cmp	r0, #0x2
 805b146: d148         	bne	0x805b1da <xQueueGenericSendFromISR+0x12a> @ imm = #0x90
 805b148: e7ff         	b	0x805b14a <xQueueGenericSendFromISR+0x9a> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
 805b14a: 9805         	ldr	r0, [sp, #0x14]
 805b14c: f890 0045    	ldrb.w	r0, [r0, #0x45]
 805b150: f807 0c1d    	strb	r0, [r7, #-29]
;             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 805b154: 9805         	ldr	r0, [sp, #0x14]
 805b156: 6b80         	ldr	r0, [r0, #0x38]
 805b158: 9003         	str	r0, [sp, #0xc]
;             ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 805b15a: 9805         	ldr	r0, [sp, #0x14]
 805b15c: 990a         	ldr	r1, [sp, #0x28]
 805b15e: 9a08         	ldr	r2, [sp, #0x20]
 805b160: 4b26         	ldr	r3, [pc, #0x98]         @ 0x805b1fc <xQueueGenericSendFromISR+0x14c>
 805b162: 4798         	blx	r3
;             if( cTxLock == queueUNLOCKED )
 805b164: f917 0c1d    	ldrsb	r0, [r7, #-29]
 805b168: 3001         	adds	r0, #0x1
 805b16a: b9b8         	cbnz	r0, 0x805b19c <xQueueGenericSendFromISR+0xec> @ imm = #0x2e
 805b16c: e7ff         	b	0x805b16e <xQueueGenericSendFromISR+0xbe> @ imm = #-0x2
;                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 805b16e: 9805         	ldr	r0, [sp, #0x14]
 805b170: 6a40         	ldr	r0, [r0, #0x24]
 805b172: b188         	cbz	r0, 0x805b198 <xQueueGenericSendFromISR+0xe8> @ imm = #0x22
 805b174: e7ff         	b	0x805b176 <xQueueGenericSendFromISR+0xc6> @ imm = #-0x2
;                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 805b176: 9805         	ldr	r0, [sp, #0x14]
 805b178: 3024         	adds	r0, #0x24
 805b17a: 4923         	ldr	r1, [pc, #0x8c]         @ 0x805b208 <xQueueGenericSendFromISR+0x158>
 805b17c: 4788         	blx	r1
 805b17e: b148         	cbz	r0, 0x805b194 <xQueueGenericSendFromISR+0xe4> @ imm = #0x12
 805b180: e7ff         	b	0x805b182 <xQueueGenericSendFromISR+0xd2> @ imm = #-0x2
;                             if( pxHigherPriorityTaskWoken != NULL )
 805b182: 9809         	ldr	r0, [sp, #0x24]
 805b184: b120         	cbz	r0, 0x805b190 <xQueueGenericSendFromISR+0xe0> @ imm = #0x8
 805b186: e7ff         	b	0x805b188 <xQueueGenericSendFromISR+0xd8> @ imm = #-0x2
;                                 *pxHigherPriorityTaskWoken = pdTRUE;
 805b188: 9909         	ldr	r1, [sp, #0x24]
 805b18a: 2001         	movs	r0, #0x1
 805b18c: 6008         	str	r0, [r1]
;                             }
 805b18e: e000         	b	0x805b192 <xQueueGenericSendFromISR+0xe2> @ imm = #0x0
 805b190: e7ff         	b	0x805b192 <xQueueGenericSendFromISR+0xe2> @ imm = #-0x2
;                         }
 805b192: e000         	b	0x805b196 <xQueueGenericSendFromISR+0xe6> @ imm = #0x0
 805b194: e7ff         	b	0x805b196 <xQueueGenericSendFromISR+0xe6> @ imm = #-0x2
;                     }
 805b196: e000         	b	0x805b19a <xQueueGenericSendFromISR+0xea> @ imm = #0x0
 805b198: e7ff         	b	0x805b19a <xQueueGenericSendFromISR+0xea> @ imm = #-0x2
;             }
 805b19a: e01b         	b	0x805b1d4 <xQueueGenericSendFromISR+0x124> @ imm = #0x36
;                 prvIncrementQueueTxLock( pxQueue, cTxLock );
 805b19c: e7ff         	b	0x805b19e <xQueueGenericSendFromISR+0xee> @ imm = #-0x2
 805b19e: 4818         	ldr	r0, [pc, #0x60]         @ 0x805b200 <xQueueGenericSendFromISR+0x150>
 805b1a0: 4780         	blx	r0
 805b1a2: 9002         	str	r0, [sp, #0x8]
 805b1a4: f917 0c1d    	ldrsb	r0, [r7, #-29]
 805b1a8: 9902         	ldr	r1, [sp, #0x8]
 805b1aa: 4288         	cmp	r0, r1
 805b1ac: d210         	bhs	0x805b1d0 <xQueueGenericSendFromISR+0x120> @ imm = #0x20
 805b1ae: e7ff         	b	0x805b1b0 <xQueueGenericSendFromISR+0x100> @ imm = #-0x2
 805b1b0: f917 0c1d    	ldrsb	r0, [r7, #-29]
 805b1b4: 287f         	cmp	r0, #0x7f
 805b1b6: d104         	bne	0x805b1c2 <xQueueGenericSendFromISR+0x112> @ imm = #0x8
 805b1b8: e7ff         	b	0x805b1ba <xQueueGenericSendFromISR+0x10a> @ imm = #-0x2
 805b1ba: 4812         	ldr	r0, [pc, #0x48]         @ 0x805b204 <xQueueGenericSendFromISR+0x154>
 805b1bc: 4780         	blx	r0
 805b1be: e7ff         	b	0x805b1c0 <xQueueGenericSendFromISR+0x110> @ imm = #-0x2
 805b1c0: e7fe         	b	0x805b1c0 <xQueueGenericSendFromISR+0x110> @ imm = #-0x4
 805b1c2: f817 0c1d    	ldrb	r0, [r7, #-29]
 805b1c6: 3001         	adds	r0, #0x1
 805b1c8: 9905         	ldr	r1, [sp, #0x14]
 805b1ca: f881 0045    	strb.w	r0, [r1, #0x45]
 805b1ce: e7ff         	b	0x805b1d0 <xQueueGenericSendFromISR+0x120> @ imm = #-0x2
 805b1d0: e7ff         	b	0x805b1d2 <xQueueGenericSendFromISR+0x122> @ imm = #-0x2
 805b1d2: e7ff         	b	0x805b1d4 <xQueueGenericSendFromISR+0x124> @ imm = #-0x2
 805b1d4: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
 805b1d6: 9007         	str	r0, [sp, #0x1c]
;         }
 805b1d8: e002         	b	0x805b1e0 <xQueueGenericSendFromISR+0x130> @ imm = #0x4
 805b1da: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
 805b1dc: 9007         	str	r0, [sp, #0x1c]
 805b1de: e7ff         	b	0x805b1e0 <xQueueGenericSendFromISR+0x130> @ imm = #-0x2
;     taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
 805b1e0: 9806         	ldr	r0, [sp, #0x18]
 805b1e2: 490a         	ldr	r1, [pc, #0x28]         @ 0x805b20c <xQueueGenericSendFromISR+0x15c>
 805b1e4: 4788         	blx	r1
;     return xReturn;
 805b1e6: 9807         	ldr	r0, [sp, #0x1c]
 805b1e8: b00c         	add	sp, #0x30
 805b1ea: bc80         	pop	{r7}
 805b1ec: eba8 0809    	sub.w	r8, r8, r9
 805b1f0: f858 fd70    	ldr	pc, [r8, #-112]!

0805b1f4 <$d.31>:
 805b1f4: 1d f8 05 08  	.word	0x0805f81d
 805b1f8: 15 d7 05 08  	.word	0x0805d715
 805b1fc: 9d ae 05 08  	.word	0x0805ae9d
 805b200: 3d 6b 05 08  	.word	0x08056b3d
 805b204: 15 d7 05 08  	.word	0x0805d715
 805b208: a9 6f 05 08  	.word	0x08056fa9
 805b20c: 2b d7 05 08  	.word	0x0805d72b
 805b210: 15 d7 05 08  	.word	0x0805d715
 805b214: 15 d7 05 08  	.word	0x0805d715
 805b218: 15 d7 05 08  	.word	0x0805d715

0805b21c <xQueueGiveFromISR>:
; {
 805b21c: f848 eb10    	str	lr, [r8], #16
 805b220: eb08 0809    	add.w	r8, r8, r9
 805b224: b480         	push	{r7}
 805b226: 466f         	mov	r7, sp
 805b228: b08a         	sub	sp, #0x28
 805b22a: 9009         	str	r0, [sp, #0x24]
 805b22c: 9108         	str	r1, [sp, #0x20]
;     Queue_t * const pxQueue = xQueue;
 805b22e: 9809         	ldr	r0, [sp, #0x24]
 805b230: 9005         	str	r0, [sp, #0x14]
;     configASSERT( pxQueue );
 805b232: 9805         	ldr	r0, [sp, #0x14]
 805b234: b920         	cbnz	r0, 0x805b240 <xQueueGiveFromISR+0x24> @ imm = #0x8
 805b236: e7ff         	b	0x805b238 <xQueueGiveFromISR+0x1c> @ imm = #-0x2
 805b238: 4847         	ldr	r0, [pc, #0x11c]        @ 0x805b358 <xQueueGiveFromISR+0x13c>
 805b23a: 4780         	blx	r0
 805b23c: e7ff         	b	0x805b23e <xQueueGiveFromISR+0x22> @ imm = #-0x2
 805b23e: e7fe         	b	0x805b23e <xQueueGiveFromISR+0x22> @ imm = #-0x4
;     configASSERT( pxQueue->uxItemSize == 0 );
 805b240: 9805         	ldr	r0, [sp, #0x14]
 805b242: 6c00         	ldr	r0, [r0, #0x40]
 805b244: b120         	cbz	r0, 0x805b250 <xQueueGiveFromISR+0x34> @ imm = #0x8
 805b246: e7ff         	b	0x805b248 <xQueueGiveFromISR+0x2c> @ imm = #-0x2
 805b248: 4842         	ldr	r0, [pc, #0x108]        @ 0x805b354 <xQueueGiveFromISR+0x138>
 805b24a: 4780         	blx	r0
 805b24c: e7ff         	b	0x805b24e <xQueueGiveFromISR+0x32> @ imm = #-0x2
 805b24e: e7fe         	b	0x805b24e <xQueueGiveFromISR+0x32> @ imm = #-0x4
;     configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 805b250: 9805         	ldr	r0, [sp, #0x14]
 805b252: 6801         	ldr	r1, [r0]
 805b254: 2000         	movs	r0, #0x0
 805b256: 9001         	str	r0, [sp, #0x4]
 805b258: b939         	cbnz	r1, 0x805b26a <xQueueGiveFromISR+0x4e> @ imm = #0xe
 805b25a: e7ff         	b	0x805b25c <xQueueGiveFromISR+0x40> @ imm = #-0x2
 805b25c: 9805         	ldr	r0, [sp, #0x14]
 805b25e: 6880         	ldr	r0, [r0, #0x8]
 805b260: 2800         	cmp	r0, #0x0
 805b262: bf18         	it	ne
 805b264: 2001         	movne	r0, #0x1
 805b266: 9001         	str	r0, [sp, #0x4]
 805b268: e7ff         	b	0x805b26a <xQueueGiveFromISR+0x4e> @ imm = #-0x2
 805b26a: 9801         	ldr	r0, [sp, #0x4]
;     configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 805b26c: 07c0         	lsls	r0, r0, #0x1f
 805b26e: b120         	cbz	r0, 0x805b27a <xQueueGiveFromISR+0x5e> @ imm = #0x8
 805b270: e7ff         	b	0x805b272 <xQueueGiveFromISR+0x56> @ imm = #-0x2
 805b272: 4837         	ldr	r0, [pc, #0xdc]         @ 0x805b350 <xQueueGiveFromISR+0x134>
 805b274: 4780         	blx	r0
 805b276: e7ff         	b	0x805b278 <xQueueGiveFromISR+0x5c> @ imm = #-0x2
 805b278: e7fe         	b	0x805b278 <xQueueGiveFromISR+0x5c> @ imm = #-0x4
;     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 805b27a: 482f         	ldr	r0, [pc, #0xbc]         @ 0x805b338 <xQueueGiveFromISR+0x11c>
 805b27c: 4780         	blx	r0
;     uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
 805b27e: 482f         	ldr	r0, [pc, #0xbc]         @ 0x805b33c <xQueueGiveFromISR+0x120>
 805b280: 4780         	blx	r0
 805b282: 9006         	str	r0, [sp, #0x18]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 805b284: 9805         	ldr	r0, [sp, #0x14]
 805b286: 6b80         	ldr	r0, [r0, #0x38]
 805b288: 9004         	str	r0, [sp, #0x10]
;         if( uxMessagesWaiting < pxQueue->uxLength )
 805b28a: 9804         	ldr	r0, [sp, #0x10]
 805b28c: 9905         	ldr	r1, [sp, #0x14]
 805b28e: 6bc9         	ldr	r1, [r1, #0x3c]
 805b290: 4288         	cmp	r0, r1
 805b292: d244         	bhs	0x805b31e <xQueueGiveFromISR+0x102> @ imm = #0x88
 805b294: e7ff         	b	0x805b296 <xQueueGiveFromISR+0x7a> @ imm = #-0x2
;             const int8_t cTxLock = pxQueue->cTxLock;
 805b296: 9805         	ldr	r0, [sp, #0x14]
 805b298: f890 0045    	ldrb.w	r0, [r0, #0x45]
 805b29c: f807 0c19    	strb	r0, [r7, #-25]
;             pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );
 805b2a0: 9804         	ldr	r0, [sp, #0x10]
 805b2a2: 3001         	adds	r0, #0x1
 805b2a4: 9905         	ldr	r1, [sp, #0x14]
 805b2a6: 6388         	str	r0, [r1, #0x38]
;             if( cTxLock == queueUNLOCKED )
 805b2a8: f917 0c19    	ldrsb	r0, [r7, #-25]
 805b2ac: 3001         	adds	r0, #0x1
 805b2ae: b9b8         	cbnz	r0, 0x805b2e0 <xQueueGiveFromISR+0xc4> @ imm = #0x2e
 805b2b0: e7ff         	b	0x805b2b2 <xQueueGiveFromISR+0x96> @ imm = #-0x2
;                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 805b2b2: 9805         	ldr	r0, [sp, #0x14]
 805b2b4: 6a40         	ldr	r0, [r0, #0x24]
 805b2b6: b188         	cbz	r0, 0x805b2dc <xQueueGiveFromISR+0xc0> @ imm = #0x22
 805b2b8: e7ff         	b	0x805b2ba <xQueueGiveFromISR+0x9e> @ imm = #-0x2
;                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 805b2ba: 9805         	ldr	r0, [sp, #0x14]
 805b2bc: 3024         	adds	r0, #0x24
 805b2be: 4922         	ldr	r1, [pc, #0x88]         @ 0x805b348 <xQueueGiveFromISR+0x12c>
 805b2c0: 4788         	blx	r1
 805b2c2: b148         	cbz	r0, 0x805b2d8 <xQueueGiveFromISR+0xbc> @ imm = #0x12
 805b2c4: e7ff         	b	0x805b2c6 <xQueueGiveFromISR+0xaa> @ imm = #-0x2
;                             if( pxHigherPriorityTaskWoken != NULL )
 805b2c6: 9808         	ldr	r0, [sp, #0x20]
 805b2c8: b120         	cbz	r0, 0x805b2d4 <xQueueGiveFromISR+0xb8> @ imm = #0x8
 805b2ca: e7ff         	b	0x805b2cc <xQueueGiveFromISR+0xb0> @ imm = #-0x2
;                                 *pxHigherPriorityTaskWoken = pdTRUE;
 805b2cc: 9908         	ldr	r1, [sp, #0x20]
 805b2ce: 2001         	movs	r0, #0x1
 805b2d0: 6008         	str	r0, [r1]
;                             }
 805b2d2: e000         	b	0x805b2d6 <xQueueGiveFromISR+0xba> @ imm = #0x0
 805b2d4: e7ff         	b	0x805b2d6 <xQueueGiveFromISR+0xba> @ imm = #-0x2
;                         }
 805b2d6: e000         	b	0x805b2da <xQueueGiveFromISR+0xbe> @ imm = #0x0
 805b2d8: e7ff         	b	0x805b2da <xQueueGiveFromISR+0xbe> @ imm = #-0x2
;                     }
 805b2da: e000         	b	0x805b2de <xQueueGiveFromISR+0xc2> @ imm = #0x0
 805b2dc: e7ff         	b	0x805b2de <xQueueGiveFromISR+0xc2> @ imm = #-0x2
;             }
 805b2de: e01b         	b	0x805b318 <xQueueGiveFromISR+0xfc> @ imm = #0x36
;                 prvIncrementQueueTxLock( pxQueue, cTxLock );
 805b2e0: e7ff         	b	0x805b2e2 <xQueueGiveFromISR+0xc6> @ imm = #-0x2
 805b2e2: 4817         	ldr	r0, [pc, #0x5c]         @ 0x805b340 <xQueueGiveFromISR+0x124>
 805b2e4: 4780         	blx	r0
 805b2e6: 9002         	str	r0, [sp, #0x8]
 805b2e8: f917 0c19    	ldrsb	r0, [r7, #-25]
 805b2ec: 9902         	ldr	r1, [sp, #0x8]
 805b2ee: 4288         	cmp	r0, r1
 805b2f0: d210         	bhs	0x805b314 <xQueueGiveFromISR+0xf8> @ imm = #0x20
 805b2f2: e7ff         	b	0x805b2f4 <xQueueGiveFromISR+0xd8> @ imm = #-0x2
 805b2f4: f917 0c19    	ldrsb	r0, [r7, #-25]
 805b2f8: 287f         	cmp	r0, #0x7f
 805b2fa: d104         	bne	0x805b306 <xQueueGiveFromISR+0xea> @ imm = #0x8
 805b2fc: e7ff         	b	0x805b2fe <xQueueGiveFromISR+0xe2> @ imm = #-0x2
 805b2fe: 4811         	ldr	r0, [pc, #0x44]         @ 0x805b344 <xQueueGiveFromISR+0x128>
 805b300: 4780         	blx	r0
 805b302: e7ff         	b	0x805b304 <xQueueGiveFromISR+0xe8> @ imm = #-0x2
 805b304: e7fe         	b	0x805b304 <xQueueGiveFromISR+0xe8> @ imm = #-0x4
 805b306: f817 0c19    	ldrb	r0, [r7, #-25]
 805b30a: 3001         	adds	r0, #0x1
 805b30c: 9905         	ldr	r1, [sp, #0x14]
 805b30e: f881 0045    	strb.w	r0, [r1, #0x45]
 805b312: e7ff         	b	0x805b314 <xQueueGiveFromISR+0xf8> @ imm = #-0x2
 805b314: e7ff         	b	0x805b316 <xQueueGiveFromISR+0xfa> @ imm = #-0x2
 805b316: e7ff         	b	0x805b318 <xQueueGiveFromISR+0xfc> @ imm = #-0x2
 805b318: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
 805b31a: 9007         	str	r0, [sp, #0x1c]
;         }
 805b31c: e002         	b	0x805b324 <xQueueGiveFromISR+0x108> @ imm = #0x4
 805b31e: 2000         	movs	r0, #0x0
;             xReturn = errQUEUE_FULL;
 805b320: 9007         	str	r0, [sp, #0x1c]
 805b322: e7ff         	b	0x805b324 <xQueueGiveFromISR+0x108> @ imm = #-0x2
;     taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
 805b324: 9806         	ldr	r0, [sp, #0x18]
 805b326: 4909         	ldr	r1, [pc, #0x24]         @ 0x805b34c <xQueueGiveFromISR+0x130>
 805b328: 4788         	blx	r1
;     return xReturn;
 805b32a: 9807         	ldr	r0, [sp, #0x1c]
 805b32c: b00a         	add	sp, #0x28
 805b32e: bc80         	pop	{r7}
 805b330: eba8 0809    	sub.w	r8, r8, r9
 805b334: f858 fd10    	ldr	pc, [r8, #-16]!

0805b338 <$d.33>:
 805b338: 1d f8 05 08  	.word	0x0805f81d
 805b33c: 15 d7 05 08  	.word	0x0805d715
 805b340: 3d 6b 05 08  	.word	0x08056b3d
 805b344: 15 d7 05 08  	.word	0x0805d715
 805b348: a9 6f 05 08  	.word	0x08056fa9
 805b34c: 2b d7 05 08  	.word	0x0805d72b
 805b350: 15 d7 05 08  	.word	0x0805d715
 805b354: 15 d7 05 08  	.word	0x0805d715
 805b358: 15 d7 05 08  	.word	0x0805d715

0805b35c <xQueueReceive>:
; {
 805b35c: f848 eb40    	str	lr, [r8], #64
 805b360: eb08 0809    	add.w	r8, r8, r9
 805b364: b480         	push	{r7}
 805b366: 466f         	mov	r7, sp
 805b368: b08c         	sub	sp, #0x30
 805b36a: 900a         	str	r0, [sp, #0x28]
 805b36c: 9109         	str	r1, [sp, #0x24]
 805b36e: 9208         	str	r2, [sp, #0x20]
 805b370: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
 805b372: 9007         	str	r0, [sp, #0x1c]
;     Queue_t * const pxQueue = xQueue;
 805b374: 980a         	ldr	r0, [sp, #0x28]
 805b376: 9004         	str	r0, [sp, #0x10]
;     configASSERT( ( pxQueue ) );
 805b378: 9804         	ldr	r0, [sp, #0x10]
 805b37a: b920         	cbnz	r0, 0x805b386 <xQueueReceive+0x2a> @ imm = #0x8
 805b37c: e7ff         	b	0x805b37e <xQueueReceive+0x22> @ imm = #-0x2
 805b37e: 4878         	ldr	r0, [pc, #0x1e0]        @ 0x805b560 <xQueueReceive+0x204>
 805b380: 4780         	blx	r0
 805b382: e7ff         	b	0x805b384 <xQueueReceive+0x28> @ imm = #-0x2
 805b384: e7fe         	b	0x805b384 <xQueueReceive+0x28> @ imm = #-0x4
;     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 805b386: 9909         	ldr	r1, [sp, #0x24]
 805b388: 2000         	movs	r0, #0x0
 805b38a: 9002         	str	r0, [sp, #0x8]
 805b38c: b939         	cbnz	r1, 0x805b39e <xQueueReceive+0x42> @ imm = #0xe
 805b38e: e7ff         	b	0x805b390 <xQueueReceive+0x34> @ imm = #-0x2
 805b390: 9804         	ldr	r0, [sp, #0x10]
 805b392: 6c00         	ldr	r0, [r0, #0x40]
 805b394: 2800         	cmp	r0, #0x0
 805b396: bf18         	it	ne
 805b398: 2001         	movne	r0, #0x1
 805b39a: 9002         	str	r0, [sp, #0x8]
 805b39c: e7ff         	b	0x805b39e <xQueueReceive+0x42> @ imm = #-0x2
 805b39e: 9802         	ldr	r0, [sp, #0x8]
;     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 805b3a0: 07c0         	lsls	r0, r0, #0x1f
 805b3a2: b120         	cbz	r0, 0x805b3ae <xQueueReceive+0x52> @ imm = #0x8
 805b3a4: e7ff         	b	0x805b3a6 <xQueueReceive+0x4a> @ imm = #-0x2
 805b3a6: 486d         	ldr	r0, [pc, #0x1b4]        @ 0x805b55c <xQueueReceive+0x200>
 805b3a8: 4780         	blx	r0
 805b3aa: e7ff         	b	0x805b3ac <xQueueReceive+0x50> @ imm = #-0x2
 805b3ac: e7fe         	b	0x805b3ac <xQueueReceive+0x50> @ imm = #-0x4
;         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 805b3ae: 4853         	ldr	r0, [pc, #0x14c]        @ 0x805b4fc <xQueueReceive+0x1a0>
 805b3b0: 4780         	blx	r0
 805b3b2: 4601         	mov	r1, r0
 805b3b4: 2000         	movs	r0, #0x0
 805b3b6: 9001         	str	r0, [sp, #0x4]
 805b3b8: b931         	cbnz	r1, 0x805b3c8 <xQueueReceive+0x6c> @ imm = #0xc
 805b3ba: e7ff         	b	0x805b3bc <xQueueReceive+0x60> @ imm = #-0x2
 805b3bc: 9808         	ldr	r0, [sp, #0x20]
 805b3be: 2800         	cmp	r0, #0x0
 805b3c0: bf18         	it	ne
 805b3c2: 2001         	movne	r0, #0x1
 805b3c4: 9001         	str	r0, [sp, #0x4]
 805b3c6: e7ff         	b	0x805b3c8 <xQueueReceive+0x6c> @ imm = #-0x2
 805b3c8: 9801         	ldr	r0, [sp, #0x4]
;         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 805b3ca: 07c0         	lsls	r0, r0, #0x1f
 805b3cc: b120         	cbz	r0, 0x805b3d8 <xQueueReceive+0x7c> @ imm = #0x8
 805b3ce: e7ff         	b	0x805b3d0 <xQueueReceive+0x74> @ imm = #-0x2
 805b3d0: 4861         	ldr	r0, [pc, #0x184]        @ 0x805b558 <xQueueReceive+0x1fc>
 805b3d2: 4780         	blx	r0
 805b3d4: e7ff         	b	0x805b3d6 <xQueueReceive+0x7a> @ imm = #-0x2
 805b3d6: e7fe         	b	0x805b3d6 <xQueueReceive+0x7a> @ imm = #-0x4
;     for( ; ; )
 805b3d8: e7ff         	b	0x805b3da <xQueueReceive+0x7e> @ imm = #-0x2
;         taskENTER_CRITICAL();
 805b3da: 4849         	ldr	r0, [pc, #0x124]        @ 0x805b500 <xQueueReceive+0x1a4>
 805b3dc: 4780         	blx	r0
;             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 805b3de: 9804         	ldr	r0, [sp, #0x10]
 805b3e0: 6b80         	ldr	r0, [r0, #0x38]
 805b3e2: 9003         	str	r0, [sp, #0xc]
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 805b3e4: 9803         	ldr	r0, [sp, #0xc]
 805b3e6: b1e8         	cbz	r0, 0x805b424 <xQueueReceive+0xc8> @ imm = #0x3a
 805b3e8: e7ff         	b	0x805b3ea <xQueueReceive+0x8e> @ imm = #-0x2
;                 prvCopyDataFromQueue( pxQueue, pvBuffer );
 805b3ea: 9804         	ldr	r0, [sp, #0x10]
 805b3ec: 9909         	ldr	r1, [sp, #0x24]
 805b3ee: 4a56         	ldr	r2, [pc, #0x158]        @ 0x805b548 <xQueueReceive+0x1ec>
 805b3f0: 4790         	blx	r2
;                 pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting - ( UBaseType_t ) 1 );
 805b3f2: 9803         	ldr	r0, [sp, #0xc]
 805b3f4: 3801         	subs	r0, #0x1
 805b3f6: 9904         	ldr	r1, [sp, #0x10]
 805b3f8: 6388         	str	r0, [r1, #0x38]
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 805b3fa: 9804         	ldr	r0, [sp, #0x10]
 805b3fc: 6900         	ldr	r0, [r0, #0x10]
 805b3fe: b158         	cbz	r0, 0x805b418 <xQueueReceive+0xbc> @ imm = #0x16
 805b400: e7ff         	b	0x805b402 <xQueueReceive+0xa6> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 805b402: 9804         	ldr	r0, [sp, #0x10]
 805b404: 3010         	adds	r0, #0x10
 805b406: 4951         	ldr	r1, [pc, #0x144]        @ 0x805b54c <xQueueReceive+0x1f0>
 805b408: 4788         	blx	r1
 805b40a: b118         	cbz	r0, 0x805b414 <xQueueReceive+0xb8> @ imm = #0x6
 805b40c: e7ff         	b	0x805b40e <xQueueReceive+0xb2> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
 805b40e: 4850         	ldr	r0, [pc, #0x140]        @ 0x805b550 <xQueueReceive+0x1f4>
 805b410: 4780         	blx	r0
;                     }
 805b412: e000         	b	0x805b416 <xQueueReceive+0xba> @ imm = #0x0
 805b414: e7ff         	b	0x805b416 <xQueueReceive+0xba> @ imm = #-0x2
;                 }
 805b416: e000         	b	0x805b41a <xQueueReceive+0xbe> @ imm = #0x0
 805b418: e7ff         	b	0x805b41a <xQueueReceive+0xbe> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
 805b41a: 484e         	ldr	r0, [pc, #0x138]        @ 0x805b554 <xQueueReceive+0x1f8>
 805b41c: 4780         	blx	r0
 805b41e: 2001         	movs	r0, #0x1
;                 return pdPASS;
 805b420: 900b         	str	r0, [sp, #0x2c]
 805b422: e064         	b	0x805b4ee <xQueueReceive+0x192> @ imm = #0xc8
;                 if( xTicksToWait == ( TickType_t ) 0 )
 805b424: 9808         	ldr	r0, [sp, #0x20]
 805b426: b928         	cbnz	r0, 0x805b434 <xQueueReceive+0xd8> @ imm = #0xa
 805b428: e7ff         	b	0x805b42a <xQueueReceive+0xce> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
 805b42a: 4846         	ldr	r0, [pc, #0x118]        @ 0x805b544 <xQueueReceive+0x1e8>
 805b42c: 4780         	blx	r0
 805b42e: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
 805b430: 900b         	str	r0, [sp, #0x2c]
 805b432: e05c         	b	0x805b4ee <xQueueReceive+0x192> @ imm = #0xb8
;                 else if( xEntryTimeSet == pdFALSE )
 805b434: 9807         	ldr	r0, [sp, #0x1c]
 805b436: b930         	cbnz	r0, 0x805b446 <xQueueReceive+0xea> @ imm = #0xc
 805b438: e7ff         	b	0x805b43a <xQueueReceive+0xde> @ imm = #-0x2
;                     vTaskInternalSetTimeOutState( &xTimeOut );
 805b43a: 4932         	ldr	r1, [pc, #0xc8]         @ 0x805b504 <xQueueReceive+0x1a8>
 805b43c: a805         	add	r0, sp, #0x14
 805b43e: 4788         	blx	r1
 805b440: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
 805b442: 9007         	str	r0, [sp, #0x1c]
;                 }
 805b444: e000         	b	0x805b448 <xQueueReceive+0xec> @ imm = #0x0
 805b446: e7ff         	b	0x805b448 <xQueueReceive+0xec> @ imm = #-0x2
 805b448: e7ff         	b	0x805b44a <xQueueReceive+0xee> @ imm = #-0x2
 805b44a: e7ff         	b	0x805b44c <xQueueReceive+0xf0> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 805b44c: 482e         	ldr	r0, [pc, #0xb8]         @ 0x805b508 <xQueueReceive+0x1ac>
 805b44e: 4780         	blx	r0
;         vTaskSuspendAll();
 805b450: 482e         	ldr	r0, [pc, #0xb8]         @ 0x805b50c <xQueueReceive+0x1b0>
 805b452: 4780         	blx	r0
;         prvLockQueue( pxQueue );
 805b454: 482e         	ldr	r0, [pc, #0xb8]         @ 0x805b510 <xQueueReceive+0x1b4>
 805b456: 4780         	blx	r0
 805b458: 9804         	ldr	r0, [sp, #0x10]
 805b45a: f990 0044    	ldrsb.w	r0, [r0, #0x44]
 805b45e: 3001         	adds	r0, #0x1
 805b460: b928         	cbnz	r0, 0x805b46e <xQueueReceive+0x112> @ imm = #0xa
 805b462: e7ff         	b	0x805b464 <xQueueReceive+0x108> @ imm = #-0x2
 805b464: 9904         	ldr	r1, [sp, #0x10]
 805b466: 2000         	movs	r0, #0x0
 805b468: f881 0044    	strb.w	r0, [r1, #0x44]
 805b46c: e7ff         	b	0x805b46e <xQueueReceive+0x112> @ imm = #-0x2
 805b46e: 9804         	ldr	r0, [sp, #0x10]
 805b470: f990 0045    	ldrsb.w	r0, [r0, #0x45]
 805b474: 3001         	adds	r0, #0x1
 805b476: b928         	cbnz	r0, 0x805b484 <xQueueReceive+0x128> @ imm = #0xa
 805b478: e7ff         	b	0x805b47a <xQueueReceive+0x11e> @ imm = #-0x2
 805b47a: 9904         	ldr	r1, [sp, #0x10]
 805b47c: 2000         	movs	r0, #0x0
 805b47e: f881 0045    	strb.w	r0, [r1, #0x45]
 805b482: e7ff         	b	0x805b484 <xQueueReceive+0x128> @ imm = #-0x2
 805b484: 4823         	ldr	r0, [pc, #0x8c]         @ 0x805b514 <xQueueReceive+0x1b8>
 805b486: 4780         	blx	r0
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 805b488: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x805b518 <xQueueReceive+0x1bc>
 805b48a: a805         	add	r0, sp, #0x14
 805b48c: a908         	add	r1, sp, #0x20
 805b48e: 4790         	blx	r2
 805b490: b9e8         	cbnz	r0, 0x805b4ce <xQueueReceive+0x172> @ imm = #0x3a
 805b492: e7ff         	b	0x805b494 <xQueueReceive+0x138> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 805b494: 9804         	ldr	r0, [sp, #0x10]
 805b496: 4924         	ldr	r1, [pc, #0x90]         @ 0x805b528 <xQueueReceive+0x1cc>
 805b498: 4788         	blx	r1
 805b49a: b188         	cbz	r0, 0x805b4c0 <xQueueReceive+0x164> @ imm = #0x22
 805b49c: e7ff         	b	0x805b49e <xQueueReceive+0x142> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 805b49e: 9804         	ldr	r0, [sp, #0x10]
 805b4a0: 3024         	adds	r0, #0x24
 805b4a2: 9908         	ldr	r1, [sp, #0x20]
 805b4a4: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x805b534 <xQueueReceive+0x1d8>
 805b4a6: 4790         	blx	r2
;                 prvUnlockQueue( pxQueue );
 805b4a8: 9804         	ldr	r0, [sp, #0x10]
 805b4aa: 4923         	ldr	r1, [pc, #0x8c]         @ 0x805b538 <xQueueReceive+0x1dc>
 805b4ac: 4788         	blx	r1
;                 if( xTaskResumeAll() == pdFALSE )
 805b4ae: 4823         	ldr	r0, [pc, #0x8c]         @ 0x805b53c <xQueueReceive+0x1e0>
 805b4b0: 4780         	blx	r0
 805b4b2: b918         	cbnz	r0, 0x805b4bc <xQueueReceive+0x160> @ imm = #0x6
 805b4b4: e7ff         	b	0x805b4b6 <xQueueReceive+0x15a> @ imm = #-0x2
;                     taskYIELD_WITHIN_API();
 805b4b6: 4822         	ldr	r0, [pc, #0x88]         @ 0x805b540 <xQueueReceive+0x1e4>
 805b4b8: 4780         	blx	r0
;                 }
 805b4ba: e000         	b	0x805b4be <xQueueReceive+0x162> @ imm = #0x0
 805b4bc: e7ff         	b	0x805b4be <xQueueReceive+0x162> @ imm = #-0x2
;             }
 805b4be: e005         	b	0x805b4cc <xQueueReceive+0x170> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
 805b4c0: 9804         	ldr	r0, [sp, #0x10]
 805b4c2: 491a         	ldr	r1, [pc, #0x68]         @ 0x805b52c <xQueueReceive+0x1d0>
 805b4c4: 4788         	blx	r1
;                 ( void ) xTaskResumeAll();
 805b4c6: 481a         	ldr	r0, [pc, #0x68]         @ 0x805b530 <xQueueReceive+0x1d4>
 805b4c8: 4780         	blx	r0
 805b4ca: e7ff         	b	0x805b4cc <xQueueReceive+0x170> @ imm = #-0x2
;         }
 805b4cc: e00e         	b	0x805b4ec <xQueueReceive+0x190> @ imm = #0x1c
;             prvUnlockQueue( pxQueue );
 805b4ce: 9804         	ldr	r0, [sp, #0x10]
 805b4d0: 4912         	ldr	r1, [pc, #0x48]         @ 0x805b51c <xQueueReceive+0x1c0>
 805b4d2: 4788         	blx	r1
;             ( void ) xTaskResumeAll();
 805b4d4: 4812         	ldr	r0, [pc, #0x48]         @ 0x805b520 <xQueueReceive+0x1c4>
 805b4d6: 4780         	blx	r0
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 805b4d8: 9804         	ldr	r0, [sp, #0x10]
 805b4da: 4912         	ldr	r1, [pc, #0x48]         @ 0x805b524 <xQueueReceive+0x1c8>
 805b4dc: 4788         	blx	r1
 805b4de: b118         	cbz	r0, 0x805b4e8 <xQueueReceive+0x18c> @ imm = #0x6
 805b4e0: e7ff         	b	0x805b4e2 <xQueueReceive+0x186> @ imm = #-0x2
 805b4e2: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
 805b4e4: 900b         	str	r0, [sp, #0x2c]
 805b4e6: e002         	b	0x805b4ee <xQueueReceive+0x192> @ imm = #0x4
 805b4e8: e7ff         	b	0x805b4ea <xQueueReceive+0x18e> @ imm = #-0x2
 805b4ea: e7ff         	b	0x805b4ec <xQueueReceive+0x190> @ imm = #-0x2
;     for( ; ; )
 805b4ec: e775         	b	0x805b3da <xQueueReceive+0x7e> @ imm = #-0x116
; }
 805b4ee: 980b         	ldr	r0, [sp, #0x2c]
 805b4f0: b00c         	add	sp, #0x30
 805b4f2: bc80         	pop	{r7}
 805b4f4: eba8 0809    	sub.w	r8, r8, r9
 805b4f8: f858 fd40    	ldr	pc, [r8, #-64]!

0805b4fc <$d.35>:
 805b4fc: 0d 77 05 08  	.word	0x0805770d
 805b500: 49 cd 05 08  	.word	0x0805cd49
 805b504: 9d 73 05 08  	.word	0x0805739d
 805b508: 7d cd 05 08  	.word	0x0805cd7d
 805b50c: d9 58 05 08  	.word	0x080558d9
 805b510: 49 cd 05 08  	.word	0x0805cd49
 805b514: 7d cd 05 08  	.word	0x0805cd7d
 805b518: c1 73 05 08  	.word	0x080573c1
 805b51c: d1 af 05 08  	.word	0x0805afd1
 805b520: 0d 5a 05 08  	.word	0x08055a0d
 805b524: bd b5 05 08  	.word	0x0805b5bd
 805b528: bd b5 05 08  	.word	0x0805b5bd
 805b52c: d1 af 05 08  	.word	0x0805afd1
 805b530: 0d 5a 05 08  	.word	0x08055a0d
 805b534: 0d 6e 05 08  	.word	0x08056e0d
 805b538: d1 af 05 08  	.word	0x0805afd1
 805b53c: 0d 5a 05 08  	.word	0x08055a0d
 805b540: 2f cd 05 08  	.word	0x0805cd2f
 805b544: 7d cd 05 08  	.word	0x0805cd7d
 805b548: 65 b5 05 08  	.word	0x0805b565
 805b54c: a9 6f 05 08  	.word	0x08056fa9
 805b550: 2f cd 05 08  	.word	0x0805cd2f
 805b554: 7d cd 05 08  	.word	0x0805cd7d
 805b558: 15 d7 05 08  	.word	0x0805d715
 805b55c: 15 d7 05 08  	.word	0x0805d715
 805b560: 15 d7 05 08  	.word	0x0805d715

0805b564 <prvCopyDataFromQueue>:
; {
 805b564: f848 eb5c    	str	lr, [r8], #92
 805b568: eb08 0809    	add.w	r8, r8, r9
 805b56c: b480         	push	{r7}
 805b56e: 466f         	mov	r7, sp
 805b570: b082         	sub	sp, #0x8
 805b572: 9001         	str	r0, [sp, #0x4]
 805b574: 9100         	str	r1, [sp]
;     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 805b576: 9801         	ldr	r0, [sp, #0x4]
 805b578: 6c00         	ldr	r0, [r0, #0x40]
 805b57a: b1b8         	cbz	r0, 0x805b5ac <prvCopyDataFromQueue+0x48> @ imm = #0x2e
 805b57c: e7ff         	b	0x805b57e <prvCopyDataFromQueue+0x1a> @ imm = #-0x2
;         pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 805b57e: 9901         	ldr	r1, [sp, #0x4]
 805b580: 68c8         	ldr	r0, [r1, #0xc]
 805b582: 6c0a         	ldr	r2, [r1, #0x40]
 805b584: 4410         	add	r0, r2
 805b586: 60c8         	str	r0, [r1, #0xc]
;         if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 805b588: 9801         	ldr	r0, [sp, #0x4]
 805b58a: 6881         	ldr	r1, [r0, #0x8]
 805b58c: 68c0         	ldr	r0, [r0, #0xc]
 805b58e: 4288         	cmp	r0, r1
 805b590: d304         	blo	0x805b59c <prvCopyDataFromQueue+0x38> @ imm = #0x8
 805b592: e7ff         	b	0x805b594 <prvCopyDataFromQueue+0x30> @ imm = #-0x2
;             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 805b594: 9901         	ldr	r1, [sp, #0x4]
 805b596: 6808         	ldr	r0, [r1]
 805b598: 60c8         	str	r0, [r1, #0xc]
;         }
 805b59a: e000         	b	0x805b59e <prvCopyDataFromQueue+0x3a> @ imm = #0x0
 805b59c: e7ff         	b	0x805b59e <prvCopyDataFromQueue+0x3a> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 805b59e: 9800         	ldr	r0, [sp]
 805b5a0: 9a01         	ldr	r2, [sp, #0x4]
 805b5a2: 68d1         	ldr	r1, [r2, #0xc]
 805b5a4: 6c12         	ldr	r2, [r2, #0x40]
 805b5a6: 4b04         	ldr	r3, [pc, #0x10]         @ 0x805b5b8 <prvCopyDataFromQueue+0x54>
 805b5a8: 4798         	blx	r3
;     }
 805b5aa: e7ff         	b	0x805b5ac <prvCopyDataFromQueue+0x48> @ imm = #-0x2
; }
 805b5ac: b002         	add	sp, #0x8
 805b5ae: bc80         	pop	{r7}
 805b5b0: eba8 0809    	sub.w	r8, r8, r9
 805b5b4: f858 fd5c    	ldr	pc, [r8, #-92]!

0805b5b8 <$d.37>:
 805b5b8: c1 f8 05 08  	.word	0x0805f8c1

0805b5bc <prvIsQueueEmpty>:
; {
 805b5bc: f848 eb10    	str	lr, [r8], #16
 805b5c0: eb08 0809    	add.w	r8, r8, r9
 805b5c4: b480         	push	{r7}
 805b5c6: 466f         	mov	r7, sp
 805b5c8: b082         	sub	sp, #0x8
 805b5ca: 9001         	str	r0, [sp, #0x4]
;     taskENTER_CRITICAL();
 805b5cc: 480a         	ldr	r0, [pc, #0x28]         @ 0x805b5f8 <prvIsQueueEmpty+0x3c>
 805b5ce: 4780         	blx	r0
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 805b5d0: 9801         	ldr	r0, [sp, #0x4]
 805b5d2: 6b80         	ldr	r0, [r0, #0x38]
 805b5d4: b918         	cbnz	r0, 0x805b5de <prvIsQueueEmpty+0x22> @ imm = #0x6
 805b5d6: e7ff         	b	0x805b5d8 <prvIsQueueEmpty+0x1c> @ imm = #-0x2
 805b5d8: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
 805b5da: 9000         	str	r0, [sp]
;         }
 805b5dc: e002         	b	0x805b5e4 <prvIsQueueEmpty+0x28> @ imm = #0x4
 805b5de: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
 805b5e0: 9000         	str	r0, [sp]
 805b5e2: e7ff         	b	0x805b5e4 <prvIsQueueEmpty+0x28> @ imm = #-0x2
;     taskEXIT_CRITICAL();
 805b5e4: 4805         	ldr	r0, [pc, #0x14]         @ 0x805b5fc <prvIsQueueEmpty+0x40>
 805b5e6: 4780         	blx	r0
;     return xReturn;
 805b5e8: 9800         	ldr	r0, [sp]
 805b5ea: b002         	add	sp, #0x8
 805b5ec: bc80         	pop	{r7}
 805b5ee: eba8 0809    	sub.w	r8, r8, r9
 805b5f2: f858 fd10    	ldr	pc, [r8, #-16]!
 805b5f6: bf00         	nop

0805b5f8 <$d.39>:
 805b5f8: 49 cd 05 08  	.word	0x0805cd49
 805b5fc: 7d cd 05 08  	.word	0x0805cd7d

0805b600 <prvGetDisinheritPriorityAfterTimeout>:
;     {
 805b600: b082         	sub	sp, #0x8
 805b602: 9001         	str	r0, [sp, #0x4]
;         if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 805b604: 9801         	ldr	r0, [sp, #0x4]
 805b606: 6a40         	ldr	r0, [r0, #0x24]
 805b608: b138         	cbz	r0, 0x805b61a <prvGetDisinheritPriorityAfterTimeout+0x1a> @ imm = #0xe
 805b60a: e7ff         	b	0x805b60c <prvGetDisinheritPriorityAfterTimeout+0xc> @ imm = #-0x2
;             uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) ( ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) ) );
 805b60c: 9801         	ldr	r0, [sp, #0x4]
 805b60e: 6b00         	ldr	r0, [r0, #0x30]
 805b610: 6800         	ldr	r0, [r0]
 805b612: f1c0 0010    	rsb.w	r0, r0, #0x10
 805b616: 9000         	str	r0, [sp]
;         }
 805b618: e002         	b	0x805b620 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #0x4
 805b61a: 2000         	movs	r0, #0x0
;             uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 805b61c: 9000         	str	r0, [sp]
 805b61e: e7ff         	b	0x805b620 <prvGetDisinheritPriorityAfterTimeout+0x20> @ imm = #-0x2
;         return uxHighestPriorityOfWaitingTasks;
 805b620: 9800         	ldr	r0, [sp]
 805b622: b002         	add	sp, #0x8
 805b624: 4770         	bx	lr
 805b626: bf00         	nop

0805b628 <xQueuePeek>:
; {
 805b628: f848 eb34    	str	lr, [r8], #52
 805b62c: eb08 0809    	add.w	r8, r8, r9
 805b630: b480         	push	{r7}
 805b632: 466f         	mov	r7, sp
 805b634: b08c         	sub	sp, #0x30
 805b636: 900a         	str	r0, [sp, #0x28]
 805b638: 9109         	str	r1, [sp, #0x24]
 805b63a: 9208         	str	r2, [sp, #0x20]
 805b63c: 2000         	movs	r0, #0x0
;     BaseType_t xEntryTimeSet = pdFALSE;
 805b63e: 9007         	str	r0, [sp, #0x1c]
;     Queue_t * const pxQueue = xQueue;
 805b640: 980a         	ldr	r0, [sp, #0x28]
 805b642: 9003         	str	r0, [sp, #0xc]
;     configASSERT( ( pxQueue ) );
 805b644: 9803         	ldr	r0, [sp, #0xc]
 805b646: b920         	cbnz	r0, 0x805b652 <xQueuePeek+0x2a> @ imm = #0x8
 805b648: e7ff         	b	0x805b64a <xQueuePeek+0x22> @ imm = #-0x2
 805b64a: 4879         	ldr	r0, [pc, #0x1e4]        @ 0x805b830 <xQueuePeek+0x208>
 805b64c: 4780         	blx	r0
 805b64e: e7ff         	b	0x805b650 <xQueuePeek+0x28> @ imm = #-0x2
 805b650: e7fe         	b	0x805b650 <xQueuePeek+0x28> @ imm = #-0x4
;     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 805b652: 9909         	ldr	r1, [sp, #0x24]
 805b654: 2000         	movs	r0, #0x0
 805b656: 9001         	str	r0, [sp, #0x4]
 805b658: b939         	cbnz	r1, 0x805b66a <xQueuePeek+0x42> @ imm = #0xe
 805b65a: e7ff         	b	0x805b65c <xQueuePeek+0x34> @ imm = #-0x2
 805b65c: 9803         	ldr	r0, [sp, #0xc]
 805b65e: 6c00         	ldr	r0, [r0, #0x40]
 805b660: 2800         	cmp	r0, #0x0
 805b662: bf18         	it	ne
 805b664: 2001         	movne	r0, #0x1
 805b666: 9001         	str	r0, [sp, #0x4]
 805b668: e7ff         	b	0x805b66a <xQueuePeek+0x42> @ imm = #-0x2
 805b66a: 9801         	ldr	r0, [sp, #0x4]
;     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 805b66c: 07c0         	lsls	r0, r0, #0x1f
 805b66e: b120         	cbz	r0, 0x805b67a <xQueuePeek+0x52> @ imm = #0x8
 805b670: e7ff         	b	0x805b672 <xQueuePeek+0x4a> @ imm = #-0x2
 805b672: 486e         	ldr	r0, [pc, #0x1b8]        @ 0x805b82c <xQueuePeek+0x204>
 805b674: 4780         	blx	r0
 805b676: e7ff         	b	0x805b678 <xQueuePeek+0x50> @ imm = #-0x2
 805b678: e7fe         	b	0x805b678 <xQueuePeek+0x50> @ imm = #-0x4
;         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 805b67a: 4854         	ldr	r0, [pc, #0x150]        @ 0x805b7cc <xQueuePeek+0x1a4>
 805b67c: 4780         	blx	r0
 805b67e: 4601         	mov	r1, r0
 805b680: 2000         	movs	r0, #0x0
 805b682: 9000         	str	r0, [sp]
 805b684: b931         	cbnz	r1, 0x805b694 <xQueuePeek+0x6c> @ imm = #0xc
 805b686: e7ff         	b	0x805b688 <xQueuePeek+0x60> @ imm = #-0x2
 805b688: 9808         	ldr	r0, [sp, #0x20]
 805b68a: 2800         	cmp	r0, #0x0
 805b68c: bf18         	it	ne
 805b68e: 2001         	movne	r0, #0x1
 805b690: 9000         	str	r0, [sp]
 805b692: e7ff         	b	0x805b694 <xQueuePeek+0x6c> @ imm = #-0x2
 805b694: 9800         	ldr	r0, [sp]
;         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 805b696: 07c0         	lsls	r0, r0, #0x1f
 805b698: b120         	cbz	r0, 0x805b6a4 <xQueuePeek+0x7c> @ imm = #0x8
 805b69a: e7ff         	b	0x805b69c <xQueuePeek+0x74> @ imm = #-0x2
 805b69c: 4862         	ldr	r0, [pc, #0x188]        @ 0x805b828 <xQueuePeek+0x200>
 805b69e: 4780         	blx	r0
 805b6a0: e7ff         	b	0x805b6a2 <xQueuePeek+0x7a> @ imm = #-0x2
 805b6a2: e7fe         	b	0x805b6a2 <xQueuePeek+0x7a> @ imm = #-0x4
;     for( ; ; )
 805b6a4: e7ff         	b	0x805b6a6 <xQueuePeek+0x7e> @ imm = #-0x2
;         taskENTER_CRITICAL();
 805b6a6: 484a         	ldr	r0, [pc, #0x128]        @ 0x805b7d0 <xQueuePeek+0x1a8>
 805b6a8: 4780         	blx	r0
;             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 805b6aa: 9803         	ldr	r0, [sp, #0xc]
 805b6ac: 6b80         	ldr	r0, [r0, #0x38]
 805b6ae: 9002         	str	r0, [sp, #0x8]
;             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 805b6b0: 9802         	ldr	r0, [sp, #0x8]
 805b6b2: b1f8         	cbz	r0, 0x805b6f4 <xQueuePeek+0xcc> @ imm = #0x3e
 805b6b4: e7ff         	b	0x805b6b6 <xQueuePeek+0x8e> @ imm = #-0x2
;                 pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 805b6b6: 9803         	ldr	r0, [sp, #0xc]
 805b6b8: 68c0         	ldr	r0, [r0, #0xc]
 805b6ba: 9004         	str	r0, [sp, #0x10]
;                 prvCopyDataFromQueue( pxQueue, pvBuffer );
 805b6bc: 9803         	ldr	r0, [sp, #0xc]
 805b6be: 9909         	ldr	r1, [sp, #0x24]
 805b6c0: 4a55         	ldr	r2, [pc, #0x154]        @ 0x805b818 <xQueuePeek+0x1f0>
 805b6c2: 4790         	blx	r2
;                 pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 805b6c4: 9804         	ldr	r0, [sp, #0x10]
 805b6c6: 9903         	ldr	r1, [sp, #0xc]
 805b6c8: 60c8         	str	r0, [r1, #0xc]
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 805b6ca: 9803         	ldr	r0, [sp, #0xc]
 805b6cc: 6a40         	ldr	r0, [r0, #0x24]
 805b6ce: b158         	cbz	r0, 0x805b6e8 <xQueuePeek+0xc0> @ imm = #0x16
 805b6d0: e7ff         	b	0x805b6d2 <xQueuePeek+0xaa> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 805b6d2: 9803         	ldr	r0, [sp, #0xc]
 805b6d4: 3024         	adds	r0, #0x24
 805b6d6: 4951         	ldr	r1, [pc, #0x144]        @ 0x805b81c <xQueuePeek+0x1f4>
 805b6d8: 4788         	blx	r1
 805b6da: b118         	cbz	r0, 0x805b6e4 <xQueuePeek+0xbc> @ imm = #0x6
 805b6dc: e7ff         	b	0x805b6de <xQueuePeek+0xb6> @ imm = #-0x2
;                         queueYIELD_IF_USING_PREEMPTION();
 805b6de: 4850         	ldr	r0, [pc, #0x140]        @ 0x805b820 <xQueuePeek+0x1f8>
 805b6e0: 4780         	blx	r0
;                     }
 805b6e2: e000         	b	0x805b6e6 <xQueuePeek+0xbe> @ imm = #0x0
 805b6e4: e7ff         	b	0x805b6e6 <xQueuePeek+0xbe> @ imm = #-0x2
;                 }
 805b6e6: e000         	b	0x805b6ea <xQueuePeek+0xc2> @ imm = #0x0
 805b6e8: e7ff         	b	0x805b6ea <xQueuePeek+0xc2> @ imm = #-0x2
;                 taskEXIT_CRITICAL();
 805b6ea: 484e         	ldr	r0, [pc, #0x138]        @ 0x805b824 <xQueuePeek+0x1fc>
 805b6ec: 4780         	blx	r0
 805b6ee: 2001         	movs	r0, #0x1
;                 return pdPASS;
 805b6f0: 900b         	str	r0, [sp, #0x2c]
 805b6f2: e064         	b	0x805b7be <xQueuePeek+0x196> @ imm = #0xc8
;                 if( xTicksToWait == ( TickType_t ) 0 )
 805b6f4: 9808         	ldr	r0, [sp, #0x20]
 805b6f6: b928         	cbnz	r0, 0x805b704 <xQueuePeek+0xdc> @ imm = #0xa
 805b6f8: e7ff         	b	0x805b6fa <xQueuePeek+0xd2> @ imm = #-0x2
;                     taskEXIT_CRITICAL();
 805b6fa: 4846         	ldr	r0, [pc, #0x118]        @ 0x805b814 <xQueuePeek+0x1ec>
 805b6fc: 4780         	blx	r0
 805b6fe: 2000         	movs	r0, #0x0
;                     return errQUEUE_EMPTY;
 805b700: 900b         	str	r0, [sp, #0x2c]
 805b702: e05c         	b	0x805b7be <xQueuePeek+0x196> @ imm = #0xb8
;                 else if( xEntryTimeSet == pdFALSE )
 805b704: 9807         	ldr	r0, [sp, #0x1c]
 805b706: b930         	cbnz	r0, 0x805b716 <xQueuePeek+0xee> @ imm = #0xc
 805b708: e7ff         	b	0x805b70a <xQueuePeek+0xe2> @ imm = #-0x2
;                     vTaskInternalSetTimeOutState( &xTimeOut );
 805b70a: 4932         	ldr	r1, [pc, #0xc8]         @ 0x805b7d4 <xQueuePeek+0x1ac>
 805b70c: a805         	add	r0, sp, #0x14
 805b70e: 4788         	blx	r1
 805b710: 2001         	movs	r0, #0x1
;                     xEntryTimeSet = pdTRUE;
 805b712: 9007         	str	r0, [sp, #0x1c]
;                 }
 805b714: e000         	b	0x805b718 <xQueuePeek+0xf0> @ imm = #0x0
 805b716: e7ff         	b	0x805b718 <xQueuePeek+0xf0> @ imm = #-0x2
 805b718: e7ff         	b	0x805b71a <xQueuePeek+0xf2> @ imm = #-0x2
 805b71a: e7ff         	b	0x805b71c <xQueuePeek+0xf4> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 805b71c: 482e         	ldr	r0, [pc, #0xb8]         @ 0x805b7d8 <xQueuePeek+0x1b0>
 805b71e: 4780         	blx	r0
;         vTaskSuspendAll();
 805b720: 482e         	ldr	r0, [pc, #0xb8]         @ 0x805b7dc <xQueuePeek+0x1b4>
 805b722: 4780         	blx	r0
;         prvLockQueue( pxQueue );
 805b724: 482e         	ldr	r0, [pc, #0xb8]         @ 0x805b7e0 <xQueuePeek+0x1b8>
 805b726: 4780         	blx	r0
 805b728: 9803         	ldr	r0, [sp, #0xc]
 805b72a: f990 0044    	ldrsb.w	r0, [r0, #0x44]
 805b72e: 3001         	adds	r0, #0x1
 805b730: b928         	cbnz	r0, 0x805b73e <xQueuePeek+0x116> @ imm = #0xa
 805b732: e7ff         	b	0x805b734 <xQueuePeek+0x10c> @ imm = #-0x2
 805b734: 9903         	ldr	r1, [sp, #0xc]
 805b736: 2000         	movs	r0, #0x0
 805b738: f881 0044    	strb.w	r0, [r1, #0x44]
 805b73c: e7ff         	b	0x805b73e <xQueuePeek+0x116> @ imm = #-0x2
 805b73e: 9803         	ldr	r0, [sp, #0xc]
 805b740: f990 0045    	ldrsb.w	r0, [r0, #0x45]
 805b744: 3001         	adds	r0, #0x1
 805b746: b928         	cbnz	r0, 0x805b754 <xQueuePeek+0x12c> @ imm = #0xa
 805b748: e7ff         	b	0x805b74a <xQueuePeek+0x122> @ imm = #-0x2
 805b74a: 9903         	ldr	r1, [sp, #0xc]
 805b74c: 2000         	movs	r0, #0x0
 805b74e: f881 0045    	strb.w	r0, [r1, #0x45]
 805b752: e7ff         	b	0x805b754 <xQueuePeek+0x12c> @ imm = #-0x2
 805b754: 4823         	ldr	r0, [pc, #0x8c]         @ 0x805b7e4 <xQueuePeek+0x1bc>
 805b756: 4780         	blx	r0
;         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 805b758: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x805b7e8 <xQueuePeek+0x1c0>
 805b75a: a805         	add	r0, sp, #0x14
 805b75c: a908         	add	r1, sp, #0x20
 805b75e: 4790         	blx	r2
 805b760: b9e8         	cbnz	r0, 0x805b79e <xQueuePeek+0x176> @ imm = #0x3a
 805b762: e7ff         	b	0x805b764 <xQueuePeek+0x13c> @ imm = #-0x2
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 805b764: 9803         	ldr	r0, [sp, #0xc]
 805b766: 4924         	ldr	r1, [pc, #0x90]         @ 0x805b7f8 <xQueuePeek+0x1d0>
 805b768: 4788         	blx	r1
 805b76a: b188         	cbz	r0, 0x805b790 <xQueuePeek+0x168> @ imm = #0x22
 805b76c: e7ff         	b	0x805b76e <xQueuePeek+0x146> @ imm = #-0x2
;                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 805b76e: 9803         	ldr	r0, [sp, #0xc]
 805b770: 3024         	adds	r0, #0x24
 805b772: 9908         	ldr	r1, [sp, #0x20]
 805b774: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x805b804 <xQueuePeek+0x1dc>
 805b776: 4790         	blx	r2
;                 prvUnlockQueue( pxQueue );
 805b778: 9803         	ldr	r0, [sp, #0xc]
 805b77a: 4923         	ldr	r1, [pc, #0x8c]         @ 0x805b808 <xQueuePeek+0x1e0>
 805b77c: 4788         	blx	r1
;                 if( xTaskResumeAll() == pdFALSE )
 805b77e: 4823         	ldr	r0, [pc, #0x8c]         @ 0x805b80c <xQueuePeek+0x1e4>
 805b780: 4780         	blx	r0
 805b782: b918         	cbnz	r0, 0x805b78c <xQueuePeek+0x164> @ imm = #0x6
 805b784: e7ff         	b	0x805b786 <xQueuePeek+0x15e> @ imm = #-0x2
;                     taskYIELD_WITHIN_API();
 805b786: 4822         	ldr	r0, [pc, #0x88]         @ 0x805b810 <xQueuePeek+0x1e8>
 805b788: 4780         	blx	r0
;                 }
 805b78a: e000         	b	0x805b78e <xQueuePeek+0x166> @ imm = #0x0
 805b78c: e7ff         	b	0x805b78e <xQueuePeek+0x166> @ imm = #-0x2
;             }
 805b78e: e005         	b	0x805b79c <xQueuePeek+0x174> @ imm = #0xa
;                 prvUnlockQueue( pxQueue );
 805b790: 9803         	ldr	r0, [sp, #0xc]
 805b792: 491a         	ldr	r1, [pc, #0x68]         @ 0x805b7fc <xQueuePeek+0x1d4>
 805b794: 4788         	blx	r1
;                 ( void ) xTaskResumeAll();
 805b796: 481a         	ldr	r0, [pc, #0x68]         @ 0x805b800 <xQueuePeek+0x1d8>
 805b798: 4780         	blx	r0
 805b79a: e7ff         	b	0x805b79c <xQueuePeek+0x174> @ imm = #-0x2
;         }
 805b79c: e00e         	b	0x805b7bc <xQueuePeek+0x194> @ imm = #0x1c
;             prvUnlockQueue( pxQueue );
 805b79e: 9803         	ldr	r0, [sp, #0xc]
 805b7a0: 4912         	ldr	r1, [pc, #0x48]         @ 0x805b7ec <xQueuePeek+0x1c4>
 805b7a2: 4788         	blx	r1
;             ( void ) xTaskResumeAll();
 805b7a4: 4812         	ldr	r0, [pc, #0x48]         @ 0x805b7f0 <xQueuePeek+0x1c8>
 805b7a6: 4780         	blx	r0
;             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 805b7a8: 9803         	ldr	r0, [sp, #0xc]
 805b7aa: 4912         	ldr	r1, [pc, #0x48]         @ 0x805b7f4 <xQueuePeek+0x1cc>
 805b7ac: 4788         	blx	r1
 805b7ae: b118         	cbz	r0, 0x805b7b8 <xQueuePeek+0x190> @ imm = #0x6
 805b7b0: e7ff         	b	0x805b7b2 <xQueuePeek+0x18a> @ imm = #-0x2
 805b7b2: 2000         	movs	r0, #0x0
;                 return errQUEUE_EMPTY;
 805b7b4: 900b         	str	r0, [sp, #0x2c]
 805b7b6: e002         	b	0x805b7be <xQueuePeek+0x196> @ imm = #0x4
 805b7b8: e7ff         	b	0x805b7ba <xQueuePeek+0x192> @ imm = #-0x2
 805b7ba: e7ff         	b	0x805b7bc <xQueuePeek+0x194> @ imm = #-0x2
;     for( ; ; )
 805b7bc: e773         	b	0x805b6a6 <xQueuePeek+0x7e> @ imm = #-0x11a
; }
 805b7be: 980b         	ldr	r0, [sp, #0x2c]
 805b7c0: b00c         	add	sp, #0x30
 805b7c2: bc80         	pop	{r7}
 805b7c4: eba8 0809    	sub.w	r8, r8, r9
 805b7c8: f858 fd34    	ldr	pc, [r8, #-52]!

0805b7cc <$d.41>:
 805b7cc: 0d 77 05 08  	.word	0x0805770d
 805b7d0: 49 cd 05 08  	.word	0x0805cd49
 805b7d4: 9d 73 05 08  	.word	0x0805739d
 805b7d8: 7d cd 05 08  	.word	0x0805cd7d
 805b7dc: d9 58 05 08  	.word	0x080558d9
 805b7e0: 49 cd 05 08  	.word	0x0805cd49
 805b7e4: 7d cd 05 08  	.word	0x0805cd7d
 805b7e8: c1 73 05 08  	.word	0x080573c1
 805b7ec: d1 af 05 08  	.word	0x0805afd1
 805b7f0: 0d 5a 05 08  	.word	0x08055a0d
 805b7f4: bd b5 05 08  	.word	0x0805b5bd
 805b7f8: bd b5 05 08  	.word	0x0805b5bd
 805b7fc: d1 af 05 08  	.word	0x0805afd1
 805b800: 0d 5a 05 08  	.word	0x08055a0d
 805b804: 0d 6e 05 08  	.word	0x08056e0d
 805b808: d1 af 05 08  	.word	0x0805afd1
 805b80c: 0d 5a 05 08  	.word	0x08055a0d
 805b810: 2f cd 05 08  	.word	0x0805cd2f
 805b814: 7d cd 05 08  	.word	0x0805cd7d
 805b818: 65 b5 05 08  	.word	0x0805b565
 805b81c: a9 6f 05 08  	.word	0x08056fa9
 805b820: 2f cd 05 08  	.word	0x0805cd2f
 805b824: 7d cd 05 08  	.word	0x0805cd7d
 805b828: 15 d7 05 08  	.word	0x0805d715
 805b82c: 15 d7 05 08  	.word	0x0805d715
 805b830: 15 d7 05 08  	.word	0x0805d715

0805b834 <xQueueReceiveFromISR>:
; {
 805b834: f848 eb48    	str	lr, [r8], #72
 805b838: eb08 0809    	add.w	r8, r8, r9
 805b83c: b480         	push	{r7}
 805b83e: 466f         	mov	r7, sp
 805b840: b08a         	sub	sp, #0x28
 805b842: 9009         	str	r0, [sp, #0x24]
 805b844: 9108         	str	r1, [sp, #0x20]
 805b846: 9207         	str	r2, [sp, #0x1c]
;     Queue_t * const pxQueue = xQueue;
 805b848: 9809         	ldr	r0, [sp, #0x24]
 805b84a: 9004         	str	r0, [sp, #0x10]
;     configASSERT( pxQueue );
 805b84c: 9804         	ldr	r0, [sp, #0x10]
 805b84e: b920         	cbnz	r0, 0x805b85a <xQueueReceiveFromISR+0x26> @ imm = #0x8
 805b850: e7ff         	b	0x805b852 <xQueueReceiveFromISR+0x1e> @ imm = #-0x2
 805b852: 4844         	ldr	r0, [pc, #0x110]        @ 0x805b964 <xQueueReceiveFromISR+0x130>
 805b854: 4780         	blx	r0
 805b856: e7ff         	b	0x805b858 <xQueueReceiveFromISR+0x24> @ imm = #-0x2
 805b858: e7fe         	b	0x805b858 <xQueueReceiveFromISR+0x24> @ imm = #-0x4
;     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 805b85a: 9908         	ldr	r1, [sp, #0x20]
 805b85c: 2000         	movs	r0, #0x0
 805b85e: 9000         	str	r0, [sp]
 805b860: b939         	cbnz	r1, 0x805b872 <xQueueReceiveFromISR+0x3e> @ imm = #0xe
 805b862: e7ff         	b	0x805b864 <xQueueReceiveFromISR+0x30> @ imm = #-0x2
 805b864: 9804         	ldr	r0, [sp, #0x10]
 805b866: 6c00         	ldr	r0, [r0, #0x40]
 805b868: 2800         	cmp	r0, #0x0
 805b86a: bf18         	it	ne
 805b86c: 2001         	movne	r0, #0x1
 805b86e: 9000         	str	r0, [sp]
 805b870: e7ff         	b	0x805b872 <xQueueReceiveFromISR+0x3e> @ imm = #-0x2
 805b872: 9800         	ldr	r0, [sp]
;     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 805b874: 07c0         	lsls	r0, r0, #0x1f
 805b876: b120         	cbz	r0, 0x805b882 <xQueueReceiveFromISR+0x4e> @ imm = #0x8
 805b878: e7ff         	b	0x805b87a <xQueueReceiveFromISR+0x46> @ imm = #-0x2
 805b87a: 4839         	ldr	r0, [pc, #0xe4]         @ 0x805b960 <xQueueReceiveFromISR+0x12c>
 805b87c: 4780         	blx	r0
 805b87e: e7ff         	b	0x805b880 <xQueueReceiveFromISR+0x4c> @ imm = #-0x2
 805b880: e7fe         	b	0x805b880 <xQueueReceiveFromISR+0x4c> @ imm = #-0x4
;     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 805b882: 4830         	ldr	r0, [pc, #0xc0]         @ 0x805b944 <xQueueReceiveFromISR+0x110>
 805b884: 4780         	blx	r0
;     uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
 805b886: 4830         	ldr	r0, [pc, #0xc0]         @ 0x805b948 <xQueueReceiveFromISR+0x114>
 805b888: 4780         	blx	r0
 805b88a: 9005         	str	r0, [sp, #0x14]
;         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 805b88c: 9804         	ldr	r0, [sp, #0x10]
 805b88e: 6b80         	ldr	r0, [r0, #0x38]
 805b890: 9003         	str	r0, [sp, #0xc]
;         if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 805b892: 9803         	ldr	r0, [sp, #0xc]
 805b894: 2800         	cmp	r0, #0x0
 805b896: d048         	beq	0x805b92a <xQueueReceiveFromISR+0xf6> @ imm = #0x90
 805b898: e7ff         	b	0x805b89a <xQueueReceiveFromISR+0x66> @ imm = #-0x2
;             const int8_t cRxLock = pxQueue->cRxLock;
 805b89a: 9804         	ldr	r0, [sp, #0x10]
 805b89c: f890 0044    	ldrb.w	r0, [r0, #0x44]
 805b8a0: f807 0c1d    	strb	r0, [r7, #-29]
;             prvCopyDataFromQueue( pxQueue, pvBuffer );
 805b8a4: 9804         	ldr	r0, [sp, #0x10]
 805b8a6: 9908         	ldr	r1, [sp, #0x20]
 805b8a8: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x805b94c <xQueueReceiveFromISR+0x118>
 805b8aa: 4790         	blx	r2
;             pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting - ( UBaseType_t ) 1 );
 805b8ac: 9803         	ldr	r0, [sp, #0xc]
 805b8ae: 3801         	subs	r0, #0x1
 805b8b0: 9904         	ldr	r1, [sp, #0x10]
 805b8b2: 6388         	str	r0, [r1, #0x38]
;             if( cRxLock == queueUNLOCKED )
 805b8b4: f917 0c1d    	ldrsb	r0, [r7, #-29]
 805b8b8: 3001         	adds	r0, #0x1
 805b8ba: b9b8         	cbnz	r0, 0x805b8ec <xQueueReceiveFromISR+0xb8> @ imm = #0x2e
 805b8bc: e7ff         	b	0x805b8be <xQueueReceiveFromISR+0x8a> @ imm = #-0x2
;                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 805b8be: 9804         	ldr	r0, [sp, #0x10]
 805b8c0: 6900         	ldr	r0, [r0, #0x10]
 805b8c2: b188         	cbz	r0, 0x805b8e8 <xQueueReceiveFromISR+0xb4> @ imm = #0x22
 805b8c4: e7ff         	b	0x805b8c6 <xQueueReceiveFromISR+0x92> @ imm = #-0x2
;                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 805b8c6: 9804         	ldr	r0, [sp, #0x10]
 805b8c8: 3010         	adds	r0, #0x10
 805b8ca: 4923         	ldr	r1, [pc, #0x8c]         @ 0x805b958 <xQueueReceiveFromISR+0x124>
 805b8cc: 4788         	blx	r1
 805b8ce: b148         	cbz	r0, 0x805b8e4 <xQueueReceiveFromISR+0xb0> @ imm = #0x12
 805b8d0: e7ff         	b	0x805b8d2 <xQueueReceiveFromISR+0x9e> @ imm = #-0x2
;                         if( pxHigherPriorityTaskWoken != NULL )
 805b8d2: 9807         	ldr	r0, [sp, #0x1c]
 805b8d4: b120         	cbz	r0, 0x805b8e0 <xQueueReceiveFromISR+0xac> @ imm = #0x8
 805b8d6: e7ff         	b	0x805b8d8 <xQueueReceiveFromISR+0xa4> @ imm = #-0x2
;                             *pxHigherPriorityTaskWoken = pdTRUE;
 805b8d8: 9907         	ldr	r1, [sp, #0x1c]
 805b8da: 2001         	movs	r0, #0x1
 805b8dc: 6008         	str	r0, [r1]
;                         }
 805b8de: e000         	b	0x805b8e2 <xQueueReceiveFromISR+0xae> @ imm = #0x0
 805b8e0: e7ff         	b	0x805b8e2 <xQueueReceiveFromISR+0xae> @ imm = #-0x2
;                     }
 805b8e2: e000         	b	0x805b8e6 <xQueueReceiveFromISR+0xb2> @ imm = #0x0
 805b8e4: e7ff         	b	0x805b8e6 <xQueueReceiveFromISR+0xb2> @ imm = #-0x2
;                 }
 805b8e6: e000         	b	0x805b8ea <xQueueReceiveFromISR+0xb6> @ imm = #0x0
 805b8e8: e7ff         	b	0x805b8ea <xQueueReceiveFromISR+0xb6> @ imm = #-0x2
;             }
 805b8ea: e01b         	b	0x805b924 <xQueueReceiveFromISR+0xf0> @ imm = #0x36
;                 prvIncrementQueueRxLock( pxQueue, cRxLock );
 805b8ec: e7ff         	b	0x805b8ee <xQueueReceiveFromISR+0xba> @ imm = #-0x2
 805b8ee: 4818         	ldr	r0, [pc, #0x60]         @ 0x805b950 <xQueueReceiveFromISR+0x11c>
 805b8f0: 4780         	blx	r0
 805b8f2: 9001         	str	r0, [sp, #0x4]
 805b8f4: f917 0c1d    	ldrsb	r0, [r7, #-29]
 805b8f8: 9901         	ldr	r1, [sp, #0x4]
 805b8fa: 4288         	cmp	r0, r1
 805b8fc: d210         	bhs	0x805b920 <xQueueReceiveFromISR+0xec> @ imm = #0x20
 805b8fe: e7ff         	b	0x805b900 <xQueueReceiveFromISR+0xcc> @ imm = #-0x2
 805b900: f917 0c1d    	ldrsb	r0, [r7, #-29]
 805b904: 287f         	cmp	r0, #0x7f
 805b906: d104         	bne	0x805b912 <xQueueReceiveFromISR+0xde> @ imm = #0x8
 805b908: e7ff         	b	0x805b90a <xQueueReceiveFromISR+0xd6> @ imm = #-0x2
 805b90a: 4812         	ldr	r0, [pc, #0x48]         @ 0x805b954 <xQueueReceiveFromISR+0x120>
 805b90c: 4780         	blx	r0
 805b90e: e7ff         	b	0x805b910 <xQueueReceiveFromISR+0xdc> @ imm = #-0x2
 805b910: e7fe         	b	0x805b910 <xQueueReceiveFromISR+0xdc> @ imm = #-0x4
 805b912: f817 0c1d    	ldrb	r0, [r7, #-29]
 805b916: 3001         	adds	r0, #0x1
 805b918: 9904         	ldr	r1, [sp, #0x10]
 805b91a: f881 0044    	strb.w	r0, [r1, #0x44]
 805b91e: e7ff         	b	0x805b920 <xQueueReceiveFromISR+0xec> @ imm = #-0x2
 805b920: e7ff         	b	0x805b922 <xQueueReceiveFromISR+0xee> @ imm = #-0x2
 805b922: e7ff         	b	0x805b924 <xQueueReceiveFromISR+0xf0> @ imm = #-0x2
 805b924: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
 805b926: 9006         	str	r0, [sp, #0x18]
;         }
 805b928: e002         	b	0x805b930 <xQueueReceiveFromISR+0xfc> @ imm = #0x4
 805b92a: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
 805b92c: 9006         	str	r0, [sp, #0x18]
 805b92e: e7ff         	b	0x805b930 <xQueueReceiveFromISR+0xfc> @ imm = #-0x2
;     taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
 805b930: 9805         	ldr	r0, [sp, #0x14]
 805b932: 490a         	ldr	r1, [pc, #0x28]         @ 0x805b95c <xQueueReceiveFromISR+0x128>
 805b934: 4788         	blx	r1
;     return xReturn;
 805b936: 9806         	ldr	r0, [sp, #0x18]
 805b938: b00a         	add	sp, #0x28
 805b93a: bc80         	pop	{r7}
 805b93c: eba8 0809    	sub.w	r8, r8, r9
 805b940: f858 fd48    	ldr	pc, [r8, #-72]!

0805b944 <$d.43>:
 805b944: 1d f8 05 08  	.word	0x0805f81d
 805b948: 15 d7 05 08  	.word	0x0805d715
 805b94c: 65 b5 05 08  	.word	0x0805b565
 805b950: 3d 6b 05 08  	.word	0x08056b3d
 805b954: 15 d7 05 08  	.word	0x0805d715
 805b958: a9 6f 05 08  	.word	0x08056fa9
 805b95c: 2b d7 05 08  	.word	0x0805d72b
 805b960: 15 d7 05 08  	.word	0x0805d715
 805b964: 15 d7 05 08  	.word	0x0805d715

0805b968 <xQueuePeekFromISR>:
; {
 805b968: f848 eb64    	str	lr, [r8], #100
 805b96c: eb08 0809    	add.w	r8, r8, r9
 805b970: b480         	push	{r7}
 805b972: 466f         	mov	r7, sp
 805b974: b088         	sub	sp, #0x20
 805b976: 9007         	str	r0, [sp, #0x1c]
 805b978: 9106         	str	r1, [sp, #0x18]
;     Queue_t * const pxQueue = xQueue;
 805b97a: 9807         	ldr	r0, [sp, #0x1c]
 805b97c: 9002         	str	r0, [sp, #0x8]
;     configASSERT( pxQueue );
 805b97e: 9802         	ldr	r0, [sp, #0x8]
 805b980: b920         	cbnz	r0, 0x805b98c <xQueuePeekFromISR+0x24> @ imm = #0x8
 805b982: e7ff         	b	0x805b984 <xQueuePeekFromISR+0x1c> @ imm = #-0x2
 805b984: 4827         	ldr	r0, [pc, #0x9c]         @ 0x805ba24 <xQueuePeekFromISR+0xbc>
 805b986: 4780         	blx	r0
 805b988: e7ff         	b	0x805b98a <xQueuePeekFromISR+0x22> @ imm = #-0x2
 805b98a: e7fe         	b	0x805b98a <xQueuePeekFromISR+0x22> @ imm = #-0x4
;     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 805b98c: 9906         	ldr	r1, [sp, #0x18]
 805b98e: 2000         	movs	r0, #0x0
 805b990: 9001         	str	r0, [sp, #0x4]
 805b992: b939         	cbnz	r1, 0x805b9a4 <xQueuePeekFromISR+0x3c> @ imm = #0xe
 805b994: e7ff         	b	0x805b996 <xQueuePeekFromISR+0x2e> @ imm = #-0x2
 805b996: 9802         	ldr	r0, [sp, #0x8]
 805b998: 6c00         	ldr	r0, [r0, #0x40]
 805b99a: 2800         	cmp	r0, #0x0
 805b99c: bf18         	it	ne
 805b99e: 2001         	movne	r0, #0x1
 805b9a0: 9001         	str	r0, [sp, #0x4]
 805b9a2: e7ff         	b	0x805b9a4 <xQueuePeekFromISR+0x3c> @ imm = #-0x2
 805b9a4: 9801         	ldr	r0, [sp, #0x4]
;     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 805b9a6: 07c0         	lsls	r0, r0, #0x1f
 805b9a8: b120         	cbz	r0, 0x805b9b4 <xQueuePeekFromISR+0x4c> @ imm = #0x8
 805b9aa: e7ff         	b	0x805b9ac <xQueuePeekFromISR+0x44> @ imm = #-0x2
 805b9ac: 481c         	ldr	r0, [pc, #0x70]         @ 0x805ba20 <xQueuePeekFromISR+0xb8>
 805b9ae: 4780         	blx	r0
 805b9b0: e7ff         	b	0x805b9b2 <xQueuePeekFromISR+0x4a> @ imm = #-0x2
 805b9b2: e7fe         	b	0x805b9b2 <xQueuePeekFromISR+0x4a> @ imm = #-0x4
;     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 805b9b4: 9802         	ldr	r0, [sp, #0x8]
 805b9b6: 6c00         	ldr	r0, [r0, #0x40]
 805b9b8: b920         	cbnz	r0, 0x805b9c4 <xQueuePeekFromISR+0x5c> @ imm = #0x8
 805b9ba: e7ff         	b	0x805b9bc <xQueuePeekFromISR+0x54> @ imm = #-0x2
 805b9bc: 4817         	ldr	r0, [pc, #0x5c]         @ 0x805ba1c <xQueuePeekFromISR+0xb4>
 805b9be: 4780         	blx	r0
 805b9c0: e7ff         	b	0x805b9c2 <xQueuePeekFromISR+0x5a> @ imm = #-0x2
 805b9c2: e7fe         	b	0x805b9c2 <xQueuePeekFromISR+0x5a> @ imm = #-0x4
;     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 805b9c4: 4811         	ldr	r0, [pc, #0x44]         @ 0x805ba0c <xQueuePeekFromISR+0xa4>
 805b9c6: 4780         	blx	r0
;     uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
 805b9c8: 4811         	ldr	r0, [pc, #0x44]         @ 0x805ba10 <xQueuePeekFromISR+0xa8>
 805b9ca: 4780         	blx	r0
 805b9cc: 9004         	str	r0, [sp, #0x10]
;         if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 805b9ce: 9802         	ldr	r0, [sp, #0x8]
 805b9d0: 6b80         	ldr	r0, [r0, #0x38]
 805b9d2: b168         	cbz	r0, 0x805b9f0 <xQueuePeekFromISR+0x88> @ imm = #0x1a
 805b9d4: e7ff         	b	0x805b9d6 <xQueuePeekFromISR+0x6e> @ imm = #-0x2
;             pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 805b9d6: 9802         	ldr	r0, [sp, #0x8]
 805b9d8: 68c0         	ldr	r0, [r0, #0xc]
 805b9da: 9003         	str	r0, [sp, #0xc]
;             prvCopyDataFromQueue( pxQueue, pvBuffer );
 805b9dc: 9802         	ldr	r0, [sp, #0x8]
 805b9de: 9906         	ldr	r1, [sp, #0x18]
 805b9e0: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x805ba14 <xQueuePeekFromISR+0xac>
 805b9e2: 4790         	blx	r2
;             pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 805b9e4: 9803         	ldr	r0, [sp, #0xc]
 805b9e6: 9902         	ldr	r1, [sp, #0x8]
 805b9e8: 60c8         	str	r0, [r1, #0xc]
 805b9ea: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
 805b9ec: 9005         	str	r0, [sp, #0x14]
;         }
 805b9ee: e002         	b	0x805b9f6 <xQueuePeekFromISR+0x8e> @ imm = #0x4
 805b9f0: 2000         	movs	r0, #0x0
;             xReturn = pdFAIL;
 805b9f2: 9005         	str	r0, [sp, #0x14]
 805b9f4: e7ff         	b	0x805b9f6 <xQueuePeekFromISR+0x8e> @ imm = #-0x2
;     taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
 805b9f6: 9804         	ldr	r0, [sp, #0x10]
 805b9f8: 4907         	ldr	r1, [pc, #0x1c]         @ 0x805ba18 <xQueuePeekFromISR+0xb0>
 805b9fa: 4788         	blx	r1
;     return xReturn;
 805b9fc: 9805         	ldr	r0, [sp, #0x14]
 805b9fe: b008         	add	sp, #0x20
 805ba00: bc80         	pop	{r7}
 805ba02: eba8 0809    	sub.w	r8, r8, r9
 805ba06: f858 fd64    	ldr	pc, [r8, #-100]!
 805ba0a: bf00         	nop

0805ba0c <$d.45>:
 805ba0c: 1d f8 05 08  	.word	0x0805f81d
 805ba10: 15 d7 05 08  	.word	0x0805d715
 805ba14: 65 b5 05 08  	.word	0x0805b565
 805ba18: 2b d7 05 08  	.word	0x0805d72b
 805ba1c: 15 d7 05 08  	.word	0x0805d715
 805ba20: 15 d7 05 08  	.word	0x0805d715
 805ba24: 15 d7 05 08  	.word	0x0805d715

0805ba28 <uxQueueMessagesWaiting>:
; {
 805ba28: f848 eb78    	str	lr, [r8], #120
 805ba2c: eb08 0809    	add.w	r8, r8, r9
 805ba30: b480         	push	{r7}
 805ba32: 466f         	mov	r7, sp
 805ba34: b082         	sub	sp, #0x8
 805ba36: 9001         	str	r0, [sp, #0x4]
;     configASSERT( xQueue );
 805ba38: 9801         	ldr	r0, [sp, #0x4]
 805ba3a: b920         	cbnz	r0, 0x805ba46 <uxQueueMessagesWaiting+0x1e> @ imm = #0x8
 805ba3c: e7ff         	b	0x805ba3e <uxQueueMessagesWaiting+0x16> @ imm = #-0x2
 805ba3e: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805ba6c <uxQueueMessagesWaiting+0x44>
 805ba40: 4780         	blx	r0
 805ba42: e7ff         	b	0x805ba44 <uxQueueMessagesWaiting+0x1c> @ imm = #-0x2
 805ba44: e7fe         	b	0x805ba44 <uxQueueMessagesWaiting+0x1c> @ imm = #-0x4
;     taskENTER_CRITICAL();
 805ba46: 4807         	ldr	r0, [pc, #0x1c]         @ 0x805ba64 <uxQueueMessagesWaiting+0x3c>
 805ba48: 4780         	blx	r0
;         uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 805ba4a: 9801         	ldr	r0, [sp, #0x4]
 805ba4c: 6b80         	ldr	r0, [r0, #0x38]
 805ba4e: 9000         	str	r0, [sp]
;     taskEXIT_CRITICAL();
 805ba50: 4805         	ldr	r0, [pc, #0x14]         @ 0x805ba68 <uxQueueMessagesWaiting+0x40>
 805ba52: 4780         	blx	r0
;     return uxReturn;
 805ba54: 9800         	ldr	r0, [sp]
 805ba56: b002         	add	sp, #0x8
 805ba58: bc80         	pop	{r7}
 805ba5a: eba8 0809    	sub.w	r8, r8, r9
 805ba5e: f858 fd78    	ldr	pc, [r8, #-120]!
 805ba62: bf00         	nop

0805ba64 <$d.47>:
 805ba64: 49 cd 05 08  	.word	0x0805cd49
 805ba68: 7d cd 05 08  	.word	0x0805cd7d
 805ba6c: 15 d7 05 08  	.word	0x0805d715

0805ba70 <uxQueueSpacesAvailable>:
; {
 805ba70: f848 eb64    	str	lr, [r8], #100
 805ba74: eb08 0809    	add.w	r8, r8, r9
 805ba78: b480         	push	{r7}
 805ba7a: 466f         	mov	r7, sp
 805ba7c: b084         	sub	sp, #0x10
 805ba7e: 9003         	str	r0, [sp, #0xc]
;     Queue_t * const pxQueue = xQueue;
 805ba80: 9803         	ldr	r0, [sp, #0xc]
 805ba82: 9001         	str	r0, [sp, #0x4]
;     configASSERT( pxQueue );
 805ba84: 9801         	ldr	r0, [sp, #0x4]
 805ba86: b920         	cbnz	r0, 0x805ba92 <uxQueueSpacesAvailable+0x22> @ imm = #0x8
 805ba88: e7ff         	b	0x805ba8a <uxQueueSpacesAvailable+0x1a> @ imm = #-0x2
 805ba8a: 480c         	ldr	r0, [pc, #0x30]         @ 0x805babc <uxQueueSpacesAvailable+0x4c>
 805ba8c: 4780         	blx	r0
 805ba8e: e7ff         	b	0x805ba90 <uxQueueSpacesAvailable+0x20> @ imm = #-0x2
 805ba90: e7fe         	b	0x805ba90 <uxQueueSpacesAvailable+0x20> @ imm = #-0x4
;     taskENTER_CRITICAL();
 805ba92: 4808         	ldr	r0, [pc, #0x20]         @ 0x805bab4 <uxQueueSpacesAvailable+0x44>
 805ba94: 4780         	blx	r0
;         uxReturn = ( UBaseType_t ) ( pxQueue->uxLength - pxQueue->uxMessagesWaiting );
 805ba96: 9901         	ldr	r1, [sp, #0x4]
 805ba98: 6bc8         	ldr	r0, [r1, #0x3c]
 805ba9a: 6b89         	ldr	r1, [r1, #0x38]
 805ba9c: 1a40         	subs	r0, r0, r1
 805ba9e: 9002         	str	r0, [sp, #0x8]
;     taskEXIT_CRITICAL();
 805baa0: 4805         	ldr	r0, [pc, #0x14]         @ 0x805bab8 <uxQueueSpacesAvailable+0x48>
 805baa2: 4780         	blx	r0
;     return uxReturn;
 805baa4: 9802         	ldr	r0, [sp, #0x8]
 805baa6: b004         	add	sp, #0x10
 805baa8: bc80         	pop	{r7}
 805baaa: eba8 0809    	sub.w	r8, r8, r9
 805baae: f858 fd64    	ldr	pc, [r8, #-100]!
 805bab2: bf00         	nop

0805bab4 <$d.49>:
 805bab4: 49 cd 05 08  	.word	0x0805cd49
 805bab8: 7d cd 05 08  	.word	0x0805cd7d
 805babc: 15 d7 05 08  	.word	0x0805d715

0805bac0 <uxQueueMessagesWaitingFromISR>:
; {
 805bac0: f848 eb54    	str	lr, [r8], #84
 805bac4: eb08 0809    	add.w	r8, r8, r9
 805bac8: b480         	push	{r7}
 805baca: 466f         	mov	r7, sp
 805bacc: b084         	sub	sp, #0x10
 805bace: 9003         	str	r0, [sp, #0xc]
;     Queue_t * const pxQueue = xQueue;
 805bad0: 9803         	ldr	r0, [sp, #0xc]
 805bad2: 9001         	str	r0, [sp, #0x4]
;     configASSERT( pxQueue );
 805bad4: 9801         	ldr	r0, [sp, #0x4]
 805bad6: b920         	cbnz	r0, 0x805bae2 <uxQueueMessagesWaitingFromISR+0x22> @ imm = #0x8
 805bad8: e7ff         	b	0x805bada <uxQueueMessagesWaitingFromISR+0x1a> @ imm = #-0x2
 805bada: 4807         	ldr	r0, [pc, #0x1c]         @ 0x805baf8 <uxQueueMessagesWaitingFromISR+0x38>
 805badc: 4780         	blx	r0
 805bade: e7ff         	b	0x805bae0 <uxQueueMessagesWaitingFromISR+0x20> @ imm = #-0x2
 805bae0: e7fe         	b	0x805bae0 <uxQueueMessagesWaitingFromISR+0x20> @ imm = #-0x4
;     uxReturn = pxQueue->uxMessagesWaiting;
 805bae2: 9801         	ldr	r0, [sp, #0x4]
 805bae4: 6b80         	ldr	r0, [r0, #0x38]
 805bae6: 9002         	str	r0, [sp, #0x8]
;     return uxReturn;
 805bae8: 9802         	ldr	r0, [sp, #0x8]
 805baea: b004         	add	sp, #0x10
 805baec: bc80         	pop	{r7}
 805baee: eba8 0809    	sub.w	r8, r8, r9
 805baf2: f858 fd54    	ldr	pc, [r8, #-84]!
 805baf6: bf00         	nop

0805baf8 <$d.51>:
 805baf8: 15 d7 05 08  	.word	0x0805d715

0805bafc <vQueueDelete>:
; {
 805bafc: f848 eb48    	str	lr, [r8], #72
 805bb00: eb08 0809    	add.w	r8, r8, r9
 805bb04: b480         	push	{r7}
 805bb06: 466f         	mov	r7, sp
 805bb08: b082         	sub	sp, #0x8
 805bb0a: 9001         	str	r0, [sp, #0x4]
;     Queue_t * const pxQueue = xQueue;
 805bb0c: 9801         	ldr	r0, [sp, #0x4]
 805bb0e: 9000         	str	r0, [sp]
;     configASSERT( pxQueue );
 805bb10: 9800         	ldr	r0, [sp]
 805bb12: b920         	cbnz	r0, 0x805bb1e <vQueueDelete+0x22> @ imm = #0x8
 805bb14: e7ff         	b	0x805bb16 <vQueueDelete+0x1a> @ imm = #-0x2
 805bb16: 480a         	ldr	r0, [pc, #0x28]         @ 0x805bb40 <vQueueDelete+0x44>
 805bb18: 4780         	blx	r0
 805bb1a: e7ff         	b	0x805bb1c <vQueueDelete+0x20> @ imm = #-0x2
 805bb1c: e7fe         	b	0x805bb1c <vQueueDelete+0x20> @ imm = #-0x4
;         vQueueUnregisterQueue( pxQueue );
 805bb1e: 9800         	ldr	r0, [sp]
 805bb20: 4905         	ldr	r1, [pc, #0x14]         @ 0x805bb38 <vQueueDelete+0x3c>
 805bb22: 4788         	blx	r1
;         vPortFree( pxQueue );
 805bb24: 9800         	ldr	r0, [sp]
 805bb26: 4905         	ldr	r1, [pc, #0x14]         @ 0x805bb3c <vQueueDelete+0x40>
 805bb28: 4788         	blx	r1
; }
 805bb2a: b002         	add	sp, #0x8
 805bb2c: bc80         	pop	{r7}
 805bb2e: eba8 0809    	sub.w	r8, r8, r9
 805bb32: f858 fd48    	ldr	pc, [r8, #-72]!
 805bb36: bf00         	nop

0805bb38 <$d.53>:
 805bb38: 45 bb 05 08  	.word	0x0805bb45
 805bb3c: 61 9a 05 08  	.word	0x08059a61
 805bb40: 15 d7 05 08  	.word	0x0805d715

0805bb44 <vQueueUnregisterQueue>:
;     {
 805bb44: f848 eb10    	str	lr, [r8], #16
 805bb48: eb08 0809    	add.w	r8, r8, r9
 805bb4c: b480         	push	{r7}
 805bb4e: 466f         	mov	r7, sp
 805bb50: b082         	sub	sp, #0x8
 805bb52: 9001         	str	r0, [sp, #0x4]
;         configASSERT( xQueue );
 805bb54: 9801         	ldr	r0, [sp, #0x4]
 805bb56: b920         	cbnz	r0, 0x805bb62 <vQueueUnregisterQueue+0x1e> @ imm = #0x8
 805bb58: e7ff         	b	0x805bb5a <vQueueUnregisterQueue+0x16> @ imm = #-0x2
 805bb5a: 4818         	ldr	r0, [pc, #0x60]         @ 0x805bbbc <vQueueUnregisterQueue+0x78>
 805bb5c: 4780         	blx	r0
 805bb5e: e7ff         	b	0x805bb60 <vQueueUnregisterQueue+0x1c> @ imm = #-0x2
 805bb60: e7fe         	b	0x805bb60 <vQueueUnregisterQueue+0x1c> @ imm = #-0x4
 805bb62: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 805bb64: 9000         	str	r0, [sp]
 805bb66: e7ff         	b	0x805bb68 <vQueueUnregisterQueue+0x24> @ imm = #-0x2
 805bb68: 9800         	ldr	r0, [sp]
 805bb6a: 2807         	cmp	r0, #0x7
 805bb6c: d81f         	bhi	0x805bbae <vQueueUnregisterQueue+0x6a> @ imm = #0x3e
 805bb6e: e7ff         	b	0x805bb70 <vQueueUnregisterQueue+0x2c> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].xHandle == xQueue )
 805bb70: 9900         	ldr	r1, [sp]
 805bb72: f242 3038    	movw	r0, #0x2338
 805bb76: f2c2 0000    	movt	r0, #0x2000
 805bb7a: eb00 00c1    	add.w	r0, r0, r1, lsl #3
 805bb7e: 6840         	ldr	r0, [r0, #0x4]
 805bb80: 9901         	ldr	r1, [sp, #0x4]
 805bb82: 4288         	cmp	r0, r1
 805bb84: d10d         	bne	0x805bba2 <vQueueUnregisterQueue+0x5e> @ imm = #0x1a
 805bb86: e7ff         	b	0x805bb88 <vQueueUnregisterQueue+0x44> @ imm = #-0x2
;                 xQueueRegistry[ ux ].pcQueueName = NULL;
 805bb88: 9a00         	ldr	r2, [sp]
 805bb8a: f242 3138    	movw	r1, #0x2338
 805bb8e: f2c2 0100    	movt	r1, #0x2000
 805bb92: 2000         	movs	r0, #0x0
 805bb94: f841 0032    	str.w	r0, [r1, r2, lsl #3]
;                 xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 805bb98: 9a00         	ldr	r2, [sp]
 805bb9a: eb01 01c2    	add.w	r1, r1, r2, lsl #3
 805bb9e: 6048         	str	r0, [r1, #0x4]
;                 break;
 805bba0: e005         	b	0x805bbae <vQueueUnregisterQueue+0x6a> @ imm = #0xa
 805bba2: e7ff         	b	0x805bba4 <vQueueUnregisterQueue+0x60> @ imm = #-0x2
;         }
 805bba4: e7ff         	b	0x805bba6 <vQueueUnregisterQueue+0x62> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 805bba6: 9800         	ldr	r0, [sp]
 805bba8: 3001         	adds	r0, #0x1
 805bbaa: 9000         	str	r0, [sp]
 805bbac: e7dc         	b	0x805bb68 <vQueueUnregisterQueue+0x24> @ imm = #-0x48
;     } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 805bbae: b002         	add	sp, #0x8
 805bbb0: bc80         	pop	{r7}
 805bbb2: eba8 0809    	sub.w	r8, r8, r9
 805bbb6: f858 fd10    	ldr	pc, [r8, #-16]!
 805bbba: bf00         	nop

0805bbbc <$d.55>:
 805bbbc: 15 d7 05 08  	.word	0x0805d715

0805bbc0 <uxQueueGetQueueNumber>:
;     {
 805bbc0: b081         	sub	sp, #0x4
 805bbc2: 9000         	str	r0, [sp]
;         return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 805bbc4: 9800         	ldr	r0, [sp]
 805bbc6: 6c80         	ldr	r0, [r0, #0x48]
 805bbc8: b001         	add	sp, #0x4
 805bbca: 4770         	bx	lr

0805bbcc <vQueueSetQueueNumber>:
;     {
 805bbcc: b082         	sub	sp, #0x8
 805bbce: 9001         	str	r0, [sp, #0x4]
 805bbd0: 9100         	str	r1, [sp]
;         ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 805bbd2: 9800         	ldr	r0, [sp]
 805bbd4: 9901         	ldr	r1, [sp, #0x4]
 805bbd6: 6488         	str	r0, [r1, #0x48]
;     }
 805bbd8: b002         	add	sp, #0x8
 805bbda: 4770         	bx	lr

0805bbdc <ucQueueGetQueueType>:
;     {
 805bbdc: b081         	sub	sp, #0x4
 805bbde: 9000         	str	r0, [sp]
;         return ( ( Queue_t * ) xQueue )->ucQueueType;
 805bbe0: 9800         	ldr	r0, [sp]
 805bbe2: f890 004c    	ldrb.w	r0, [r0, #0x4c]
 805bbe6: b001         	add	sp, #0x4
 805bbe8: 4770         	bx	lr

0805bbea <uxQueueGetQueueItemSize>:
; {
 805bbea: b081         	sub	sp, #0x4
 805bbec: 9000         	str	r0, [sp]
;     return ( ( Queue_t * ) xQueue )->uxItemSize;
 805bbee: 9800         	ldr	r0, [sp]
 805bbf0: 6c00         	ldr	r0, [r0, #0x40]
 805bbf2: b001         	add	sp, #0x4
 805bbf4: 4770         	bx	lr

0805bbf6 <uxQueueGetQueueLength>:
; {
 805bbf6: b081         	sub	sp, #0x4
 805bbf8: 9000         	str	r0, [sp]
;     return ( ( Queue_t * ) xQueue )->uxLength;
 805bbfa: 9800         	ldr	r0, [sp]
 805bbfc: 6bc0         	ldr	r0, [r0, #0x3c]
 805bbfe: b001         	add	sp, #0x4
 805bc00: 4770         	bx	lr
 805bc02: bf00         	nop

0805bc04 <xQueueIsQueueEmptyFromISR>:
; {
 805bc04: f848 eb68    	str	lr, [r8], #104
 805bc08: eb08 0809    	add.w	r8, r8, r9
 805bc0c: b480         	push	{r7}
 805bc0e: 466f         	mov	r7, sp
 805bc10: b084         	sub	sp, #0x10
 805bc12: 9003         	str	r0, [sp, #0xc]
;     Queue_t * const pxQueue = xQueue;
 805bc14: 9803         	ldr	r0, [sp, #0xc]
 805bc16: 9001         	str	r0, [sp, #0x4]
;     configASSERT( pxQueue );
 805bc18: 9801         	ldr	r0, [sp, #0x4]
 805bc1a: b920         	cbnz	r0, 0x805bc26 <xQueueIsQueueEmptyFromISR+0x22> @ imm = #0x8
 805bc1c: e7ff         	b	0x805bc1e <xQueueIsQueueEmptyFromISR+0x1a> @ imm = #-0x2
 805bc1e: 480a         	ldr	r0, [pc, #0x28]         @ 0x805bc48 <xQueueIsQueueEmptyFromISR+0x44>
 805bc20: 4780         	blx	r0
 805bc22: e7ff         	b	0x805bc24 <xQueueIsQueueEmptyFromISR+0x20> @ imm = #-0x2
 805bc24: e7fe         	b	0x805bc24 <xQueueIsQueueEmptyFromISR+0x20> @ imm = #-0x4
;     if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 805bc26: 9801         	ldr	r0, [sp, #0x4]
 805bc28: 6b80         	ldr	r0, [r0, #0x38]
 805bc2a: b918         	cbnz	r0, 0x805bc34 <xQueueIsQueueEmptyFromISR+0x30> @ imm = #0x6
 805bc2c: e7ff         	b	0x805bc2e <xQueueIsQueueEmptyFromISR+0x2a> @ imm = #-0x2
 805bc2e: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
 805bc30: 9002         	str	r0, [sp, #0x8]
;     }
 805bc32: e002         	b	0x805bc3a <xQueueIsQueueEmptyFromISR+0x36> @ imm = #0x4
 805bc34: 2000         	movs	r0, #0x0
;         xReturn = pdFALSE;
 805bc36: 9002         	str	r0, [sp, #0x8]
 805bc38: e7ff         	b	0x805bc3a <xQueueIsQueueEmptyFromISR+0x36> @ imm = #-0x2
;     return xReturn;
 805bc3a: 9802         	ldr	r0, [sp, #0x8]
 805bc3c: b004         	add	sp, #0x10
 805bc3e: bc80         	pop	{r7}
 805bc40: eba8 0809    	sub.w	r8, r8, r9
 805bc44: f858 fd68    	ldr	pc, [r8, #-104]!

0805bc48 <$d.57>:
 805bc48: 15 d7 05 08  	.word	0x0805d715

0805bc4c <xQueueIsQueueFullFromISR>:
; {
 805bc4c: f848 eb48    	str	lr, [r8], #72
 805bc50: eb08 0809    	add.w	r8, r8, r9
 805bc54: b480         	push	{r7}
 805bc56: 466f         	mov	r7, sp
 805bc58: b084         	sub	sp, #0x10
 805bc5a: 9003         	str	r0, [sp, #0xc]
;     Queue_t * const pxQueue = xQueue;
 805bc5c: 9803         	ldr	r0, [sp, #0xc]
 805bc5e: 9001         	str	r0, [sp, #0x4]
;     configASSERT( pxQueue );
 805bc60: 9801         	ldr	r0, [sp, #0x4]
 805bc62: b920         	cbnz	r0, 0x805bc6e <xQueueIsQueueFullFromISR+0x22> @ imm = #0x8
 805bc64: e7ff         	b	0x805bc66 <xQueueIsQueueFullFromISR+0x1a> @ imm = #-0x2
 805bc66: 480c         	ldr	r0, [pc, #0x30]         @ 0x805bc98 <xQueueIsQueueFullFromISR+0x4c>
 805bc68: 4780         	blx	r0
 805bc6a: e7ff         	b	0x805bc6c <xQueueIsQueueFullFromISR+0x20> @ imm = #-0x2
 805bc6c: e7fe         	b	0x805bc6c <xQueueIsQueueFullFromISR+0x20> @ imm = #-0x4
;     if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 805bc6e: 9801         	ldr	r0, [sp, #0x4]
 805bc70: 6b80         	ldr	r0, [r0, #0x38]
 805bc72: 9901         	ldr	r1, [sp, #0x4]
 805bc74: 6bc9         	ldr	r1, [r1, #0x3c]
 805bc76: 4288         	cmp	r0, r1
 805bc78: d103         	bne	0x805bc82 <xQueueIsQueueFullFromISR+0x36> @ imm = #0x6
 805bc7a: e7ff         	b	0x805bc7c <xQueueIsQueueFullFromISR+0x30> @ imm = #-0x2
 805bc7c: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
 805bc7e: 9002         	str	r0, [sp, #0x8]
;     }
 805bc80: e002         	b	0x805bc88 <xQueueIsQueueFullFromISR+0x3c> @ imm = #0x4
 805bc82: 2000         	movs	r0, #0x0
;         xReturn = pdFALSE;
 805bc84: 9002         	str	r0, [sp, #0x8]
 805bc86: e7ff         	b	0x805bc88 <xQueueIsQueueFullFromISR+0x3c> @ imm = #-0x2
;     return xReturn;
 805bc88: 9802         	ldr	r0, [sp, #0x8]
 805bc8a: b004         	add	sp, #0x10
 805bc8c: bc80         	pop	{r7}
 805bc8e: eba8 0809    	sub.w	r8, r8, r9
 805bc92: f858 fd48    	ldr	pc, [r8, #-72]!
 805bc96: bf00         	nop

0805bc98 <$d.59>:
 805bc98: 15 d7 05 08  	.word	0x0805d715

0805bc9c <vQueueAddToRegistry>:
;     {
 805bc9c: f848 eb78    	str	lr, [r8], #120
 805bca0: eb08 0809    	add.w	r8, r8, r9
 805bca4: b480         	push	{r7}
 805bca6: 466f         	mov	r7, sp
 805bca8: b084         	sub	sp, #0x10
 805bcaa: 9003         	str	r0, [sp, #0xc]
 805bcac: 9102         	str	r1, [sp, #0x8]
 805bcae: 2000         	movs	r0, #0x0
;         QueueRegistryItem_t * pxEntryToWrite = NULL;
 805bcb0: 9000         	str	r0, [sp]
;         configASSERT( xQueue );
 805bcb2: 9803         	ldr	r0, [sp, #0xc]
 805bcb4: b920         	cbnz	r0, 0x805bcc0 <vQueueAddToRegistry+0x24> @ imm = #0x8
 805bcb6: e7ff         	b	0x805bcb8 <vQueueAddToRegistry+0x1c> @ imm = #-0x2
 805bcb8: 4827         	ldr	r0, [pc, #0x9c]         @ 0x805bd58 <vQueueAddToRegistry+0xbc>
 805bcba: 4780         	blx	r0
 805bcbc: e7ff         	b	0x805bcbe <vQueueAddToRegistry+0x22> @ imm = #-0x2
 805bcbe: e7fe         	b	0x805bcbe <vQueueAddToRegistry+0x22> @ imm = #-0x4
;         if( pcQueueName != NULL )
 805bcc0: 9802         	ldr	r0, [sp, #0x8]
 805bcc2: b3c8         	cbz	r0, 0x805bd38 <vQueueAddToRegistry+0x9c> @ imm = #0x72
 805bcc4: e7ff         	b	0x805bcc6 <vQueueAddToRegistry+0x2a> @ imm = #-0x2
 805bcc6: 2000         	movs	r0, #0x0
;             for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 805bcc8: 9001         	str	r0, [sp, #0x4]
 805bcca: e7ff         	b	0x805bccc <vQueueAddToRegistry+0x30> @ imm = #-0x2
 805bccc: 9801         	ldr	r0, [sp, #0x4]
 805bcce: 2807         	cmp	r0, #0x7
 805bcd0: d831         	bhi	0x805bd36 <vQueueAddToRegistry+0x9a> @ imm = #0x62
 805bcd2: e7ff         	b	0x805bcd4 <vQueueAddToRegistry+0x38> @ imm = #-0x2
;                 if( xQueue == xQueueRegistry[ ux ].xHandle )
 805bcd4: 9803         	ldr	r0, [sp, #0xc]
 805bcd6: 9a01         	ldr	r2, [sp, #0x4]
 805bcd8: f242 3138    	movw	r1, #0x2338
 805bcdc: f2c2 0100    	movt	r1, #0x2000
 805bce0: eb01 01c2    	add.w	r1, r1, r2, lsl #3
 805bce4: 6849         	ldr	r1, [r1, #0x4]
 805bce6: 4288         	cmp	r0, r1
 805bce8: d109         	bne	0x805bcfe <vQueueAddToRegistry+0x62> @ imm = #0x12
 805bcea: e7ff         	b	0x805bcec <vQueueAddToRegistry+0x50> @ imm = #-0x2
;                     pxEntryToWrite = &( xQueueRegistry[ ux ] );
 805bcec: 9901         	ldr	r1, [sp, #0x4]
 805bcee: f242 3038    	movw	r0, #0x2338
 805bcf2: f2c2 0000    	movt	r0, #0x2000
 805bcf6: eb00 00c1    	add.w	r0, r0, r1, lsl #3
 805bcfa: 9000         	str	r0, [sp]
;                     break;
 805bcfc: e01b         	b	0x805bd36 <vQueueAddToRegistry+0x9a> @ imm = #0x36
;                 else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL ) )
 805bcfe: 9800         	ldr	r0, [sp]
 805bd00: b990         	cbnz	r0, 0x805bd28 <vQueueAddToRegistry+0x8c> @ imm = #0x24
 805bd02: e7ff         	b	0x805bd04 <vQueueAddToRegistry+0x68> @ imm = #-0x2
 805bd04: 9901         	ldr	r1, [sp, #0x4]
 805bd06: f242 3038    	movw	r0, #0x2338
 805bd0a: f2c2 0000    	movt	r0, #0x2000
 805bd0e: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
 805bd12: b948         	cbnz	r0, 0x805bd28 <vQueueAddToRegistry+0x8c> @ imm = #0x12
 805bd14: e7ff         	b	0x805bd16 <vQueueAddToRegistry+0x7a> @ imm = #-0x2
;                     pxEntryToWrite = &( xQueueRegistry[ ux ] );
 805bd16: 9901         	ldr	r1, [sp, #0x4]
 805bd18: f242 3038    	movw	r0, #0x2338
 805bd1c: f2c2 0000    	movt	r0, #0x2000
 805bd20: eb00 00c1    	add.w	r0, r0, r1, lsl #3
 805bd24: 9000         	str	r0, [sp]
;                 }
 805bd26: e000         	b	0x805bd2a <vQueueAddToRegistry+0x8e> @ imm = #0x0
 805bd28: e7ff         	b	0x805bd2a <vQueueAddToRegistry+0x8e> @ imm = #-0x2
 805bd2a: e7ff         	b	0x805bd2c <vQueueAddToRegistry+0x90> @ imm = #-0x2
;             }
 805bd2c: e7ff         	b	0x805bd2e <vQueueAddToRegistry+0x92> @ imm = #-0x2
;             for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 805bd2e: 9801         	ldr	r0, [sp, #0x4]
 805bd30: 3001         	adds	r0, #0x1
 805bd32: 9001         	str	r0, [sp, #0x4]
 805bd34: e7ca         	b	0x805bccc <vQueueAddToRegistry+0x30> @ imm = #-0x6c
;         }
 805bd36: e7ff         	b	0x805bd38 <vQueueAddToRegistry+0x9c> @ imm = #-0x2
;         if( pxEntryToWrite != NULL )
 805bd38: 9800         	ldr	r0, [sp]
 805bd3a: b138         	cbz	r0, 0x805bd4c <vQueueAddToRegistry+0xb0> @ imm = #0xe
 805bd3c: e7ff         	b	0x805bd3e <vQueueAddToRegistry+0xa2> @ imm = #-0x2
;             pxEntryToWrite->pcQueueName = pcQueueName;
 805bd3e: 9802         	ldr	r0, [sp, #0x8]
 805bd40: 9900         	ldr	r1, [sp]
 805bd42: 6008         	str	r0, [r1]
;             pxEntryToWrite->xHandle = xQueue;
 805bd44: 9803         	ldr	r0, [sp, #0xc]
 805bd46: 9900         	ldr	r1, [sp]
 805bd48: 6048         	str	r0, [r1, #0x4]
;         }
 805bd4a: e7ff         	b	0x805bd4c <vQueueAddToRegistry+0xb0> @ imm = #-0x2
;     }
 805bd4c: b004         	add	sp, #0x10
 805bd4e: bc80         	pop	{r7}
 805bd50: eba8 0809    	sub.w	r8, r8, r9
 805bd54: f858 fd78    	ldr	pc, [r8, #-120]!

0805bd58 <$d.61>:
 805bd58: 15 d7 05 08  	.word	0x0805d715

0805bd5c <pcQueueGetName>:
;     {
 805bd5c: f848 eb74    	str	lr, [r8], #116
 805bd60: eb08 0809    	add.w	r8, r8, r9
 805bd64: b480         	push	{r7}
 805bd66: 466f         	mov	r7, sp
 805bd68: b084         	sub	sp, #0x10
 805bd6a: 9003         	str	r0, [sp, #0xc]
 805bd6c: 2000         	movs	r0, #0x0
;         const char * pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
 805bd6e: 9001         	str	r0, [sp, #0x4]
;         configASSERT( xQueue );
 805bd70: 9803         	ldr	r0, [sp, #0xc]
 805bd72: b920         	cbnz	r0, 0x805bd7e <pcQueueGetName+0x22> @ imm = #0x8
 805bd74: e7ff         	b	0x805bd76 <pcQueueGetName+0x1a> @ imm = #-0x2
 805bd76: 4816         	ldr	r0, [pc, #0x58]         @ 0x805bdd0 <pcQueueGetName+0x74>
 805bd78: 4780         	blx	r0
 805bd7a: e7ff         	b	0x805bd7c <pcQueueGetName+0x20> @ imm = #-0x2
 805bd7c: e7fe         	b	0x805bd7c <pcQueueGetName+0x20> @ imm = #-0x4
 805bd7e: 2000         	movs	r0, #0x0
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 805bd80: 9002         	str	r0, [sp, #0x8]
 805bd82: e7ff         	b	0x805bd84 <pcQueueGetName+0x28> @ imm = #-0x2
 805bd84: 9802         	ldr	r0, [sp, #0x8]
 805bd86: 2807         	cmp	r0, #0x7
 805bd88: d81b         	bhi	0x805bdc2 <pcQueueGetName+0x66> @ imm = #0x36
 805bd8a: e7ff         	b	0x805bd8c <pcQueueGetName+0x30> @ imm = #-0x2
;             if( xQueueRegistry[ ux ].xHandle == xQueue )
 805bd8c: 9902         	ldr	r1, [sp, #0x8]
 805bd8e: f242 3038    	movw	r0, #0x2338
 805bd92: f2c2 0000    	movt	r0, #0x2000
 805bd96: eb00 00c1    	add.w	r0, r0, r1, lsl #3
 805bd9a: 6840         	ldr	r0, [r0, #0x4]
 805bd9c: 9903         	ldr	r1, [sp, #0xc]
 805bd9e: 4288         	cmp	r0, r1
 805bda0: d109         	bne	0x805bdb6 <pcQueueGetName+0x5a> @ imm = #0x12
 805bda2: e7ff         	b	0x805bda4 <pcQueueGetName+0x48> @ imm = #-0x2
;                 pcReturn = xQueueRegistry[ ux ].pcQueueName;
 805bda4: 9902         	ldr	r1, [sp, #0x8]
 805bda6: f242 3038    	movw	r0, #0x2338
 805bdaa: f2c2 0000    	movt	r0, #0x2000
 805bdae: f850 0031    	ldr.w	r0, [r0, r1, lsl #3]
 805bdb2: 9001         	str	r0, [sp, #0x4]
;                 break;
 805bdb4: e005         	b	0x805bdc2 <pcQueueGetName+0x66> @ imm = #0xa
 805bdb6: e7ff         	b	0x805bdb8 <pcQueueGetName+0x5c> @ imm = #-0x2
;         }
 805bdb8: e7ff         	b	0x805bdba <pcQueueGetName+0x5e> @ imm = #-0x2
;         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 805bdba: 9802         	ldr	r0, [sp, #0x8]
 805bdbc: 3001         	adds	r0, #0x1
 805bdbe: 9002         	str	r0, [sp, #0x8]
 805bdc0: e7e0         	b	0x805bd84 <pcQueueGetName+0x28> @ imm = #-0x40
;         return pcReturn;
 805bdc2: 9801         	ldr	r0, [sp, #0x4]
 805bdc4: b004         	add	sp, #0x10
 805bdc6: bc80         	pop	{r7}
 805bdc8: eba8 0809    	sub.w	r8, r8, r9
 805bdcc: f858 fd74    	ldr	pc, [r8, #-116]!

0805bdd0 <$d.63>:
 805bdd0: 15 d7 05 08  	.word	0x0805d715

0805bdd4 <vQueueWaitForMessageRestricted>:
;     {
 805bdd4: f848 eb50    	str	lr, [r8], #80
 805bdd8: eb08 0809    	add.w	r8, r8, r9
 805bddc: b480         	push	{r7}
 805bdde: 466f         	mov	r7, sp
 805bde0: b084         	sub	sp, #0x10
 805bde2: 9003         	str	r0, [sp, #0xc]
 805bde4: 9102         	str	r1, [sp, #0x8]
 805bde6: 9201         	str	r2, [sp, #0x4]
;         Queue_t * const pxQueue = xQueue;
 805bde8: 9803         	ldr	r0, [sp, #0xc]
 805bdea: 9000         	str	r0, [sp]
;         prvLockQueue( pxQueue );
 805bdec: 4817         	ldr	r0, [pc, #0x5c]         @ 0x805be4c <vQueueWaitForMessageRestricted+0x78>
 805bdee: 4780         	blx	r0
 805bdf0: 9800         	ldr	r0, [sp]
 805bdf2: f990 0044    	ldrsb.w	r0, [r0, #0x44]
 805bdf6: 3001         	adds	r0, #0x1
 805bdf8: b928         	cbnz	r0, 0x805be06 <vQueueWaitForMessageRestricted+0x32> @ imm = #0xa
 805bdfa: e7ff         	b	0x805bdfc <vQueueWaitForMessageRestricted+0x28> @ imm = #-0x2
 805bdfc: 9900         	ldr	r1, [sp]
 805bdfe: 2000         	movs	r0, #0x0
 805be00: f881 0044    	strb.w	r0, [r1, #0x44]
 805be04: e7ff         	b	0x805be06 <vQueueWaitForMessageRestricted+0x32> @ imm = #-0x2
 805be06: 9800         	ldr	r0, [sp]
 805be08: f990 0045    	ldrsb.w	r0, [r0, #0x45]
 805be0c: 3001         	adds	r0, #0x1
 805be0e: b928         	cbnz	r0, 0x805be1c <vQueueWaitForMessageRestricted+0x48> @ imm = #0xa
 805be10: e7ff         	b	0x805be12 <vQueueWaitForMessageRestricted+0x3e> @ imm = #-0x2
 805be12: 9900         	ldr	r1, [sp]
 805be14: 2000         	movs	r0, #0x0
 805be16: f881 0045    	strb.w	r0, [r1, #0x45]
 805be1a: e7ff         	b	0x805be1c <vQueueWaitForMessageRestricted+0x48> @ imm = #-0x2
 805be1c: 480c         	ldr	r0, [pc, #0x30]         @ 0x805be50 <vQueueWaitForMessageRestricted+0x7c>
 805be1e: 4780         	blx	r0
;         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 805be20: 9800         	ldr	r0, [sp]
 805be22: 6b80         	ldr	r0, [r0, #0x38]
 805be24: b938         	cbnz	r0, 0x805be36 <vQueueWaitForMessageRestricted+0x62> @ imm = #0xe
 805be26: e7ff         	b	0x805be28 <vQueueWaitForMessageRestricted+0x54> @ imm = #-0x2
;             vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 805be28: 9800         	ldr	r0, [sp]
 805be2a: 3024         	adds	r0, #0x24
 805be2c: 9902         	ldr	r1, [sp, #0x8]
 805be2e: 9a01         	ldr	r2, [sp, #0x4]
 805be30: 4b08         	ldr	r3, [pc, #0x20]         @ 0x805be54 <vQueueWaitForMessageRestricted+0x80>
 805be32: 4798         	blx	r3
;         }
 805be34: e000         	b	0x805be38 <vQueueWaitForMessageRestricted+0x64> @ imm = #0x0
 805be36: e7ff         	b	0x805be38 <vQueueWaitForMessageRestricted+0x64> @ imm = #-0x2
;         prvUnlockQueue( pxQueue );
 805be38: 9800         	ldr	r0, [sp]
 805be3a: 4907         	ldr	r1, [pc, #0x1c]         @ 0x805be58 <vQueueWaitForMessageRestricted+0x84>
 805be3c: 4788         	blx	r1
;     }
 805be3e: b004         	add	sp, #0x10
 805be40: bc80         	pop	{r7}
 805be42: eba8 0809    	sub.w	r8, r8, r9
 805be46: f858 fd50    	ldr	pc, [r8, #-80]!
 805be4a: bf00         	nop

0805be4c <$d.65>:
 805be4c: 49 cd 05 08  	.word	0x0805cd49
 805be50: 7d cd 05 08  	.word	0x0805cd7d
 805be54: 15 6f 05 08  	.word	0x08056f15
 805be58: d1 af 05 08  	.word	0x0805afd1

0805be5c <xStreamBufferGenericCreate>:
;     {
 805be5c: f848 eb20    	str	lr, [r8], #32
 805be60: eb08 0809    	add.w	r8, r8, r9
 805be64: b4b0         	push	{r4, r5, r7}
 805be66: af02         	add	r7, sp, #0x8
 805be68: b08a         	sub	sp, #0x28
 805be6a: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805be6e: 9009         	str	r0, [sp, #0x24]
 805be70: 9108         	str	r1, [sp, #0x20]
 805be72: 9207         	str	r2, [sp, #0x1c]
 805be74: 9306         	str	r3, [sp, #0x18]
;         if( xIsMessageBuffer == pdTRUE )
 805be76: 9807         	ldr	r0, [sp, #0x1c]
 805be78: 2801         	cmp	r0, #0x1
 805be7a: d10c         	bne	0x805be96 <xStreamBufferGenericCreate+0x3a> @ imm = #0x18
 805be7c: e7ff         	b	0x805be7e <xStreamBufferGenericCreate+0x22> @ imm = #-0x2
 805be7e: 2001         	movs	r0, #0x1
;             ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
 805be80: f807 0c1d    	strb	r0, [r7, #-29]
;             configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
 805be84: 9809         	ldr	r0, [sp, #0x24]
 805be86: 2804         	cmp	r0, #0x4
 805be88: d804         	bhi	0x805be94 <xStreamBufferGenericCreate+0x38> @ imm = #0x8
 805be8a: e7ff         	b	0x805be8c <xStreamBufferGenericCreate+0x30> @ imm = #-0x2
 805be8c: 482b         	ldr	r0, [pc, #0xac]         @ 0x805bf3c <xStreamBufferGenericCreate+0xe0>
 805be8e: 4780         	blx	r0
 805be90: e7ff         	b	0x805be92 <xStreamBufferGenericCreate+0x36> @ imm = #-0x2
 805be92: e7fe         	b	0x805be92 <xStreamBufferGenericCreate+0x36> @ imm = #-0x4
;         }
 805be94: e00a         	b	0x805beac <xStreamBufferGenericCreate+0x50> @ imm = #0x14
 805be96: 2000         	movs	r0, #0x0
;             ucFlags = 0;
 805be98: f807 0c1d    	strb	r0, [r7, #-29]
;             configASSERT( xBufferSizeBytes > 0 );
 805be9c: 9809         	ldr	r0, [sp, #0x24]
 805be9e: b920         	cbnz	r0, 0x805beaa <xStreamBufferGenericCreate+0x4e> @ imm = #0x8
 805bea0: e7ff         	b	0x805bea2 <xStreamBufferGenericCreate+0x46> @ imm = #-0x2
 805bea2: 4822         	ldr	r0, [pc, #0x88]         @ 0x805bf2c <xStreamBufferGenericCreate+0xd0>
 805bea4: 4780         	blx	r0
 805bea6: e7ff         	b	0x805bea8 <xStreamBufferGenericCreate+0x4c> @ imm = #-0x2
 805bea8: e7fe         	b	0x805bea8 <xStreamBufferGenericCreate+0x4c> @ imm = #-0x4
 805beaa: e7ff         	b	0x805beac <xStreamBufferGenericCreate+0x50> @ imm = #-0x2
;         configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
 805beac: 9808         	ldr	r0, [sp, #0x20]
 805beae: 9909         	ldr	r1, [sp, #0x24]
 805beb0: 4288         	cmp	r0, r1
 805beb2: d904         	bls	0x805bebe <xStreamBufferGenericCreate+0x62> @ imm = #0x8
 805beb4: e7ff         	b	0x805beb6 <xStreamBufferGenericCreate+0x5a> @ imm = #-0x2
 805beb6: 4820         	ldr	r0, [pc, #0x80]         @ 0x805bf38 <xStreamBufferGenericCreate+0xdc>
 805beb8: 4780         	blx	r0
 805beba: e7ff         	b	0x805bebc <xStreamBufferGenericCreate+0x60> @ imm = #-0x2
 805bebc: e7fe         	b	0x805bebc <xStreamBufferGenericCreate+0x60> @ imm = #-0x4
;         if( xTriggerLevelBytes == ( size_t ) 0 )
 805bebe: 9808         	ldr	r0, [sp, #0x20]
 805bec0: b918         	cbnz	r0, 0x805beca <xStreamBufferGenericCreate+0x6e> @ imm = #0x6
 805bec2: e7ff         	b	0x805bec4 <xStreamBufferGenericCreate+0x68> @ imm = #-0x2
 805bec4: 2001         	movs	r0, #0x1
;             xTriggerLevelBytes = ( size_t ) 1;
 805bec6: 9008         	str	r0, [sp, #0x20]
;         }
 805bec8: e7ff         	b	0x805beca <xStreamBufferGenericCreate+0x6e> @ imm = #-0x2
;         if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
 805beca: 9809         	ldr	r0, [sp, #0x24]
 805becc: f100 0125    	add.w	r1, r0, #0x25
 805bed0: 4288         	cmp	r0, r1
 805bed2: d209         	bhs	0x805bee8 <xStreamBufferGenericCreate+0x8c> @ imm = #0x12
 805bed4: e7ff         	b	0x805bed6 <xStreamBufferGenericCreate+0x7a> @ imm = #-0x2
;             xBufferSizeBytes++;
 805bed6: 9809         	ldr	r0, [sp, #0x24]
 805bed8: 3001         	adds	r0, #0x1
 805beda: 9009         	str	r0, [sp, #0x24]
;             pvAllocatedMemory = pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) );
 805bedc: 9809         	ldr	r0, [sp, #0x24]
 805bede: 3024         	adds	r0, #0x24
 805bee0: 4913         	ldr	r1, [pc, #0x4c]         @ 0x805bf30 <xStreamBufferGenericCreate+0xd4>
 805bee2: 4788         	blx	r1
 805bee4: 9005         	str	r0, [sp, #0x14]
;         }
 805bee6: e002         	b	0x805beee <xStreamBufferGenericCreate+0x92> @ imm = #0x4
 805bee8: 2000         	movs	r0, #0x0
;             pvAllocatedMemory = NULL;
 805beea: 9005         	str	r0, [sp, #0x14]
 805beec: e7ff         	b	0x805beee <xStreamBufferGenericCreate+0x92> @ imm = #-0x2
;         if( pvAllocatedMemory != NULL )
 805beee: 9805         	ldr	r0, [sp, #0x14]
 805bef0: b1a0         	cbz	r0, 0x805bf1c <xStreamBufferGenericCreate+0xc0> @ imm = #0x28
 805bef2: e7ff         	b	0x805bef4 <xStreamBufferGenericCreate+0x98> @ imm = #-0x2
;             prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pvAllocatedMemory,                         /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
 805bef4: 9805         	ldr	r0, [sp, #0x14]
;                                           ( ( uint8_t * ) pvAllocatedMemory ) + sizeof( StreamBuffer_t ), /* Storage area follows. */ /*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */
 805bef6: f100 0124    	add.w	r1, r0, #0x24
;                                           xBufferSizeBytes,
 805befa: 9a09         	ldr	r2, [sp, #0x24]
;                                           xTriggerLevelBytes,
 805befc: 9b08         	ldr	r3, [sp, #0x20]
;                                           ucFlags,
 805befe: f817 cc1d    	ldrb	r12, [r7, #-29]
;                                           pxSendCompletedCallback,
 805bf02: 9c06         	ldr	r4, [sp, #0x18]
;                                           pxReceiveCompletedCallback );
 805bf04: 68bd         	ldr	r5, [r7, #0x8]
;             prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pvAllocatedMemory,                         /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
 805bf06: 46ee         	mov	lr, sp
 805bf08: f8ce 5008    	str.w	r5, [lr, #0x8]
 805bf0c: f8ce 4004    	str.w	r4, [lr, #0x4]
 805bf10: f8ce c000    	str.w	r12, [lr]
 805bf14: f8df c01c    	ldr.w	r12, [pc, #0x1c]        @ 0x805bf34 <xStreamBufferGenericCreate+0xd8>
 805bf18: 47e0         	blx	r12
;         }
 805bf1a: e000         	b	0x805bf1e <xStreamBufferGenericCreate+0xc2> @ imm = #0x0
 805bf1c: e7ff         	b	0x805bf1e <xStreamBufferGenericCreate+0xc2> @ imm = #-0x2
;         return ( StreamBufferHandle_t ) pvAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
 805bf1e: 9805         	ldr	r0, [sp, #0x14]
 805bf20: b00a         	add	sp, #0x28
 805bf22: bcb0         	pop	{r4, r5, r7}
 805bf24: eba8 0809    	sub.w	r8, r8, r9
 805bf28: f858 fd20    	ldr	pc, [r8, #-32]!

0805bf2c <$d.1>:
 805bf2c: 15 d7 05 08  	.word	0x0805d715
 805bf30: cd 96 05 08  	.word	0x080596cd
 805bf34: 41 bf 05 08  	.word	0x0805bf41
 805bf38: 15 d7 05 08  	.word	0x0805d715
 805bf3c: 15 d7 05 08  	.word	0x0805d715

0805bf40 <prvInitialiseNewStreamBuffer>:
; {
 805bf40: f848 eb04    	str	lr, [r8], #4
 805bf44: eb08 0809    	add.w	r8, r8, r9
 805bf48: b480         	push	{r7}
 805bf4a: 466f         	mov	r7, sp
 805bf4c: b086         	sub	sp, #0x18
 805bf4e: 4684         	mov	r12, r0
 805bf50: 6938         	ldr	r0, [r7, #0x10]
 805bf52: 68f8         	ldr	r0, [r7, #0xc]
 805bf54: 68b8         	ldr	r0, [r7, #0x8]
 805bf56: f8cd c014    	str.w	r12, [sp, #0x14]
 805bf5a: 9104         	str	r1, [sp, #0x10]
 805bf5c: 9203         	str	r2, [sp, #0xc]
 805bf5e: 9302         	str	r3, [sp, #0x8]
 805bf60: f807 0c11    	strb	r0, [r7, #-17]
;         configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );
 805bf64: 9804         	ldr	r0, [sp, #0x10]
 805bf66: 9a03         	ldr	r2, [sp, #0xc]
 805bf68: 4b11         	ldr	r3, [pc, #0x44]         @ 0x805bfb0 <prvInitialiseNewStreamBuffer+0x70>
 805bf6a: 2155         	movs	r1, #0x55
 805bf6c: 4798         	blx	r3
 805bf6e: 9904         	ldr	r1, [sp, #0x10]
 805bf70: 4288         	cmp	r0, r1
 805bf72: d004         	beq	0x805bf7e <prvInitialiseNewStreamBuffer+0x3e> @ imm = #0x8
 805bf74: e7ff         	b	0x805bf76 <prvInitialiseNewStreamBuffer+0x36> @ imm = #-0x2
 805bf76: 4810         	ldr	r0, [pc, #0x40]         @ 0x805bfb8 <prvInitialiseNewStreamBuffer+0x78>
 805bf78: 4780         	blx	r0
 805bf7a: e7ff         	b	0x805bf7c <prvInitialiseNewStreamBuffer+0x3c> @ imm = #-0x2
 805bf7c: e7fe         	b	0x805bf7c <prvInitialiseNewStreamBuffer+0x3c> @ imm = #-0x4
;     ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
 805bf7e: 9805         	ldr	r0, [sp, #0x14]
 805bf80: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x805bfb4 <prvInitialiseNewStreamBuffer+0x74>
 805bf82: 2100         	movs	r1, #0x0
 805bf84: 2224         	movs	r2, #0x24
 805bf86: 4798         	blx	r3
;     pxStreamBuffer->pucBuffer = pucBuffer;
 805bf88: 9804         	ldr	r0, [sp, #0x10]
 805bf8a: 9905         	ldr	r1, [sp, #0x14]
 805bf8c: 6188         	str	r0, [r1, #0x18]
;     pxStreamBuffer->xLength = xBufferSizeBytes;
 805bf8e: 9803         	ldr	r0, [sp, #0xc]
 805bf90: 9905         	ldr	r1, [sp, #0x14]
 805bf92: 6088         	str	r0, [r1, #0x8]
;     pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 805bf94: 9802         	ldr	r0, [sp, #0x8]
 805bf96: 9905         	ldr	r1, [sp, #0x14]
 805bf98: 60c8         	str	r0, [r1, #0xc]
;     pxStreamBuffer->ucFlags = ucFlags;
 805bf9a: f817 0c11    	ldrb	r0, [r7, #-17]
 805bf9e: 9905         	ldr	r1, [sp, #0x14]
 805bfa0: 7708         	strb	r0, [r1, #0x1c]
; }
 805bfa2: b006         	add	sp, #0x18
 805bfa4: bc80         	pop	{r7}
 805bfa6: eba8 0809    	sub.w	r8, r8, r9
 805bfaa: f858 fd04    	ldr	pc, [r8, #-4]!
 805bfae: bf00         	nop

0805bfb0 <$d.3>:
 805bfb0: ad f9 05 08  	.word	0x0805f9ad
 805bfb4: ad f9 05 08  	.word	0x0805f9ad
 805bfb8: 15 d7 05 08  	.word	0x0805d715

0805bfbc <vStreamBufferDelete>:
; {
 805bfbc: f848 eb14    	str	lr, [r8], #20
 805bfc0: eb08 0809    	add.w	r8, r8, r9
 805bfc4: b480         	push	{r7}
 805bfc6: 466f         	mov	r7, sp
 805bfc8: b082         	sub	sp, #0x8
 805bfca: 9001         	str	r0, [sp, #0x4]
;     StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
 805bfcc: 9801         	ldr	r0, [sp, #0x4]
 805bfce: 9000         	str	r0, [sp]
;     configASSERT( pxStreamBuffer );
 805bfd0: 9800         	ldr	r0, [sp]
 805bfd2: b920         	cbnz	r0, 0x805bfde <vStreamBufferDelete+0x22> @ imm = #0x8
 805bfd4: e7ff         	b	0x805bfd6 <vStreamBufferDelete+0x1a> @ imm = #-0x2
 805bfd6: 480f         	ldr	r0, [pc, #0x3c]         @ 0x805c014 <vStreamBufferDelete+0x58>
 805bfd8: 4780         	blx	r0
 805bfda: e7ff         	b	0x805bfdc <vStreamBufferDelete+0x20> @ imm = #-0x2
 805bfdc: e7fe         	b	0x805bfdc <vStreamBufferDelete+0x20> @ imm = #-0x4
;     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
 805bfde: 9800         	ldr	r0, [sp]
 805bfe0: 7f00         	ldrb	r0, [r0, #0x1c]
 805bfe2: 0780         	lsls	r0, r0, #0x1e
 805bfe4: 2800         	cmp	r0, #0x0
 805bfe6: d404         	bmi	0x805bff2 <vStreamBufferDelete+0x36> @ imm = #0x8
 805bfe8: e7ff         	b	0x805bfea <vStreamBufferDelete+0x2e> @ imm = #-0x2
;             vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
 805bfea: 9800         	ldr	r0, [sp]
 805bfec: 4908         	ldr	r1, [pc, #0x20]         @ 0x805c010 <vStreamBufferDelete+0x54>
 805bfee: 4788         	blx	r1
;     }
 805bff0: e005         	b	0x805bffe <vStreamBufferDelete+0x42> @ imm = #0xa
;         ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 805bff2: 9800         	ldr	r0, [sp]
 805bff4: 4b05         	ldr	r3, [pc, #0x14]         @ 0x805c00c <vStreamBufferDelete+0x50>
 805bff6: 2100         	movs	r1, #0x0
 805bff8: 2224         	movs	r2, #0x24
 805bffa: 4798         	blx	r3
 805bffc: e7ff         	b	0x805bffe <vStreamBufferDelete+0x42> @ imm = #-0x2
; }
 805bffe: b002         	add	sp, #0x8
 805c000: bc80         	pop	{r7}
 805c002: eba8 0809    	sub.w	r8, r8, r9
 805c006: f858 fd14    	ldr	pc, [r8, #-20]!
 805c00a: bf00         	nop

0805c00c <$d.5>:
 805c00c: ad f9 05 08  	.word	0x0805f9ad
 805c010: 61 9a 05 08  	.word	0x08059a61
 805c014: 15 d7 05 08  	.word	0x0805d715

0805c018 <xStreamBufferReset>:
; {
 805c018: f848 eb2c    	str	lr, [r8], #44
 805c01c: eb08 0809    	add.w	r8, r8, r9
 805c020: b4b0         	push	{r4, r5, r7}
 805c022: af02         	add	r7, sp, #0x8
 805c024: b08a         	sub	sp, #0x28
 805c026: 9009         	str	r0, [sp, #0x24]
;     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 805c028: 9809         	ldr	r0, [sp, #0x24]
 805c02a: 9008         	str	r0, [sp, #0x20]
 805c02c: 2000         	movs	r0, #0x0
;     BaseType_t xReturn = pdFAIL;
 805c02e: 9007         	str	r0, [sp, #0x1c]
;     StreamBufferCallbackFunction_t pxSendCallback = NULL, pxReceiveCallback = NULL;
 805c030: 9006         	str	r0, [sp, #0x18]
 805c032: 9005         	str	r0, [sp, #0x14]
;     configASSERT( pxStreamBuffer );
 805c034: 9808         	ldr	r0, [sp, #0x20]
 805c036: b920         	cbnz	r0, 0x805c042 <xStreamBufferReset+0x2a> @ imm = #0x8
 805c038: e7ff         	b	0x805c03a <xStreamBufferReset+0x22> @ imm = #-0x2
 805c03a: 481c         	ldr	r0, [pc, #0x70]         @ 0x805c0ac <xStreamBufferReset+0x94>
 805c03c: 4780         	blx	r0
 805c03e: e7ff         	b	0x805c040 <xStreamBufferReset+0x28> @ imm = #-0x2
 805c040: e7fe         	b	0x805c040 <xStreamBufferReset+0x28> @ imm = #-0x4
;         uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
 805c042: 9808         	ldr	r0, [sp, #0x20]
 805c044: 6a00         	ldr	r0, [r0, #0x20]
 805c046: 9004         	str	r0, [sp, #0x10]
;     taskENTER_CRITICAL();
 805c048: 4815         	ldr	r0, [pc, #0x54]         @ 0x805c0a0 <xStreamBufferReset+0x88>
 805c04a: 4780         	blx	r0
;         if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
 805c04c: 9808         	ldr	r0, [sp, #0x20]
 805c04e: 6900         	ldr	r0, [r0, #0x10]
 805c050: b9e0         	cbnz	r0, 0x805c08c <xStreamBufferReset+0x74> @ imm = #0x38
 805c052: e7ff         	b	0x805c054 <xStreamBufferReset+0x3c> @ imm = #-0x2
 805c054: 9808         	ldr	r0, [sp, #0x20]
 805c056: 6940         	ldr	r0, [r0, #0x14]
 805c058: b9c0         	cbnz	r0, 0x805c08c <xStreamBufferReset+0x74> @ imm = #0x30
 805c05a: e7ff         	b	0x805c05c <xStreamBufferReset+0x44> @ imm = #-0x2
;             prvInitialiseNewStreamBuffer( pxStreamBuffer,
 805c05c: 9808         	ldr	r0, [sp, #0x20]
;                                           pxStreamBuffer->xLength,
 805c05e: 6882         	ldr	r2, [r0, #0x8]
;                                           pxStreamBuffer->xTriggerLevelBytes,
 805c060: 68c3         	ldr	r3, [r0, #0xc]
;                                           pxStreamBuffer->pucBuffer,
 805c062: 6981         	ldr	r1, [r0, #0x18]
;                                           pxStreamBuffer->ucFlags,
 805c064: f890 c01c    	ldrb.w	r12, [r0, #0x1c]
;                                           pxSendCallback,
 805c068: 9c06         	ldr	r4, [sp, #0x18]
;                                           pxReceiveCallback );
 805c06a: 9d05         	ldr	r5, [sp, #0x14]
;             prvInitialiseNewStreamBuffer( pxStreamBuffer,
 805c06c: 46ee         	mov	lr, sp
 805c06e: f8ce 5008    	str.w	r5, [lr, #0x8]
 805c072: f8ce 4004    	str.w	r4, [lr, #0x4]
 805c076: f8ce c000    	str.w	r12, [lr]
 805c07a: f8df c028    	ldr.w	r12, [pc, #0x28]        @ 0x805c0a4 <xStreamBufferReset+0x8c>
 805c07e: 47e0         	blx	r12
;                 pxStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
 805c080: 9804         	ldr	r0, [sp, #0x10]
 805c082: 9908         	ldr	r1, [sp, #0x20]
 805c084: 6208         	str	r0, [r1, #0x20]
 805c086: 2001         	movs	r0, #0x1
;             xReturn = pdPASS;
 805c088: 9007         	str	r0, [sp, #0x1c]
;         }
 805c08a: e7ff         	b	0x805c08c <xStreamBufferReset+0x74> @ imm = #-0x2
;     taskEXIT_CRITICAL();
 805c08c: 4806         	ldr	r0, [pc, #0x18]         @ 0x805c0a8 <xStreamBufferReset+0x90>
 805c08e: 4780         	blx	r0
;     return xReturn;
 805c090: 9807         	ldr	r0, [sp, #0x1c]
 805c092: b00a         	add	sp, #0x28
 805c094: bcb0         	pop	{r4, r5, r7}
 805c096: eba8 0809    	sub.w	r8, r8, r9
 805c09a: f858 fd2c    	ldr	pc, [r8, #-44]!
 805c09e: bf00         	nop

0805c0a0 <$d.7>:
 805c0a0: 49 cd 05 08  	.word	0x0805cd49
 805c0a4: 41 bf 05 08  	.word	0x0805bf41
 805c0a8: 7d cd 05 08  	.word	0x0805cd7d
 805c0ac: 15 d7 05 08  	.word	0x0805d715

0805c0b0 <xStreamBufferSetTriggerLevel>:
; {
 805c0b0: f848 eb54    	str	lr, [r8], #84
 805c0b4: eb08 0809    	add.w	r8, r8, r9
 805c0b8: b480         	push	{r7}
 805c0ba: 466f         	mov	r7, sp
 805c0bc: b084         	sub	sp, #0x10
 805c0be: 9003         	str	r0, [sp, #0xc]
 805c0c0: 9102         	str	r1, [sp, #0x8]
;     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 805c0c2: 9803         	ldr	r0, [sp, #0xc]
 805c0c4: 9001         	str	r0, [sp, #0x4]
;     configASSERT( pxStreamBuffer );
 805c0c6: 9801         	ldr	r0, [sp, #0x4]
 805c0c8: b920         	cbnz	r0, 0x805c0d4 <xStreamBufferSetTriggerLevel+0x24> @ imm = #0x8
 805c0ca: e7ff         	b	0x805c0cc <xStreamBufferSetTriggerLevel+0x1c> @ imm = #-0x2
 805c0cc: 480f         	ldr	r0, [pc, #0x3c]         @ 0x805c10c <xStreamBufferSetTriggerLevel+0x5c>
 805c0ce: 4780         	blx	r0
 805c0d0: e7ff         	b	0x805c0d2 <xStreamBufferSetTriggerLevel+0x22> @ imm = #-0x2
 805c0d2: e7fe         	b	0x805c0d2 <xStreamBufferSetTriggerLevel+0x22> @ imm = #-0x4
;     if( xTriggerLevel == ( size_t ) 0 )
 805c0d4: 9802         	ldr	r0, [sp, #0x8]
 805c0d6: b918         	cbnz	r0, 0x805c0e0 <xStreamBufferSetTriggerLevel+0x30> @ imm = #0x6
 805c0d8: e7ff         	b	0x805c0da <xStreamBufferSetTriggerLevel+0x2a> @ imm = #-0x2
 805c0da: 2001         	movs	r0, #0x1
;         xTriggerLevel = ( size_t ) 1;
 805c0dc: 9002         	str	r0, [sp, #0x8]
;     }
 805c0de: e7ff         	b	0x805c0e0 <xStreamBufferSetTriggerLevel+0x30> @ imm = #-0x2
;     if( xTriggerLevel < pxStreamBuffer->xLength )
 805c0e0: 9802         	ldr	r0, [sp, #0x8]
 805c0e2: 9901         	ldr	r1, [sp, #0x4]
 805c0e4: 6889         	ldr	r1, [r1, #0x8]
 805c0e6: 4288         	cmp	r0, r1
 805c0e8: d206         	bhs	0x805c0f8 <xStreamBufferSetTriggerLevel+0x48> @ imm = #0xc
 805c0ea: e7ff         	b	0x805c0ec <xStreamBufferSetTriggerLevel+0x3c> @ imm = #-0x2
;         pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
 805c0ec: 9802         	ldr	r0, [sp, #0x8]
 805c0ee: 9901         	ldr	r1, [sp, #0x4]
 805c0f0: 60c8         	str	r0, [r1, #0xc]
 805c0f2: 2001         	movs	r0, #0x1
;         xReturn = pdPASS;
 805c0f4: 9000         	str	r0, [sp]
;     }
 805c0f6: e002         	b	0x805c0fe <xStreamBufferSetTriggerLevel+0x4e> @ imm = #0x4
 805c0f8: 2000         	movs	r0, #0x0
;         xReturn = pdFALSE;
 805c0fa: 9000         	str	r0, [sp]
 805c0fc: e7ff         	b	0x805c0fe <xStreamBufferSetTriggerLevel+0x4e> @ imm = #-0x2
;     return xReturn;
 805c0fe: 9800         	ldr	r0, [sp]
 805c100: b004         	add	sp, #0x10
 805c102: bc80         	pop	{r7}
 805c104: eba8 0809    	sub.w	r8, r8, r9
 805c108: f858 fd54    	ldr	pc, [r8, #-84]!

0805c10c <$d.9>:
 805c10c: 15 d7 05 08  	.word	0x0805d715

0805c110 <xStreamBufferSpacesAvailable>:
; {
 805c110: f848 eb78    	str	lr, [r8], #120
 805c114: eb08 0809    	add.w	r8, r8, r9
 805c118: b480         	push	{r7}
 805c11a: 466f         	mov	r7, sp
 805c11c: b084         	sub	sp, #0x10
 805c11e: 9003         	str	r0, [sp, #0xc]
;     const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 805c120: 9803         	ldr	r0, [sp, #0xc]
 805c122: 9002         	str	r0, [sp, #0x8]
;     configASSERT( pxStreamBuffer );
 805c124: 9802         	ldr	r0, [sp, #0x8]
 805c126: b920         	cbnz	r0, 0x805c132 <xStreamBufferSpacesAvailable+0x22> @ imm = #0x8
 805c128: e7ff         	b	0x805c12a <xStreamBufferSpacesAvailable+0x1a> @ imm = #-0x2
 805c12a: 4818         	ldr	r0, [pc, #0x60]         @ 0x805c18c <xStreamBufferSpacesAvailable+0x7c>
 805c12c: 4780         	blx	r0
 805c12e: e7ff         	b	0x805c130 <xStreamBufferSpacesAvailable+0x20> @ imm = #-0x2
 805c130: e7fe         	b	0x805c130 <xStreamBufferSpacesAvailable+0x20> @ imm = #-0x4
;     do
 805c132: e7ff         	b	0x805c134 <xStreamBufferSpacesAvailable+0x24> @ imm = #-0x2
;         xOriginalTail = pxStreamBuffer->xTail;
 805c134: 9802         	ldr	r0, [sp, #0x8]
 805c136: 6800         	ldr	r0, [r0]
 805c138: 9000         	str	r0, [sp]
;         xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 805c13a: 9902         	ldr	r1, [sp, #0x8]
 805c13c: 6888         	ldr	r0, [r1, #0x8]
 805c13e: 6809         	ldr	r1, [r1]
 805c140: 4408         	add	r0, r1
 805c142: 9001         	str	r0, [sp, #0x4]
;         xSpace -= pxStreamBuffer->xHead;
 805c144: 9802         	ldr	r0, [sp, #0x8]
 805c146: 6841         	ldr	r1, [r0, #0x4]
 805c148: 9801         	ldr	r0, [sp, #0x4]
 805c14a: 1a40         	subs	r0, r0, r1
 805c14c: 9001         	str	r0, [sp, #0x4]
;     } while( xOriginalTail != pxStreamBuffer->xTail );
 805c14e: e7ff         	b	0x805c150 <xStreamBufferSpacesAvailable+0x40> @ imm = #-0x2
 805c150: 9800         	ldr	r0, [sp]
 805c152: 9902         	ldr	r1, [sp, #0x8]
 805c154: 6809         	ldr	r1, [r1]
 805c156: 4288         	cmp	r0, r1
 805c158: d1ec         	bne	0x805c134 <xStreamBufferSpacesAvailable+0x24> @ imm = #-0x28
 805c15a: e7ff         	b	0x805c15c <xStreamBufferSpacesAvailable+0x4c> @ imm = #-0x2
;     xSpace -= ( size_t ) 1;
 805c15c: 9801         	ldr	r0, [sp, #0x4]
 805c15e: 3801         	subs	r0, #0x1
 805c160: 9001         	str	r0, [sp, #0x4]
;     if( xSpace >= pxStreamBuffer->xLength )
 805c162: 9801         	ldr	r0, [sp, #0x4]
 805c164: 9902         	ldr	r1, [sp, #0x8]
 805c166: 6889         	ldr	r1, [r1, #0x8]
 805c168: 4288         	cmp	r0, r1
 805c16a: d306         	blo	0x805c17a <xStreamBufferSpacesAvailable+0x6a> @ imm = #0xc
 805c16c: e7ff         	b	0x805c16e <xStreamBufferSpacesAvailable+0x5e> @ imm = #-0x2
;         xSpace -= pxStreamBuffer->xLength;
 805c16e: 9802         	ldr	r0, [sp, #0x8]
 805c170: 6881         	ldr	r1, [r0, #0x8]
 805c172: 9801         	ldr	r0, [sp, #0x4]
 805c174: 1a40         	subs	r0, r0, r1
 805c176: 9001         	str	r0, [sp, #0x4]
;     }
 805c178: e000         	b	0x805c17c <xStreamBufferSpacesAvailable+0x6c> @ imm = #0x0
 805c17a: e7ff         	b	0x805c17c <xStreamBufferSpacesAvailable+0x6c> @ imm = #-0x2
;     return xSpace;
 805c17c: 9801         	ldr	r0, [sp, #0x4]
 805c17e: b004         	add	sp, #0x10
 805c180: bc80         	pop	{r7}
 805c182: eba8 0809    	sub.w	r8, r8, r9
 805c186: f858 fd78    	ldr	pc, [r8, #-120]!
 805c18a: bf00         	nop

0805c18c <$d.11>:
 805c18c: 15 d7 05 08  	.word	0x0805d715

0805c190 <xStreamBufferBytesAvailable>:
; {
 805c190: f848 eb68    	str	lr, [r8], #104
 805c194: eb08 0809    	add.w	r8, r8, r9
 805c198: b480         	push	{r7}
 805c19a: 466f         	mov	r7, sp
 805c19c: b084         	sub	sp, #0x10
 805c19e: 9003         	str	r0, [sp, #0xc]
;     const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 805c1a0: 9803         	ldr	r0, [sp, #0xc]
 805c1a2: 9002         	str	r0, [sp, #0x8]
;     configASSERT( pxStreamBuffer );
 805c1a4: 9802         	ldr	r0, [sp, #0x8]
 805c1a6: b920         	cbnz	r0, 0x805c1b2 <xStreamBufferBytesAvailable+0x22> @ imm = #0x8
 805c1a8: e7ff         	b	0x805c1aa <xStreamBufferBytesAvailable+0x1a> @ imm = #-0x2
 805c1aa: 4808         	ldr	r0, [pc, #0x20]         @ 0x805c1cc <xStreamBufferBytesAvailable+0x3c>
 805c1ac: 4780         	blx	r0
 805c1ae: e7ff         	b	0x805c1b0 <xStreamBufferBytesAvailable+0x20> @ imm = #-0x2
 805c1b0: e7fe         	b	0x805c1b0 <xStreamBufferBytesAvailable+0x20> @ imm = #-0x4
;     xReturn = prvBytesInBuffer( pxStreamBuffer );
 805c1b2: 9802         	ldr	r0, [sp, #0x8]
 805c1b4: 4904         	ldr	r1, [pc, #0x10]         @ 0x805c1c8 <xStreamBufferBytesAvailable+0x38>
 805c1b6: 4788         	blx	r1
 805c1b8: 9001         	str	r0, [sp, #0x4]
;     return xReturn;
 805c1ba: 9801         	ldr	r0, [sp, #0x4]
 805c1bc: b004         	add	sp, #0x10
 805c1be: bc80         	pop	{r7}
 805c1c0: eba8 0809    	sub.w	r8, r8, r9
 805c1c4: f858 fd68    	ldr	pc, [r8, #-104]!

0805c1c8 <$d.13>:
 805c1c8: d1 c1 05 08  	.word	0x0805c1d1
 805c1cc: 15 d7 05 08  	.word	0x0805d715

0805c1d0 <prvBytesInBuffer>:
; {
 805c1d0: b082         	sub	sp, #0x8
 805c1d2: 9001         	str	r0, [sp, #0x4]
;     xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 805c1d4: 9901         	ldr	r1, [sp, #0x4]
 805c1d6: 6888         	ldr	r0, [r1, #0x8]
 805c1d8: 6849         	ldr	r1, [r1, #0x4]
 805c1da: 4408         	add	r0, r1
 805c1dc: 9000         	str	r0, [sp]
;     xCount -= pxStreamBuffer->xTail;
 805c1de: 9801         	ldr	r0, [sp, #0x4]
 805c1e0: 6801         	ldr	r1, [r0]
 805c1e2: 9800         	ldr	r0, [sp]
 805c1e4: 1a40         	subs	r0, r0, r1
 805c1e6: 9000         	str	r0, [sp]
;     if( xCount >= pxStreamBuffer->xLength )
 805c1e8: 9800         	ldr	r0, [sp]
 805c1ea: 9901         	ldr	r1, [sp, #0x4]
 805c1ec: 6889         	ldr	r1, [r1, #0x8]
 805c1ee: 4288         	cmp	r0, r1
 805c1f0: d306         	blo	0x805c200 <prvBytesInBuffer+0x30> @ imm = #0xc
 805c1f2: e7ff         	b	0x805c1f4 <prvBytesInBuffer+0x24> @ imm = #-0x2
;         xCount -= pxStreamBuffer->xLength;
 805c1f4: 9801         	ldr	r0, [sp, #0x4]
 805c1f6: 6881         	ldr	r1, [r0, #0x8]
 805c1f8: 9800         	ldr	r0, [sp]
 805c1fa: 1a40         	subs	r0, r0, r1
 805c1fc: 9000         	str	r0, [sp]
;     }
 805c1fe: e000         	b	0x805c202 <prvBytesInBuffer+0x32> @ imm = #0x0
 805c200: e7ff         	b	0x805c202 <prvBytesInBuffer+0x32> @ imm = #-0x2
;     return xCount;
 805c202: 9800         	ldr	r0, [sp]
 805c204: b002         	add	sp, #0x8
 805c206: 4770         	bx	lr

0805c208 <xStreamBufferSend>:
; {
 805c208: f848 eb28    	str	lr, [r8], #40
 805c20c: eb08 0809    	add.w	r8, r8, r9
 805c210: b480         	push	{r7}
 805c212: 466f         	mov	r7, sp
 805c214: b08e         	sub	sp, #0x38
 805c216: 900d         	str	r0, [sp, #0x34]
 805c218: 910c         	str	r1, [sp, #0x30]
 805c21a: 920b         	str	r2, [sp, #0x2c]
 805c21c: 930a         	str	r3, [sp, #0x28]
;     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 805c21e: 980d         	ldr	r0, [sp, #0x34]
 805c220: 9009         	str	r0, [sp, #0x24]
 805c222: 2000         	movs	r0, #0x0
;     size_t xReturn, xSpace = 0;
 805c224: 9007         	str	r0, [sp, #0x1c]
;     size_t xRequiredSpace = xDataLengthBytes;
 805c226: 990b         	ldr	r1, [sp, #0x2c]
 805c228: 9106         	str	r1, [sp, #0x18]
;     size_t xMaxReportedSpace = 0;
 805c22a: 9003         	str	r0, [sp, #0xc]
;     configASSERT( pvTxData );
 805c22c: 980c         	ldr	r0, [sp, #0x30]
 805c22e: b920         	cbnz	r0, 0x805c23a <xStreamBufferSend+0x32> @ imm = #0x8
 805c230: e7ff         	b	0x805c232 <xStreamBufferSend+0x2a> @ imm = #-0x2
 805c232: 486d         	ldr	r0, [pc, #0x1b4]        @ 0x805c3e8 <xStreamBufferSend+0x1e0>
 805c234: 4780         	blx	r0
 805c236: e7ff         	b	0x805c238 <xStreamBufferSend+0x30> @ imm = #-0x2
 805c238: e7fe         	b	0x805c238 <xStreamBufferSend+0x30> @ imm = #-0x4
;     configASSERT( pxStreamBuffer );
 805c23a: 9809         	ldr	r0, [sp, #0x24]
 805c23c: b920         	cbnz	r0, 0x805c248 <xStreamBufferSend+0x40> @ imm = #0x8
 805c23e: e7ff         	b	0x805c240 <xStreamBufferSend+0x38> @ imm = #-0x2
 805c240: 4868         	ldr	r0, [pc, #0x1a0]        @ 0x805c3e4 <xStreamBufferSend+0x1dc>
 805c242: 4780         	blx	r0
 805c244: e7ff         	b	0x805c246 <xStreamBufferSend+0x3e> @ imm = #-0x2
 805c246: e7fe         	b	0x805c246 <xStreamBufferSend+0x3e> @ imm = #-0x4
;     xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
 805c248: 9809         	ldr	r0, [sp, #0x24]
 805c24a: 6880         	ldr	r0, [r0, #0x8]
 805c24c: 3801         	subs	r0, #0x1
 805c24e: 9003         	str	r0, [sp, #0xc]
;     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 805c250: 9809         	ldr	r0, [sp, #0x24]
 805c252: 7f00         	ldrb	r0, [r0, #0x1c]
 805c254: 07c0         	lsls	r0, r0, #0x1f
 805c256: b1b0         	cbz	r0, 0x805c286 <xStreamBufferSend+0x7e> @ imm = #0x2c
 805c258: e7ff         	b	0x805c25a <xStreamBufferSend+0x52> @ imm = #-0x2
;         xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 805c25a: 9806         	ldr	r0, [sp, #0x18]
 805c25c: 3004         	adds	r0, #0x4
 805c25e: 9006         	str	r0, [sp, #0x18]
;         configASSERT( xRequiredSpace > xDataLengthBytes );
 805c260: 9806         	ldr	r0, [sp, #0x18]
 805c262: 990b         	ldr	r1, [sp, #0x2c]
 805c264: 4288         	cmp	r0, r1
 805c266: d804         	bhi	0x805c272 <xStreamBufferSend+0x6a> @ imm = #0x8
 805c268: e7ff         	b	0x805c26a <xStreamBufferSend+0x62> @ imm = #-0x2
 805c26a: 485d         	ldr	r0, [pc, #0x174]        @ 0x805c3e0 <xStreamBufferSend+0x1d8>
 805c26c: 4780         	blx	r0
 805c26e: e7ff         	b	0x805c270 <xStreamBufferSend+0x68> @ imm = #-0x2
 805c270: e7fe         	b	0x805c270 <xStreamBufferSend+0x68> @ imm = #-0x4
;         if( xRequiredSpace > xMaxReportedSpace )
 805c272: 9806         	ldr	r0, [sp, #0x18]
 805c274: 9903         	ldr	r1, [sp, #0xc]
 805c276: 4288         	cmp	r0, r1
 805c278: d903         	bls	0x805c282 <xStreamBufferSend+0x7a> @ imm = #0x6
 805c27a: e7ff         	b	0x805c27c <xStreamBufferSend+0x74> @ imm = #-0x2
 805c27c: 2000         	movs	r0, #0x0
;             xTicksToWait = ( TickType_t ) 0;
 805c27e: 900a         	str	r0, [sp, #0x28]
;         }
 805c280: e000         	b	0x805c284 <xStreamBufferSend+0x7c> @ imm = #0x0
 805c282: e7ff         	b	0x805c284 <xStreamBufferSend+0x7c> @ imm = #-0x2
;     }
 805c284: e009         	b	0x805c29a <xStreamBufferSend+0x92> @ imm = #0x12
;         if( xRequiredSpace > xMaxReportedSpace )
 805c286: 9806         	ldr	r0, [sp, #0x18]
 805c288: 9903         	ldr	r1, [sp, #0xc]
 805c28a: 4288         	cmp	r0, r1
 805c28c: d903         	bls	0x805c296 <xStreamBufferSend+0x8e> @ imm = #0x6
 805c28e: e7ff         	b	0x805c290 <xStreamBufferSend+0x88> @ imm = #-0x2
;             xRequiredSpace = xMaxReportedSpace;
 805c290: 9803         	ldr	r0, [sp, #0xc]
 805c292: 9006         	str	r0, [sp, #0x18]
;         }
 805c294: e000         	b	0x805c298 <xStreamBufferSend+0x90> @ imm = #0x0
 805c296: e7ff         	b	0x805c298 <xStreamBufferSend+0x90> @ imm = #-0x2
 805c298: e7ff         	b	0x805c29a <xStreamBufferSend+0x92> @ imm = #-0x2
;     if( xTicksToWait != ( TickType_t ) 0 )
 805c29a: 980a         	ldr	r0, [sp, #0x28]
 805c29c: b3e0         	cbz	r0, 0x805c318 <xStreamBufferSend+0x110> @ imm = #0x78
 805c29e: e7ff         	b	0x805c2a0 <xStreamBufferSend+0x98> @ imm = #-0x2
;         vTaskSetTimeOutState( &xTimeOut );
 805c2a0: 493f         	ldr	r1, [pc, #0xfc]         @ 0x805c3a0 <xStreamBufferSend+0x198>
 805c2a2: a804         	add	r0, sp, #0x10
 805c2a4: 4788         	blx	r1
;         do
 805c2a6: e7ff         	b	0x805c2a8 <xStreamBufferSend+0xa0> @ imm = #-0x2
;             taskENTER_CRITICAL();
 805c2a8: 483e         	ldr	r0, [pc, #0xf8]         @ 0x805c3a4 <xStreamBufferSend+0x19c>
 805c2aa: 4780         	blx	r0
;                 xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 805c2ac: 9809         	ldr	r0, [sp, #0x24]
 805c2ae: 493e         	ldr	r1, [pc, #0xf8]         @ 0x805c3a8 <xStreamBufferSend+0x1a0>
 805c2b0: 4788         	blx	r1
 805c2b2: 9007         	str	r0, [sp, #0x1c]
;                 if( xSpace < xRequiredSpace )
 805c2b4: 9807         	ldr	r0, [sp, #0x1c]
 805c2b6: 9906         	ldr	r1, [sp, #0x18]
 805c2b8: 4288         	cmp	r0, r1
 805c2ba: d211         	bhs	0x805c2e0 <xStreamBufferSend+0xd8> @ imm = #0x22
 805c2bc: e7ff         	b	0x805c2be <xStreamBufferSend+0xb6> @ imm = #-0x2
;                     ( void ) xTaskNotifyStateClear( NULL );
 805c2be: 4a3c         	ldr	r2, [pc, #0xf0]         @ 0x805c3b0 <xStreamBufferSend+0x1a8>
 805c2c0: 2100         	movs	r1, #0x0
 805c2c2: 4608         	mov	r0, r1
 805c2c4: 4790         	blx	r2
;                     configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
 805c2c6: 9809         	ldr	r0, [sp, #0x24]
 805c2c8: 6940         	ldr	r0, [r0, #0x14]
 805c2ca: b120         	cbz	r0, 0x805c2d6 <xStreamBufferSend+0xce> @ imm = #0x8
 805c2cc: e7ff         	b	0x805c2ce <xStreamBufferSend+0xc6> @ imm = #-0x2
 805c2ce: 4843         	ldr	r0, [pc, #0x10c]        @ 0x805c3dc <xStreamBufferSend+0x1d4>
 805c2d0: 4780         	blx	r0
 805c2d2: e7ff         	b	0x805c2d4 <xStreamBufferSend+0xcc> @ imm = #-0x2
 805c2d4: e7fe         	b	0x805c2d4 <xStreamBufferSend+0xcc> @ imm = #-0x4
;                     pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 805c2d6: 4837         	ldr	r0, [pc, #0xdc]         @ 0x805c3b4 <xStreamBufferSend+0x1ac>
 805c2d8: 4780         	blx	r0
 805c2da: 9909         	ldr	r1, [sp, #0x24]
 805c2dc: 6148         	str	r0, [r1, #0x14]
;                 }
 805c2de: e002         	b	0x805c2e6 <xStreamBufferSend+0xde> @ imm = #0x4
;                     taskEXIT_CRITICAL();
 805c2e0: 4832         	ldr	r0, [pc, #0xc8]         @ 0x805c3ac <xStreamBufferSend+0x1a4>
 805c2e2: 4780         	blx	r0
;                     break;
 805c2e4: e017         	b	0x805c316 <xStreamBufferSend+0x10e> @ imm = #0x2e
;             taskEXIT_CRITICAL();
 805c2e6: 4834         	ldr	r0, [pc, #0xd0]         @ 0x805c3b8 <xStreamBufferSend+0x1b0>
 805c2e8: 4780         	blx	r0
;             ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 805c2ea: 980a         	ldr	r0, [sp, #0x28]
 805c2ec: 4669         	mov	r1, sp
 805c2ee: 6008         	str	r0, [r1]
 805c2f0: f8df c0c8    	ldr.w	r12, [pc, #0xc8]        @ 0x805c3bc <xStreamBufferSend+0x1b4>
 805c2f4: 2300         	movs	r3, #0x0
 805c2f6: 9302         	str	r3, [sp, #0x8]
 805c2f8: 4618         	mov	r0, r3
 805c2fa: 4619         	mov	r1, r3
 805c2fc: 461a         	mov	r2, r3
 805c2fe: 47e0         	blx	r12
;             pxStreamBuffer->xTaskWaitingToSend = NULL;
 805c300: 9802         	ldr	r0, [sp, #0x8]
 805c302: 9909         	ldr	r1, [sp, #0x24]
 805c304: 6148         	str	r0, [r1, #0x14]
;         } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
 805c306: e7ff         	b	0x805c308 <xStreamBufferSend+0x100> @ imm = #-0x2
 805c308: 4a2d         	ldr	r2, [pc, #0xb4]         @ 0x805c3c0 <xStreamBufferSend+0x1b8>
 805c30a: a804         	add	r0, sp, #0x10
 805c30c: a90a         	add	r1, sp, #0x28
 805c30e: 4790         	blx	r2
 805c310: 2800         	cmp	r0, #0x0
 805c312: d0c9         	beq	0x805c2a8 <xStreamBufferSend+0xa0> @ imm = #-0x6e
 805c314: e7ff         	b	0x805c316 <xStreamBufferSend+0x10e> @ imm = #-0x2
;     }
 805c316: e000         	b	0x805c31a <xStreamBufferSend+0x112> @ imm = #0x0
 805c318: e7ff         	b	0x805c31a <xStreamBufferSend+0x112> @ imm = #-0x2
;     if( xSpace == ( size_t ) 0 )
 805c31a: 9807         	ldr	r0, [sp, #0x1c]
 805c31c: b928         	cbnz	r0, 0x805c32a <xStreamBufferSend+0x122> @ imm = #0xa
 805c31e: e7ff         	b	0x805c320 <xStreamBufferSend+0x118> @ imm = #-0x2
;         xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 805c320: 9809         	ldr	r0, [sp, #0x24]
 805c322: 4928         	ldr	r1, [pc, #0xa0]         @ 0x805c3c4 <xStreamBufferSend+0x1bc>
 805c324: 4788         	blx	r1
 805c326: 9007         	str	r0, [sp, #0x1c]
;     }
 805c328: e000         	b	0x805c32c <xStreamBufferSend+0x124> @ imm = #0x0
 805c32a: e7ff         	b	0x805c32c <xStreamBufferSend+0x124> @ imm = #-0x2
;     xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 805c32c: 9809         	ldr	r0, [sp, #0x24]
 805c32e: 990c         	ldr	r1, [sp, #0x30]
 805c330: 9a0b         	ldr	r2, [sp, #0x2c]
 805c332: 9b07         	ldr	r3, [sp, #0x1c]
 805c334: f8dd c018    	ldr.w	r12, [sp, #0x18]
 805c338: 46ee         	mov	lr, sp
 805c33a: f8ce c000    	str.w	r12, [lr]
 805c33e: f8df c088    	ldr.w	r12, [pc, #0x88]        @ 0x805c3c8 <xStreamBufferSend+0x1c0>
 805c342: 47e0         	blx	r12
 805c344: 9008         	str	r0, [sp, #0x20]
;     if( xReturn > ( size_t ) 0 )
 805c346: 9808         	ldr	r0, [sp, #0x20]
 805c348: b310         	cbz	r0, 0x805c390 <xStreamBufferSend+0x188> @ imm = #0x44
 805c34a: e7ff         	b	0x805c34c <xStreamBufferSend+0x144> @ imm = #-0x2
;         if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 805c34c: 9809         	ldr	r0, [sp, #0x24]
 805c34e: 491f         	ldr	r1, [pc, #0x7c]         @ 0x805c3cc <xStreamBufferSend+0x1c4>
 805c350: 4788         	blx	r1
 805c352: 9909         	ldr	r1, [sp, #0x24]
 805c354: 68c9         	ldr	r1, [r1, #0xc]
 805c356: 4288         	cmp	r0, r1
 805c358: d318         	blo	0x805c38c <xStreamBufferSend+0x184> @ imm = #0x30
 805c35a: e7ff         	b	0x805c35c <xStreamBufferSend+0x154> @ imm = #-0x2
;             prvSEND_COMPLETED( pxStreamBuffer );
 805c35c: 481c         	ldr	r0, [pc, #0x70]         @ 0x805c3d0 <xStreamBufferSend+0x1c8>
 805c35e: 4780         	blx	r0
 805c360: 9809         	ldr	r0, [sp, #0x24]
 805c362: 6900         	ldr	r0, [r0, #0x10]
 805c364: b178         	cbz	r0, 0x805c386 <xStreamBufferSend+0x17e> @ imm = #0x1e
 805c366: e7ff         	b	0x805c368 <xStreamBufferSend+0x160> @ imm = #-0x2
 805c368: 9809         	ldr	r0, [sp, #0x24]
 805c36a: 6900         	ldr	r0, [r0, #0x10]
 805c36c: 4669         	mov	r1, sp
 805c36e: 2300         	movs	r3, #0x0
 805c370: 9301         	str	r3, [sp, #0x4]
 805c372: 600b         	str	r3, [r1]
 805c374: f8df c05c    	ldr.w	r12, [pc, #0x5c]        @ 0x805c3d4 <xStreamBufferSend+0x1cc>
 805c378: 4619         	mov	r1, r3
 805c37a: 461a         	mov	r2, r3
 805c37c: 47e0         	blx	r12
 805c37e: 9801         	ldr	r0, [sp, #0x4]
 805c380: 9909         	ldr	r1, [sp, #0x24]
 805c382: 6108         	str	r0, [r1, #0x10]
 805c384: e7ff         	b	0x805c386 <xStreamBufferSend+0x17e> @ imm = #-0x2
 805c386: 4814         	ldr	r0, [pc, #0x50]         @ 0x805c3d8 <xStreamBufferSend+0x1d0>
 805c388: 4780         	blx	r0
;         }
 805c38a: e000         	b	0x805c38e <xStreamBufferSend+0x186> @ imm = #0x0
 805c38c: e7ff         	b	0x805c38e <xStreamBufferSend+0x186> @ imm = #-0x2
;     }
 805c38e: e000         	b	0x805c392 <xStreamBufferSend+0x18a> @ imm = #0x0
 805c390: e7ff         	b	0x805c392 <xStreamBufferSend+0x18a> @ imm = #-0x2
;     return xReturn;
 805c392: 9808         	ldr	r0, [sp, #0x20]
 805c394: b00e         	add	sp, #0x38
 805c396: bc80         	pop	{r7}
 805c398: eba8 0809    	sub.w	r8, r8, r9
 805c39c: f858 fd28    	ldr	pc, [r8, #-40]!

0805c3a0 <$d.15>:
 805c3a0: 41 73 05 08  	.word	0x08057341
 805c3a4: 49 cd 05 08  	.word	0x0805cd49
 805c3a8: 11 c1 05 08  	.word	0x0805c111
 805c3ac: 7d cd 05 08  	.word	0x0805cd7d
 805c3b0: 59 86 05 08  	.word	0x08058659
 805c3b4: f9 76 05 08  	.word	0x080576f9
 805c3b8: 7d cd 05 08  	.word	0x0805cd7d
 805c3bc: 75 7d 05 08  	.word	0x08057d75
 805c3c0: c1 73 05 08  	.word	0x080573c1
 805c3c4: 11 c1 05 08  	.word	0x0805c111
 805c3c8: ed c3 05 08  	.word	0x0805c3ed
 805c3cc: d1 c1 05 08  	.word	0x0805c1d1
 805c3d0: d9 58 05 08  	.word	0x080558d9
 805c3d4: d1 7e 05 08  	.word	0x08057ed1
 805c3d8: 0d 5a 05 08  	.word	0x08055a0d
 805c3dc: 15 d7 05 08  	.word	0x0805d715
 805c3e0: 15 d7 05 08  	.word	0x0805d715
 805c3e4: 15 d7 05 08  	.word	0x0805d715
 805c3e8: 15 d7 05 08  	.word	0x0805d715

0805c3ec <prvWriteMessageToBuffer>:
; {
 805c3ec: f848 eb1c    	str	lr, [r8], #28
 805c3f0: eb08 0809    	add.w	r8, r8, r9
 805c3f4: b480         	push	{r7}
 805c3f6: 466f         	mov	r7, sp
 805c3f8: b088         	sub	sp, #0x20
 805c3fa: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805c3fe: 9007         	str	r0, [sp, #0x1c]
 805c400: 9106         	str	r1, [sp, #0x18]
 805c402: 9205         	str	r2, [sp, #0x14]
 805c404: 9304         	str	r3, [sp, #0x10]
;     size_t xNextHead = pxStreamBuffer->xHead;
 805c406: 9807         	ldr	r0, [sp, #0x1c]
 805c408: 6840         	ldr	r0, [r0, #0x4]
 805c40a: 9003         	str	r0, [sp, #0xc]
;     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 805c40c: 9807         	ldr	r0, [sp, #0x1c]
 805c40e: 7f00         	ldrb	r0, [r0, #0x1c]
 805c410: 07c0         	lsls	r0, r0, #0x1f
 805c412: b1e8         	cbz	r0, 0x805c450 <prvWriteMessageToBuffer+0x64> @ imm = #0x3a
 805c414: e7ff         	b	0x805c416 <prvWriteMessageToBuffer+0x2a> @ imm = #-0x2
;         xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
 805c416: 9805         	ldr	r0, [sp, #0x14]
 805c418: 9002         	str	r0, [sp, #0x8]
;         configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );
 805c41a: 9802         	ldr	r0, [sp, #0x8]
 805c41c: 9905         	ldr	r1, [sp, #0x14]
 805c41e: 4288         	cmp	r0, r1
 805c420: d004         	beq	0x805c42c <prvWriteMessageToBuffer+0x40> @ imm = #0x8
 805c422: e7ff         	b	0x805c424 <prvWriteMessageToBuffer+0x38> @ imm = #-0x2
 805c424: 481d         	ldr	r0, [pc, #0x74]         @ 0x805c49c <prvWriteMessageToBuffer+0xb0>
 805c426: 4780         	blx	r0
 805c428: e7ff         	b	0x805c42a <prvWriteMessageToBuffer+0x3e> @ imm = #-0x2
 805c42a: e7fe         	b	0x805c42a <prvWriteMessageToBuffer+0x3e> @ imm = #-0x4
;         if( xSpace >= xRequiredSpace )
 805c42c: 9804         	ldr	r0, [sp, #0x10]
 805c42e: 68b9         	ldr	r1, [r7, #0x8]
 805c430: 4288         	cmp	r0, r1
 805c432: d309         	blo	0x805c448 <prvWriteMessageToBuffer+0x5c> @ imm = #0x12
 805c434: e7ff         	b	0x805c436 <prvWriteMessageToBuffer+0x4a> @ imm = #-0x2
;             xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
 805c436: 9807         	ldr	r0, [sp, #0x1c]
 805c438: 9b03         	ldr	r3, [sp, #0xc]
 805c43a: f8df c058    	ldr.w	r12, [pc, #0x58]        @ 0x805c494 <prvWriteMessageToBuffer+0xa8>
 805c43e: a902         	add	r1, sp, #0x8
 805c440: 2204         	movs	r2, #0x4
 805c442: 47e0         	blx	r12
 805c444: 9003         	str	r0, [sp, #0xc]
;         }
 805c446: e002         	b	0x805c44e <prvWriteMessageToBuffer+0x62> @ imm = #0x4
 805c448: 2000         	movs	r0, #0x0
;             xDataLengthBytes = 0;
 805c44a: 9005         	str	r0, [sp, #0x14]
 805c44c: e7ff         	b	0x805c44e <prvWriteMessageToBuffer+0x62> @ imm = #-0x2
;     }
 805c44e: e00d         	b	0x805c46c <prvWriteMessageToBuffer+0x80> @ imm = #0x1a
;         xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
 805c450: 9805         	ldr	r0, [sp, #0x14]
 805c452: 9904         	ldr	r1, [sp, #0x10]
 805c454: 4288         	cmp	r0, r1
 805c456: d203         	bhs	0x805c460 <prvWriteMessageToBuffer+0x74> @ imm = #0x6
 805c458: e7ff         	b	0x805c45a <prvWriteMessageToBuffer+0x6e> @ imm = #-0x2
 805c45a: 9805         	ldr	r0, [sp, #0x14]
 805c45c: 9001         	str	r0, [sp, #0x4]
 805c45e: e002         	b	0x805c466 <prvWriteMessageToBuffer+0x7a> @ imm = #0x4
 805c460: 9804         	ldr	r0, [sp, #0x10]
 805c462: 9001         	str	r0, [sp, #0x4]
 805c464: e7ff         	b	0x805c466 <prvWriteMessageToBuffer+0x7a> @ imm = #-0x2
 805c466: 9801         	ldr	r0, [sp, #0x4]
 805c468: 9005         	str	r0, [sp, #0x14]
 805c46a: e7ff         	b	0x805c46c <prvWriteMessageToBuffer+0x80> @ imm = #-0x2
;     if( xDataLengthBytes != ( size_t ) 0 )
 805c46c: 9805         	ldr	r0, [sp, #0x14]
 805c46e: b150         	cbz	r0, 0x805c486 <prvWriteMessageToBuffer+0x9a> @ imm = #0x14
 805c470: e7ff         	b	0x805c472 <prvWriteMessageToBuffer+0x86> @ imm = #-0x2
;         pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
 805c472: 9807         	ldr	r0, [sp, #0x1c]
 805c474: 9906         	ldr	r1, [sp, #0x18]
 805c476: 9a05         	ldr	r2, [sp, #0x14]
 805c478: 9b03         	ldr	r3, [sp, #0xc]
 805c47a: f8df c01c    	ldr.w	r12, [pc, #0x1c]        @ 0x805c498 <prvWriteMessageToBuffer+0xac>
 805c47e: 47e0         	blx	r12
 805c480: 9907         	ldr	r1, [sp, #0x1c]
 805c482: 6048         	str	r0, [r1, #0x4]
;     }
 805c484: e7ff         	b	0x805c486 <prvWriteMessageToBuffer+0x9a> @ imm = #-0x2
;     return xDataLengthBytes;
 805c486: 9805         	ldr	r0, [sp, #0x14]
 805c488: b008         	add	sp, #0x20
 805c48a: bc80         	pop	{r7}
 805c48c: eba8 0809    	sub.w	r8, r8, r9
 805c490: f858 fd1c    	ldr	pc, [r8, #-28]!

0805c494 <$d.17>:
 805c494: f9 cb 05 08  	.word	0x0805cbf9
 805c498: f9 cb 05 08  	.word	0x0805cbf9
 805c49c: 15 d7 05 08  	.word	0x0805d715

0805c4a0 <xStreamBufferSendFromISR>:
; {
 805c4a0: f848 eb3c    	str	lr, [r8], #60
 805c4a4: eb08 0809    	add.w	r8, r8, r9
 805c4a8: b480         	push	{r7}
 805c4aa: 466f         	mov	r7, sp
 805c4ac: b08c         	sub	sp, #0x30
 805c4ae: 900b         	str	r0, [sp, #0x2c]
 805c4b0: 910a         	str	r1, [sp, #0x28]
 805c4b2: 9209         	str	r2, [sp, #0x24]
 805c4b4: 9308         	str	r3, [sp, #0x20]
;     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 805c4b6: 980b         	ldr	r0, [sp, #0x2c]
 805c4b8: 9007         	str	r0, [sp, #0x1c]
;     size_t xRequiredSpace = xDataLengthBytes;
 805c4ba: 9809         	ldr	r0, [sp, #0x24]
 805c4bc: 9004         	str	r0, [sp, #0x10]
;     configASSERT( pvTxData );
 805c4be: 980a         	ldr	r0, [sp, #0x28]
 805c4c0: b920         	cbnz	r0, 0x805c4cc <xStreamBufferSendFromISR+0x2c> @ imm = #0x8
 805c4c2: e7ff         	b	0x805c4c4 <xStreamBufferSendFromISR+0x24> @ imm = #-0x2
 805c4c4: 4833         	ldr	r0, [pc, #0xcc]         @ 0x805c594 <xStreamBufferSendFromISR+0xf4>
 805c4c6: 4780         	blx	r0
 805c4c8: e7ff         	b	0x805c4ca <xStreamBufferSendFromISR+0x2a> @ imm = #-0x2
 805c4ca: e7fe         	b	0x805c4ca <xStreamBufferSendFromISR+0x2a> @ imm = #-0x4
;     configASSERT( pxStreamBuffer );
 805c4cc: 9807         	ldr	r0, [sp, #0x1c]
 805c4ce: b920         	cbnz	r0, 0x805c4da <xStreamBufferSendFromISR+0x3a> @ imm = #0x8
 805c4d0: e7ff         	b	0x805c4d2 <xStreamBufferSendFromISR+0x32> @ imm = #-0x2
 805c4d2: 482f         	ldr	r0, [pc, #0xbc]         @ 0x805c590 <xStreamBufferSendFromISR+0xf0>
 805c4d4: 4780         	blx	r0
 805c4d6: e7ff         	b	0x805c4d8 <xStreamBufferSendFromISR+0x38> @ imm = #-0x2
 805c4d8: e7fe         	b	0x805c4d8 <xStreamBufferSendFromISR+0x38> @ imm = #-0x4
;     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 805c4da: 9807         	ldr	r0, [sp, #0x1c]
 805c4dc: 7f00         	ldrb	r0, [r0, #0x1c]
 805c4de: 07c0         	lsls	r0, r0, #0x1f
 805c4e0: b120         	cbz	r0, 0x805c4ec <xStreamBufferSendFromISR+0x4c> @ imm = #0x8
 805c4e2: e7ff         	b	0x805c4e4 <xStreamBufferSendFromISR+0x44> @ imm = #-0x2
;         xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 805c4e4: 9804         	ldr	r0, [sp, #0x10]
 805c4e6: 3004         	adds	r0, #0x4
 805c4e8: 9004         	str	r0, [sp, #0x10]
;     }
 805c4ea: e000         	b	0x805c4ee <xStreamBufferSendFromISR+0x4e> @ imm = #0x0
 805c4ec: e7ff         	b	0x805c4ee <xStreamBufferSendFromISR+0x4e> @ imm = #-0x2
;     xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
 805c4ee: 9807         	ldr	r0, [sp, #0x1c]
 805c4f0: 4921         	ldr	r1, [pc, #0x84]         @ 0x805c578 <xStreamBufferSendFromISR+0xd8>
 805c4f2: 4788         	blx	r1
 805c4f4: 9005         	str	r0, [sp, #0x14]
;     xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 805c4f6: 9807         	ldr	r0, [sp, #0x1c]
 805c4f8: 990a         	ldr	r1, [sp, #0x28]
 805c4fa: 9a09         	ldr	r2, [sp, #0x24]
 805c4fc: 9b05         	ldr	r3, [sp, #0x14]
 805c4fe: f8dd c010    	ldr.w	r12, [sp, #0x10]
 805c502: 46ee         	mov	lr, sp
 805c504: f8ce c000    	str.w	r12, [lr]
 805c508: f8df c070    	ldr.w	r12, [pc, #0x70]        @ 0x805c57c <xStreamBufferSendFromISR+0xdc>
 805c50c: 47e0         	blx	r12
 805c50e: 9006         	str	r0, [sp, #0x18]
;     if( xReturn > ( size_t ) 0 )
 805c510: 9806         	ldr	r0, [sp, #0x18]
 805c512: b340         	cbz	r0, 0x805c566 <xStreamBufferSendFromISR+0xc6> @ imm = #0x50
 805c514: e7ff         	b	0x805c516 <xStreamBufferSendFromISR+0x76> @ imm = #-0x2
;         if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 805c516: 9807         	ldr	r0, [sp, #0x1c]
 805c518: 4919         	ldr	r1, [pc, #0x64]         @ 0x805c580 <xStreamBufferSendFromISR+0xe0>
 805c51a: 4788         	blx	r1
 805c51c: 9907         	ldr	r1, [sp, #0x1c]
 805c51e: 68c9         	ldr	r1, [r1, #0xc]
 805c520: 4288         	cmp	r0, r1
 805c522: d31e         	blo	0x805c562 <xStreamBufferSendFromISR+0xc2> @ imm = #0x3c
 805c524: e7ff         	b	0x805c526 <xStreamBufferSendFromISR+0x86> @ imm = #-0x2
;             prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 805c526: e7ff         	b	0x805c528 <xStreamBufferSendFromISR+0x88> @ imm = #-0x2
 805c528: 4816         	ldr	r0, [pc, #0x58]         @ 0x805c584 <xStreamBufferSendFromISR+0xe4>
 805c52a: 4780         	blx	r0
 805c52c: 9003         	str	r0, [sp, #0xc]
 805c52e: 9807         	ldr	r0, [sp, #0x1c]
 805c530: 6900         	ldr	r0, [r0, #0x10]
 805c532: b188         	cbz	r0, 0x805c558 <xStreamBufferSendFromISR+0xb8> @ imm = #0x22
 805c534: e7ff         	b	0x805c536 <xStreamBufferSendFromISR+0x96> @ imm = #-0x2
 805c536: 9807         	ldr	r0, [sp, #0x1c]
 805c538: 6900         	ldr	r0, [r0, #0x10]
 805c53a: 9a08         	ldr	r2, [sp, #0x20]
 805c53c: 4669         	mov	r1, sp
 805c53e: 604a         	str	r2, [r1, #0x4]
 805c540: 2300         	movs	r3, #0x0
 805c542: 9302         	str	r3, [sp, #0x8]
 805c544: 600b         	str	r3, [r1]
 805c546: f8df c040    	ldr.w	r12, [pc, #0x40]        @ 0x805c588 <xStreamBufferSendFromISR+0xe8>
 805c54a: 4619         	mov	r1, r3
 805c54c: 461a         	mov	r2, r3
 805c54e: 47e0         	blx	r12
 805c550: 9802         	ldr	r0, [sp, #0x8]
 805c552: 9907         	ldr	r1, [sp, #0x1c]
 805c554: 6108         	str	r0, [r1, #0x10]
 805c556: e7ff         	b	0x805c558 <xStreamBufferSendFromISR+0xb8> @ imm = #-0x2
 805c558: 9803         	ldr	r0, [sp, #0xc]
 805c55a: 490c         	ldr	r1, [pc, #0x30]         @ 0x805c58c <xStreamBufferSendFromISR+0xec>
 805c55c: 4788         	blx	r1
 805c55e: e7ff         	b	0x805c560 <xStreamBufferSendFromISR+0xc0> @ imm = #-0x2
;         }
 805c560: e000         	b	0x805c564 <xStreamBufferSendFromISR+0xc4> @ imm = #0x0
 805c562: e7ff         	b	0x805c564 <xStreamBufferSendFromISR+0xc4> @ imm = #-0x2
;     }
 805c564: e000         	b	0x805c568 <xStreamBufferSendFromISR+0xc8> @ imm = #0x0
 805c566: e7ff         	b	0x805c568 <xStreamBufferSendFromISR+0xc8> @ imm = #-0x2
;     return xReturn;
 805c568: 9806         	ldr	r0, [sp, #0x18]
 805c56a: b00c         	add	sp, #0x30
 805c56c: bc80         	pop	{r7}
 805c56e: eba8 0809    	sub.w	r8, r8, r9
 805c572: f858 fd3c    	ldr	pc, [r8, #-60]!
 805c576: bf00         	nop

0805c578 <$d.19>:
 805c578: 11 c1 05 08  	.word	0x0805c111
 805c57c: ed c3 05 08  	.word	0x0805c3ed
 805c580: d1 c1 05 08  	.word	0x0805c1d1
 805c584: 15 d7 05 08  	.word	0x0805d715
 805c588: 49 81 05 08  	.word	0x08058149
 805c58c: 2b d7 05 08  	.word	0x0805d72b
 805c590: 15 d7 05 08  	.word	0x0805d715
 805c594: 15 d7 05 08  	.word	0x0805d715

0805c598 <xStreamBufferReceive>:
; {
 805c598: f848 eb20    	str	lr, [r8], #32
 805c59c: eb08 0809    	add.w	r8, r8, r9
 805c5a0: b480         	push	{r7}
 805c5a2: 466f         	mov	r7, sp
 805c5a4: b08c         	sub	sp, #0x30
 805c5a6: 900b         	str	r0, [sp, #0x2c]
 805c5a8: 910a         	str	r1, [sp, #0x28]
 805c5aa: 9209         	str	r2, [sp, #0x24]
 805c5ac: 9308         	str	r3, [sp, #0x20]
;     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 805c5ae: 980b         	ldr	r0, [sp, #0x2c]
 805c5b0: 9007         	str	r0, [sp, #0x1c]
 805c5b2: 2000         	movs	r0, #0x0
;     size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 805c5b4: 9006         	str	r0, [sp, #0x18]
;     configASSERT( pvRxData );
 805c5b6: 980a         	ldr	r0, [sp, #0x28]
 805c5b8: b920         	cbnz	r0, 0x805c5c4 <xStreamBufferReceive+0x2c> @ imm = #0x8
 805c5ba: e7ff         	b	0x805c5bc <xStreamBufferReceive+0x24> @ imm = #-0x2
 805c5bc: 4852         	ldr	r0, [pc, #0x148]        @ 0x805c708 <xStreamBufferReceive+0x170>
 805c5be: 4780         	blx	r0
 805c5c0: e7ff         	b	0x805c5c2 <xStreamBufferReceive+0x2a> @ imm = #-0x2
 805c5c2: e7fe         	b	0x805c5c2 <xStreamBufferReceive+0x2a> @ imm = #-0x4
;     configASSERT( pxStreamBuffer );
 805c5c4: 9807         	ldr	r0, [sp, #0x1c]
 805c5c6: b920         	cbnz	r0, 0x805c5d2 <xStreamBufferReceive+0x3a> @ imm = #0x8
 805c5c8: e7ff         	b	0x805c5ca <xStreamBufferReceive+0x32> @ imm = #-0x2
 805c5ca: 484e         	ldr	r0, [pc, #0x138]        @ 0x805c704 <xStreamBufferReceive+0x16c>
 805c5cc: 4780         	blx	r0
 805c5ce: e7ff         	b	0x805c5d0 <xStreamBufferReceive+0x38> @ imm = #-0x2
 805c5d0: e7fe         	b	0x805c5d0 <xStreamBufferReceive+0x38> @ imm = #-0x4
;     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 805c5d2: 9807         	ldr	r0, [sp, #0x1c]
 805c5d4: 7f00         	ldrb	r0, [r0, #0x1c]
 805c5d6: 07c0         	lsls	r0, r0, #0x1f
 805c5d8: b118         	cbz	r0, 0x805c5e2 <xStreamBufferReceive+0x4a> @ imm = #0x6
 805c5da: e7ff         	b	0x805c5dc <xStreamBufferReceive+0x44> @ imm = #-0x2
 805c5dc: 2004         	movs	r0, #0x4
;         xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 805c5de: 9004         	str	r0, [sp, #0x10]
;     }
 805c5e0: e002         	b	0x805c5e8 <xStreamBufferReceive+0x50> @ imm = #0x4
 805c5e2: 2000         	movs	r0, #0x0
;         xBytesToStoreMessageLength = 0;
 805c5e4: 9004         	str	r0, [sp, #0x10]
 805c5e6: e7ff         	b	0x805c5e8 <xStreamBufferReceive+0x50> @ imm = #-0x2
;     if( xTicksToWait != ( TickType_t ) 0 )
 805c5e8: 9808         	ldr	r0, [sp, #0x20]
 805c5ea: b3c8         	cbz	r0, 0x805c660 <xStreamBufferReceive+0xc8> @ imm = #0x72
 805c5ec: e7ff         	b	0x805c5ee <xStreamBufferReceive+0x56> @ imm = #-0x2
;         taskENTER_CRITICAL();
 805c5ee: 4839         	ldr	r0, [pc, #0xe4]         @ 0x805c6d4 <xStreamBufferReceive+0x13c>
 805c5f0: 4780         	blx	r0
;             xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 805c5f2: 9807         	ldr	r0, [sp, #0x1c]
 805c5f4: 4938         	ldr	r1, [pc, #0xe0]         @ 0x805c6d8 <xStreamBufferReceive+0x140>
 805c5f6: 4788         	blx	r1
 805c5f8: 9005         	str	r0, [sp, #0x14]
;             if( xBytesAvailable <= xBytesToStoreMessageLength )
 805c5fa: 9805         	ldr	r0, [sp, #0x14]
 805c5fc: 9904         	ldr	r1, [sp, #0x10]
 805c5fe: 4288         	cmp	r0, r1
 805c600: d811         	bhi	0x805c626 <xStreamBufferReceive+0x8e> @ imm = #0x22
 805c602: e7ff         	b	0x805c604 <xStreamBufferReceive+0x6c> @ imm = #-0x2
;                 ( void ) xTaskNotifyStateClear( NULL );
 805c604: 4a35         	ldr	r2, [pc, #0xd4]         @ 0x805c6dc <xStreamBufferReceive+0x144>
 805c606: 2100         	movs	r1, #0x0
 805c608: 4608         	mov	r0, r1
 805c60a: 4790         	blx	r2
;                 configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
 805c60c: 9807         	ldr	r0, [sp, #0x1c]
 805c60e: 6900         	ldr	r0, [r0, #0x10]
 805c610: b120         	cbz	r0, 0x805c61c <xStreamBufferReceive+0x84> @ imm = #0x8
 805c612: e7ff         	b	0x805c614 <xStreamBufferReceive+0x7c> @ imm = #-0x2
 805c614: 483a         	ldr	r0, [pc, #0xe8]         @ 0x805c700 <xStreamBufferReceive+0x168>
 805c616: 4780         	blx	r0
 805c618: e7ff         	b	0x805c61a <xStreamBufferReceive+0x82> @ imm = #-0x2
 805c61a: e7fe         	b	0x805c61a <xStreamBufferReceive+0x82> @ imm = #-0x4
;                 pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 805c61c: 4830         	ldr	r0, [pc, #0xc0]         @ 0x805c6e0 <xStreamBufferReceive+0x148>
 805c61e: 4780         	blx	r0
 805c620: 9907         	ldr	r1, [sp, #0x1c]
 805c622: 6108         	str	r0, [r1, #0x10]
;             }
 805c624: e000         	b	0x805c628 <xStreamBufferReceive+0x90> @ imm = #0x0
 805c626: e7ff         	b	0x805c628 <xStreamBufferReceive+0x90> @ imm = #-0x2
;         taskEXIT_CRITICAL();
 805c628: 482e         	ldr	r0, [pc, #0xb8]         @ 0x805c6e4 <xStreamBufferReceive+0x14c>
 805c62a: 4780         	blx	r0
;         if( xBytesAvailable <= xBytesToStoreMessageLength )
 805c62c: 9805         	ldr	r0, [sp, #0x14]
 805c62e: 9904         	ldr	r1, [sp, #0x10]
 805c630: 4288         	cmp	r0, r1
 805c632: d813         	bhi	0x805c65c <xStreamBufferReceive+0xc4> @ imm = #0x26
 805c634: e7ff         	b	0x805c636 <xStreamBufferReceive+0x9e> @ imm = #-0x2
;             ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 805c636: 9808         	ldr	r0, [sp, #0x20]
 805c638: 4669         	mov	r1, sp
 805c63a: 6008         	str	r0, [r1]
 805c63c: f8df c0a8    	ldr.w	r12, [pc, #0xa8]        @ 0x805c6e8 <xStreamBufferReceive+0x150>
 805c640: 2300         	movs	r3, #0x0
 805c642: 9303         	str	r3, [sp, #0xc]
 805c644: 4618         	mov	r0, r3
 805c646: 4619         	mov	r1, r3
 805c648: 461a         	mov	r2, r3
 805c64a: 47e0         	blx	r12
;             pxStreamBuffer->xTaskWaitingToReceive = NULL;
 805c64c: 9803         	ldr	r0, [sp, #0xc]
 805c64e: 9907         	ldr	r1, [sp, #0x1c]
 805c650: 6108         	str	r0, [r1, #0x10]
;             xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 805c652: 9807         	ldr	r0, [sp, #0x1c]
 805c654: 4925         	ldr	r1, [pc, #0x94]         @ 0x805c6ec <xStreamBufferReceive+0x154>
 805c656: 4788         	blx	r1
 805c658: 9005         	str	r0, [sp, #0x14]
;         }
 805c65a: e000         	b	0x805c65e <xStreamBufferReceive+0xc6> @ imm = #0x0
 805c65c: e7ff         	b	0x805c65e <xStreamBufferReceive+0xc6> @ imm = #-0x2
;     }
 805c65e: e004         	b	0x805c66a <xStreamBufferReceive+0xd2> @ imm = #0x8
;         xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 805c660: 9807         	ldr	r0, [sp, #0x1c]
 805c662: 491b         	ldr	r1, [pc, #0x6c]         @ 0x805c6d0 <xStreamBufferReceive+0x138>
 805c664: 4788         	blx	r1
 805c666: 9005         	str	r0, [sp, #0x14]
 805c668: e7ff         	b	0x805c66a <xStreamBufferReceive+0xd2> @ imm = #-0x2
;     if( xBytesAvailable > xBytesToStoreMessageLength )
 805c66a: 9805         	ldr	r0, [sp, #0x14]
 805c66c: 9904         	ldr	r1, [sp, #0x10]
 805c66e: 4288         	cmp	r0, r1
 805c670: d925         	bls	0x805c6be <xStreamBufferReceive+0x126> @ imm = #0x4a
 805c672: e7ff         	b	0x805c674 <xStreamBufferReceive+0xdc> @ imm = #-0x2
;         xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
 805c674: 9807         	ldr	r0, [sp, #0x1c]
 805c676: 990a         	ldr	r1, [sp, #0x28]
 805c678: 9a09         	ldr	r2, [sp, #0x24]
 805c67a: 9b05         	ldr	r3, [sp, #0x14]
 805c67c: f8df c070    	ldr.w	r12, [pc, #0x70]        @ 0x805c6f0 <xStreamBufferReceive+0x158>
 805c680: 47e0         	blx	r12
 805c682: 9006         	str	r0, [sp, #0x18]
;         if( xReceivedLength != ( size_t ) 0 )
 805c684: 9806         	ldr	r0, [sp, #0x18]
 805c686: b1c0         	cbz	r0, 0x805c6ba <xStreamBufferReceive+0x122> @ imm = #0x30
 805c688: e7ff         	b	0x805c68a <xStreamBufferReceive+0xf2> @ imm = #-0x2
;             prvRECEIVE_COMPLETED( xStreamBuffer );
 805c68a: 481a         	ldr	r0, [pc, #0x68]         @ 0x805c6f4 <xStreamBufferReceive+0x15c>
 805c68c: 4780         	blx	r0
 805c68e: 980b         	ldr	r0, [sp, #0x2c]
 805c690: 6940         	ldr	r0, [r0, #0x14]
 805c692: b178         	cbz	r0, 0x805c6b4 <xStreamBufferReceive+0x11c> @ imm = #0x1e
 805c694: e7ff         	b	0x805c696 <xStreamBufferReceive+0xfe> @ imm = #-0x2
 805c696: 980b         	ldr	r0, [sp, #0x2c]
 805c698: 6940         	ldr	r0, [r0, #0x14]
 805c69a: 4669         	mov	r1, sp
 805c69c: 2300         	movs	r3, #0x0
 805c69e: 9302         	str	r3, [sp, #0x8]
 805c6a0: 600b         	str	r3, [r1]
 805c6a2: f8df c054    	ldr.w	r12, [pc, #0x54]        @ 0x805c6f8 <xStreamBufferReceive+0x160>
 805c6a6: 4619         	mov	r1, r3
 805c6a8: 461a         	mov	r2, r3
 805c6aa: 47e0         	blx	r12
 805c6ac: 9802         	ldr	r0, [sp, #0x8]
 805c6ae: 990b         	ldr	r1, [sp, #0x2c]
 805c6b0: 6148         	str	r0, [r1, #0x14]
 805c6b2: e7ff         	b	0x805c6b4 <xStreamBufferReceive+0x11c> @ imm = #-0x2
 805c6b4: 4811         	ldr	r0, [pc, #0x44]         @ 0x805c6fc <xStreamBufferReceive+0x164>
 805c6b6: 4780         	blx	r0
;         }
 805c6b8: e000         	b	0x805c6bc <xStreamBufferReceive+0x124> @ imm = #0x0
 805c6ba: e7ff         	b	0x805c6bc <xStreamBufferReceive+0x124> @ imm = #-0x2
;     }
 805c6bc: e000         	b	0x805c6c0 <xStreamBufferReceive+0x128> @ imm = #0x0
 805c6be: e7ff         	b	0x805c6c0 <xStreamBufferReceive+0x128> @ imm = #-0x2
;     return xReceivedLength;
 805c6c0: 9806         	ldr	r0, [sp, #0x18]
 805c6c2: b00c         	add	sp, #0x30
 805c6c4: bc80         	pop	{r7}
 805c6c6: eba8 0809    	sub.w	r8, r8, r9
 805c6ca: f858 fd20    	ldr	pc, [r8, #-32]!
 805c6ce: bf00         	nop

0805c6d0 <$d.21>:
 805c6d0: d1 c1 05 08  	.word	0x0805c1d1
 805c6d4: 49 cd 05 08  	.word	0x0805cd49
 805c6d8: d1 c1 05 08  	.word	0x0805c1d1
 805c6dc: 59 86 05 08  	.word	0x08058659
 805c6e0: f9 76 05 08  	.word	0x080576f9
 805c6e4: 7d cd 05 08  	.word	0x0805cd7d
 805c6e8: 75 7d 05 08  	.word	0x08057d75
 805c6ec: d1 c1 05 08  	.word	0x0805c1d1
 805c6f0: 0d c7 05 08  	.word	0x0805c70d
 805c6f4: d9 58 05 08  	.word	0x080558d9
 805c6f8: d1 7e 05 08  	.word	0x08057ed1
 805c6fc: 0d 5a 05 08  	.word	0x08055a0d
 805c700: 15 d7 05 08  	.word	0x0805d715
 805c704: 15 d7 05 08  	.word	0x0805d715
 805c708: 15 d7 05 08  	.word	0x0805d715

0805c70c <prvReadMessageFromBuffer>:
; {
 805c70c: f848 eb40    	str	lr, [r8], #64
 805c710: eb08 0809    	add.w	r8, r8, r9
 805c714: b480         	push	{r7}
 805c716: 466f         	mov	r7, sp
 805c718: b08a         	sub	sp, #0x28
 805c71a: 9009         	str	r0, [sp, #0x24]
 805c71c: 9108         	str	r1, [sp, #0x20]
 805c71e: 9207         	str	r2, [sp, #0x1c]
 805c720: 9306         	str	r3, [sp, #0x18]
;     size_t xNextTail = pxStreamBuffer->xTail;
 805c722: 9809         	ldr	r0, [sp, #0x24]
 805c724: 6800         	ldr	r0, [r0]
 805c726: 9002         	str	r0, [sp, #0x8]
;     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 805c728: 9809         	ldr	r0, [sp, #0x24]
 805c72a: 7f00         	ldrb	r0, [r0, #0x1c]
 805c72c: 07c0         	lsls	r0, r0, #0x1f
 805c72e: b1b8         	cbz	r0, 0x805c760 <prvReadMessageFromBuffer+0x54> @ imm = #0x2e
 805c730: e7ff         	b	0x805c732 <prvReadMessageFromBuffer+0x26> @ imm = #-0x2
;         xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
 805c732: 9809         	ldr	r0, [sp, #0x24]
 805c734: 9b02         	ldr	r3, [sp, #0x8]
 805c736: f8df c070    	ldr.w	r12, [pc, #0x70]        @ 0x805c7a8 <prvReadMessageFromBuffer+0x9c>
 805c73a: a903         	add	r1, sp, #0xc
 805c73c: 2204         	movs	r2, #0x4
 805c73e: 47e0         	blx	r12
 805c740: 9002         	str	r0, [sp, #0x8]
;         xNextMessageLength = ( size_t ) xTempNextMessageLength;
 805c742: 9803         	ldr	r0, [sp, #0xc]
 805c744: 9004         	str	r0, [sp, #0x10]
;         xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
 805c746: 9806         	ldr	r0, [sp, #0x18]
 805c748: 3804         	subs	r0, #0x4
 805c74a: 9006         	str	r0, [sp, #0x18]
;         if( xNextMessageLength > xBufferLengthBytes )
 805c74c: 9804         	ldr	r0, [sp, #0x10]
 805c74e: 9907         	ldr	r1, [sp, #0x1c]
 805c750: 4288         	cmp	r0, r1
 805c752: d903         	bls	0x805c75c <prvReadMessageFromBuffer+0x50> @ imm = #0x6
 805c754: e7ff         	b	0x805c756 <prvReadMessageFromBuffer+0x4a> @ imm = #-0x2
 805c756: 2000         	movs	r0, #0x0
;             xNextMessageLength = 0;
 805c758: 9004         	str	r0, [sp, #0x10]
;         }
 805c75a: e000         	b	0x805c75e <prvReadMessageFromBuffer+0x52> @ imm = #0x0
 805c75c: e7ff         	b	0x805c75e <prvReadMessageFromBuffer+0x52> @ imm = #-0x2
;     }
 805c75e: e002         	b	0x805c766 <prvReadMessageFromBuffer+0x5a> @ imm = #0x4
;         xNextMessageLength = xBufferLengthBytes;
 805c760: 9807         	ldr	r0, [sp, #0x1c]
 805c762: 9004         	str	r0, [sp, #0x10]
 805c764: e7ff         	b	0x805c766 <prvReadMessageFromBuffer+0x5a> @ imm = #-0x2
;     xCount = configMIN( xNextMessageLength, xBytesAvailable );
 805c766: 9804         	ldr	r0, [sp, #0x10]
 805c768: 9906         	ldr	r1, [sp, #0x18]
 805c76a: 4288         	cmp	r0, r1
 805c76c: d203         	bhs	0x805c776 <prvReadMessageFromBuffer+0x6a> @ imm = #0x6
 805c76e: e7ff         	b	0x805c770 <prvReadMessageFromBuffer+0x64> @ imm = #-0x2
 805c770: 9804         	ldr	r0, [sp, #0x10]
 805c772: 9001         	str	r0, [sp, #0x4]
 805c774: e002         	b	0x805c77c <prvReadMessageFromBuffer+0x70> @ imm = #0x4
 805c776: 9806         	ldr	r0, [sp, #0x18]
 805c778: 9001         	str	r0, [sp, #0x4]
 805c77a: e7ff         	b	0x805c77c <prvReadMessageFromBuffer+0x70> @ imm = #-0x2
 805c77c: 9801         	ldr	r0, [sp, #0x4]
 805c77e: 9005         	str	r0, [sp, #0x14]
;     if( xCount != ( size_t ) 0 )
 805c780: 9805         	ldr	r0, [sp, #0x14]
 805c782: b150         	cbz	r0, 0x805c79a <prvReadMessageFromBuffer+0x8e> @ imm = #0x14
 805c784: e7ff         	b	0x805c786 <prvReadMessageFromBuffer+0x7a> @ imm = #-0x2
;         pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
 805c786: 9809         	ldr	r0, [sp, #0x24]
 805c788: 9908         	ldr	r1, [sp, #0x20]
 805c78a: 9a05         	ldr	r2, [sp, #0x14]
 805c78c: 9b02         	ldr	r3, [sp, #0x8]
 805c78e: f8df c01c    	ldr.w	r12, [pc, #0x1c]        @ 0x805c7ac <prvReadMessageFromBuffer+0xa0>
 805c792: 47e0         	blx	r12
 805c794: 9909         	ldr	r1, [sp, #0x24]
 805c796: 6008         	str	r0, [r1]
;     }
 805c798: e7ff         	b	0x805c79a <prvReadMessageFromBuffer+0x8e> @ imm = #-0x2
;     return xCount;
 805c79a: 9805         	ldr	r0, [sp, #0x14]
 805c79c: b00a         	add	sp, #0x28
 805c79e: bc80         	pop	{r7}
 805c7a0: eba8 0809    	sub.w	r8, r8, r9
 805c7a4: f858 fd40    	ldr	pc, [r8, #-64]!

0805c7a8 <$d.23>:
 805c7a8: 3d c8 05 08  	.word	0x0805c83d
 805c7ac: 3d c8 05 08  	.word	0x0805c83d

0805c7b0 <xStreamBufferNextMessageLengthBytes>:
; {
 805c7b0: f848 eb64    	str	lr, [r8], #100
 805c7b4: eb08 0809    	add.w	r8, r8, r9
 805c7b8: b480         	push	{r7}
 805c7ba: 466f         	mov	r7, sp
 805c7bc: b086         	sub	sp, #0x18
 805c7be: 9005         	str	r0, [sp, #0x14]
;     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 805c7c0: 9805         	ldr	r0, [sp, #0x14]
 805c7c2: 9004         	str	r0, [sp, #0x10]
;     configASSERT( pxStreamBuffer );
 805c7c4: 9804         	ldr	r0, [sp, #0x10]
 805c7c6: b920         	cbnz	r0, 0x805c7d2 <xStreamBufferNextMessageLengthBytes+0x22> @ imm = #0x8
 805c7c8: e7ff         	b	0x805c7ca <xStreamBufferNextMessageLengthBytes+0x1a> @ imm = #-0x2
 805c7ca: 481b         	ldr	r0, [pc, #0x6c]         @ 0x805c838 <xStreamBufferNextMessageLengthBytes+0x88>
 805c7cc: 4780         	blx	r0
 805c7ce: e7ff         	b	0x805c7d0 <xStreamBufferNextMessageLengthBytes+0x20> @ imm = #-0x2
 805c7d0: e7fe         	b	0x805c7d0 <xStreamBufferNextMessageLengthBytes+0x20> @ imm = #-0x4
;     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 805c7d2: 9804         	ldr	r0, [sp, #0x10]
 805c7d4: 7f00         	ldrb	r0, [r0, #0x1c]
 805c7d6: 07c0         	lsls	r0, r0, #0x1f
 805c7d8: b1e8         	cbz	r0, 0x805c816 <xStreamBufferNextMessageLengthBytes+0x66> @ imm = #0x3a
 805c7da: e7ff         	b	0x805c7dc <xStreamBufferNextMessageLengthBytes+0x2c> @ imm = #-0x2
;         xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 805c7dc: 9804         	ldr	r0, [sp, #0x10]
 805c7de: 4913         	ldr	r1, [pc, #0x4c]         @ 0x805c82c <xStreamBufferNextMessageLengthBytes+0x7c>
 805c7e0: 4788         	blx	r1
 805c7e2: 9002         	str	r0, [sp, #0x8]
;         if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
 805c7e4: 9802         	ldr	r0, [sp, #0x8]
 805c7e6: 2805         	cmp	r0, #0x5
 805c7e8: d30a         	blo	0x805c800 <xStreamBufferNextMessageLengthBytes+0x50> @ imm = #0x14
 805c7ea: e7ff         	b	0x805c7ec <xStreamBufferNextMessageLengthBytes+0x3c> @ imm = #-0x2
;             ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
 805c7ec: 9804         	ldr	r0, [sp, #0x10]
 805c7ee: 6803         	ldr	r3, [r0]
 805c7f0: f8df c040    	ldr.w	r12, [pc, #0x40]        @ 0x805c834 <xStreamBufferNextMessageLengthBytes+0x84>
 805c7f4: a901         	add	r1, sp, #0x4
 805c7f6: 2204         	movs	r2, #0x4
 805c7f8: 47e0         	blx	r12
;             xReturn = ( size_t ) xTempReturn;
 805c7fa: 9801         	ldr	r0, [sp, #0x4]
 805c7fc: 9003         	str	r0, [sp, #0xc]
;         }
 805c7fe: e009         	b	0x805c814 <xStreamBufferNextMessageLengthBytes+0x64> @ imm = #0x12
;             configASSERT( xBytesAvailable == 0 );
 805c800: 9802         	ldr	r0, [sp, #0x8]
 805c802: b120         	cbz	r0, 0x805c80e <xStreamBufferNextMessageLengthBytes+0x5e> @ imm = #0x8
 805c804: e7ff         	b	0x805c806 <xStreamBufferNextMessageLengthBytes+0x56> @ imm = #-0x2
 805c806: 480a         	ldr	r0, [pc, #0x28]         @ 0x805c830 <xStreamBufferNextMessageLengthBytes+0x80>
 805c808: 4780         	blx	r0
 805c80a: e7ff         	b	0x805c80c <xStreamBufferNextMessageLengthBytes+0x5c> @ imm = #-0x2
 805c80c: e7fe         	b	0x805c80c <xStreamBufferNextMessageLengthBytes+0x5c> @ imm = #-0x4
 805c80e: 2000         	movs	r0, #0x0
;             xReturn = 0;
 805c810: 9003         	str	r0, [sp, #0xc]
 805c812: e7ff         	b	0x805c814 <xStreamBufferNextMessageLengthBytes+0x64> @ imm = #-0x2
;     }
 805c814: e002         	b	0x805c81c <xStreamBufferNextMessageLengthBytes+0x6c> @ imm = #0x4
 805c816: 2000         	movs	r0, #0x0
;         xReturn = 0;
 805c818: 9003         	str	r0, [sp, #0xc]
 805c81a: e7ff         	b	0x805c81c <xStreamBufferNextMessageLengthBytes+0x6c> @ imm = #-0x2
;     return xReturn;
 805c81c: 9803         	ldr	r0, [sp, #0xc]
 805c81e: b006         	add	sp, #0x18
 805c820: bc80         	pop	{r7}
 805c822: eba8 0809    	sub.w	r8, r8, r9
 805c826: f858 fd64    	ldr	pc, [r8, #-100]!
 805c82a: bf00         	nop

0805c82c <$d.25>:
 805c82c: d1 c1 05 08  	.word	0x0805c1d1
 805c830: 15 d7 05 08  	.word	0x0805d715
 805c834: 3d c8 05 08  	.word	0x0805c83d
 805c838: 15 d7 05 08  	.word	0x0805d715

0805c83c <prvReadBytesFromBuffer>:
; {
 805c83c: f848 eb60    	str	lr, [r8], #96
 805c840: eb08 0809    	add.w	r8, r8, r9
 805c844: b480         	push	{r7}
 805c846: 466f         	mov	r7, sp
 805c848: b086         	sub	sp, #0x18
 805c84a: 9005         	str	r0, [sp, #0x14]
 805c84c: 9104         	str	r1, [sp, #0x10]
 805c84e: 9203         	str	r2, [sp, #0xc]
 805c850: 9302         	str	r3, [sp, #0x8]
;     configASSERT( xCount != ( size_t ) 0 );
 805c852: 9803         	ldr	r0, [sp, #0xc]
 805c854: b920         	cbnz	r0, 0x805c860 <prvReadBytesFromBuffer+0x24> @ imm = #0x8
 805c856: e7ff         	b	0x805c858 <prvReadBytesFromBuffer+0x1c> @ imm = #-0x2
 805c858: 4831         	ldr	r0, [pc, #0xc4]         @ 0x805c920 <prvReadBytesFromBuffer+0xe4>
 805c85a: 4780         	blx	r0
 805c85c: e7ff         	b	0x805c85e <prvReadBytesFromBuffer+0x22> @ imm = #-0x2
 805c85e: e7fe         	b	0x805c85e <prvReadBytesFromBuffer+0x22> @ imm = #-0x4
;     xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
 805c860: 9805         	ldr	r0, [sp, #0x14]
 805c862: 6880         	ldr	r0, [r0, #0x8]
 805c864: 9902         	ldr	r1, [sp, #0x8]
 805c866: 1a40         	subs	r0, r0, r1
 805c868: 9903         	ldr	r1, [sp, #0xc]
 805c86a: 4288         	cmp	r0, r1
 805c86c: d206         	bhs	0x805c87c <prvReadBytesFromBuffer+0x40> @ imm = #0xc
 805c86e: e7ff         	b	0x805c870 <prvReadBytesFromBuffer+0x34> @ imm = #-0x2
 805c870: 9805         	ldr	r0, [sp, #0x14]
 805c872: 6880         	ldr	r0, [r0, #0x8]
 805c874: 9902         	ldr	r1, [sp, #0x8]
 805c876: 1a40         	subs	r0, r0, r1
 805c878: 9000         	str	r0, [sp]
 805c87a: e002         	b	0x805c882 <prvReadBytesFromBuffer+0x46> @ imm = #0x4
 805c87c: 9803         	ldr	r0, [sp, #0xc]
 805c87e: 9000         	str	r0, [sp]
 805c880: e7ff         	b	0x805c882 <prvReadBytesFromBuffer+0x46> @ imm = #-0x2
 805c882: 9800         	ldr	r0, [sp]
 805c884: 9001         	str	r0, [sp, #0x4]
;     configASSERT( xFirstLength <= xCount );
 805c886: 9801         	ldr	r0, [sp, #0x4]
 805c888: 9903         	ldr	r1, [sp, #0xc]
 805c88a: 4288         	cmp	r0, r1
 805c88c: d904         	bls	0x805c898 <prvReadBytesFromBuffer+0x5c> @ imm = #0x8
 805c88e: e7ff         	b	0x805c890 <prvReadBytesFromBuffer+0x54> @ imm = #-0x2
 805c890: 4822         	ldr	r0, [pc, #0x88]         @ 0x805c91c <prvReadBytesFromBuffer+0xe0>
 805c892: 4780         	blx	r0
 805c894: e7ff         	b	0x805c896 <prvReadBytesFromBuffer+0x5a> @ imm = #-0x2
 805c896: e7fe         	b	0x805c896 <prvReadBytesFromBuffer+0x5a> @ imm = #-0x4
;     configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
 805c898: 9802         	ldr	r0, [sp, #0x8]
 805c89a: 9901         	ldr	r1, [sp, #0x4]
 805c89c: 4408         	add	r0, r1
 805c89e: 9905         	ldr	r1, [sp, #0x14]
 805c8a0: 6889         	ldr	r1, [r1, #0x8]
 805c8a2: 4288         	cmp	r0, r1
 805c8a4: d904         	bls	0x805c8b0 <prvReadBytesFromBuffer+0x74> @ imm = #0x8
 805c8a6: e7ff         	b	0x805c8a8 <prvReadBytesFromBuffer+0x6c> @ imm = #-0x2
 805c8a8: 481b         	ldr	r0, [pc, #0x6c]         @ 0x805c918 <prvReadBytesFromBuffer+0xdc>
 805c8aa: 4780         	blx	r0
 805c8ac: e7ff         	b	0x805c8ae <prvReadBytesFromBuffer+0x72> @ imm = #-0x2
 805c8ae: e7fe         	b	0x805c8ae <prvReadBytesFromBuffer+0x72> @ imm = #-0x4
;     ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 805c8b0: 9804         	ldr	r0, [sp, #0x10]
 805c8b2: 9905         	ldr	r1, [sp, #0x14]
 805c8b4: 6989         	ldr	r1, [r1, #0x18]
 805c8b6: 9a02         	ldr	r2, [sp, #0x8]
 805c8b8: 4411         	add	r1, r2
 805c8ba: 9a01         	ldr	r2, [sp, #0x4]
 805c8bc: 4b14         	ldr	r3, [pc, #0x50]         @ 0x805c910 <prvReadBytesFromBuffer+0xd4>
 805c8be: 4798         	blx	r3
;     if( xCount > xFirstLength )
 805c8c0: 9803         	ldr	r0, [sp, #0xc]
 805c8c2: 9901         	ldr	r1, [sp, #0x4]
 805c8c4: 4288         	cmp	r0, r1
 805c8c6: d90a         	bls	0x805c8de <prvReadBytesFromBuffer+0xa2> @ imm = #0x14
 805c8c8: e7ff         	b	0x805c8ca <prvReadBytesFromBuffer+0x8e> @ imm = #-0x2
;         ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 805c8ca: 9804         	ldr	r0, [sp, #0x10]
 805c8cc: 9b01         	ldr	r3, [sp, #0x4]
 805c8ce: 4418         	add	r0, r3
 805c8d0: 9905         	ldr	r1, [sp, #0x14]
 805c8d2: 6989         	ldr	r1, [r1, #0x18]
 805c8d4: 9a03         	ldr	r2, [sp, #0xc]
 805c8d6: 1ad2         	subs	r2, r2, r3
 805c8d8: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x805c914 <prvReadBytesFromBuffer+0xd8>
 805c8da: 4798         	blx	r3
;     }
 805c8dc: e000         	b	0x805c8e0 <prvReadBytesFromBuffer+0xa4> @ imm = #0x0
 805c8de: e7ff         	b	0x805c8e0 <prvReadBytesFromBuffer+0xa4> @ imm = #-0x2
;     xTail += xCount;
 805c8e0: 9903         	ldr	r1, [sp, #0xc]
 805c8e2: 9802         	ldr	r0, [sp, #0x8]
 805c8e4: 4408         	add	r0, r1
 805c8e6: 9002         	str	r0, [sp, #0x8]
;     if( xTail >= pxStreamBuffer->xLength )
 805c8e8: 9802         	ldr	r0, [sp, #0x8]
 805c8ea: 9905         	ldr	r1, [sp, #0x14]
 805c8ec: 6889         	ldr	r1, [r1, #0x8]
 805c8ee: 4288         	cmp	r0, r1
 805c8f0: d306         	blo	0x805c900 <prvReadBytesFromBuffer+0xc4> @ imm = #0xc
 805c8f2: e7ff         	b	0x805c8f4 <prvReadBytesFromBuffer+0xb8> @ imm = #-0x2
;         xTail -= pxStreamBuffer->xLength;
 805c8f4: 9805         	ldr	r0, [sp, #0x14]
 805c8f6: 6881         	ldr	r1, [r0, #0x8]
 805c8f8: 9802         	ldr	r0, [sp, #0x8]
 805c8fa: 1a40         	subs	r0, r0, r1
 805c8fc: 9002         	str	r0, [sp, #0x8]
;     }
 805c8fe: e7ff         	b	0x805c900 <prvReadBytesFromBuffer+0xc4> @ imm = #-0x2
;     return xTail;
 805c900: 9802         	ldr	r0, [sp, #0x8]
 805c902: b006         	add	sp, #0x18
 805c904: bc80         	pop	{r7}
 805c906: eba8 0809    	sub.w	r8, r8, r9
 805c90a: f858 fd60    	ldr	pc, [r8, #-96]!
 805c90e: bf00         	nop

0805c910 <$d.27>:
 805c910: c1 f8 05 08  	.word	0x0805f8c1
 805c914: c1 f8 05 08  	.word	0x0805f8c1
 805c918: 15 d7 05 08  	.word	0x0805d715
 805c91c: 15 d7 05 08  	.word	0x0805d715
 805c920: 15 d7 05 08  	.word	0x0805d715

0805c924 <xStreamBufferReceiveFromISR>:
; {
 805c924: f848 eb10    	str	lr, [r8], #16
 805c928: eb08 0809    	add.w	r8, r8, r9
 805c92c: b480         	push	{r7}
 805c92e: 466f         	mov	r7, sp
 805c930: b08c         	sub	sp, #0x30
 805c932: 900b         	str	r0, [sp, #0x2c]
 805c934: 910a         	str	r1, [sp, #0x28]
 805c936: 9209         	str	r2, [sp, #0x24]
 805c938: 9308         	str	r3, [sp, #0x20]
;     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 805c93a: 980b         	ldr	r0, [sp, #0x2c]
 805c93c: 9007         	str	r0, [sp, #0x1c]
 805c93e: 2000         	movs	r0, #0x0
;     size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 805c940: 9006         	str	r0, [sp, #0x18]
;     configASSERT( pvRxData );
 805c942: 980a         	ldr	r0, [sp, #0x28]
 805c944: b920         	cbnz	r0, 0x805c950 <xStreamBufferReceiveFromISR+0x2c> @ imm = #0x8
 805c946: e7ff         	b	0x805c948 <xStreamBufferReceiveFromISR+0x24> @ imm = #-0x2
 805c948: 482e         	ldr	r0, [pc, #0xb8]         @ 0x805ca04 <xStreamBufferReceiveFromISR+0xe0>
 805c94a: 4780         	blx	r0
 805c94c: e7ff         	b	0x805c94e <xStreamBufferReceiveFromISR+0x2a> @ imm = #-0x2
 805c94e: e7fe         	b	0x805c94e <xStreamBufferReceiveFromISR+0x2a> @ imm = #-0x4
;     configASSERT( pxStreamBuffer );
 805c950: 9807         	ldr	r0, [sp, #0x1c]
 805c952: b920         	cbnz	r0, 0x805c95e <xStreamBufferReceiveFromISR+0x3a> @ imm = #0x8
 805c954: e7ff         	b	0x805c956 <xStreamBufferReceiveFromISR+0x32> @ imm = #-0x2
 805c956: 482a         	ldr	r0, [pc, #0xa8]         @ 0x805ca00 <xStreamBufferReceiveFromISR+0xdc>
 805c958: 4780         	blx	r0
 805c95a: e7ff         	b	0x805c95c <xStreamBufferReceiveFromISR+0x38> @ imm = #-0x2
 805c95c: e7fe         	b	0x805c95c <xStreamBufferReceiveFromISR+0x38> @ imm = #-0x4
;     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 805c95e: 9807         	ldr	r0, [sp, #0x1c]
 805c960: 7f00         	ldrb	r0, [r0, #0x1c]
 805c962: 07c0         	lsls	r0, r0, #0x1f
 805c964: b118         	cbz	r0, 0x805c96e <xStreamBufferReceiveFromISR+0x4a> @ imm = #0x6
 805c966: e7ff         	b	0x805c968 <xStreamBufferReceiveFromISR+0x44> @ imm = #-0x2
 805c968: 2004         	movs	r0, #0x4
;         xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 805c96a: 9004         	str	r0, [sp, #0x10]
;     }
 805c96c: e002         	b	0x805c974 <xStreamBufferReceiveFromISR+0x50> @ imm = #0x4
 805c96e: 2000         	movs	r0, #0x0
;         xBytesToStoreMessageLength = 0;
 805c970: 9004         	str	r0, [sp, #0x10]
 805c972: e7ff         	b	0x805c974 <xStreamBufferReceiveFromISR+0x50> @ imm = #-0x2
;     xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
 805c974: 9807         	ldr	r0, [sp, #0x1c]
 805c976: 491d         	ldr	r1, [pc, #0x74]         @ 0x805c9ec <xStreamBufferReceiveFromISR+0xc8>
 805c978: 4788         	blx	r1
 805c97a: 9005         	str	r0, [sp, #0x14]
;     if( xBytesAvailable > xBytesToStoreMessageLength )
 805c97c: 9805         	ldr	r0, [sp, #0x14]
 805c97e: 9904         	ldr	r1, [sp, #0x10]
 805c980: 4288         	cmp	r0, r1
 805c982: d92b         	bls	0x805c9dc <xStreamBufferReceiveFromISR+0xb8> @ imm = #0x56
 805c984: e7ff         	b	0x805c986 <xStreamBufferReceiveFromISR+0x62> @ imm = #-0x2
;         xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
 805c986: 9807         	ldr	r0, [sp, #0x1c]
 805c988: 990a         	ldr	r1, [sp, #0x28]
 805c98a: 9a09         	ldr	r2, [sp, #0x24]
 805c98c: 9b05         	ldr	r3, [sp, #0x14]
 805c98e: f8df c060    	ldr.w	r12, [pc, #0x60]        @ 0x805c9f0 <xStreamBufferReceiveFromISR+0xcc>
 805c992: 47e0         	blx	r12
 805c994: 9006         	str	r0, [sp, #0x18]
;         if( xReceivedLength != ( size_t ) 0 )
 805c996: 9806         	ldr	r0, [sp, #0x18]
 805c998: b1f0         	cbz	r0, 0x805c9d8 <xStreamBufferReceiveFromISR+0xb4> @ imm = #0x3c
 805c99a: e7ff         	b	0x805c99c <xStreamBufferReceiveFromISR+0x78> @ imm = #-0x2
;             prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 805c99c: e7ff         	b	0x805c99e <xStreamBufferReceiveFromISR+0x7a> @ imm = #-0x2
 805c99e: 4815         	ldr	r0, [pc, #0x54]         @ 0x805c9f4 <xStreamBufferReceiveFromISR+0xd0>
 805c9a0: 4780         	blx	r0
 805c9a2: 9003         	str	r0, [sp, #0xc]
 805c9a4: 9807         	ldr	r0, [sp, #0x1c]
 805c9a6: 6940         	ldr	r0, [r0, #0x14]
 805c9a8: b188         	cbz	r0, 0x805c9ce <xStreamBufferReceiveFromISR+0xaa> @ imm = #0x22
 805c9aa: e7ff         	b	0x805c9ac <xStreamBufferReceiveFromISR+0x88> @ imm = #-0x2
 805c9ac: 9807         	ldr	r0, [sp, #0x1c]
 805c9ae: 6940         	ldr	r0, [r0, #0x14]
 805c9b0: 9a08         	ldr	r2, [sp, #0x20]
 805c9b2: 4669         	mov	r1, sp
 805c9b4: 604a         	str	r2, [r1, #0x4]
 805c9b6: 2300         	movs	r3, #0x0
 805c9b8: 9302         	str	r3, [sp, #0x8]
 805c9ba: 600b         	str	r3, [r1]
 805c9bc: f8df c038    	ldr.w	r12, [pc, #0x38]        @ 0x805c9f8 <xStreamBufferReceiveFromISR+0xd4>
 805c9c0: 4619         	mov	r1, r3
 805c9c2: 461a         	mov	r2, r3
 805c9c4: 47e0         	blx	r12
 805c9c6: 9802         	ldr	r0, [sp, #0x8]
 805c9c8: 9907         	ldr	r1, [sp, #0x1c]
 805c9ca: 6148         	str	r0, [r1, #0x14]
 805c9cc: e7ff         	b	0x805c9ce <xStreamBufferReceiveFromISR+0xaa> @ imm = #-0x2
 805c9ce: 9803         	ldr	r0, [sp, #0xc]
 805c9d0: 490a         	ldr	r1, [pc, #0x28]         @ 0x805c9fc <xStreamBufferReceiveFromISR+0xd8>
 805c9d2: 4788         	blx	r1
 805c9d4: e7ff         	b	0x805c9d6 <xStreamBufferReceiveFromISR+0xb2> @ imm = #-0x2
;         }
 805c9d6: e000         	b	0x805c9da <xStreamBufferReceiveFromISR+0xb6> @ imm = #0x0
 805c9d8: e7ff         	b	0x805c9da <xStreamBufferReceiveFromISR+0xb6> @ imm = #-0x2
;     }
 805c9da: e000         	b	0x805c9de <xStreamBufferReceiveFromISR+0xba> @ imm = #0x0
 805c9dc: e7ff         	b	0x805c9de <xStreamBufferReceiveFromISR+0xba> @ imm = #-0x2
;     return xReceivedLength;
 805c9de: 9806         	ldr	r0, [sp, #0x18]
 805c9e0: b00c         	add	sp, #0x30
 805c9e2: bc80         	pop	{r7}
 805c9e4: eba8 0809    	sub.w	r8, r8, r9
 805c9e8: f858 fd10    	ldr	pc, [r8, #-16]!

0805c9ec <$d.29>:
 805c9ec: d1 c1 05 08  	.word	0x0805c1d1
 805c9f0: 0d c7 05 08  	.word	0x0805c70d
 805c9f4: 15 d7 05 08  	.word	0x0805d715
 805c9f8: 49 81 05 08  	.word	0x08058149
 805c9fc: 2b d7 05 08  	.word	0x0805d72b
 805ca00: 15 d7 05 08  	.word	0x0805d715
 805ca04: 15 d7 05 08  	.word	0x0805d715

0805ca08 <xStreamBufferIsEmpty>:
; {
 805ca08: f848 eb34    	str	lr, [r8], #52
 805ca0c: eb08 0809    	add.w	r8, r8, r9
 805ca10: b480         	push	{r7}
 805ca12: 466f         	mov	r7, sp
 805ca14: b084         	sub	sp, #0x10
 805ca16: 9003         	str	r0, [sp, #0xc]
;     const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 805ca18: 9803         	ldr	r0, [sp, #0xc]
 805ca1a: 9002         	str	r0, [sp, #0x8]
;     configASSERT( pxStreamBuffer );
 805ca1c: 9802         	ldr	r0, [sp, #0x8]
 805ca1e: b920         	cbnz	r0, 0x805ca2a <xStreamBufferIsEmpty+0x22> @ imm = #0x8
 805ca20: e7ff         	b	0x805ca22 <xStreamBufferIsEmpty+0x1a> @ imm = #-0x2
 805ca22: 480d         	ldr	r0, [pc, #0x34]         @ 0x805ca58 <xStreamBufferIsEmpty+0x50>
 805ca24: 4780         	blx	r0
 805ca26: e7ff         	b	0x805ca28 <xStreamBufferIsEmpty+0x20> @ imm = #-0x2
 805ca28: e7fe         	b	0x805ca28 <xStreamBufferIsEmpty+0x20> @ imm = #-0x4
;     xTail = pxStreamBuffer->xTail;
 805ca2a: 9802         	ldr	r0, [sp, #0x8]
 805ca2c: 6800         	ldr	r0, [r0]
 805ca2e: 9000         	str	r0, [sp]
;     if( pxStreamBuffer->xHead == xTail )
 805ca30: 9802         	ldr	r0, [sp, #0x8]
 805ca32: 6840         	ldr	r0, [r0, #0x4]
 805ca34: 9900         	ldr	r1, [sp]
 805ca36: 4288         	cmp	r0, r1
 805ca38: d103         	bne	0x805ca42 <xStreamBufferIsEmpty+0x3a> @ imm = #0x6
 805ca3a: e7ff         	b	0x805ca3c <xStreamBufferIsEmpty+0x34> @ imm = #-0x2
 805ca3c: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
 805ca3e: 9001         	str	r0, [sp, #0x4]
;     }
 805ca40: e002         	b	0x805ca48 <xStreamBufferIsEmpty+0x40> @ imm = #0x4
 805ca42: 2000         	movs	r0, #0x0
;         xReturn = pdFALSE;
 805ca44: 9001         	str	r0, [sp, #0x4]
 805ca46: e7ff         	b	0x805ca48 <xStreamBufferIsEmpty+0x40> @ imm = #-0x2
;     return xReturn;
 805ca48: 9801         	ldr	r0, [sp, #0x4]
 805ca4a: b004         	add	sp, #0x10
 805ca4c: bc80         	pop	{r7}
 805ca4e: eba8 0809    	sub.w	r8, r8, r9
 805ca52: f858 fd34    	ldr	pc, [r8, #-52]!
 805ca56: bf00         	nop

0805ca58 <$d.31>:
 805ca58: 15 d7 05 08  	.word	0x0805d715

0805ca5c <xStreamBufferIsFull>:
; {
 805ca5c: f848 eb64    	str	lr, [r8], #100
 805ca60: eb08 0809    	add.w	r8, r8, r9
 805ca64: b480         	push	{r7}
 805ca66: 466f         	mov	r7, sp
 805ca68: b084         	sub	sp, #0x10
 805ca6a: 9003         	str	r0, [sp, #0xc]
;     const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 805ca6c: 9803         	ldr	r0, [sp, #0xc]
 805ca6e: 9000         	str	r0, [sp]
;     configASSERT( pxStreamBuffer );
 805ca70: 9800         	ldr	r0, [sp]
 805ca72: b920         	cbnz	r0, 0x805ca7e <xStreamBufferIsFull+0x22> @ imm = #0x8
 805ca74: e7ff         	b	0x805ca76 <xStreamBufferIsFull+0x1a> @ imm = #-0x2
 805ca76: 4812         	ldr	r0, [pc, #0x48]         @ 0x805cac0 <xStreamBufferIsFull+0x64>
 805ca78: 4780         	blx	r0
 805ca7a: e7ff         	b	0x805ca7c <xStreamBufferIsFull+0x20> @ imm = #-0x2
 805ca7c: e7fe         	b	0x805ca7c <xStreamBufferIsFull+0x20> @ imm = #-0x4
;     if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 805ca7e: 9800         	ldr	r0, [sp]
 805ca80: 7f00         	ldrb	r0, [r0, #0x1c]
 805ca82: 07c0         	lsls	r0, r0, #0x1f
 805ca84: b118         	cbz	r0, 0x805ca8e <xStreamBufferIsFull+0x32> @ imm = #0x6
 805ca86: e7ff         	b	0x805ca88 <xStreamBufferIsFull+0x2c> @ imm = #-0x2
 805ca88: 2004         	movs	r0, #0x4
;         xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 805ca8a: 9001         	str	r0, [sp, #0x4]
;     }
 805ca8c: e002         	b	0x805ca94 <xStreamBufferIsFull+0x38> @ imm = #0x4
 805ca8e: 2000         	movs	r0, #0x0
;         xBytesToStoreMessageLength = 0;
 805ca90: 9001         	str	r0, [sp, #0x4]
 805ca92: e7ff         	b	0x805ca94 <xStreamBufferIsFull+0x38> @ imm = #-0x2
;     if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
 805ca94: 9803         	ldr	r0, [sp, #0xc]
 805ca96: 4909         	ldr	r1, [pc, #0x24]         @ 0x805cabc <xStreamBufferIsFull+0x60>
 805ca98: 4788         	blx	r1
 805ca9a: 9901         	ldr	r1, [sp, #0x4]
 805ca9c: 4288         	cmp	r0, r1
 805ca9e: d803         	bhi	0x805caa8 <xStreamBufferIsFull+0x4c> @ imm = #0x6
 805caa0: e7ff         	b	0x805caa2 <xStreamBufferIsFull+0x46> @ imm = #-0x2
 805caa2: 2001         	movs	r0, #0x1
;         xReturn = pdTRUE;
 805caa4: 9002         	str	r0, [sp, #0x8]
;     }
 805caa6: e002         	b	0x805caae <xStreamBufferIsFull+0x52> @ imm = #0x4
 805caa8: 2000         	movs	r0, #0x0
;         xReturn = pdFALSE;
 805caaa: 9002         	str	r0, [sp, #0x8]
 805caac: e7ff         	b	0x805caae <xStreamBufferIsFull+0x52> @ imm = #-0x2
;     return xReturn;
 805caae: 9802         	ldr	r0, [sp, #0x8]
 805cab0: b004         	add	sp, #0x10
 805cab2: bc80         	pop	{r7}
 805cab4: eba8 0809    	sub.w	r8, r8, r9
 805cab8: f858 fd64    	ldr	pc, [r8, #-100]!

0805cabc <$d.33>:
 805cabc: 11 c1 05 08  	.word	0x0805c111
 805cac0: 15 d7 05 08  	.word	0x0805d715

0805cac4 <xStreamBufferSendCompletedFromISR>:
; {
 805cac4: f848 eb74    	str	lr, [r8], #116
 805cac8: eb08 0809    	add.w	r8, r8, r9
 805cacc: b480         	push	{r7}
 805cace: 466f         	mov	r7, sp
 805cad0: b088         	sub	sp, #0x20
 805cad2: 9007         	str	r0, [sp, #0x1c]
 805cad4: 9106         	str	r1, [sp, #0x18]
;     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 805cad6: 9807         	ldr	r0, [sp, #0x1c]
 805cad8: 9005         	str	r0, [sp, #0x14]
;     configASSERT( pxStreamBuffer );
 805cada: 9805         	ldr	r0, [sp, #0x14]
 805cadc: b920         	cbnz	r0, 0x805cae8 <xStreamBufferSendCompletedFromISR+0x24> @ imm = #0x8
 805cade: e7ff         	b	0x805cae0 <xStreamBufferSendCompletedFromISR+0x1c> @ imm = #-0x2
 805cae0: 4818         	ldr	r0, [pc, #0x60]         @ 0x805cb44 <xStreamBufferSendCompletedFromISR+0x80>
 805cae2: 4780         	blx	r0
 805cae4: e7ff         	b	0x805cae6 <xStreamBufferSendCompletedFromISR+0x22> @ imm = #-0x2
 805cae6: e7fe         	b	0x805cae6 <xStreamBufferSendCompletedFromISR+0x22> @ imm = #-0x4
;     uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
 805cae8: 4813         	ldr	r0, [pc, #0x4c]         @ 0x805cb38 <xStreamBufferSendCompletedFromISR+0x74>
 805caea: 4780         	blx	r0
 805caec: 9003         	str	r0, [sp, #0xc]
;         if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
 805caee: 9805         	ldr	r0, [sp, #0x14]
 805caf0: 6900         	ldr	r0, [r0, #0x10]
 805caf2: b198         	cbz	r0, 0x805cb1c <xStreamBufferSendCompletedFromISR+0x58> @ imm = #0x26
 805caf4: e7ff         	b	0x805caf6 <xStreamBufferSendCompletedFromISR+0x32> @ imm = #-0x2
;             ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
 805caf6: 9805         	ldr	r0, [sp, #0x14]
 805caf8: 6900         	ldr	r0, [r0, #0x10]
 805cafa: 9a06         	ldr	r2, [sp, #0x18]
 805cafc: 4669         	mov	r1, sp
 805cafe: 604a         	str	r2, [r1, #0x4]
 805cb00: 2300         	movs	r3, #0x0
 805cb02: 9302         	str	r3, [sp, #0x8]
 805cb04: 600b         	str	r3, [r1]
 805cb06: f8df c034    	ldr.w	r12, [pc, #0x34]        @ 0x805cb3c <xStreamBufferSendCompletedFromISR+0x78>
 805cb0a: 4619         	mov	r1, r3
 805cb0c: 461a         	mov	r2, r3
 805cb0e: 47e0         	blx	r12
;             ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
 805cb10: 9802         	ldr	r0, [sp, #0x8]
 805cb12: 9905         	ldr	r1, [sp, #0x14]
 805cb14: 6108         	str	r0, [r1, #0x10]
 805cb16: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
 805cb18: 9004         	str	r0, [sp, #0x10]
;         }
 805cb1a: e002         	b	0x805cb22 <xStreamBufferSendCompletedFromISR+0x5e> @ imm = #0x4
 805cb1c: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
 805cb1e: 9004         	str	r0, [sp, #0x10]
 805cb20: e7ff         	b	0x805cb22 <xStreamBufferSendCompletedFromISR+0x5e> @ imm = #-0x2
;     taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
 805cb22: 9803         	ldr	r0, [sp, #0xc]
 805cb24: 4906         	ldr	r1, [pc, #0x18]         @ 0x805cb40 <xStreamBufferSendCompletedFromISR+0x7c>
 805cb26: 4788         	blx	r1
;     return xReturn;
 805cb28: 9804         	ldr	r0, [sp, #0x10]
 805cb2a: b008         	add	sp, #0x20
 805cb2c: bc80         	pop	{r7}
 805cb2e: eba8 0809    	sub.w	r8, r8, r9
 805cb32: f858 fd74    	ldr	pc, [r8, #-116]!
 805cb36: bf00         	nop

0805cb38 <$d.35>:
 805cb38: 15 d7 05 08  	.word	0x0805d715
 805cb3c: 49 81 05 08  	.word	0x08058149
 805cb40: 2b d7 05 08  	.word	0x0805d72b
 805cb44: 15 d7 05 08  	.word	0x0805d715

0805cb48 <xStreamBufferReceiveCompletedFromISR>:
; {
 805cb48: f848 eb40    	str	lr, [r8], #64
 805cb4c: eb08 0809    	add.w	r8, r8, r9
 805cb50: b480         	push	{r7}
 805cb52: 466f         	mov	r7, sp
 805cb54: b088         	sub	sp, #0x20
 805cb56: 9007         	str	r0, [sp, #0x1c]
 805cb58: 9106         	str	r1, [sp, #0x18]
;     StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
 805cb5a: 9807         	ldr	r0, [sp, #0x1c]
 805cb5c: 9005         	str	r0, [sp, #0x14]
;     configASSERT( pxStreamBuffer );
 805cb5e: 9805         	ldr	r0, [sp, #0x14]
 805cb60: b920         	cbnz	r0, 0x805cb6c <xStreamBufferReceiveCompletedFromISR+0x24> @ imm = #0x8
 805cb62: e7ff         	b	0x805cb64 <xStreamBufferReceiveCompletedFromISR+0x1c> @ imm = #-0x2
 805cb64: 4818         	ldr	r0, [pc, #0x60]         @ 0x805cbc8 <xStreamBufferReceiveCompletedFromISR+0x80>
 805cb66: 4780         	blx	r0
 805cb68: e7ff         	b	0x805cb6a <xStreamBufferReceiveCompletedFromISR+0x22> @ imm = #-0x2
 805cb6a: e7fe         	b	0x805cb6a <xStreamBufferReceiveCompletedFromISR+0x22> @ imm = #-0x4
;     uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();
 805cb6c: 4813         	ldr	r0, [pc, #0x4c]         @ 0x805cbbc <xStreamBufferReceiveCompletedFromISR+0x74>
 805cb6e: 4780         	blx	r0
 805cb70: 9003         	str	r0, [sp, #0xc]
;         if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
 805cb72: 9805         	ldr	r0, [sp, #0x14]
 805cb74: 6940         	ldr	r0, [r0, #0x14]
 805cb76: b198         	cbz	r0, 0x805cba0 <xStreamBufferReceiveCompletedFromISR+0x58> @ imm = #0x26
 805cb78: e7ff         	b	0x805cb7a <xStreamBufferReceiveCompletedFromISR+0x32> @ imm = #-0x2
;             ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
 805cb7a: 9805         	ldr	r0, [sp, #0x14]
 805cb7c: 6940         	ldr	r0, [r0, #0x14]
 805cb7e: 9a06         	ldr	r2, [sp, #0x18]
 805cb80: 4669         	mov	r1, sp
 805cb82: 604a         	str	r2, [r1, #0x4]
 805cb84: 2300         	movs	r3, #0x0
 805cb86: 9302         	str	r3, [sp, #0x8]
 805cb88: 600b         	str	r3, [r1]
 805cb8a: f8df c034    	ldr.w	r12, [pc, #0x34]        @ 0x805cbc0 <xStreamBufferReceiveCompletedFromISR+0x78>
 805cb8e: 4619         	mov	r1, r3
 805cb90: 461a         	mov	r2, r3
 805cb92: 47e0         	blx	r12
;             ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
 805cb94: 9802         	ldr	r0, [sp, #0x8]
 805cb96: 9905         	ldr	r1, [sp, #0x14]
 805cb98: 6148         	str	r0, [r1, #0x14]
 805cb9a: 2001         	movs	r0, #0x1
;             xReturn = pdTRUE;
 805cb9c: 9004         	str	r0, [sp, #0x10]
;         }
 805cb9e: e002         	b	0x805cba6 <xStreamBufferReceiveCompletedFromISR+0x5e> @ imm = #0x4
 805cba0: 2000         	movs	r0, #0x0
;             xReturn = pdFALSE;
 805cba2: 9004         	str	r0, [sp, #0x10]
 805cba4: e7ff         	b	0x805cba6 <xStreamBufferReceiveCompletedFromISR+0x5e> @ imm = #-0x2
;     taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );
 805cba6: 9803         	ldr	r0, [sp, #0xc]
 805cba8: 4906         	ldr	r1, [pc, #0x18]         @ 0x805cbc4 <xStreamBufferReceiveCompletedFromISR+0x7c>
 805cbaa: 4788         	blx	r1
;     return xReturn;
 805cbac: 9804         	ldr	r0, [sp, #0x10]
 805cbae: b008         	add	sp, #0x20
 805cbb0: bc80         	pop	{r7}
 805cbb2: eba8 0809    	sub.w	r8, r8, r9
 805cbb6: f858 fd40    	ldr	pc, [r8, #-64]!
 805cbba: bf00         	nop

0805cbbc <$d.37>:
 805cbbc: 15 d7 05 08  	.word	0x0805d715
 805cbc0: 49 81 05 08  	.word	0x08058149
 805cbc4: 2b d7 05 08  	.word	0x0805d72b
 805cbc8: 15 d7 05 08  	.word	0x0805d715

0805cbcc <uxStreamBufferGetStreamBufferNumber>:
;     {
 805cbcc: b081         	sub	sp, #0x4
 805cbce: 9000         	str	r0, [sp]
;         return xStreamBuffer->uxStreamBufferNumber;
 805cbd0: 9800         	ldr	r0, [sp]
 805cbd2: 6a00         	ldr	r0, [r0, #0x20]
 805cbd4: b001         	add	sp, #0x4
 805cbd6: 4770         	bx	lr

0805cbd8 <vStreamBufferSetStreamBufferNumber>:
;     {
 805cbd8: b082         	sub	sp, #0x8
 805cbda: 9001         	str	r0, [sp, #0x4]
 805cbdc: 9100         	str	r1, [sp]
;         xStreamBuffer->uxStreamBufferNumber = uxStreamBufferNumber;
 805cbde: 9800         	ldr	r0, [sp]
 805cbe0: 9901         	ldr	r1, [sp, #0x4]
 805cbe2: 6208         	str	r0, [r1, #0x20]
;     }
 805cbe4: b002         	add	sp, #0x8
 805cbe6: 4770         	bx	lr

0805cbe8 <ucStreamBufferGetStreamBufferType>:
;     {
 805cbe8: b081         	sub	sp, #0x4
 805cbea: 9000         	str	r0, [sp]
;         return( ( uint8_t ) ( xStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) );
 805cbec: 9800         	ldr	r0, [sp]
 805cbee: 7f00         	ldrb	r0, [r0, #0x1c]
 805cbf0: f000 0001    	and	r0, r0, #0x1
 805cbf4: b001         	add	sp, #0x4
 805cbf6: 4770         	bx	lr

0805cbf8 <prvWriteBytesToBuffer>:
; {
 805cbf8: f848 eb3c    	str	lr, [r8], #60
 805cbfc: eb08 0809    	add.w	r8, r8, r9
 805cc00: b480         	push	{r7}
 805cc02: 466f         	mov	r7, sp
 805cc04: b086         	sub	sp, #0x18
 805cc06: 9005         	str	r0, [sp, #0x14]
 805cc08: 9104         	str	r1, [sp, #0x10]
 805cc0a: 9203         	str	r2, [sp, #0xc]
 805cc0c: 9302         	str	r3, [sp, #0x8]
;     configASSERT( xCount > ( size_t ) 0 );
 805cc0e: 9803         	ldr	r0, [sp, #0xc]
 805cc10: b920         	cbnz	r0, 0x805cc1c <prvWriteBytesToBuffer+0x24> @ imm = #0x8
 805cc12: e7ff         	b	0x805cc14 <prvWriteBytesToBuffer+0x1c> @ imm = #-0x2
 805cc14: 4833         	ldr	r0, [pc, #0xcc]         @ 0x805cce4 <prvWriteBytesToBuffer+0xec>
 805cc16: 4780         	blx	r0
 805cc18: e7ff         	b	0x805cc1a <prvWriteBytesToBuffer+0x22> @ imm = #-0x2
 805cc1a: e7fe         	b	0x805cc1a <prvWriteBytesToBuffer+0x22> @ imm = #-0x4
;     xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
 805cc1c: 9805         	ldr	r0, [sp, #0x14]
 805cc1e: 6880         	ldr	r0, [r0, #0x8]
 805cc20: 9902         	ldr	r1, [sp, #0x8]
 805cc22: 1a40         	subs	r0, r0, r1
 805cc24: 9903         	ldr	r1, [sp, #0xc]
 805cc26: 4288         	cmp	r0, r1
 805cc28: d206         	bhs	0x805cc38 <prvWriteBytesToBuffer+0x40> @ imm = #0xc
 805cc2a: e7ff         	b	0x805cc2c <prvWriteBytesToBuffer+0x34> @ imm = #-0x2
 805cc2c: 9805         	ldr	r0, [sp, #0x14]
 805cc2e: 6880         	ldr	r0, [r0, #0x8]
 805cc30: 9902         	ldr	r1, [sp, #0x8]
 805cc32: 1a40         	subs	r0, r0, r1
 805cc34: 9000         	str	r0, [sp]
 805cc36: e002         	b	0x805cc3e <prvWriteBytesToBuffer+0x46> @ imm = #0x4
 805cc38: 9803         	ldr	r0, [sp, #0xc]
 805cc3a: 9000         	str	r0, [sp]
 805cc3c: e7ff         	b	0x805cc3e <prvWriteBytesToBuffer+0x46> @ imm = #-0x2
 805cc3e: 9800         	ldr	r0, [sp]
 805cc40: 9001         	str	r0, [sp, #0x4]
;     configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
 805cc42: 9802         	ldr	r0, [sp, #0x8]
 805cc44: 9901         	ldr	r1, [sp, #0x4]
 805cc46: 4408         	add	r0, r1
 805cc48: 9905         	ldr	r1, [sp, #0x14]
 805cc4a: 6889         	ldr	r1, [r1, #0x8]
 805cc4c: 4288         	cmp	r0, r1
 805cc4e: d904         	bls	0x805cc5a <prvWriteBytesToBuffer+0x62> @ imm = #0x8
 805cc50: e7ff         	b	0x805cc52 <prvWriteBytesToBuffer+0x5a> @ imm = #-0x2
 805cc52: 4823         	ldr	r0, [pc, #0x8c]         @ 0x805cce0 <prvWriteBytesToBuffer+0xe8>
 805cc54: 4780         	blx	r0
 805cc56: e7ff         	b	0x805cc58 <prvWriteBytesToBuffer+0x60> @ imm = #-0x2
 805cc58: e7fe         	b	0x805cc58 <prvWriteBytesToBuffer+0x60> @ imm = #-0x4
;     ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 805cc5a: 9805         	ldr	r0, [sp, #0x14]
 805cc5c: 6980         	ldr	r0, [r0, #0x18]
 805cc5e: 9902         	ldr	r1, [sp, #0x8]
 805cc60: 4408         	add	r0, r1
 805cc62: 9904         	ldr	r1, [sp, #0x10]
 805cc64: 9a01         	ldr	r2, [sp, #0x4]
 805cc66: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x805ccd4 <prvWriteBytesToBuffer+0xdc>
 805cc68: 4798         	blx	r3
;     if( xCount > xFirstLength )
 805cc6a: 9803         	ldr	r0, [sp, #0xc]
 805cc6c: 9901         	ldr	r1, [sp, #0x4]
 805cc6e: 4288         	cmp	r0, r1
 805cc70: d916         	bls	0x805cca0 <prvWriteBytesToBuffer+0xa8> @ imm = #0x2c
 805cc72: e7ff         	b	0x805cc74 <prvWriteBytesToBuffer+0x7c> @ imm = #-0x2
;         configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
 805cc74: 9803         	ldr	r0, [sp, #0xc]
 805cc76: 9901         	ldr	r1, [sp, #0x4]
 805cc78: 1a40         	subs	r0, r0, r1
 805cc7a: 9905         	ldr	r1, [sp, #0x14]
 805cc7c: 6889         	ldr	r1, [r1, #0x8]
 805cc7e: 4288         	cmp	r0, r1
 805cc80: d904         	bls	0x805cc8c <prvWriteBytesToBuffer+0x94> @ imm = #0x8
 805cc82: e7ff         	b	0x805cc84 <prvWriteBytesToBuffer+0x8c> @ imm = #-0x2
 805cc84: 4815         	ldr	r0, [pc, #0x54]         @ 0x805ccdc <prvWriteBytesToBuffer+0xe4>
 805cc86: 4780         	blx	r0
 805cc88: e7ff         	b	0x805cc8a <prvWriteBytesToBuffer+0x92> @ imm = #-0x2
 805cc8a: e7fe         	b	0x805cc8a <prvWriteBytesToBuffer+0x92> @ imm = #-0x4
;         ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
 805cc8c: 9805         	ldr	r0, [sp, #0x14]
 805cc8e: 6980         	ldr	r0, [r0, #0x18]
 805cc90: 9904         	ldr	r1, [sp, #0x10]
 805cc92: 9b01         	ldr	r3, [sp, #0x4]
 805cc94: 4419         	add	r1, r3
 805cc96: 9a03         	ldr	r2, [sp, #0xc]
 805cc98: 1ad2         	subs	r2, r2, r3
 805cc9a: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x805ccd8 <prvWriteBytesToBuffer+0xe0>
 805cc9c: 4798         	blx	r3
;     }
 805cc9e: e000         	b	0x805cca2 <prvWriteBytesToBuffer+0xaa> @ imm = #0x0
 805cca0: e7ff         	b	0x805cca2 <prvWriteBytesToBuffer+0xaa> @ imm = #-0x2
;     xHead += xCount;
 805cca2: 9903         	ldr	r1, [sp, #0xc]
 805cca4: 9802         	ldr	r0, [sp, #0x8]
 805cca6: 4408         	add	r0, r1
 805cca8: 9002         	str	r0, [sp, #0x8]
;     if( xHead >= pxStreamBuffer->xLength )
 805ccaa: 9802         	ldr	r0, [sp, #0x8]
 805ccac: 9905         	ldr	r1, [sp, #0x14]
 805ccae: 6889         	ldr	r1, [r1, #0x8]
 805ccb0: 4288         	cmp	r0, r1
 805ccb2: d306         	blo	0x805ccc2 <prvWriteBytesToBuffer+0xca> @ imm = #0xc
 805ccb4: e7ff         	b	0x805ccb6 <prvWriteBytesToBuffer+0xbe> @ imm = #-0x2
;         xHead -= pxStreamBuffer->xLength;
 805ccb6: 9805         	ldr	r0, [sp, #0x14]
 805ccb8: 6881         	ldr	r1, [r0, #0x8]
 805ccba: 9802         	ldr	r0, [sp, #0x8]
 805ccbc: 1a40         	subs	r0, r0, r1
 805ccbe: 9002         	str	r0, [sp, #0x8]
;     }
 805ccc0: e000         	b	0x805ccc4 <prvWriteBytesToBuffer+0xcc> @ imm = #0x0
 805ccc2: e7ff         	b	0x805ccc4 <prvWriteBytesToBuffer+0xcc> @ imm = #-0x2
;     return xHead;
 805ccc4: 9802         	ldr	r0, [sp, #0x8]
 805ccc6: b006         	add	sp, #0x18
 805ccc8: bc80         	pop	{r7}
 805ccca: eba8 0809    	sub.w	r8, r8, r9
 805ccce: f858 fd3c    	ldr	pc, [r8, #-60]!
 805ccd2: bf00         	nop

0805ccd4 <$d.39>:
 805ccd4: c1 f8 05 08  	.word	0x0805f8c1
 805ccd8: c1 f8 05 08  	.word	0x0805f8c1
 805ccdc: 15 d7 05 08  	.word	0x0805d715
 805cce0: 15 d7 05 08  	.word	0x0805d715
 805cce4: 15 d7 05 08  	.word	0x0805d715

0805cce8 <vPortSetupTimerInterrupt>:
; {
 805cce8: f24e 0110    	movw	r1, #0xe010
 805ccec: f2ce 0100    	movt	r1, #0xe000
 805ccf0: 2004         	movs	r0, #0x4
;     portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT_CONFIG;
 805ccf2: 6008         	str	r0, [r1]
 805ccf4: f24e 0218    	movw	r2, #0xe018
 805ccf8: f2ce 0200    	movt	r2, #0xe000
 805ccfc: 2000         	movs	r0, #0x0
;     portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 805ccfe: 6010         	str	r0, [r2]
;     portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 805cd00: f242 3088    	movw	r0, #0x2388
 805cd04: f2c2 0000    	movt	r0, #0x2000
 805cd08: 6800         	ldr	r0, [r0]
 805cd0a: f644 52d3    	movw	r2, #0x4dd3
 805cd0e: f2c1 0262    	movt	r2, #0x1062
 805cd12: fba0 0202    	umull	r0, r2, r0, r2
 805cd16: f04f 30ff    	mov.w	r0, #0xffffffff
 805cd1a: eb00 1092    	add.w	r0, r0, r2, lsr #6
 805cd1e: f24e 0214    	movw	r2, #0xe014
 805cd22: f2ce 0200    	movt	r2, #0xe000
 805cd26: 6010         	str	r0, [r2]
 805cd28: 2007         	movs	r0, #0x7
;     portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
 805cd2a: 6008         	str	r0, [r1]
; }
 805cd2c: 4770         	bx	lr

0805cd2e <vPortYield>:
; {
 805cd2e: f64e 5104    	movw	r1, #0xed04
 805cd32: f2ce 0100    	movt	r1, #0xe000
 805cd36: f04f 5080    	mov.w	r0, #0x10000000
;     portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 805cd3a: 6008         	str	r0, [r1]
;     __asm volatile ( "dsb" ::: "memory" );
 805cd3c: f3bf 8f4f    	dsb	sy
;     __asm volatile ( "isb" );
 805cd40: f3bf 8f6f    	isb	sy
; }
 805cd44: 4770         	bx	lr
 805cd46: bf00         	nop

0805cd48 <vPortEnterCritical>:
; {
 805cd48: f848 eb40    	str	lr, [r8], #64
 805cd4c: eb08 0809    	add.w	r8, r8, r9
 805cd50: b480         	push	{r7}
 805cd52: 466f         	mov	r7, sp
;     portDISABLE_INTERRUPTS();
 805cd54: 4808         	ldr	r0, [pc, #0x20]         @ 0x805cd78 <vPortEnterCritical+0x30>
 805cd56: 4780         	blx	r0
;     ulCriticalNesting++;
 805cd58: f242 3178    	movw	r1, #0x2378
 805cd5c: f2c2 0100    	movt	r1, #0x2000
 805cd60: 6808         	ldr	r0, [r1]
 805cd62: 3001         	adds	r0, #0x1
 805cd64: 6008         	str	r0, [r1]
;     __asm volatile ( "dsb" ::: "memory" );
 805cd66: f3bf 8f4f    	dsb	sy
;     __asm volatile ( "isb" );
 805cd6a: f3bf 8f6f    	isb	sy
; }
 805cd6e: bc80         	pop	{r7}
 805cd70: eba8 0809    	sub.w	r8, r8, r9
 805cd74: f858 fd40    	ldr	pc, [r8, #-64]!

0805cd78 <$d.1>:
 805cd78: 15 d7 05 08  	.word	0x0805d715

0805cd7c <vPortExitCritical>:
; {
 805cd7c: f848 eb58    	str	lr, [r8], #88
 805cd80: eb08 0809    	add.w	r8, r8, r9
 805cd84: b480         	push	{r7}
 805cd86: 466f         	mov	r7, sp
;     configASSERT( ulCriticalNesting );
 805cd88: f242 3078    	movw	r0, #0x2378
 805cd8c: f2c2 0000    	movt	r0, #0x2000
 805cd90: 6800         	ldr	r0, [r0]
 805cd92: b920         	cbnz	r0, 0x805cd9e <vPortExitCritical+0x22> @ imm = #0x8
 805cd94: e7ff         	b	0x805cd96 <vPortExitCritical+0x1a> @ imm = #-0x2
 805cd96: 480c         	ldr	r0, [pc, #0x30]         @ 0x805cdc8 <vPortExitCritical+0x4c>
 805cd98: 4780         	blx	r0
 805cd9a: e7ff         	b	0x805cd9c <vPortExitCritical+0x20> @ imm = #-0x2
 805cd9c: e7fe         	b	0x805cd9c <vPortExitCritical+0x20> @ imm = #-0x4
;     ulCriticalNesting--;
 805cd9e: f242 3078    	movw	r0, #0x2378
 805cda2: f2c2 0000    	movt	r0, #0x2000
 805cda6: 6801         	ldr	r1, [r0]
 805cda8: 3901         	subs	r1, #0x1
 805cdaa: 6001         	str	r1, [r0]
;     if( ulCriticalNesting == 0 )
 805cdac: 6800         	ldr	r0, [r0]
 805cdae: b920         	cbnz	r0, 0x805cdba <vPortExitCritical+0x3e> @ imm = #0x8
 805cdb0: e7ff         	b	0x805cdb2 <vPortExitCritical+0x36> @ imm = #-0x2
;         portENABLE_INTERRUPTS();
 805cdb2: 4904         	ldr	r1, [pc, #0x10]         @ 0x805cdc4 <vPortExitCritical+0x48>
 805cdb4: 2000         	movs	r0, #0x0
 805cdb6: 4788         	blx	r1
;     }
 805cdb8: e7ff         	b	0x805cdba <vPortExitCritical+0x3e> @ imm = #-0x2
; }
 805cdba: bc80         	pop	{r7}
 805cdbc: eba8 0809    	sub.w	r8, r8, r9
 805cdc0: f858 fd58    	ldr	pc, [r8, #-88]!

0805cdc4 <$d.3>:
 805cdc4: 2b d7 05 08  	.word	0x0805d72b
 805cdc8: 15 d7 05 08  	.word	0x0805d715

0805cdcc <SysTick_Handler>:
; {
 805cdcc: f848 eb68    	str	lr, [r8], #104
 805cdd0: eb08 0809    	add.w	r8, r8, r9
 805cdd4: b480         	push	{r7}
 805cdd6: 466f         	mov	r7, sp
 805cdd8: b082         	sub	sp, #0x8
;     ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 805cdda: 480c         	ldr	r0, [pc, #0x30]         @ 0x805ce0c <SysTick_Handler+0x40>
 805cddc: 4780         	blx	r0
 805cdde: 9001         	str	r0, [sp, #0x4]
;         if( xTaskIncrementTick() != pdFALSE )
 805cde0: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805ce10 <SysTick_Handler+0x44>
 805cde2: 4780         	blx	r0
 805cde4: b140         	cbz	r0, 0x805cdf8 <SysTick_Handler+0x2c> @ imm = #0x10
 805cde6: e7ff         	b	0x805cde8 <SysTick_Handler+0x1c> @ imm = #-0x2
 805cde8: f64e 5104    	movw	r1, #0xed04
 805cdec: f2ce 0100    	movt	r1, #0xe000
 805cdf0: f04f 5080    	mov.w	r0, #0x10000000
;             portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 805cdf4: 6008         	str	r0, [r1]
;         }
 805cdf6: e000         	b	0x805cdfa <SysTick_Handler+0x2e> @ imm = #0x0
 805cdf8: e7ff         	b	0x805cdfa <SysTick_Handler+0x2e> @ imm = #-0x2
;     portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 805cdfa: 9801         	ldr	r0, [sp, #0x4]
 805cdfc: 4905         	ldr	r1, [pc, #0x14]         @ 0x805ce14 <SysTick_Handler+0x48>
 805cdfe: 4788         	blx	r1
; }
 805ce00: b002         	add	sp, #0x8
 805ce02: bc80         	pop	{r7}
 805ce04: eba8 0809    	sub.w	r8, r8, r9
 805ce08: f858 fd68    	ldr	pc, [r8, #-104]!

0805ce0c <$d.5>:
 805ce0c: 15 d7 05 08  	.word	0x0805d715
 805ce10: 2d 68 05 08  	.word	0x0805682d
 805ce14: 2b d7 05 08  	.word	0x0805d72b

0805ce18 <vPortSVCHandler_C>:
; {
 805ce18: f848 eb60    	str	lr, [r8], #96
 805ce1c: eb08 0809    	add.w	r8, r8, r9
 805ce20: b480         	push	{r7}
 805ce22: 466f         	mov	r7, sp
 805ce24: b084         	sub	sp, #0x10
 805ce26: 9003         	str	r0, [sp, #0xc]
;     ulPC = pulCallerStackAddress[ portOFFSET_TO_PC ];
 805ce28: 9803         	ldr	r0, [sp, #0xc]
 805ce2a: 6980         	ldr	r0, [r0, #0x18]
 805ce2c: 9002         	str	r0, [sp, #0x8]
;     ucSVCNumber = ( ( uint8_t * ) ulPC )[ -2 ];
 805ce2e: 9802         	ldr	r0, [sp, #0x8]
 805ce30: f810 0c02    	ldrb	r0, [r0, #-2]
 805ce34: f807 0c09    	strb	r0, [r7, #-9]
;     switch( ucSVCNumber )
 805ce38: f817 0c09    	ldrb	r0, [r7, #-9]
 805ce3c: 4601         	mov	r1, r0
 805ce3e: 9100         	str	r1, [sp]
 805ce40: 2802         	cmp	r0, #0x2
 805ce42: d008         	beq	0x805ce56 <vPortSVCHandler_C+0x3e> @ imm = #0x10
 805ce44: e7ff         	b	0x805ce46 <vPortSVCHandler_C+0x2e> @ imm = #-0x2
 805ce46: 9800         	ldr	r0, [sp]
 805ce48: 2803         	cmp	r0, #0x3
 805ce4a: d007         	beq	0x805ce5c <vPortSVCHandler_C+0x44> @ imm = #0xe
 805ce4c: e7ff         	b	0x805ce4e <vPortSVCHandler_C+0x36> @ imm = #-0x2
 805ce4e: 9800         	ldr	r0, [sp]
 805ce50: 2807         	cmp	r0, #0x7
 805ce52: d017         	beq	0x805ce84 <vPortSVCHandler_C+0x6c> @ imm = #0x2e
 805ce54: e019         	b	0x805ce8a <vPortSVCHandler_C+0x72> @ imm = #0x32
;             vRestoreContextOfFirstTask();
 805ce56: 4814         	ldr	r0, [pc, #0x50]         @ 0x805cea8 <vPortSVCHandler_C+0x90>
 805ce58: 4780         	blx	r0
;             break;
 805ce5a: e01a         	b	0x805ce92 <vPortSVCHandler_C+0x7a> @ imm = #0x34
;                     if( ( ulPC >= ( uint32_t ) __syscalls_flash_start__ ) &&
 805ce5c: 9802         	ldr	r0, [sp, #0x8]
 805ce5e: f64d 0120    	movw	r1, #0xd820
 805ce62: f6c0 0105    	movt	r1, #0x805
 805ce66: 4288         	cmp	r0, r1
 805ce68: d30b         	blo	0x805ce82 <vPortSVCHandler_C+0x6a> @ imm = #0x16
 805ce6a: e7ff         	b	0x805ce6c <vPortSVCHandler_C+0x54> @ imm = #-0x2
;                         ( ulPC <= ( uint32_t ) __syscalls_flash_end__ ) )
 805ce6c: 9802         	ldr	r0, [sp, #0x8]
 805ce6e: f64e 219f    	movw	r1, #0xea9f
 805ce72: f6c0 0105    	movt	r1, #0x805
;                     if( ( ulPC >= ( uint32_t ) __syscalls_flash_start__ ) &&
 805ce76: 4288         	cmp	r0, r1
 805ce78: d803         	bhi	0x805ce82 <vPortSVCHandler_C+0x6a> @ imm = #0x6
 805ce7a: e7ff         	b	0x805ce7c <vPortSVCHandler_C+0x64> @ imm = #-0x2
;                         vRaisePrivilege();
 805ce7c: 4809         	ldr	r0, [pc, #0x24]         @ 0x805cea4 <vPortSVCHandler_C+0x8c>
 805ce7e: 4780         	blx	r0
;                     }
 805ce80: e7ff         	b	0x805ce82 <vPortSVCHandler_C+0x6a> @ imm = #-0x2
;                     break;
 805ce82: e006         	b	0x805ce92 <vPortSVCHandler_C+0x7a> @ imm = #0xc
;                     vPortYield();
 805ce84: 4806         	ldr	r0, [pc, #0x18]         @ 0x805cea0 <vPortSVCHandler_C+0x88>
 805ce86: 4780         	blx	r0
;                     break;
 805ce88: e003         	b	0x805ce92 <vPortSVCHandler_C+0x7a> @ imm = #0x6
;             configASSERT( pdFALSE );
 805ce8a: 4808         	ldr	r0, [pc, #0x20]         @ 0x805ceac <vPortSVCHandler_C+0x94>
 805ce8c: 4780         	blx	r0
 805ce8e: e7ff         	b	0x805ce90 <vPortSVCHandler_C+0x78> @ imm = #-0x2
 805ce90: e7fe         	b	0x805ce90 <vPortSVCHandler_C+0x78> @ imm = #-0x4
; }
 805ce92: b004         	add	sp, #0x10
 805ce94: bc80         	pop	{r7}
 805ce96: eba8 0809    	sub.w	r8, r8, r9
 805ce9a: f858 fd60    	ldr	pc, [r8, #-96]!
 805ce9e: bf00         	nop

0805cea0 <$d.7>:
 805cea0: 2f cd 05 08  	.word	0x0805cd2f
 805cea4: e5 d6 05 08  	.word	0x0805d6e5
 805cea8: 61 d6 05 08  	.word	0x0805d661
 805ceac: 15 d7 05 08  	.word	0x0805d715

0805ceb0 <xPortIsTaskPrivileged>:
;     {
 805ceb0: f848 eb08    	str	lr, [r8], #8
 805ceb4: eb08 0809    	add.w	r8, r8, r9
 805ceb8: b480         	push	{r7}
 805ceba: 466f         	mov	r7, sp
 805cebc: b082         	sub	sp, #0x8
 805cebe: 2000         	movs	r0, #0x0
;         BaseType_t xTaskIsPrivileged = pdFALSE;
 805cec0: 9001         	str	r0, [sp, #0x4]
;         const xMPU_SETTINGS * xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling task's MPU settings. */
 805cec2: 490a         	ldr	r1, [pc, #0x28]         @ 0x805ceec <xPortIsTaskPrivileged+0x3c>
 805cec4: 4788         	blx	r1
 805cec6: 9000         	str	r0, [sp]
;         if( ( xTaskMpuSettings->ulTaskFlags & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )
 805cec8: 9800         	ldr	r0, [sp]
 805ceca: f890 0078    	ldrb.w	r0, [r0, #0x78]
 805cece: 0780         	lsls	r0, r0, #0x1e
 805ced0: 2800         	cmp	r0, #0x0
 805ced2: d503         	bpl	0x805cedc <xPortIsTaskPrivileged+0x2c> @ imm = #0x6
 805ced4: e7ff         	b	0x805ced6 <xPortIsTaskPrivileged+0x26> @ imm = #-0x2
 805ced6: 2001         	movs	r0, #0x1
;             xTaskIsPrivileged = pdTRUE;
 805ced8: 9001         	str	r0, [sp, #0x4]
;         }
 805ceda: e7ff         	b	0x805cedc <xPortIsTaskPrivileged+0x2c> @ imm = #-0x2
;         return xTaskIsPrivileged;
 805cedc: 9801         	ldr	r0, [sp, #0x4]
 805cede: b002         	add	sp, #0x8
 805cee0: bc80         	pop	{r7}
 805cee2: eba8 0809    	sub.w	r8, r8, r9
 805cee6: f858 fd08    	ldr	pc, [r8, #-8]!
 805ceea: bf00         	nop

0805ceec <$d.9>:
 805ceec: 65 87 05 08  	.word	0x08058765

0805cef0 <pxPortInitialiseStack>:
;     {
 805cef0: b085         	sub	sp, #0x14
 805cef2: f8dd c018    	ldr.w	r12, [sp, #0x18]
 805cef6: f8dd c014    	ldr.w	r12, [sp, #0x14]
 805cefa: 9004         	str	r0, [sp, #0x10]
 805cefc: 9103         	str	r1, [sp, #0xc]
 805cefe: 9202         	str	r2, [sp, #0x8]
 805cf00: 9301         	str	r3, [sp, #0x4]
 805cf02: 2000         	movs	r0, #0x0
;         uint32_t ulIndex = 0;
 805cf04: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = 0x04040404; /* r4. */
 805cf06: 9806         	ldr	r0, [sp, #0x18]
 805cf08: 9900         	ldr	r1, [sp]
 805cf0a: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805cf0e: f04f 3004    	mov.w	r0, #0x4040404
 805cf12: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805cf14: 9800         	ldr	r0, [sp]
 805cf16: 3001         	adds	r0, #0x1
 805cf18: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = 0x05050505; /* r5. */
 805cf1a: 9806         	ldr	r0, [sp, #0x18]
 805cf1c: 9900         	ldr	r1, [sp]
 805cf1e: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805cf22: f04f 3005    	mov.w	r0, #0x5050505
 805cf26: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805cf28: 9800         	ldr	r0, [sp]
 805cf2a: 3001         	adds	r0, #0x1
 805cf2c: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = 0x06060606; /* r6. */
 805cf2e: 9806         	ldr	r0, [sp, #0x18]
 805cf30: 9900         	ldr	r1, [sp]
 805cf32: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805cf36: f04f 3006    	mov.w	r0, #0x6060606
 805cf3a: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805cf3c: 9800         	ldr	r0, [sp]
 805cf3e: 3001         	adds	r0, #0x1
 805cf40: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = 0x07070707; /* r7. */
 805cf42: 9806         	ldr	r0, [sp, #0x18]
 805cf44: 9900         	ldr	r1, [sp]
 805cf46: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805cf4a: f04f 3007    	mov.w	r0, #0x7070707
 805cf4e: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805cf50: 9800         	ldr	r0, [sp]
 805cf52: 3001         	adds	r0, #0x1
 805cf54: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = 0x08080808; /* r8. */
 805cf56: 9806         	ldr	r0, [sp, #0x18]
 805cf58: 9900         	ldr	r1, [sp]
 805cf5a: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805cf5e: f04f 3008    	mov.w	r0, #0x8080808
 805cf62: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805cf64: 9800         	ldr	r0, [sp]
 805cf66: 3001         	adds	r0, #0x1
 805cf68: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = 0x09090909; /* r9. */
 805cf6a: 9806         	ldr	r0, [sp, #0x18]
 805cf6c: 9900         	ldr	r1, [sp]
 805cf6e: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805cf72: f04f 3009    	mov.w	r0, #0x9090909
 805cf76: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805cf78: 9800         	ldr	r0, [sp]
 805cf7a: 3001         	adds	r0, #0x1
 805cf7c: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = 0x10101010; /* r10. */
 805cf7e: 9806         	ldr	r0, [sp, #0x18]
 805cf80: 9900         	ldr	r1, [sp]
 805cf82: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805cf86: f04f 3010    	mov.w	r0, #0x10101010
 805cf8a: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805cf8c: 9800         	ldr	r0, [sp]
 805cf8e: 3001         	adds	r0, #0x1
 805cf90: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = 0x11111111; /* r11. */
 805cf92: 9806         	ldr	r0, [sp, #0x18]
 805cf94: 9900         	ldr	r1, [sp]
 805cf96: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805cf9a: f04f 3011    	mov.w	r0, #0x11111111
 805cf9e: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805cfa0: 9800         	ldr	r0, [sp]
 805cfa2: 3001         	adds	r0, #0x1
 805cfa4: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) pvParameters;            /* r0. */
 805cfa6: 9801         	ldr	r0, [sp, #0x4]
 805cfa8: 9906         	ldr	r1, [sp, #0x18]
 805cfaa: 9a00         	ldr	r2, [sp]
 805cfac: eb01 0182    	add.w	r1, r1, r2, lsl #2
 805cfb0: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805cfb2: 9800         	ldr	r0, [sp]
 805cfb4: 3001         	adds	r0, #0x1
 805cfb6: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = 0x01010101;                           /* r1. */
 805cfb8: 9806         	ldr	r0, [sp, #0x18]
 805cfba: 9900         	ldr	r1, [sp]
 805cfbc: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805cfc0: f04f 3001    	mov.w	r0, #0x1010101
 805cfc4: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805cfc6: 9800         	ldr	r0, [sp]
 805cfc8: 3001         	adds	r0, #0x1
 805cfca: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = 0x02020202;                           /* r2. */
 805cfcc: 9806         	ldr	r0, [sp, #0x18]
 805cfce: 9900         	ldr	r1, [sp]
 805cfd0: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805cfd4: f04f 3002    	mov.w	r0, #0x2020202
 805cfd8: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805cfda: 9800         	ldr	r0, [sp]
 805cfdc: 3001         	adds	r0, #0x1
 805cfde: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = 0x03030303;                           /* r3. */
 805cfe0: 9806         	ldr	r0, [sp, #0x18]
 805cfe2: 9900         	ldr	r1, [sp]
 805cfe4: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805cfe8: f04f 3003    	mov.w	r0, #0x3030303
 805cfec: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805cfee: 9800         	ldr	r0, [sp]
 805cff0: 3001         	adds	r0, #0x1
 805cff2: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = 0x12121212;                           /* r12. */
 805cff4: 9806         	ldr	r0, [sp, #0x18]
 805cff6: 9900         	ldr	r1, [sp]
 805cff8: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805cffc: f04f 3012    	mov.w	r0, #0x12121212
 805d000: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805d002: 9800         	ldr	r0, [sp]
 805d004: 3001         	adds	r0, #0x1
 805d006: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) portTASK_RETURN_ADDRESS; /* LR. */
 805d008: 9806         	ldr	r0, [sp, #0x18]
 805d00a: 9900         	ldr	r1, [sp]
 805d00c: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805d010: f24f 70d1    	movw	r0, #0xf7d1
 805d014: f6c0 0005    	movt	r0, #0x805
 805d018: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805d01a: 9800         	ldr	r0, [sp]
 805d01c: 3001         	adds	r0, #0x1
 805d01e: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) pxCode;                  /* PC. */
 805d020: 9802         	ldr	r0, [sp, #0x8]
 805d022: 9906         	ldr	r1, [sp, #0x18]
 805d024: 9a00         	ldr	r2, [sp]
 805d026: eb01 0182    	add.w	r1, r1, r2, lsl #2
 805d02a: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805d02c: 9800         	ldr	r0, [sp]
 805d02e: 3001         	adds	r0, #0x1
 805d030: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = portINITIAL_XPSR;                     /* xPSR. */
 805d032: 9806         	ldr	r0, [sp, #0x18]
 805d034: 9900         	ldr	r1, [sp]
 805d036: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805d03a: f04f 7080    	mov.w	r0, #0x1000000
 805d03e: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805d040: 9800         	ldr	r0, [sp]
 805d042: 3001         	adds	r0, #0x1
 805d044: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) ( pxTopOfStack - 8 ); /* PSP with the hardware saved stack. */
 805d046: 9804         	ldr	r0, [sp, #0x10]
 805d048: 3820         	subs	r0, #0x20
 805d04a: 9906         	ldr	r1, [sp, #0x18]
 805d04c: 9a00         	ldr	r2, [sp]
 805d04e: eb01 0182    	add.w	r1, r1, r2, lsl #2
 805d052: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805d054: 9800         	ldr	r0, [sp]
 805d056: 3001         	adds	r0, #0x1
 805d058: 9000         	str	r0, [sp]
;         xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) pxEndOfStack;         /* PSPLIM. */
 805d05a: 9803         	ldr	r0, [sp, #0xc]
 805d05c: 9906         	ldr	r1, [sp, #0x18]
 805d05e: 9a00         	ldr	r2, [sp]
 805d060: eb01 0182    	add.w	r1, r1, r2, lsl #2
 805d064: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805d066: 9800         	ldr	r0, [sp]
 805d068: 3001         	adds	r0, #0x1
 805d06a: 9000         	str	r0, [sp]
;         if( xRunPrivileged == pdTRUE )
 805d06c: 9805         	ldr	r0, [sp, #0x14]
 805d06e: 2801         	cmp	r0, #0x1
 805d070: d10f         	bne	0x805d092 <pxPortInitialiseStack+0x1a2> @ imm = #0x1e
 805d072: e7ff         	b	0x805d074 <pxPortInitialiseStack+0x184> @ imm = #-0x2
;             xMPUSettings->ulTaskFlags |= portTASK_IS_PRIVILEGED_FLAG;
 805d074: 9906         	ldr	r1, [sp, #0x18]
 805d076: 6f88         	ldr	r0, [r1, #0x78]
 805d078: f040 0002    	orr	r0, r0, #0x2
 805d07c: 6788         	str	r0, [r1, #0x78]
;             xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) portINITIAL_CONTROL_PRIVILEGED; /* CONTROL. */
 805d07e: 9806         	ldr	r0, [sp, #0x18]
 805d080: 9900         	ldr	r1, [sp]
 805d082: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805d086: 2002         	movs	r0, #0x2
 805d088: 6248         	str	r0, [r1, #0x24]
;             ulIndex++;
 805d08a: 9800         	ldr	r0, [sp]
 805d08c: 3001         	adds	r0, #0x1
 805d08e: 9000         	str	r0, [sp]
;         }
 805d090: e00e         	b	0x805d0b0 <pxPortInitialiseStack+0x1c0> @ imm = #0x1c
;             xMPUSettings->ulTaskFlags &= ( ~portTASK_IS_PRIVILEGED_FLAG );
 805d092: 9906         	ldr	r1, [sp, #0x18]
 805d094: 6f88         	ldr	r0, [r1, #0x78]
 805d096: f020 0002    	bic	r0, r0, #0x2
 805d09a: 6788         	str	r0, [r1, #0x78]
;             xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) portINITIAL_CONTROL_UNPRIVILEGED; /* CONTROL. */
 805d09c: 9806         	ldr	r0, [sp, #0x18]
 805d09e: 9900         	ldr	r1, [sp]
 805d0a0: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805d0a4: 2003         	movs	r0, #0x3
 805d0a6: 6248         	str	r0, [r1, #0x24]
;             ulIndex++;
 805d0a8: 9800         	ldr	r0, [sp]
 805d0aa: 3001         	adds	r0, #0x1
 805d0ac: 9000         	str	r0, [sp]
 805d0ae: e7ff         	b	0x805d0b0 <pxPortInitialiseStack+0x1c0> @ imm = #-0x2
;         xMPUSettings->ulContext[ ulIndex ] = portINITIAL_EXC_RETURN; /* LR (EXC_RETURN). */
 805d0b0: 9806         	ldr	r0, [sp, #0x18]
 805d0b2: 9900         	ldr	r1, [sp]
 805d0b4: eb00 0181    	add.w	r1, r0, r1, lsl #2
 805d0b8: f06f 0043    	mvn	r0, #0x43
 805d0bc: 6248         	str	r0, [r1, #0x24]
;         ulIndex++;
 805d0be: 9800         	ldr	r0, [sp]
 805d0c0: 3001         	adds	r0, #0x1
 805d0c2: 9000         	str	r0, [sp]
;         return &( xMPUSettings->ulContext[ ulIndex ] );
 805d0c4: 9806         	ldr	r0, [sp, #0x18]
 805d0c6: 9900         	ldr	r1, [sp]
 805d0c8: eb00 0081    	add.w	r0, r0, r1, lsl #2
 805d0cc: 3024         	adds	r0, #0x24
 805d0ce: b005         	add	sp, #0x14
 805d0d0: 4770         	bx	lr
 805d0d2: bf00         	nop

0805d0d4 <xPortStartScheduler>:
; {
 805d0d4: f848 eb40    	str	lr, [r8], #64
 805d0d8: eb08 0809    	add.w	r8, r8, r9
 805d0dc: b480         	push	{r7}
 805d0de: 466f         	mov	r7, sp
 805d0e0: b084         	sub	sp, #0x10
 805d0e2: 2000         	movs	r0, #0x0
;         volatile uint32_t ulImplementedPrioBits = 0;
 805d0e4: 9002         	str	r0, [sp, #0x8]
 805d0e6: f64e 501c    	movw	r0, #0xed1c
 805d0ea: f2ce 0000    	movt	r0, #0xe000
;         ulOriginalPriority = portNVIC_SHPR2_REG;
 805d0ee: 6801         	ldr	r1, [r0]
 805d0f0: 9103         	str	r1, [sp, #0xc]
 805d0f2: f04f 417f    	mov.w	r1, #0xff000000
;         portNVIC_SHPR2_REG = 0xFF000000;
 805d0f6: 6001         	str	r1, [r0]
;         ucMaxPriorityValue = ( uint8_t ) ( ( portNVIC_SHPR2_REG & 0xFF000000 ) >> 24 );
 805d0f8: 6800         	ldr	r0, [r0]
 805d0fa: 0e00         	lsrs	r0, r0, #0x18
 805d0fc: f807 0c09    	strb	r0, [r7, #-9]
;         ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 805d100: f817 0c09    	ldrb	r0, [r7, #-9]
 805d104: f000 01a0    	and	r1, r0, #0xa0
 805d108: f242 50c0    	movw	r0, #0x25c0
 805d10c: f2c2 0000    	movt	r0, #0x2000
 805d110: 7001         	strb	r1, [r0]
;         configASSERT( ucMaxSysCallPriority );
 805d112: 7800         	ldrb	r0, [r0]
 805d114: b920         	cbnz	r0, 0x805d120 <xPortStartScheduler+0x4c> @ imm = #0x8
 805d116: e7ff         	b	0x805d118 <xPortStartScheduler+0x44> @ imm = #-0x2
 805d118: 4839         	ldr	r0, [pc, #0xe4]         @ 0x805d200 <xPortStartScheduler+0x12c>
 805d11a: 4780         	blx	r0
 805d11c: e7ff         	b	0x805d11e <xPortStartScheduler+0x4a> @ imm = #-0x2
 805d11e: e7fe         	b	0x805d11e <xPortStartScheduler+0x4a> @ imm = #-0x4
;         configASSERT( ( configMAX_SYSCALL_INTERRUPT_PRIORITY & ( uint8_t ) ( ~( uint32_t ) ucMaxPriorityValue ) ) == 0U );
 805d120: f817 0c09    	ldrb	r0, [r7, #-9]
 805d124: 43c0         	mvns	r0, r0
 805d126: f010 0fa0    	tst.w	r0, #0xa0
 805d12a: d004         	beq	0x805d136 <xPortStartScheduler+0x62> @ imm = #0x8
 805d12c: e7ff         	b	0x805d12e <xPortStartScheduler+0x5a> @ imm = #-0x2
 805d12e: 4833         	ldr	r0, [pc, #0xcc]         @ 0x805d1fc <xPortStartScheduler+0x128>
 805d130: 4780         	blx	r0
 805d132: e7ff         	b	0x805d134 <xPortStartScheduler+0x60> @ imm = #-0x2
 805d134: e7fe         	b	0x805d134 <xPortStartScheduler+0x60> @ imm = #-0x4
;         while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 805d136: e7ff         	b	0x805d138 <xPortStartScheduler+0x64> @ imm = #-0x2
 805d138: f817 0c09    	ldrb	r0, [r7, #-9]
 805d13c: 0600         	lsls	r0, r0, #0x18
 805d13e: 2800         	cmp	r0, #0x0
 805d140: d509         	bpl	0x805d156 <xPortStartScheduler+0x82> @ imm = #0x12
 805d142: e7ff         	b	0x805d144 <xPortStartScheduler+0x70> @ imm = #-0x2
;             ulImplementedPrioBits++;
 805d144: 9802         	ldr	r0, [sp, #0x8]
 805d146: 3001         	adds	r0, #0x1
 805d148: 9002         	str	r0, [sp, #0x8]
;             ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 805d14a: f817 0c09    	ldrb	r0, [r7, #-9]
 805d14e: 0040         	lsls	r0, r0, #0x1
 805d150: f807 0c09    	strb	r0, [r7, #-9]
;         while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 805d154: e7f0         	b	0x805d138 <xPortStartScheduler+0x64> @ imm = #-0x20
;         if( ulImplementedPrioBits == 8 )
 805d156: 9802         	ldr	r0, [sp, #0x8]
 805d158: 2808         	cmp	r0, #0x8
 805d15a: d107         	bne	0x805d16c <xPortStartScheduler+0x98> @ imm = #0xe
 805d15c: e7ff         	b	0x805d15e <xPortStartScheduler+0x8a> @ imm = #-0x2
;             ulMaxPRIGROUPValue = 0;
 805d15e: f242 51c4    	movw	r1, #0x25c4
 805d162: f2c2 0100    	movt	r1, #0x2000
 805d166: 2000         	movs	r0, #0x0
 805d168: 6008         	str	r0, [r1]
;         }
 805d16a: e008         	b	0x805d17e <xPortStartScheduler+0xaa> @ imm = #0x10
;             ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS - ulImplementedPrioBits;
 805d16c: 9802         	ldr	r0, [sp, #0x8]
 805d16e: f1c0 0007    	rsb.w	r0, r0, #0x7
 805d172: f242 51c4    	movw	r1, #0x25c4
 805d176: f2c2 0100    	movt	r1, #0x2000
 805d17a: 6008         	str	r0, [r1]
 805d17c: e7ff         	b	0x805d17e <xPortStartScheduler+0xaa> @ imm = #-0x2
;         ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 805d17e: f242 51c4    	movw	r1, #0x25c4
 805d182: f2c2 0100    	movt	r1, #0x2000
 805d186: 6808         	ldr	r0, [r1]
 805d188: 0200         	lsls	r0, r0, #0x8
 805d18a: 6008         	str	r0, [r1]
;         ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 805d18c: 6808         	ldr	r0, [r1]
 805d18e: f400 60e0    	and	r0, r0, #0x700
 805d192: 6008         	str	r0, [r1]
;         portNVIC_SHPR2_REG = ulOriginalPriority;
 805d194: 9803         	ldr	r0, [sp, #0xc]
 805d196: f64e 511c    	movw	r1, #0xed1c
 805d19a: f2ce 0100    	movt	r1, #0xe000
 805d19e: 6008         	str	r0, [r1]
 805d1a0: f64e 5120    	movw	r1, #0xed20
 805d1a4: f2ce 0100    	movt	r1, #0xe000
;     portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
 805d1a8: 6808         	ldr	r0, [r1]
 805d1aa: f440 007f    	orr	r0, r0, #0xff0000
 805d1ae: 6008         	str	r0, [r1]
;     portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 805d1b0: 6808         	ldr	r0, [r1]
 805d1b2: f040 407f    	orr	r0, r0, #0xff000000
 805d1b6: 6008         	str	r0, [r1]
;         prvSetupMPU();
 805d1b8: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805d1e8 <xPortStartScheduler+0x114>
 805d1ba: 4780         	blx	r0
;     vPortSetupTimerInterrupt();
 805d1bc: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805d1ec <xPortStartScheduler+0x118>
 805d1be: 4780         	blx	r0
;     ulCriticalNesting = 0;
 805d1c0: f242 3178    	movw	r1, #0x2378
 805d1c4: f2c2 0100    	movt	r1, #0x2000
 805d1c8: 2000         	movs	r0, #0x0
 805d1ca: 9000         	str	r0, [sp]
 805d1cc: 6008         	str	r0, [r1]
;     vStartFirstTask();
 805d1ce: 4808         	ldr	r0, [pc, #0x20]         @ 0x805d1f0 <xPortStartScheduler+0x11c>
 805d1d0: 4780         	blx	r0
;     vTaskSwitchContext();
 805d1d2: 4808         	ldr	r0, [pc, #0x20]         @ 0x805d1f4 <xPortStartScheduler+0x120>
 805d1d4: 4780         	blx	r0
;     prvTaskExitError();
 805d1d6: 4808         	ldr	r0, [pc, #0x20]         @ 0x805d1f8 <xPortStartScheduler+0x124>
 805d1d8: 4780         	blx	r0
 805d1da: 9800         	ldr	r0, [sp]
;     return 0;
 805d1dc: b004         	add	sp, #0x10
 805d1de: bc80         	pop	{r7}
 805d1e0: eba8 0809    	sub.w	r8, r8, r9
 805d1e4: f858 fd40    	ldr	pc, [r8, #-64]!

0805d1e8 <$d.13>:
 805d1e8: 05 d2 05 08  	.word	0x0805d205
 805d1ec: e9 cc 05 08  	.word	0x0805cce9
 805d1f0: f3 d6 05 08  	.word	0x0805d6f3
 805d1f4: 61 63 05 08  	.word	0x08056361
 805d1f8: d1 f7 05 08  	.word	0x0805f7d1
 805d1fc: 15 d7 05 08  	.word	0x0805d715
 805d200: 15 d7 05 08  	.word	0x0805d715

0805d204 <prvSetupMPU>:
;     {
 805d204: f848 eb04    	str	lr, [r8], #4
 805d208: eb08 0809    	add.w	r8, r8, r9
 805d20c: b480         	push	{r7}
 805d20e: 466f         	mov	r7, sp
 805d210: f64e 5090    	movw	r0, #0xed90
 805d214: f2ce 0000    	movt	r0, #0xe000
;         configASSERT( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE );
 805d218: 6800         	ldr	r0, [r0]
 805d21a: f5b0 6f00    	cmp.w	r0, #0x800
 805d21e: d004         	beq	0x805d22a <prvSetupMPU+0x26> @ imm = #0x8
 805d220: e7ff         	b	0x805d222 <prvSetupMPU+0x1e> @ imm = #-0x2
 805d222: 4841         	ldr	r0, [pc, #0x104]        @ 0x805d328 <prvSetupMPU+0x124>
 805d224: 4780         	blx	r0
 805d226: e7ff         	b	0x805d228 <prvSetupMPU+0x24> @ imm = #-0x2
 805d228: e7fe         	b	0x805d228 <prvSetupMPU+0x24> @ imm = #-0x4
 805d22a: f64e 5090    	movw	r0, #0xed90
 805d22e: f2ce 0000    	movt	r0, #0xe000
;         if( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )
 805d232: 6800         	ldr	r0, [r0]
 805d234: f5b0 6f00    	cmp.w	r0, #0x800
 805d238: d170         	bne	0x805d31c <prvSetupMPU+0x118> @ imm = #0xe0
 805d23a: e7ff         	b	0x805d23c <prvSetupMPU+0x38> @ imm = #-0x2
 805d23c: f64e 51c0    	movw	r1, #0xedc0
 805d240: f2ce 0100    	movt	r1, #0xe000
;             portMPU_MAIR0_REG |= ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
 805d244: 6808         	ldr	r0, [r1]
 805d246: f040 00ff    	orr	r0, r0, #0xff
 805d24a: 6008         	str	r0, [r1]
;             portMPU_MAIR0_REG |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
 805d24c: 6808         	ldr	r0, [r1]
 805d24e: f440 6080    	orr	r0, r0, #0x400
 805d252: 6008         	str	r0, [r1]
 805d254: f64e 5c98    	movw	r12, #0xed98
 805d258: f2ce 0c00    	movt	r12, #0xe000
 805d25c: 2000         	movs	r0, #0x0
;             portMPU_RNR_REG = portPRIVILEGED_FLASH_REGION;
 805d25e: f8cc 0000    	str.w	r0, [r12]
;             portMPU_RBAR_REG = ( ( ( uint32_t ) __privileged_functions_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
 805d262: f245 2000    	movw	r0, #0x5200
 805d266: f6c0 0005    	movt	r0, #0x805
 805d26a: 2104         	movs	r1, #0x4
 805d26c: f361 0004    	bfi	r0, r1, #0, #5
 805d270: f64e 539c    	movw	r3, #0xed9c
 805d274: f2ce 0300    	movt	r3, #0xe000
 805d278: 6018         	str	r0, [r3]
;             portMPU_RLAR_REG = ( ( ( uint32_t ) __privileged_functions_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
 805d27a: f64d 001f    	movw	r0, #0xd81f
 805d27e: f6c0 0005    	movt	r0, #0x805
 805d282: 2201         	movs	r2, #0x1
 805d284: f362 0004    	bfi	r0, r2, #0, #5
 805d288: f64e 51a0    	movw	r1, #0xeda0
 805d28c: f2ce 0100    	movt	r1, #0xe000
 805d290: 6008         	str	r0, [r1]
;             portMPU_RNR_REG = portUNPRIVILEGED_FLASH_REGION;
 805d292: f8cc 2000    	str.w	r2, [r12]
;             portMPU_RBAR_REG = ( ( ( uint32_t ) __unprivileged_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
 805d296: f64e 20a0    	movw	r0, #0xeaa0
 805d29a: f6c0 0005    	movt	r0, #0x805
 805d29e: f04f 0e06    	mov.w	lr, #0x6
 805d2a2: f36e 0004    	bfi	r0, lr, #0, #5
 805d2a6: 6018         	str	r0, [r3]
;             portMPU_RLAR_REG = ( ( ( uint32_t ) __unprivileged_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
 805d2a8: f64f 20ff    	movw	r0, #0xfaff
 805d2ac: f6c0 0005    	movt	r0, #0x805
 805d2b0: f362 0004    	bfi	r0, r2, #0, #5
 805d2b4: 6008         	str	r0, [r1]
 805d2b6: 2002         	movs	r0, #0x2
;             portMPU_RNR_REG = portUNPRIVILEGED_SYSCALLS_REGION;
 805d2b8: f8cc 0000    	str.w	r0, [r12]
;             portMPU_RBAR_REG = ( ( ( uint32_t ) __syscalls_flash_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
 805d2bc: f64d 0020    	movw	r0, #0xd820
 805d2c0: f6c0 0005    	movt	r0, #0x805
 805d2c4: f36e 0004    	bfi	r0, lr, #0, #5
 805d2c8: 6018         	str	r0, [r3]
;             portMPU_RLAR_REG = ( ( ( uint32_t ) __syscalls_flash_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
 805d2ca: f64e 209f    	movw	r0, #0xea9f
 805d2ce: f6c0 0005    	movt	r0, #0x805
 805d2d2: f362 0004    	bfi	r0, r2, #0, #5
 805d2d6: 6008         	str	r0, [r1]
 805d2d8: 2003         	movs	r0, #0x3
;             portMPU_RNR_REG = portPRIVILEGED_RAM_REGION;
 805d2da: f8cc 0000    	str.w	r0, [r12]
;             portMPU_RBAR_REG = ( ( ( uint32_t ) __privileged_sram_start__ ) & portMPU_RBAR_ADDRESS_MASK ) |
 805d2de: f240 1000    	movw	r0, #0x100
 805d2e2: f2c2 0000    	movt	r0, #0x2000
 805d2e6: f362 0004    	bfi	r0, r2, #0, #5
 805d2ea: 6018         	str	r0, [r3]
;             portMPU_RLAR_REG = ( ( ( uint32_t ) __privileged_sram_end__ ) & portMPU_RLAR_ADDRESS_MASK ) |
 805d2ec: f242 307f    	movw	r0, #0x237f
 805d2f0: f2c2 0000    	movt	r0, #0x2000
 805d2f4: f362 0004    	bfi	r0, r2, #0, #5
 805d2f8: 6008         	str	r0, [r1]
 805d2fa: f64e 5124    	movw	r1, #0xed24
 805d2fe: f2ce 0100    	movt	r1, #0xe000
;             portSCB_SYS_HANDLER_CTRL_STATE_REG |= portSCB_MEM_FAULT_ENABLE_BIT;
 805d302: 6808         	ldr	r0, [r1]
 805d304: f440 3080    	orr	r0, r0, #0x10000
 805d308: 6008         	str	r0, [r1]
 805d30a: f64e 5194    	movw	r1, #0xed94
 805d30e: f2ce 0100    	movt	r1, #0xe000
;             portMPU_CTRL_REG |= ( portMPU_PRIV_BACKGROUND_ENABLE_BIT | portMPU_ENABLE_BIT );
 805d312: 6808         	ldr	r0, [r1]
 805d314: f040 0005    	orr	r0, r0, #0x5
 805d318: 6008         	str	r0, [r1]
;         }
 805d31a: e7ff         	b	0x805d31c <prvSetupMPU+0x118> @ imm = #-0x2
;     }
 805d31c: bc80         	pop	{r7}
 805d31e: eba8 0809    	sub.w	r8, r8, r9
 805d322: f858 fd04    	ldr	pc, [r8, #-4]!
 805d326: bf00         	nop

0805d328 <$d.15>:
 805d328: 15 d7 05 08  	.word	0x0805d715

0805d32c <vPortEndScheduler>:
; {
 805d32c: f848 eb14    	str	lr, [r8], #20
 805d330: eb08 0809    	add.w	r8, r8, r9
 805d334: b480         	push	{r7}
 805d336: 466f         	mov	r7, sp
;     configASSERT( ulCriticalNesting == 1000UL );
 805d338: f242 3078    	movw	r0, #0x2378
 805d33c: f2c2 0000    	movt	r0, #0x2000
 805d340: 6800         	ldr	r0, [r0]
 805d342: f5b0 7f7a    	cmp.w	r0, #0x3e8
 805d346: d004         	beq	0x805d352 <vPortEndScheduler+0x26> @ imm = #0x8
 805d348: e7ff         	b	0x805d34a <vPortEndScheduler+0x1e> @ imm = #-0x2
 805d34a: 4804         	ldr	r0, [pc, #0x10]         @ 0x805d35c <vPortEndScheduler+0x30>
 805d34c: 4780         	blx	r0
 805d34e: e7ff         	b	0x805d350 <vPortEndScheduler+0x24> @ imm = #-0x2
 805d350: e7fe         	b	0x805d350 <vPortEndScheduler+0x24> @ imm = #-0x4
; }
 805d352: bc80         	pop	{r7}
 805d354: eba8 0809    	sub.w	r8, r8, r9
 805d358: f858 fd14    	ldr	pc, [r8, #-20]!

0805d35c <$d.17>:
 805d35c: 15 d7 05 08  	.word	0x0805d715

0805d360 <vPortStoreTaskMPUSettings>:
;     {
 805d360: b088         	sub	sp, #0x20
 805d362: 9007         	str	r0, [sp, #0x1c]
 805d364: 9106         	str	r1, [sp, #0x18]
 805d366: 9205         	str	r2, [sp, #0x14]
 805d368: 9304         	str	r3, [sp, #0x10]
 805d36a: 2000         	movs	r0, #0x0
;         int32_t lIndex = 0;
 805d36c: 9000         	str	r0, [sp]
;         xMPUSettings->ulMAIR0 = ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR0_POS ) & portMPU_MAIR_ATTR0_MASK );
 805d36e: 9907         	ldr	r1, [sp, #0x1c]
 805d370: 20ff         	movs	r0, #0xff
 805d372: 6008         	str	r0, [r1]
;         xMPUSettings->ulMAIR0 |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & portMPU_MAIR_ATTR1_MASK );
 805d374: 9907         	ldr	r1, [sp, #0x1c]
 805d376: 6808         	ldr	r0, [r1]
 805d378: f440 6080    	orr	r0, r0, #0x400
 805d37c: 6008         	str	r0, [r1]
;         if( ulStackDepth > 0 )
 805d37e: 9804         	ldr	r0, [sp, #0x10]
 805d380: b390         	cbz	r0, 0x805d3e8 <vPortStoreTaskMPUSettings+0x88> @ imm = #0x64
 805d382: e7ff         	b	0x805d384 <vPortStoreTaskMPUSettings+0x24> @ imm = #-0x2
;             ulRegionStartAddress = ( uint32_t ) pxBottomOfStack;
 805d384: 9805         	ldr	r0, [sp, #0x14]
 805d386: 9003         	str	r0, [sp, #0xc]
;             ulRegionEndAddress = ( uint32_t ) pxBottomOfStack + ( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) ) - 1;
 805d388: 9805         	ldr	r0, [sp, #0x14]
 805d38a: 9904         	ldr	r1, [sp, #0x10]
 805d38c: eb00 0081    	add.w	r0, r0, r1, lsl #2
 805d390: 3801         	subs	r0, #0x1
 805d392: 9002         	str	r0, [sp, #0x8]
;             if( ( ulRegionStartAddress >= ( uint32_t ) __privileged_sram_start__ ) &&
 805d394: 9803         	ldr	r0, [sp, #0xc]
 805d396: f240 1100    	movw	r1, #0x100
 805d39a: f2c2 0100    	movt	r1, #0x2000
 805d39e: 4288         	cmp	r0, r1
 805d3a0: d30e         	blo	0x805d3c0 <vPortStoreTaskMPUSettings+0x60> @ imm = #0x1c
 805d3a2: e7ff         	b	0x805d3a4 <vPortStoreTaskMPUSettings+0x44> @ imm = #-0x2
;                 ( ulRegionEndAddress <= ( uint32_t ) __privileged_sram_end__ ) )
 805d3a4: 9802         	ldr	r0, [sp, #0x8]
 805d3a6: f242 317f    	movw	r1, #0x237f
 805d3aa: f2c2 0100    	movt	r1, #0x2000
;             if( ( ulRegionStartAddress >= ( uint32_t ) __privileged_sram_start__ ) &&
 805d3ae: 4288         	cmp	r0, r1
 805d3b0: d806         	bhi	0x805d3c0 <vPortStoreTaskMPUSettings+0x60> @ imm = #0xc
 805d3b2: e7ff         	b	0x805d3b4 <vPortStoreTaskMPUSettings+0x54> @ imm = #-0x2
;                 xMPUSettings->xRegionsSettings[ 0 ].ulRBAR = 0;
 805d3b4: 9907         	ldr	r1, [sp, #0x1c]
 805d3b6: 2000         	movs	r0, #0x0
 805d3b8: 6048         	str	r0, [r1, #0x4]
;                 xMPUSettings->xRegionsSettings[ 0 ].ulRLAR = 0;
 805d3ba: 9907         	ldr	r1, [sp, #0x1c]
 805d3bc: 6088         	str	r0, [r1, #0x8]
;             }
 805d3be: e012         	b	0x805d3e6 <vPortStoreTaskMPUSettings+0x86> @ imm = #0x24
;                 ulRegionStartAddress &= portMPU_RBAR_ADDRESS_MASK;
 805d3c0: 9803         	ldr	r0, [sp, #0xc]
 805d3c2: f020 001f    	bic	r0, r0, #0x1f
 805d3c6: 9003         	str	r0, [sp, #0xc]
;                 ulRegionEndAddress &= portMPU_RLAR_ADDRESS_MASK;
 805d3c8: 9802         	ldr	r0, [sp, #0x8]
 805d3ca: f020 001f    	bic	r0, r0, #0x1f
 805d3ce: 9002         	str	r0, [sp, #0x8]
;                 xMPUSettings->xRegionsSettings[ 0 ].ulRBAR = ( ulRegionStartAddress ) |
 805d3d0: 9803         	ldr	r0, [sp, #0xc]
;                                                              ( portMPU_REGION_READ_WRITE ) |
 805d3d2: f040 0003    	orr	r0, r0, #0x3
;                 xMPUSettings->xRegionsSettings[ 0 ].ulRBAR = ( ulRegionStartAddress ) |
 805d3d6: 9907         	ldr	r1, [sp, #0x1c]
 805d3d8: 6048         	str	r0, [r1, #0x4]
;                 xMPUSettings->xRegionsSettings[ 0 ].ulRLAR = ( ulRegionEndAddress ) |
 805d3da: 9802         	ldr	r0, [sp, #0x8]
;                                                              ( portMPU_RLAR_ATTR_INDEX0 ) |
 805d3dc: f040 0001    	orr	r0, r0, #0x1
;                 xMPUSettings->xRegionsSettings[ 0 ].ulRLAR = ( ulRegionEndAddress ) |
 805d3e0: 9907         	ldr	r1, [sp, #0x1c]
 805d3e2: 6088         	str	r0, [r1, #0x8]
 805d3e4: e7ff         	b	0x805d3e6 <vPortStoreTaskMPUSettings+0x86> @ imm = #-0x2
;         }
 805d3e6: e7ff         	b	0x805d3e8 <vPortStoreTaskMPUSettings+0x88> @ imm = #-0x2
 805d3e8: 2001         	movs	r0, #0x1
;         for( ulRegionNumber = 1; ulRegionNumber <= portNUM_CONFIGURABLE_REGIONS; ulRegionNumber++ )
 805d3ea: 9001         	str	r0, [sp, #0x4]
 805d3ec: e7ff         	b	0x805d3ee <vPortStoreTaskMPUSettings+0x8e> @ imm = #-0x2
 805d3ee: 9801         	ldr	r0, [sp, #0x4]
 805d3f0: 2803         	cmp	r0, #0x3
 805d3f2: f200 8090    	bhi.w	0x805d516 <vPortStoreTaskMPUSettings+0x1b6> @ imm = #0x120
 805d3f6: e7ff         	b	0x805d3f8 <vPortStoreTaskMPUSettings+0x98> @ imm = #-0x2
;             if( ( xRegions != NULL ) && ( xRegions[ lIndex ].ulLengthInBytes > 0UL ) )
 805d3f8: 9806         	ldr	r0, [sp, #0x18]
 805d3fa: 2800         	cmp	r0, #0x0
 805d3fc: d077         	beq	0x805d4ee <vPortStoreTaskMPUSettings+0x18e> @ imm = #0xee
 805d3fe: e7ff         	b	0x805d400 <vPortStoreTaskMPUSettings+0xa0> @ imm = #-0x2
 805d400: 9806         	ldr	r0, [sp, #0x18]
 805d402: 9900         	ldr	r1, [sp]
 805d404: eb01 0141    	add.w	r1, r1, r1, lsl #1
 805d408: eb00 0081    	add.w	r0, r0, r1, lsl #2
 805d40c: 6840         	ldr	r0, [r0, #0x4]
 805d40e: 2800         	cmp	r0, #0x0
 805d410: d06d         	beq	0x805d4ee <vPortStoreTaskMPUSettings+0x18e> @ imm = #0xda
 805d412: e7ff         	b	0x805d414 <vPortStoreTaskMPUSettings+0xb4> @ imm = #-0x2
;                 ulRegionStartAddress = ( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) & portMPU_RBAR_ADDRESS_MASK;
 805d414: 9806         	ldr	r0, [sp, #0x18]
 805d416: 9900         	ldr	r1, [sp]
 805d418: eb01 0141    	add.w	r1, r1, r1, lsl #1
 805d41c: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
 805d420: f020 001f    	bic	r0, r0, #0x1f
 805d424: 9003         	str	r0, [sp, #0xc]
;                 ulRegionEndAddress = ( uint32_t ) xRegions[ lIndex ].pvBaseAddress + xRegions[ lIndex ].ulLengthInBytes - 1;
 805d426: 9806         	ldr	r0, [sp, #0x18]
 805d428: 9900         	ldr	r1, [sp]
 805d42a: eb01 0241    	add.w	r2, r1, r1, lsl #1
 805d42e: eb00 0182    	add.w	r1, r0, r2, lsl #2
 805d432: f850 0022    	ldr.w	r0, [r0, r2, lsl #2]
 805d436: 6849         	ldr	r1, [r1, #0x4]
 805d438: 4408         	add	r0, r1
 805d43a: 3801         	subs	r0, #0x1
 805d43c: 9002         	str	r0, [sp, #0x8]
;                 ulRegionEndAddress &= portMPU_RLAR_ADDRESS_MASK;
 805d43e: 9802         	ldr	r0, [sp, #0x8]
 805d440: f020 001f    	bic	r0, r0, #0x1f
 805d444: 9002         	str	r0, [sp, #0x8]
;                 xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR = ( ulRegionStartAddress ) |
 805d446: 9803         	ldr	r0, [sp, #0xc]
 805d448: 9907         	ldr	r1, [sp, #0x1c]
 805d44a: 9a01         	ldr	r2, [sp, #0x4]
 805d44c: eb01 01c2    	add.w	r1, r1, r2, lsl #3
 805d450: 6048         	str	r0, [r1, #0x4]
;                 if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_READ_ONLY ) != 0 )
 805d452: 9806         	ldr	r0, [sp, #0x18]
 805d454: 9900         	ldr	r1, [sp]
 805d456: eb01 0141    	add.w	r1, r1, r1, lsl #1
 805d45a: eb00 0081    	add.w	r0, r0, r1, lsl #2
 805d45e: 7a00         	ldrb	r0, [r0, #0x8]
 805d460: 07c0         	lsls	r0, r0, #0x1f
 805d462: b148         	cbz	r0, 0x805d478 <vPortStoreTaskMPUSettings+0x118> @ imm = #0x12
 805d464: e7ff         	b	0x805d466 <vPortStoreTaskMPUSettings+0x106> @ imm = #-0x2
;                     xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_ONLY );
 805d466: 9807         	ldr	r0, [sp, #0x1c]
 805d468: 9901         	ldr	r1, [sp, #0x4]
 805d46a: eb00 01c1    	add.w	r1, r0, r1, lsl #3
 805d46e: 6848         	ldr	r0, [r1, #0x4]
 805d470: f040 0006    	orr	r0, r0, #0x6
 805d474: 6048         	str	r0, [r1, #0x4]
;                 }
 805d476: e008         	b	0x805d48a <vPortStoreTaskMPUSettings+0x12a> @ imm = #0x10
;                     xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_READ_WRITE );
 805d478: 9807         	ldr	r0, [sp, #0x1c]
 805d47a: 9901         	ldr	r1, [sp, #0x4]
 805d47c: eb00 01c1    	add.w	r1, r0, r1, lsl #3
 805d480: 6848         	ldr	r0, [r1, #0x4]
 805d482: f040 0002    	orr	r0, r0, #0x2
 805d486: 6048         	str	r0, [r1, #0x4]
 805d488: e7ff         	b	0x805d48a <vPortStoreTaskMPUSettings+0x12a> @ imm = #-0x2
;                 if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_EXECUTE_NEVER ) != 0 )
 805d48a: 9806         	ldr	r0, [sp, #0x18]
 805d48c: 9900         	ldr	r1, [sp]
 805d48e: eb01 0141    	add.w	r1, r1, r1, lsl #1
 805d492: eb00 0081    	add.w	r0, r0, r1, lsl #2
 805d496: 7a00         	ldrb	r0, [r0, #0x8]
 805d498: 0740         	lsls	r0, r0, #0x1d
 805d49a: 2800         	cmp	r0, #0x0
 805d49c: d509         	bpl	0x805d4b2 <vPortStoreTaskMPUSettings+0x152> @ imm = #0x12
 805d49e: e7ff         	b	0x805d4a0 <vPortStoreTaskMPUSettings+0x140> @ imm = #-0x2
;                     xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_EXECUTE_NEVER );
 805d4a0: 9807         	ldr	r0, [sp, #0x1c]
 805d4a2: 9901         	ldr	r1, [sp, #0x4]
 805d4a4: eb00 01c1    	add.w	r1, r0, r1, lsl #3
 805d4a8: 6848         	ldr	r0, [r1, #0x4]
 805d4aa: f040 0001    	orr	r0, r0, #0x1
 805d4ae: 6048         	str	r0, [r1, #0x4]
;                 }
 805d4b0: e7ff         	b	0x805d4b2 <vPortStoreTaskMPUSettings+0x152> @ imm = #-0x2
;                 xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR = ( ulRegionEndAddress ) |
 805d4b2: 9802         	ldr	r0, [sp, #0x8]
 805d4b4: f040 0001    	orr	r0, r0, #0x1
 805d4b8: 9907         	ldr	r1, [sp, #0x1c]
 805d4ba: 9a01         	ldr	r2, [sp, #0x4]
 805d4bc: eb01 01c2    	add.w	r1, r1, r2, lsl #3
 805d4c0: 6088         	str	r0, [r1, #0x8]
;                 if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_DEVICE_MEMORY ) != 0 )
 805d4c2: 9806         	ldr	r0, [sp, #0x18]
 805d4c4: 9900         	ldr	r1, [sp]
 805d4c6: eb01 0141    	add.w	r1, r1, r1, lsl #1
 805d4ca: eb00 0081    	add.w	r0, r0, r1, lsl #2
 805d4ce: 7a00         	ldrb	r0, [r0, #0x8]
 805d4d0: 06c0         	lsls	r0, r0, #0x1b
 805d4d2: 2800         	cmp	r0, #0x0
 805d4d4: d509         	bpl	0x805d4ea <vPortStoreTaskMPUSettings+0x18a> @ imm = #0x12
 805d4d6: e7ff         	b	0x805d4d8 <vPortStoreTaskMPUSettings+0x178> @ imm = #-0x2
;                     xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_INDEX1;
 805d4d8: 9807         	ldr	r0, [sp, #0x1c]
 805d4da: 9901         	ldr	r1, [sp, #0x4]
 805d4dc: eb00 01c1    	add.w	r1, r0, r1, lsl #3
 805d4e0: 6888         	ldr	r0, [r1, #0x8]
 805d4e2: f040 0002    	orr	r0, r0, #0x2
 805d4e6: 6088         	str	r0, [r1, #0x8]
;                 }
 805d4e8: e000         	b	0x805d4ec <vPortStoreTaskMPUSettings+0x18c> @ imm = #0x0
 805d4ea: e7ff         	b	0x805d4ec <vPortStoreTaskMPUSettings+0x18c> @ imm = #-0x2
;             }
 805d4ec: e00b         	b	0x805d506 <vPortStoreTaskMPUSettings+0x1a6> @ imm = #0x16
;                 xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR = 0UL;
 805d4ee: 9807         	ldr	r0, [sp, #0x1c]
 805d4f0: 9901         	ldr	r1, [sp, #0x4]
 805d4f2: eb00 01c1    	add.w	r1, r0, r1, lsl #3
 805d4f6: 2000         	movs	r0, #0x0
 805d4f8: 6048         	str	r0, [r1, #0x4]
;                 xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR = 0UL;
 805d4fa: 9907         	ldr	r1, [sp, #0x1c]
 805d4fc: 9a01         	ldr	r2, [sp, #0x4]
 805d4fe: eb01 01c2    	add.w	r1, r1, r2, lsl #3
 805d502: 6088         	str	r0, [r1, #0x8]
 805d504: e7ff         	b	0x805d506 <vPortStoreTaskMPUSettings+0x1a6> @ imm = #-0x2
;             lIndex++;
 805d506: 9800         	ldr	r0, [sp]
 805d508: 3001         	adds	r0, #0x1
 805d50a: 9000         	str	r0, [sp]
;         }
 805d50c: e7ff         	b	0x805d50e <vPortStoreTaskMPUSettings+0x1ae> @ imm = #-0x2
;         for( ulRegionNumber = 1; ulRegionNumber <= portNUM_CONFIGURABLE_REGIONS; ulRegionNumber++ )
 805d50e: 9801         	ldr	r0, [sp, #0x4]
 805d510: 3001         	adds	r0, #0x1
 805d512: 9001         	str	r0, [sp, #0x4]
 805d514: e76b         	b	0x805d3ee <vPortStoreTaskMPUSettings+0x8e> @ imm = #-0x12a
;     }
 805d516: b008         	add	sp, #0x20
 805d518: 4770         	bx	lr
 805d51a: bf00         	nop

0805d51c <xPortIsAuthorizedToAccessBuffer>:
;     {
 805d51c: f848 eb30    	str	lr, [r8], #48
 805d520: eb08 0809    	add.w	r8, r8, r9
 805d524: b480         	push	{r7}
 805d526: 466f         	mov	r7, sp
 805d528: b088         	sub	sp, #0x20
 805d52a: 9007         	str	r0, [sp, #0x1c]
 805d52c: 9106         	str	r1, [sp, #0x18]
 805d52e: 9205         	str	r2, [sp, #0x14]
 805d530: 2000         	movs	r0, #0x0
;         BaseType_t xAccessGranted = pdFALSE;
 805d532: 9001         	str	r0, [sp, #0x4]
;         const xMPU_SETTINGS * xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling task's MPU settings. */
 805d534: 4939         	ldr	r1, [pc, #0xe4]         @ 0x805d61c <xPortIsAuthorizedToAccessBuffer+0x100>
 805d536: 4788         	blx	r1
 805d538: 9000         	str	r0, [sp]
;         if( ( xTaskMpuSettings->ulTaskFlags & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )
 805d53a: 9800         	ldr	r0, [sp]
 805d53c: f890 0078    	ldrb.w	r0, [r0, #0x78]
 805d540: 0780         	lsls	r0, r0, #0x1e
 805d542: 2800         	cmp	r0, #0x0
 805d544: d503         	bpl	0x805d54e <xPortIsAuthorizedToAccessBuffer+0x32> @ imm = #0x6
 805d546: e7ff         	b	0x805d548 <xPortIsAuthorizedToAccessBuffer+0x2c> @ imm = #-0x2
 805d548: 2001         	movs	r0, #0x1
;             xAccessGranted = pdTRUE;
 805d54a: 9001         	str	r0, [sp, #0x4]
;         }
 805d54c: e05e         	b	0x805d60c <xPortIsAuthorizedToAccessBuffer+0xf0> @ imm = #0xbc
;             if( portADD_UINT32_WILL_OVERFLOW( ( ( uint32_t ) pvBuffer ), ( ulBufferLength - 1UL ) ) == pdFALSE )
 805d54e: 9807         	ldr	r0, [sp, #0x1c]
 805d550: 9906         	ldr	r1, [sp, #0x18]
 805d552: 4249         	rsbs	r1, r1, #0
 805d554: 4288         	cmp	r0, r1
 805d556: d858         	bhi	0x805d60a <xPortIsAuthorizedToAccessBuffer+0xee> @ imm = #0xb0
 805d558: e7ff         	b	0x805d55a <xPortIsAuthorizedToAccessBuffer+0x3e> @ imm = #-0x2
;                 ulBufferStartAddress = ( uint32_t ) pvBuffer;
 805d55a: 9807         	ldr	r0, [sp, #0x1c]
 805d55c: 9003         	str	r0, [sp, #0xc]
;                 ulBufferEndAddress = ( ( ( uint32_t ) pvBuffer ) + ulBufferLength - 1UL );
 805d55e: 9807         	ldr	r0, [sp, #0x1c]
 805d560: 9906         	ldr	r1, [sp, #0x18]
 805d562: 4408         	add	r0, r1
 805d564: 3801         	subs	r0, #0x1
 805d566: 9002         	str	r0, [sp, #0x8]
 805d568: 2000         	movs	r0, #0x0
;                 for( i = 0; i < portTOTAL_NUM_REGIONS; i++ )
 805d56a: 9004         	str	r0, [sp, #0x10]
 805d56c: e7ff         	b	0x805d56e <xPortIsAuthorizedToAccessBuffer+0x52> @ imm = #-0x2
 805d56e: 9804         	ldr	r0, [sp, #0x10]
 805d570: 2803         	cmp	r0, #0x3
 805d572: d849         	bhi	0x805d608 <xPortIsAuthorizedToAccessBuffer+0xec> @ imm = #0x92
 805d574: e7ff         	b	0x805d576 <xPortIsAuthorizedToAccessBuffer+0x5a> @ imm = #-0x2
;                     if( ( xTaskMpuSettings->xRegionsSettings[ i ].ulRLAR & portMPU_RLAR_REGION_ENABLE ) == portMPU_RLAR_REGION_ENABLE )
 805d576: 9800         	ldr	r0, [sp]
 805d578: 9904         	ldr	r1, [sp, #0x10]
 805d57a: eb00 00c1    	add.w	r0, r0, r1, lsl #3
 805d57e: 7a00         	ldrb	r0, [r0, #0x8]
 805d580: 07c0         	lsls	r0, r0, #0x1f
 805d582: b3e0         	cbz	r0, 0x805d5fe <xPortIsAuthorizedToAccessBuffer+0xe2> @ imm = #0x78
 805d584: e7ff         	b	0x805d586 <xPortIsAuthorizedToAccessBuffer+0x6a> @ imm = #-0x2
;                         if( portIS_ADDRESS_WITHIN_RANGE( ulBufferStartAddress,
 805d586: 9803         	ldr	r0, [sp, #0xc]
 805d588: 9900         	ldr	r1, [sp]
 805d58a: 9a04         	ldr	r2, [sp, #0x10]
 805d58c: eb01 01c2    	add.w	r1, r1, r2, lsl #3
 805d590: 6849         	ldr	r1, [r1, #0x4]
 805d592: f021 011f    	bic	r1, r1, #0x1f
 805d596: 4288         	cmp	r0, r1
 805d598: d330         	blo	0x805d5fc <xPortIsAuthorizedToAccessBuffer+0xe0> @ imm = #0x60
 805d59a: e7ff         	b	0x805d59c <xPortIsAuthorizedToAccessBuffer+0x80> @ imm = #-0x2
 805d59c: 9803         	ldr	r0, [sp, #0xc]
 805d59e: 9900         	ldr	r1, [sp]
 805d5a0: 9a04         	ldr	r2, [sp, #0x10]
 805d5a2: eb01 01c2    	add.w	r1, r1, r2, lsl #3
 805d5a6: 6889         	ldr	r1, [r1, #0x8]
 805d5a8: f041 011f    	orr	r1, r1, #0x1f
;                                                          portEXTRACT_LAST_ADDRESS_FROM_RLAR( xTaskMpuSettings->xRegionsSettings[ i ].ulRLAR ) ) &&
 805d5ac: 4288         	cmp	r0, r1
 805d5ae: d825         	bhi	0x805d5fc <xPortIsAuthorizedToAccessBuffer+0xe0> @ imm = #0x4a
 805d5b0: e7ff         	b	0x805d5b2 <xPortIsAuthorizedToAccessBuffer+0x96> @ imm = #-0x2
;                             portIS_ADDRESS_WITHIN_RANGE( ulBufferEndAddress,
 805d5b2: 9802         	ldr	r0, [sp, #0x8]
 805d5b4: 9900         	ldr	r1, [sp]
 805d5b6: 9a04         	ldr	r2, [sp, #0x10]
 805d5b8: eb01 01c2    	add.w	r1, r1, r2, lsl #3
 805d5bc: 6849         	ldr	r1, [r1, #0x4]
 805d5be: f021 011f    	bic	r1, r1, #0x1f
 805d5c2: 4288         	cmp	r0, r1
 805d5c4: d31a         	blo	0x805d5fc <xPortIsAuthorizedToAccessBuffer+0xe0> @ imm = #0x34
 805d5c6: e7ff         	b	0x805d5c8 <xPortIsAuthorizedToAccessBuffer+0xac> @ imm = #-0x2
 805d5c8: 9802         	ldr	r0, [sp, #0x8]
 805d5ca: 9900         	ldr	r1, [sp]
 805d5cc: 9a04         	ldr	r2, [sp, #0x10]
 805d5ce: eb01 01c2    	add.w	r1, r1, r2, lsl #3
 805d5d2: 6889         	ldr	r1, [r1, #0x8]
 805d5d4: f041 011f    	orr	r1, r1, #0x1f
;                                                          portEXTRACT_LAST_ADDRESS_FROM_RLAR( xTaskMpuSettings->xRegionsSettings[ i ].ulRLAR ) ) &&
 805d5d8: 4288         	cmp	r0, r1
 805d5da: d80f         	bhi	0x805d5fc <xPortIsAuthorizedToAccessBuffer+0xe0> @ imm = #0x1e
 805d5dc: e7ff         	b	0x805d5de <xPortIsAuthorizedToAccessBuffer+0xc2> @ imm = #-0x2
;                             portIS_AUTHORIZED( ulAccessRequested,
 805d5de: 9800         	ldr	r0, [sp]
 805d5e0: 9904         	ldr	r1, [sp, #0x10]
 805d5e2: eb00 00c1    	add.w	r0, r0, r1, lsl #3
 805d5e6: 6840         	ldr	r0, [r0, #0x4]
 805d5e8: 490d         	ldr	r1, [pc, #0x34]         @ 0x805d620 <xPortIsAuthorizedToAccessBuffer+0x104>
 805d5ea: 4788         	blx	r1
 805d5ec: 9905         	ldr	r1, [sp, #0x14]
 805d5ee: 4008         	ands	r0, r1
;                         if( portIS_ADDRESS_WITHIN_RANGE( ulBufferStartAddress,
 805d5f0: 4288         	cmp	r0, r1
 805d5f2: d103         	bne	0x805d5fc <xPortIsAuthorizedToAccessBuffer+0xe0> @ imm = #0x6
 805d5f4: e7ff         	b	0x805d5f6 <xPortIsAuthorizedToAccessBuffer+0xda> @ imm = #-0x2
 805d5f6: 2001         	movs	r0, #0x1
;                             xAccessGranted = pdTRUE;
 805d5f8: 9001         	str	r0, [sp, #0x4]
;                             break;
 805d5fa: e005         	b	0x805d608 <xPortIsAuthorizedToAccessBuffer+0xec> @ imm = #0xa
;                     }
 805d5fc: e7ff         	b	0x805d5fe <xPortIsAuthorizedToAccessBuffer+0xe2> @ imm = #-0x2
;                 }
 805d5fe: e7ff         	b	0x805d600 <xPortIsAuthorizedToAccessBuffer+0xe4> @ imm = #-0x2
;                 for( i = 0; i < portTOTAL_NUM_REGIONS; i++ )
 805d600: 9804         	ldr	r0, [sp, #0x10]
 805d602: 3001         	adds	r0, #0x1
 805d604: 9004         	str	r0, [sp, #0x10]
 805d606: e7b2         	b	0x805d56e <xPortIsAuthorizedToAccessBuffer+0x52> @ imm = #-0x9c
;             }
 805d608: e7ff         	b	0x805d60a <xPortIsAuthorizedToAccessBuffer+0xee> @ imm = #-0x2
 805d60a: e7ff         	b	0x805d60c <xPortIsAuthorizedToAccessBuffer+0xf0> @ imm = #-0x2
;         return xAccessGranted;
 805d60c: 9801         	ldr	r0, [sp, #0x4]
 805d60e: b008         	add	sp, #0x20
 805d610: bc80         	pop	{r7}
 805d612: eba8 0809    	sub.w	r8, r8, r9
 805d616: f858 fd30    	ldr	pc, [r8, #-48]!
 805d61a: bf00         	nop

0805d61c <$d.19>:
 805d61c: 65 87 05 08  	.word	0x08058765
 805d620: 25 d6 05 08  	.word	0x0805d625

0805d624 <prvGetRegionAccessPermissions>:
;     {
 805d624: b082         	sub	sp, #0x8
 805d626: 9001         	str	r0, [sp, #0x4]
 805d628: 2000         	movs	r0, #0x0
;         uint32_t ulAccessPermissions = 0;
 805d62a: 9000         	str	r0, [sp]
;         if( ( ulRBARValue & portMPU_RBAR_ACCESS_PERMISSIONS_MASK ) == portMPU_REGION_READ_ONLY )
 805d62c: 9801         	ldr	r0, [sp, #0x4]
 805d62e: f000 0006    	and	r0, r0, #0x6
 805d632: 2806         	cmp	r0, #0x6
 805d634: d103         	bne	0x805d63e <prvGetRegionAccessPermissions+0x1a> @ imm = #0x6
 805d636: e7ff         	b	0x805d638 <prvGetRegionAccessPermissions+0x14> @ imm = #-0x2
 805d638: 2001         	movs	r0, #0x1
;             ulAccessPermissions = tskMPU_READ_PERMISSION;
 805d63a: 9000         	str	r0, [sp]
;         }
 805d63c: e7ff         	b	0x805d63e <prvGetRegionAccessPermissions+0x1a> @ imm = #-0x2
;         if( ( ulRBARValue & portMPU_RBAR_ACCESS_PERMISSIONS_MASK ) == portMPU_REGION_READ_WRITE )
 805d63e: 9801         	ldr	r0, [sp, #0x4]
 805d640: f000 0006    	and	r0, r0, #0x6
 805d644: 2802         	cmp	r0, #0x2
 805d646: d103         	bne	0x805d650 <prvGetRegionAccessPermissions+0x2c> @ imm = #0x6
 805d648: e7ff         	b	0x805d64a <prvGetRegionAccessPermissions+0x26> @ imm = #-0x2
 805d64a: 2003         	movs	r0, #0x3
;             ulAccessPermissions = ( tskMPU_READ_PERMISSION | tskMPU_WRITE_PERMISSION );
 805d64c: 9000         	str	r0, [sp]
;         }
 805d64e: e7ff         	b	0x805d650 <prvGetRegionAccessPermissions+0x2c> @ imm = #-0x2
;         return ulAccessPermissions;
 805d650: 9800         	ldr	r0, [sp]
 805d652: b002         	add	sp, #0x8
 805d654: 4770         	bx	lr
		...
 805d65e: 0000         	movs	r0, r0

0805d660 <vRestoreContextOfFirstTask>:
;         __asm volatile
 805d660: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x805d6d0 <pxCurrentTCBConst2>
 805d662: 6810         	ldr	r0, [r2]
 805d664: f3bf 8f5f    	dmb	sy
 805d668: 491a         	ldr	r1, [pc, #0x68]         @ 0x805d6d4 <xMPUCTRLConst2>
 805d66a: 680a         	ldr	r2, [r1]
 805d66c: f022 0201    	bic	r2, r2, #0x1
 805d670: 600a         	str	r2, [r1]
 805d672: 3004         	adds	r0, #0x4
 805d674: 6801         	ldr	r1, [r0]
 805d676: 4a18         	ldr	r2, [pc, #0x60]         @ 0x805d6d8 <xMAIR0Const2>
 805d678: 6011         	str	r1, [r2]
 805d67a: 3004         	adds	r0, #0x4
 805d67c: 4917         	ldr	r1, [pc, #0x5c]         @ 0x805d6dc <xRNRConst2>
 805d67e: 4a18         	ldr	r2, [pc, #0x60]         @ 0x805d6e0 <xRBARConst2>
 805d680: 2304         	movs	r3, #0x4
 805d682: 600b         	str	r3, [r1]
 805d684: e8b0 0ff0    	ldm.w	r0!, {r4, r5, r6, r7, r8, r9, r10, r11}
 805d688: e882 0ff0    	stm.w	r2, {r4, r5, r6, r7, r8, r9, r10, r11}
 805d68c: 4911         	ldr	r1, [pc, #0x44]         @ 0x805d6d4 <xMPUCTRLConst2>
 805d68e: 680a         	ldr	r2, [r1]
 805d690: f042 0201    	orr	r2, r2, #0x1
 805d694: 600a         	str	r2, [r1]
 805d696: f3bf 8f4f    	dsb	sy

0805d69a <restore_context_first_task>:
 805d69a: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x805d6d0 <pxCurrentTCBConst2>
 805d69c: 6810         	ldr	r0, [r2]
 805d69e: 6801         	ldr	r1, [r0]

0805d6a0 <restore_special_regs_first_task>:
 805d6a0: e931 401c    	ldmdb	r1!, {r2, r3, r4, lr}
 805d6a4: f382 8809    	msr	psp, r2
 805d6a8: f383 880b    	msr	psplim, r3
 805d6ac: f384 8814    	msr	control, r4

0805d6b0 <restore_general_regs_first_task>:
 805d6b0: e931 0ff0    	ldmdb	r1!, {r4, r5, r6, r7, r8, r9, r10, r11}
 805d6b4: e8a2 0ff0    	stm.w	r2!, {r4, r5, r6, r7, r8, r9, r10, r11}
 805d6b8: e931 0ff0    	ldmdb	r1!, {r4, r5, r6, r7, r8, r9, r10, r11}

0805d6bc <restore_context_done_first_task>:
 805d6bc: 6001         	str	r1, [r0]
 805d6be: f04f 0000    	mov.w	r0, #0x0
 805d6c2: f380 8811    	msr	basepri, r0
 805d6c6: 4770         	bx	lr
 805d6c8: bf00         	nop
 805d6ca: bf00         	nop
 805d6cc: bf00         	nop
 805d6ce: bf00         	nop

0805d6d0 <pxCurrentTCBConst2>:
 805d6d0: 00 01 00 20  	.word	0x20000100

0805d6d4 <xMPUCTRLConst2>:
 805d6d4: 94 ed 00 e0  	.word	0xe000ed94

0805d6d8 <xMAIR0Const2>:
 805d6d8: c0 ed 00 e0  	.word	0xe000edc0

0805d6dc <xRNRConst2>:
 805d6dc: 98 ed 00 e0  	.word	0xe000ed98

0805d6e0 <xRBARConst2>:
 805d6e0: 9c ed 00 e0  	.word	0xe000ed9c

0805d6e4 <vRaisePrivilege>:
;     __asm volatile
 805d6e4: f3ef 8014    	mrs	r0, control
 805d6e8: f020 0001    	bic	r0, r0, #0x1
 805d6ec: f380 8814    	msr	control, r0
 805d6f0: 4770         	bx	lr

0805d6f2 <vStartFirstTask>:
;     __asm volatile
 805d6f2: 4807         	ldr	r0, [pc, #0x1c]         @ 0x805d710 <xVTORConst>
 805d6f4: 6800         	ldr	r0, [r0]
 805d6f6: 6800         	ldr	r0, [r0]
 805d6f8: f380 8808    	msr	msp, r0
 805d6fc: b662         	cpsie i
 805d6fe: b661         	cpsie f
 805d700: f3bf 8f4f    	dsb	sy
 805d704: f3bf 8f6f    	isb	sy
 805d708: df02         	svc	#0x2
 805d70a: bf00         	nop
 805d70c: bf00         	nop
 805d70e: bf00         	nop

0805d710 <xVTORConst>:
 805d710: 08 ed 00 e0  	.word	0xe000ed08

0805d714 <ulSetInterruptMask>:
;     __asm volatile
 805d714: f3ef 8011    	mrs	r0, basepri
 805d718: f04f 01a0    	mov.w	r1, #0xa0
 805d71c: f381 8811    	msr	basepri, r1
 805d720: f3bf 8f4f    	dsb	sy
 805d724: f3bf 8f6f    	isb	sy
 805d728: 4770         	bx	lr

0805d72a <vClearInterruptMask>:
;     __asm volatile
 805d72a: f380 8811    	msr	basepri, r0
 805d72e: f3bf 8f4f    	dsb	sy
 805d732: f3bf 8f6f    	isb	sy
 805d736: 4770         	bx	lr

0805d738 <PendSV_Handler>:
;         __asm volatile
 805d738: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x805d7e0 <pxCurrentTCBConst>
 805d73a: 6810         	ldr	r0, [r2]
 805d73c: 6801         	ldr	r1, [r0]
 805d73e: f3ef 8209    	mrs	r2, psp

0805d742 <save_general_regs>:
 805d742: e8a1 0ff0    	stm.w	r1!, {r4, r5, r6, r7, r8, r9, r10, r11}
 805d746: e892 0ff0    	ldm.w	r2, {r4, r5, r6, r7, r8, r9, r10, r11}
 805d74a: e8a1 0ff0    	stm.w	r1!, {r4, r5, r6, r7, r8, r9, r10, r11}

0805d74e <save_special_regs>:
 805d74e: f3ef 830b    	mrs	r3, psplim
 805d752: f3ef 8414    	mrs	r4, control
 805d756: e8a1 401c    	stm.w	r1!, {r2, r3, r4, lr}
 805d75a: 6001         	str	r1, [r0]

0805d75c <select_next_task>:
 805d75c: f04f 00a0    	mov.w	r0, #0xa0
 805d760: f380 8811    	msr	basepri, r0
 805d764: f3bf 8f4f    	dsb	sy
 805d768: f3bf 8f6f    	isb	sy
 805d76c: f7f8 fdf8    	bl	0x8056360 <vTaskSwitchContext> @ imm = #-0x7410
 805d770: f04f 0000    	mov.w	r0, #0x0
 805d774: f380 8811    	msr	basepri, r0

0805d778 <program_mpu>:
 805d778: 4a19         	ldr	r2, [pc, #0x64]         @ 0x805d7e0 <pxCurrentTCBConst>
 805d77a: 6810         	ldr	r0, [r2]
 805d77c: f3bf 8f5f    	dmb	sy
 805d780: 4918         	ldr	r1, [pc, #0x60]         @ 0x805d7e4 <xMPUCTRLConst>
 805d782: 680a         	ldr	r2, [r1]
 805d784: f022 0201    	bic	r2, r2, #0x1
 805d788: 600a         	str	r2, [r1]
 805d78a: 3004         	adds	r0, #0x4
 805d78c: 6801         	ldr	r1, [r0]
 805d78e: 4a16         	ldr	r2, [pc, #0x58]         @ 0x805d7e8 <xMAIR0Const>
 805d790: 6011         	str	r1, [r2]
 805d792: 3004         	adds	r0, #0x4
 805d794: 4915         	ldr	r1, [pc, #0x54]         @ 0x805d7ec <xRNRConst>
 805d796: 4a16         	ldr	r2, [pc, #0x58]         @ 0x805d7f0 <xRBARConst>
 805d798: 2304         	movs	r3, #0x4
 805d79a: 600b         	str	r3, [r1]
 805d79c: e8b0 0ff0    	ldm.w	r0!, {r4, r5, r6, r7, r8, r9, r10, r11}
 805d7a0: e882 0ff0    	stm.w	r2, {r4, r5, r6, r7, r8, r9, r10, r11}
 805d7a4: 490f         	ldr	r1, [pc, #0x3c]         @ 0x805d7e4 <xMPUCTRLConst>
 805d7a6: 680a         	ldr	r2, [r1]
 805d7a8: f042 0201    	orr	r2, r2, #0x1
 805d7ac: 600a         	str	r2, [r1]
 805d7ae: f3bf 8f4f    	dsb	sy

0805d7b2 <restore_context>:
 805d7b2: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x805d7e0 <pxCurrentTCBConst>
 805d7b4: 6810         	ldr	r0, [r2]
 805d7b6: 6801         	ldr	r1, [r0]

0805d7b8 <restore_special_regs>:
 805d7b8: e931 401c    	ldmdb	r1!, {r2, r3, r4, lr}
 805d7bc: f382 8809    	msr	psp, r2
 805d7c0: f383 880b    	msr	psplim, r3
 805d7c4: f384 8814    	msr	control, r4

0805d7c8 <restore_general_regs>:
 805d7c8: e931 0ff0    	ldmdb	r1!, {r4, r5, r6, r7, r8, r9, r10, r11}
 805d7cc: e8a2 0ff0    	stm.w	r2!, {r4, r5, r6, r7, r8, r9, r10, r11}
 805d7d0: e931 0ff0    	ldmdb	r1!, {r4, r5, r6, r7, r8, r9, r10, r11}

0805d7d4 <restore_context_done>:
 805d7d4: 6001         	str	r1, [r0]
 805d7d6: 4770         	bx	lr
 805d7d8: bf00         	nop
 805d7da: bf00         	nop
 805d7dc: bf00         	nop
 805d7de: bf00         	nop

0805d7e0 <pxCurrentTCBConst>:
 805d7e0: 00 01 00 20  	.word	0x20000100

0805d7e4 <xMPUCTRLConst>:
 805d7e4: 94 ed 00 e0  	.word	0xe000ed94

0805d7e8 <xMAIR0Const>:
 805d7e8: c0 ed 00 e0  	.word	0xe000edc0

0805d7ec <xRNRConst>:
 805d7ec: 98 ed 00 e0  	.word	0xe000ed98

0805d7f0 <xRBARConst>:
 805d7f0: 9c ed 00 e0  	.word	0xe000ed9c

0805d7f4 <SVC_Handler>:
;         __asm volatile
 805d7f4: f01e 0f04    	tst.w	lr, #0x4
 805d7f8: bf0c         	ite	eq
 805d7fa: f3ef 8008    	mrseq	r0, msp
 805d7fe: f3ef 8009    	mrsne	r0, psp
 805d802: 4903         	ldr	r1, [pc, #0xc]          @ 0x805d810 <svchandler_address_const>
 805d804: 4708         	bx	r1
 805d806: bf00         	nop
 805d808: bf00         	nop
 805d80a: bf00         	nop
 805d80c: bf00         	nop
 805d80e: bf00         	nop

0805d810 <svchandler_address_const>:
 805d810: 19 ce 05 08  	.word	0x0805ce19
 805d814: 00 00 00 00  	.word	0x00000000
 805d818: 00 00 00 00  	.word	0x00000000
 805d81c: 00 00        	.short	0x0000
 805d81e: 00           	.byte	0x00

0805d81f <__privileged_functions_end__>:
 805d81f: 00           	.byte	0x00

Disassembly of section .freertos_system_calls:

0805d820 <__syscalls_flash_start__>:
;         {
 805d820: f848 eb48    	str	lr, [r8], #72
 805d824: eb08 0809    	add.w	r8, r8, r9
 805d828: b480         	push	{r7}
 805d82a: 466f         	mov	r7, sp
 805d82c: b084         	sub	sp, #0x10
 805d82e: 9003         	str	r0, [sp, #0xc]
 805d830: 9102         	str	r1, [sp, #0x8]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805d832: 480d         	ldr	r0, [pc, #0x34]         @ 0x805d868 <__syscalls_flash_start__+0x48>
 805d834: 4780         	blx	r0
 805d836: b948         	cbnz	r0, 0x805d84c <__syscalls_flash_start__+0x2c> @ imm = #0x12
 805d838: e7ff         	b	0x805d83a <__syscalls_flash_start__+0x1a> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805d83a: df03         	svc	#0x3
;                 xReturn = xTaskDelayUntil( pxPreviousWakeTime, xTimeIncrement );
 805d83c: 9803         	ldr	r0, [sp, #0xc]
 805d83e: 9902         	ldr	r1, [sp, #0x8]
 805d840: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x805d870 <__syscalls_flash_start__+0x50>
 805d842: 4790         	blx	r2
 805d844: 9001         	str	r0, [sp, #0x4]
;                 portRESET_PRIVILEGE();
 805d846: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805d874 <__syscalls_flash_start__+0x54>
 805d848: 4780         	blx	r0
;             }
 805d84a: e005         	b	0x805d858 <__syscalls_flash_start__+0x38> @ imm = #0xa
;                 xReturn = xTaskDelayUntil( pxPreviousWakeTime, xTimeIncrement );
 805d84c: 9803         	ldr	r0, [sp, #0xc]
 805d84e: 9902         	ldr	r1, [sp, #0x8]
 805d850: 4a06         	ldr	r2, [pc, #0x18]         @ 0x805d86c <__syscalls_flash_start__+0x4c>
 805d852: 4790         	blx	r2
 805d854: 9001         	str	r0, [sp, #0x4]
 805d856: e7ff         	b	0x805d858 <__syscalls_flash_start__+0x38> @ imm = #-0x2
;             return xReturn;
 805d858: 9801         	ldr	r0, [sp, #0x4]
 805d85a: b004         	add	sp, #0x10
 805d85c: bc80         	pop	{r7}
 805d85e: eba8 0809    	sub.w	r8, r8, r9
 805d862: f858 fd48    	ldr	pc, [r8, #-72]!
 805d866: bf00         	nop

0805d868 <$d.5>:
 805d868: a1 f8 05 08  	.word	0x0805f8a1
 805d86c: cd 57 05 08  	.word	0x080557cd
 805d870: cd 57 05 08  	.word	0x080557cd
 805d874: b1 f8 05 08  	.word	0x0805f8b1

0805d878 <MPU_vTaskDelay>:
;         {
 805d878: f848 eb0c    	str	lr, [r8], #12
 805d87c: eb08 0809    	add.w	r8, r8, r9
 805d880: b480         	push	{r7}
 805d882: 466f         	mov	r7, sp
 805d884: b082         	sub	sp, #0x8
 805d886: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805d888: 480a         	ldr	r0, [pc, #0x28]         @ 0x805d8b4 <MPU_vTaskDelay+0x3c>
 805d88a: 4780         	blx	r0
 805d88c: b938         	cbnz	r0, 0x805d89e <MPU_vTaskDelay+0x26> @ imm = #0xe
 805d88e: e7ff         	b	0x805d890 <MPU_vTaskDelay+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805d890: df03         	svc	#0x3
;                 vTaskDelay( xTicksToDelay );
 805d892: 9801         	ldr	r0, [sp, #0x4]
 805d894: 4909         	ldr	r1, [pc, #0x24]         @ 0x805d8bc <MPU_vTaskDelay+0x44>
 805d896: 4788         	blx	r1
;                 portRESET_PRIVILEGE();
 805d898: 4809         	ldr	r0, [pc, #0x24]         @ 0x805d8c0 <MPU_vTaskDelay+0x48>
 805d89a: 4780         	blx	r0
;             }
 805d89c: e003         	b	0x805d8a6 <MPU_vTaskDelay+0x2e> @ imm = #0x6
;                 vTaskDelay( xTicksToDelay );
 805d89e: 9801         	ldr	r0, [sp, #0x4]
 805d8a0: 4905         	ldr	r1, [pc, #0x14]         @ 0x805d8b8 <MPU_vTaskDelay+0x40>
 805d8a2: 4788         	blx	r1
 805d8a4: e7ff         	b	0x805d8a6 <MPU_vTaskDelay+0x2e> @ imm = #-0x2
;         }
 805d8a6: b002         	add	sp, #0x8
 805d8a8: bc80         	pop	{r7}
 805d8aa: eba8 0809    	sub.w	r8, r8, r9
 805d8ae: f858 fd0c    	ldr	pc, [r8, #-12]!
 805d8b2: bf00         	nop

0805d8b4 <$d.7>:
 805d8b4: a1 f8 05 08  	.word	0x0805f8a1
 805d8b8: a9 5c 05 08  	.word	0x08055ca9
 805d8bc: a9 5c 05 08  	.word	0x08055ca9
 805d8c0: b1 f8 05 08  	.word	0x0805f8b1

0805d8c4 <MPU_uxTaskPriorityGet>:
;         {
 805d8c4: f848 eb74    	str	lr, [r8], #116
 805d8c8: eb08 0809    	add.w	r8, r8, r9
 805d8cc: b480         	push	{r7}
 805d8ce: 466f         	mov	r7, sp
 805d8d0: b082         	sub	sp, #0x8
 805d8d2: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805d8d4: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805d904 <MPU_uxTaskPriorityGet+0x40>
 805d8d6: 4780         	blx	r0
 805d8d8: b940         	cbnz	r0, 0x805d8ec <MPU_uxTaskPriorityGet+0x28> @ imm = #0x10
 805d8da: e7ff         	b	0x805d8dc <MPU_uxTaskPriorityGet+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805d8dc: df03         	svc	#0x3
;                 uxReturn = uxTaskPriorityGet( pxTask );
 805d8de: 9801         	ldr	r0, [sp, #0x4]
 805d8e0: 490a         	ldr	r1, [pc, #0x28]         @ 0x805d90c <MPU_uxTaskPriorityGet+0x48>
 805d8e2: 4788         	blx	r1
 805d8e4: 9000         	str	r0, [sp]
;                 portRESET_PRIVILEGE();
 805d8e6: 480a         	ldr	r0, [pc, #0x28]         @ 0x805d910 <MPU_uxTaskPriorityGet+0x4c>
 805d8e8: 4780         	blx	r0
;             }
 805d8ea: e004         	b	0x805d8f6 <MPU_uxTaskPriorityGet+0x32> @ imm = #0x8
;                 uxReturn = uxTaskPriorityGet( pxTask );
 805d8ec: 9801         	ldr	r0, [sp, #0x4]
 805d8ee: 4906         	ldr	r1, [pc, #0x18]         @ 0x805d908 <MPU_uxTaskPriorityGet+0x44>
 805d8f0: 4788         	blx	r1
 805d8f2: 9000         	str	r0, [sp]
 805d8f4: e7ff         	b	0x805d8f6 <MPU_uxTaskPriorityGet+0x32> @ imm = #-0x2
;             return uxReturn;
 805d8f6: 9800         	ldr	r0, [sp]
 805d8f8: b002         	add	sp, #0x8
 805d8fa: bc80         	pop	{r7}
 805d8fc: eba8 0809    	sub.w	r8, r8, r9
 805d900: f858 fd74    	ldr	pc, [r8, #-116]!

0805d904 <$d.9>:
 805d904: a1 f8 05 08  	.word	0x0805f8a1
 805d908: 69 5e 05 08  	.word	0x08055e69
 805d90c: 69 5e 05 08  	.word	0x08055e69
 805d910: b1 f8 05 08  	.word	0x0805f8b1

0805d914 <MPU_eTaskGetState>:
;         {
 805d914: f848 eb48    	str	lr, [r8], #72
 805d918: eb08 0809    	add.w	r8, r8, r9
 805d91c: b480         	push	{r7}
 805d91e: 466f         	mov	r7, sp
 805d920: b082         	sub	sp, #0x8
 805d922: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805d924: 480d         	ldr	r0, [pc, #0x34]         @ 0x805d95c <MPU_eTaskGetState+0x48>
 805d926: 4780         	blx	r0
 805d928: b948         	cbnz	r0, 0x805d93e <MPU_eTaskGetState+0x2a> @ imm = #0x12
 805d92a: e7ff         	b	0x805d92c <MPU_eTaskGetState+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805d92c: df03         	svc	#0x3
;                 eReturn = eTaskGetState( pxTask );
 805d92e: 9801         	ldr	r0, [sp, #0x4]
 805d930: 490c         	ldr	r1, [pc, #0x30]         @ 0x805d964 <MPU_eTaskGetState+0x50>
 805d932: 4788         	blx	r1
 805d934: f807 0c05    	strb	r0, [r7, #-5]
;                 portRESET_PRIVILEGE();
 805d938: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805d968 <MPU_eTaskGetState+0x54>
 805d93a: 4780         	blx	r0
;             }
 805d93c: e005         	b	0x805d94a <MPU_eTaskGetState+0x36> @ imm = #0xa
;                 eReturn = eTaskGetState( pxTask );
 805d93e: 9801         	ldr	r0, [sp, #0x4]
 805d940: 4907         	ldr	r1, [pc, #0x1c]         @ 0x805d960 <MPU_eTaskGetState+0x4c>
 805d942: 4788         	blx	r1
 805d944: f807 0c05    	strb	r0, [r7, #-5]
 805d948: e7ff         	b	0x805d94a <MPU_eTaskGetState+0x36> @ imm = #-0x2
;             return eReturn;
 805d94a: f817 0c05    	ldrb	r0, [r7, #-5]
 805d94e: b002         	add	sp, #0x8
 805d950: bc80         	pop	{r7}
 805d952: eba8 0809    	sub.w	r8, r8, r9
 805d956: f858 fd48    	ldr	pc, [r8, #-72]!
 805d95a: bf00         	nop

0805d95c <$d.13>:
 805d95c: a1 f8 05 08  	.word	0x0805f8a1
 805d960: 21 5d 05 08  	.word	0x08055d21
 805d964: 21 5d 05 08  	.word	0x08055d21
 805d968: b1 f8 05 08  	.word	0x0805f8b1

0805d96c <MPU_vTaskGetInfo>:
;         {
 805d96c: f848 eb04    	str	lr, [r8], #4
 805d970: eb08 0809    	add.w	r8, r8, r9
 805d974: b480         	push	{r7}
 805d976: 466f         	mov	r7, sp
 805d978: b084         	sub	sp, #0x10
 805d97a: 9003         	str	r0, [sp, #0xc]
 805d97c: 9102         	str	r1, [sp, #0x8]
 805d97e: 9201         	str	r2, [sp, #0x4]
 805d980: f807 3c0d    	strb	r3, [r7, #-13]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805d984: 480f         	ldr	r0, [pc, #0x3c]         @ 0x805d9c4 <MPU_vTaskGetInfo+0x58>
 805d986: 4780         	blx	r0
 805d988: b960         	cbnz	r0, 0x805d9a4 <MPU_vTaskGetInfo+0x38> @ imm = #0x18
 805d98a: e7ff         	b	0x805d98c <MPU_vTaskGetInfo+0x20> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805d98c: df03         	svc	#0x3
;                 vTaskGetInfo( xTask, pxTaskStatus, xGetFreeStackSpace, eState );
 805d98e: 9803         	ldr	r0, [sp, #0xc]
 805d990: 9902         	ldr	r1, [sp, #0x8]
 805d992: 9a01         	ldr	r2, [sp, #0x4]
 805d994: f817 3c0d    	ldrb	r3, [r7, #-13]
 805d998: f8df c030    	ldr.w	r12, [pc, #0x30]        @ 0x805d9cc <MPU_vTaskGetInfo+0x60>
 805d99c: 47e0         	blx	r12
;                 portRESET_PRIVILEGE();
 805d99e: 480c         	ldr	r0, [pc, #0x30]         @ 0x805d9d0 <MPU_vTaskGetInfo+0x64>
 805d9a0: 4780         	blx	r0
;             }
 805d9a2: e008         	b	0x805d9b6 <MPU_vTaskGetInfo+0x4a> @ imm = #0x10
;                 vTaskGetInfo( xTask, pxTaskStatus, xGetFreeStackSpace, eState );
 805d9a4: 9803         	ldr	r0, [sp, #0xc]
 805d9a6: 9902         	ldr	r1, [sp, #0x8]
 805d9a8: 9a01         	ldr	r2, [sp, #0x4]
 805d9aa: f817 3c0d    	ldrb	r3, [r7, #-13]
 805d9ae: f8df c018    	ldr.w	r12, [pc, #0x18]        @ 0x805d9c8 <MPU_vTaskGetInfo+0x5c>
 805d9b2: 47e0         	blx	r12
 805d9b4: e7ff         	b	0x805d9b6 <MPU_vTaskGetInfo+0x4a> @ imm = #-0x2
;         }
 805d9b6: b004         	add	sp, #0x10
 805d9b8: bc80         	pop	{r7}
 805d9ba: eba8 0809    	sub.w	r8, r8, r9
 805d9be: f858 fd04    	ldr	pc, [r8, #-4]!
 805d9c2: bf00         	nop

0805d9c4 <$d.15>:
 805d9c4: a1 f8 05 08  	.word	0x0805f8a1
 805d9c8: 3d 75 05 08  	.word	0x0805753d
 805d9cc: 3d 75 05 08  	.word	0x0805753d
 805d9d0: b1 f8 05 08  	.word	0x0805f8b1

0805d9d4 <MPU_vTaskSuspend>:
;         {
 805d9d4: f848 eb44    	str	lr, [r8], #68
 805d9d8: eb08 0809    	add.w	r8, r8, r9
 805d9dc: b480         	push	{r7}
 805d9de: 466f         	mov	r7, sp
 805d9e0: b082         	sub	sp, #0x8
 805d9e2: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805d9e4: 480a         	ldr	r0, [pc, #0x28]         @ 0x805da10 <MPU_vTaskSuspend+0x3c>
 805d9e6: 4780         	blx	r0
 805d9e8: b938         	cbnz	r0, 0x805d9fa <MPU_vTaskSuspend+0x26> @ imm = #0xe
 805d9ea: e7ff         	b	0x805d9ec <MPU_vTaskSuspend+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805d9ec: df03         	svc	#0x3
;                 vTaskSuspend( pxTaskToSuspend );
 805d9ee: 9801         	ldr	r0, [sp, #0x4]
 805d9f0: 4909         	ldr	r1, [pc, #0x24]         @ 0x805da18 <MPU_vTaskSuspend+0x44>
 805d9f2: 4788         	blx	r1
;                 portRESET_PRIVILEGE();
 805d9f4: 4809         	ldr	r0, [pc, #0x24]         @ 0x805da1c <MPU_vTaskSuspend+0x48>
 805d9f6: 4780         	blx	r0
;             }
 805d9f8: e003         	b	0x805da02 <MPU_vTaskSuspend+0x2e> @ imm = #0x6
;                 vTaskSuspend( pxTaskToSuspend );
 805d9fa: 9801         	ldr	r0, [sp, #0x4]
 805d9fc: 4905         	ldr	r1, [pc, #0x14]         @ 0x805da14 <MPU_vTaskSuspend+0x40>
 805d9fe: 4788         	blx	r1
 805da00: e7ff         	b	0x805da02 <MPU_vTaskSuspend+0x2e> @ imm = #-0x2
;         }
 805da02: b002         	add	sp, #0x8
 805da04: bc80         	pop	{r7}
 805da06: eba8 0809    	sub.w	r8, r8, r9
 805da0a: f858 fd44    	ldr	pc, [r8, #-68]!
 805da0e: bf00         	nop

0805da10 <$d.17>:
 805da10: a1 f8 05 08  	.word	0x0805f8a1
 805da14: f5 61 05 08  	.word	0x080561f5
 805da18: f5 61 05 08  	.word	0x080561f5
 805da1c: b1 f8 05 08  	.word	0x0805f8b1

0805da20 <MPU_vTaskResume>:
;         {
 805da20: f848 eb54    	str	lr, [r8], #84
 805da24: eb08 0809    	add.w	r8, r8, r9
 805da28: b480         	push	{r7}
 805da2a: 466f         	mov	r7, sp
 805da2c: b082         	sub	sp, #0x8
 805da2e: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805da30: 480a         	ldr	r0, [pc, #0x28]         @ 0x805da5c <MPU_vTaskResume+0x3c>
 805da32: 4780         	blx	r0
 805da34: b938         	cbnz	r0, 0x805da46 <MPU_vTaskResume+0x26> @ imm = #0xe
 805da36: e7ff         	b	0x805da38 <MPU_vTaskResume+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805da38: df03         	svc	#0x3
;                 vTaskResume( pxTaskToResume );
 805da3a: 9801         	ldr	r0, [sp, #0x4]
 805da3c: 4909         	ldr	r1, [pc, #0x24]         @ 0x805da64 <MPU_vTaskResume+0x44>
 805da3e: 4788         	blx	r1
;                 portRESET_PRIVILEGE();
 805da40: 4809         	ldr	r0, [pc, #0x24]         @ 0x805da68 <MPU_vTaskResume+0x48>
 805da42: 4780         	blx	r0
;             }
 805da44: e003         	b	0x805da4e <MPU_vTaskResume+0x2e> @ imm = #0x6
;                 vTaskResume( pxTaskToResume );
 805da46: 9801         	ldr	r0, [sp, #0x4]
 805da48: 4905         	ldr	r1, [pc, #0x14]         @ 0x805da60 <MPU_vTaskResume+0x40>
 805da4a: 4788         	blx	r1
 805da4c: e7ff         	b	0x805da4e <MPU_vTaskResume+0x2e> @ imm = #-0x2
;         }
 805da4e: b002         	add	sp, #0x8
 805da50: bc80         	pop	{r7}
 805da52: eba8 0809    	sub.w	r8, r8, r9
 805da56: f858 fd54    	ldr	pc, [r8, #-84]!
 805da5a: bf00         	nop

0805da5c <$d.19>:
 805da5c: a1 f8 05 08  	.word	0x0805f8a1
 805da60: 39 64 05 08  	.word	0x08056439
 805da64: 39 64 05 08  	.word	0x08056439
 805da68: b1 f8 05 08  	.word	0x0805f8b1

0805da6c <MPU_xTaskGetTickCount>:
;     {
 805da6c: f848 eb34    	str	lr, [r8], #52
 805da70: eb08 0809    	add.w	r8, r8, r9
 805da74: b480         	push	{r7}
 805da76: 466f         	mov	r7, sp
 805da78: b082         	sub	sp, #0x8
;         if( portIS_PRIVILEGED() == pdFALSE )
 805da7a: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805daa8 <MPU_xTaskGetTickCount+0x3c>
 805da7c: 4780         	blx	r0
 805da7e: b938         	cbnz	r0, 0x805da90 <MPU_xTaskGetTickCount+0x24> @ imm = #0xe
 805da80: e7ff         	b	0x805da82 <MPU_xTaskGetTickCount+0x16> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805da82: df03         	svc	#0x3
;             xReturn = xTaskGetTickCount();
 805da84: 480a         	ldr	r0, [pc, #0x28]         @ 0x805dab0 <MPU_xTaskGetTickCount+0x44>
 805da86: 4780         	blx	r0
 805da88: 9001         	str	r0, [sp, #0x4]
;             portRESET_PRIVILEGE();
 805da8a: 480a         	ldr	r0, [pc, #0x28]         @ 0x805dab4 <MPU_xTaskGetTickCount+0x48>
 805da8c: 4780         	blx	r0
;         }
 805da8e: e003         	b	0x805da98 <MPU_xTaskGetTickCount+0x2c> @ imm = #0x6
;             xReturn = xTaskGetTickCount();
 805da90: 4806         	ldr	r0, [pc, #0x18]         @ 0x805daac <MPU_xTaskGetTickCount+0x40>
 805da92: 4780         	blx	r0
 805da94: 9001         	str	r0, [sp, #0x4]
 805da96: e7ff         	b	0x805da98 <MPU_xTaskGetTickCount+0x2c> @ imm = #-0x2
;         return xReturn;
 805da98: 9801         	ldr	r0, [sp, #0x4]
 805da9a: b002         	add	sp, #0x8
 805da9c: bc80         	pop	{r7}
 805da9e: eba8 0809    	sub.w	r8, r8, r9
 805daa2: f858 fd34    	ldr	pc, [r8, #-52]!
 805daa6: bf00         	nop

0805daa8 <$d.25>:
 805daa8: a1 f8 05 08  	.word	0x0805f8a1
 805daac: f5 6a 05 08  	.word	0x08056af5
 805dab0: f5 6a 05 08  	.word	0x08056af5
 805dab4: b1 f8 05 08  	.word	0x0805f8b1

0805dab8 <MPU_uxTaskGetNumberOfTasks>:
;     {
 805dab8: f848 eb70    	str	lr, [r8], #112
 805dabc: eb08 0809    	add.w	r8, r8, r9
 805dac0: b480         	push	{r7}
 805dac2: 466f         	mov	r7, sp
 805dac4: b082         	sub	sp, #0x8
;         if( portIS_PRIVILEGED() == pdFALSE )
 805dac6: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805daf4 <MPU_uxTaskGetNumberOfTasks+0x3c>
 805dac8: 4780         	blx	r0
 805daca: b938         	cbnz	r0, 0x805dadc <MPU_uxTaskGetNumberOfTasks+0x24> @ imm = #0xe
 805dacc: e7ff         	b	0x805dace <MPU_uxTaskGetNumberOfTasks+0x16> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805dace: df03         	svc	#0x3
;             uxReturn = uxTaskGetNumberOfTasks();
 805dad0: 480a         	ldr	r0, [pc, #0x28]         @ 0x805dafc <MPU_uxTaskGetNumberOfTasks+0x44>
 805dad2: 4780         	blx	r0
 805dad4: 9001         	str	r0, [sp, #0x4]
;             portRESET_PRIVILEGE();
 805dad6: 480a         	ldr	r0, [pc, #0x28]         @ 0x805db00 <MPU_uxTaskGetNumberOfTasks+0x48>
 805dad8: 4780         	blx	r0
;         }
 805dada: e003         	b	0x805dae4 <MPU_uxTaskGetNumberOfTasks+0x2c> @ imm = #0x6
;             uxReturn = uxTaskGetNumberOfTasks();
 805dadc: 4806         	ldr	r0, [pc, #0x18]         @ 0x805daf8 <MPU_uxTaskGetNumberOfTasks+0x40>
 805dade: 4780         	blx	r0
 805dae0: 9001         	str	r0, [sp, #0x4]
 805dae2: e7ff         	b	0x805dae4 <MPU_uxTaskGetNumberOfTasks+0x2c> @ imm = #-0x2
;         return uxReturn;
 805dae4: 9801         	ldr	r0, [sp, #0x4]
 805dae6: b002         	add	sp, #0x8
 805dae8: bc80         	pop	{r7}
 805daea: eba8 0809    	sub.w	r8, r8, r9
 805daee: f858 fd70    	ldr	pc, [r8, #-112]!
 805daf2: bf00         	nop

0805daf4 <$d.27>:
 805daf4: a1 f8 05 08  	.word	0x0805f8a1
 805daf8: 3d 6b 05 08  	.word	0x08056b3d
 805dafc: 3d 6b 05 08  	.word	0x08056b3d
 805db00: b1 f8 05 08  	.word	0x0805f8b1

0805db04 <MPU_uxTaskGetSystemState>:
;         {
 805db04: f848 eb5c    	str	lr, [r8], #92
 805db08: eb08 0809    	add.w	r8, r8, r9
 805db0c: b480         	push	{r7}
 805db0e: 466f         	mov	r7, sp
 805db10: b084         	sub	sp, #0x10
 805db12: 9003         	str	r0, [sp, #0xc]
 805db14: 9102         	str	r1, [sp, #0x8]
 805db16: 9201         	str	r2, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805db18: 480d         	ldr	r0, [pc, #0x34]         @ 0x805db50 <MPU_uxTaskGetSystemState+0x4c>
 805db1a: 4780         	blx	r0
 805db1c: b950         	cbnz	r0, 0x805db34 <MPU_uxTaskGetSystemState+0x30> @ imm = #0x14
 805db1e: e7ff         	b	0x805db20 <MPU_uxTaskGetSystemState+0x1c> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805db20: df03         	svc	#0x3
;                 uxReturn = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, pulTotalRunTime );
 805db22: 9803         	ldr	r0, [sp, #0xc]
 805db24: 9902         	ldr	r1, [sp, #0x8]
 805db26: 9a01         	ldr	r2, [sp, #0x4]
 805db28: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x805db58 <MPU_uxTaskGetSystemState+0x54>
 805db2a: 4798         	blx	r3
 805db2c: 9000         	str	r0, [sp]
;                 portRESET_PRIVILEGE();
 805db2e: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805db5c <MPU_uxTaskGetSystemState+0x58>
 805db30: 4780         	blx	r0
;             }
 805db32: e006         	b	0x805db42 <MPU_uxTaskGetSystemState+0x3e> @ imm = #0xc
;                 uxReturn = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, pulTotalRunTime );
 805db34: 9803         	ldr	r0, [sp, #0xc]
 805db36: 9902         	ldr	r1, [sp, #0x8]
 805db38: 9a01         	ldr	r2, [sp, #0x4]
 805db3a: 4b06         	ldr	r3, [pc, #0x18]         @ 0x805db54 <MPU_uxTaskGetSystemState+0x50>
 805db3c: 4798         	blx	r3
 805db3e: 9000         	str	r0, [sp]
 805db40: e7ff         	b	0x805db42 <MPU_uxTaskGetSystemState+0x3e> @ imm = #-0x2
;             return uxReturn;
 805db42: 9800         	ldr	r0, [sp]
 805db44: b004         	add	sp, #0x10
 805db46: bc80         	pop	{r7}
 805db48: eba8 0809    	sub.w	r8, r8, r9
 805db4c: f858 fd5c    	ldr	pc, [r8, #-92]!

0805db50 <$d.29>:
 805db50: a1 f8 05 08  	.word	0x0805f8a1
 805db54: 99 6b 05 08  	.word	0x08056b99
 805db58: 99 6b 05 08  	.word	0x08056b99
 805db5c: b1 f8 05 08  	.word	0x0805f8b1

0805db60 <MPU_uxTaskGetStackHighWaterMark>:
;         {
 805db60: f848 eb20    	str	lr, [r8], #32
 805db64: eb08 0809    	add.w	r8, r8, r9
 805db68: b480         	push	{r7}
 805db6a: 466f         	mov	r7, sp
 805db6c: b082         	sub	sp, #0x8
 805db6e: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805db70: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805dba0 <MPU_uxTaskGetStackHighWaterMark+0x40>
 805db72: 4780         	blx	r0
 805db74: b940         	cbnz	r0, 0x805db88 <MPU_uxTaskGetStackHighWaterMark+0x28> @ imm = #0x10
 805db76: e7ff         	b	0x805db78 <MPU_uxTaskGetStackHighWaterMark+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805db78: df03         	svc	#0x3
;                 uxReturn = uxTaskGetStackHighWaterMark( xTask );
 805db7a: 9801         	ldr	r0, [sp, #0x4]
 805db7c: 490a         	ldr	r1, [pc, #0x28]         @ 0x805dba8 <MPU_uxTaskGetStackHighWaterMark+0x48>
 805db7e: 4788         	blx	r1
 805db80: 9000         	str	r0, [sp]
;                 portRESET_PRIVILEGE();
 805db82: 480a         	ldr	r0, [pc, #0x28]         @ 0x805dbac <MPU_uxTaskGetStackHighWaterMark+0x4c>
 805db84: 4780         	blx	r0
;             }
 805db86: e004         	b	0x805db92 <MPU_uxTaskGetStackHighWaterMark+0x32> @ imm = #0x8
;                 uxReturn = uxTaskGetStackHighWaterMark( xTask );
 805db88: 9801         	ldr	r0, [sp, #0x4]
 805db8a: 4906         	ldr	r1, [pc, #0x18]         @ 0x805dba4 <MPU_uxTaskGetStackHighWaterMark+0x44>
 805db8c: 4788         	blx	r1
 805db8e: 9000         	str	r0, [sp]
 805db90: e7ff         	b	0x805db92 <MPU_uxTaskGetStackHighWaterMark+0x32> @ imm = #-0x2
;             return uxReturn;
 805db92: 9800         	ldr	r0, [sp]
 805db94: b002         	add	sp, #0x8
 805db96: bc80         	pop	{r7}
 805db98: eba8 0809    	sub.w	r8, r8, r9
 805db9c: f858 fd20    	ldr	pc, [r8, #-32]!

0805dba0 <$d.33>:
 805dba0: a1 f8 05 08  	.word	0x0805f8a1
 805dba4: a9 76 05 08  	.word	0x080576a9
 805dba8: a9 76 05 08  	.word	0x080576a9
 805dbac: b1 f8 05 08  	.word	0x0805f8b1

0805dbb0 <MPU_xTaskGetCurrentTaskHandle>:
;         {
 805dbb0: f848 eb48    	str	lr, [r8], #72
 805dbb4: eb08 0809    	add.w	r8, r8, r9
 805dbb8: b480         	push	{r7}
 805dbba: 466f         	mov	r7, sp
 805dbbc: b082         	sub	sp, #0x8
;             if( portIS_PRIVILEGED() == pdFALSE )
 805dbbe: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805dbec <MPU_xTaskGetCurrentTaskHandle+0x3c>
 805dbc0: 4780         	blx	r0
 805dbc2: b938         	cbnz	r0, 0x805dbd4 <MPU_xTaskGetCurrentTaskHandle+0x24> @ imm = #0xe
 805dbc4: e7ff         	b	0x805dbc6 <MPU_xTaskGetCurrentTaskHandle+0x16> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805dbc6: df03         	svc	#0x3
;                 xReturn = xTaskGetCurrentTaskHandle();
 805dbc8: 480a         	ldr	r0, [pc, #0x28]         @ 0x805dbf4 <MPU_xTaskGetCurrentTaskHandle+0x44>
 805dbca: 4780         	blx	r0
 805dbcc: 9001         	str	r0, [sp, #0x4]
;                 portRESET_PRIVILEGE();
 805dbce: 480a         	ldr	r0, [pc, #0x28]         @ 0x805dbf8 <MPU_xTaskGetCurrentTaskHandle+0x48>
 805dbd0: 4780         	blx	r0
;             }
 805dbd2: e003         	b	0x805dbdc <MPU_xTaskGetCurrentTaskHandle+0x2c> @ imm = #0x6
;                 xReturn = xTaskGetCurrentTaskHandle();
 805dbd4: 4806         	ldr	r0, [pc, #0x18]         @ 0x805dbf0 <MPU_xTaskGetCurrentTaskHandle+0x40>
 805dbd6: 4780         	blx	r0
 805dbd8: 9001         	str	r0, [sp, #0x4]
 805dbda: e7ff         	b	0x805dbdc <MPU_xTaskGetCurrentTaskHandle+0x2c> @ imm = #-0x2
;             return xReturn;
 805dbdc: 9801         	ldr	r0, [sp, #0x4]
 805dbde: b002         	add	sp, #0x8
 805dbe0: bc80         	pop	{r7}
 805dbe2: eba8 0809    	sub.w	r8, r8, r9
 805dbe6: f858 fd48    	ldr	pc, [r8, #-72]!
 805dbea: bf00         	nop

0805dbec <$d.35>:
 805dbec: a1 f8 05 08  	.word	0x0805f8a1
 805dbf0: f9 76 05 08  	.word	0x080576f9
 805dbf4: f9 76 05 08  	.word	0x080576f9
 805dbf8: b1 f8 05 08  	.word	0x0805f8b1

0805dbfc <MPU_xTaskGetSchedulerState>:
;         {
 805dbfc: f848 eb40    	str	lr, [r8], #64
 805dc00: eb08 0809    	add.w	r8, r8, r9
 805dc04: b480         	push	{r7}
 805dc06: 466f         	mov	r7, sp
 805dc08: b082         	sub	sp, #0x8
;             if( portIS_PRIVILEGED() == pdFALSE )
 805dc0a: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805dc38 <MPU_xTaskGetSchedulerState+0x3c>
 805dc0c: 4780         	blx	r0
 805dc0e: b938         	cbnz	r0, 0x805dc20 <MPU_xTaskGetSchedulerState+0x24> @ imm = #0xe
 805dc10: e7ff         	b	0x805dc12 <MPU_xTaskGetSchedulerState+0x16> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805dc12: df03         	svc	#0x3
;                 xReturn = xTaskGetSchedulerState();
 805dc14: 480a         	ldr	r0, [pc, #0x28]         @ 0x805dc40 <MPU_xTaskGetSchedulerState+0x44>
 805dc16: 4780         	blx	r0
 805dc18: 9001         	str	r0, [sp, #0x4]
;                 portRESET_PRIVILEGE();
 805dc1a: 480a         	ldr	r0, [pc, #0x28]         @ 0x805dc44 <MPU_xTaskGetSchedulerState+0x48>
 805dc1c: 4780         	blx	r0
;             }
 805dc1e: e003         	b	0x805dc28 <MPU_xTaskGetSchedulerState+0x2c> @ imm = #0x6
;                 xReturn = xTaskGetSchedulerState();
 805dc20: 4806         	ldr	r0, [pc, #0x18]         @ 0x805dc3c <MPU_xTaskGetSchedulerState+0x40>
 805dc22: 4780         	blx	r0
 805dc24: 9001         	str	r0, [sp, #0x4]
 805dc26: e7ff         	b	0x805dc28 <MPU_xTaskGetSchedulerState+0x2c> @ imm = #-0x2
;             return xReturn;
 805dc28: 9801         	ldr	r0, [sp, #0x4]
 805dc2a: b002         	add	sp, #0x8
 805dc2c: bc80         	pop	{r7}
 805dc2e: eba8 0809    	sub.w	r8, r8, r9
 805dc32: f858 fd40    	ldr	pc, [r8, #-64]!
 805dc36: bf00         	nop

0805dc38 <$d.37>:
 805dc38: a1 f8 05 08  	.word	0x0805f8a1
 805dc3c: 0d 77 05 08  	.word	0x0805770d
 805dc40: 0d 77 05 08  	.word	0x0805770d
 805dc44: b1 f8 05 08  	.word	0x0805f8b1

0805dc48 <MPU_vTaskSetTimeOutState>:
;     {
 805dc48: f848 eb04    	str	lr, [r8], #4
 805dc4c: eb08 0809    	add.w	r8, r8, r9
 805dc50: b480         	push	{r7}
 805dc52: 466f         	mov	r7, sp
 805dc54: b082         	sub	sp, #0x8
 805dc56: 9001         	str	r0, [sp, #0x4]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805dc58: 480a         	ldr	r0, [pc, #0x28]         @ 0x805dc84 <MPU_vTaskSetTimeOutState+0x3c>
 805dc5a: 4780         	blx	r0
 805dc5c: b938         	cbnz	r0, 0x805dc6e <MPU_vTaskSetTimeOutState+0x26> @ imm = #0xe
 805dc5e: e7ff         	b	0x805dc60 <MPU_vTaskSetTimeOutState+0x18> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805dc60: df03         	svc	#0x3
;             vTaskSetTimeOutState( pxTimeOut );
 805dc62: 9801         	ldr	r0, [sp, #0x4]
 805dc64: 4909         	ldr	r1, [pc, #0x24]         @ 0x805dc8c <MPU_vTaskSetTimeOutState+0x44>
 805dc66: 4788         	blx	r1
;             portRESET_PRIVILEGE();
 805dc68: 4809         	ldr	r0, [pc, #0x24]         @ 0x805dc90 <MPU_vTaskSetTimeOutState+0x48>
 805dc6a: 4780         	blx	r0
;         }
 805dc6c: e003         	b	0x805dc76 <MPU_vTaskSetTimeOutState+0x2e> @ imm = #0x6
;             vTaskSetTimeOutState( pxTimeOut );
 805dc6e: 9801         	ldr	r0, [sp, #0x4]
 805dc70: 4905         	ldr	r1, [pc, #0x14]         @ 0x805dc88 <MPU_vTaskSetTimeOutState+0x40>
 805dc72: 4788         	blx	r1
 805dc74: e7ff         	b	0x805dc76 <MPU_vTaskSetTimeOutState+0x2e> @ imm = #-0x2
;     }
 805dc76: b002         	add	sp, #0x8
 805dc78: bc80         	pop	{r7}
 805dc7a: eba8 0809    	sub.w	r8, r8, r9
 805dc7e: f858 fd04    	ldr	pc, [r8, #-4]!
 805dc82: bf00         	nop

0805dc84 <$d.39>:
 805dc84: a1 f8 05 08  	.word	0x0805f8a1
 805dc88: 41 73 05 08  	.word	0x08057341
 805dc8c: 41 73 05 08  	.word	0x08057341
 805dc90: b1 f8 05 08  	.word	0x0805f8b1

0805dc94 <MPU_xTaskCheckForTimeOut>:
;     {
 805dc94: f848 eb5c    	str	lr, [r8], #92
 805dc98: eb08 0809    	add.w	r8, r8, r9
 805dc9c: b480         	push	{r7}
 805dc9e: 466f         	mov	r7, sp
 805dca0: b084         	sub	sp, #0x10
 805dca2: 9003         	str	r0, [sp, #0xc]
 805dca4: 9102         	str	r1, [sp, #0x8]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805dca6: 480d         	ldr	r0, [pc, #0x34]         @ 0x805dcdc <MPU_xTaskCheckForTimeOut+0x48>
 805dca8: 4780         	blx	r0
 805dcaa: b948         	cbnz	r0, 0x805dcc0 <MPU_xTaskCheckForTimeOut+0x2c> @ imm = #0x12
 805dcac: e7ff         	b	0x805dcae <MPU_xTaskCheckForTimeOut+0x1a> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805dcae: df03         	svc	#0x3
;             xReturn = xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );
 805dcb0: 9803         	ldr	r0, [sp, #0xc]
 805dcb2: 9902         	ldr	r1, [sp, #0x8]
 805dcb4: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x805dce4 <MPU_xTaskCheckForTimeOut+0x50>
 805dcb6: 4790         	blx	r2
 805dcb8: 9001         	str	r0, [sp, #0x4]
;             portRESET_PRIVILEGE();
 805dcba: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805dce8 <MPU_xTaskCheckForTimeOut+0x54>
 805dcbc: 4780         	blx	r0
;         }
 805dcbe: e005         	b	0x805dccc <MPU_xTaskCheckForTimeOut+0x38> @ imm = #0xa
;             xReturn = xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );
 805dcc0: 9803         	ldr	r0, [sp, #0xc]
 805dcc2: 9902         	ldr	r1, [sp, #0x8]
 805dcc4: 4a06         	ldr	r2, [pc, #0x18]         @ 0x805dce0 <MPU_xTaskCheckForTimeOut+0x4c>
 805dcc6: 4790         	blx	r2
 805dcc8: 9001         	str	r0, [sp, #0x4]
 805dcca: e7ff         	b	0x805dccc <MPU_xTaskCheckForTimeOut+0x38> @ imm = #-0x2
;         return xReturn;
 805dccc: 9801         	ldr	r0, [sp, #0x4]
 805dcce: b004         	add	sp, #0x10
 805dcd0: bc80         	pop	{r7}
 805dcd2: eba8 0809    	sub.w	r8, r8, r9
 805dcd6: f858 fd5c    	ldr	pc, [r8, #-92]!
 805dcda: bf00         	nop

0805dcdc <$d.41>:
 805dcdc: a1 f8 05 08  	.word	0x0805f8a1
 805dce0: c1 73 05 08  	.word	0x080573c1
 805dce4: c1 73 05 08  	.word	0x080573c1
 805dce8: b1 f8 05 08  	.word	0x0805f8b1

0805dcec <MPU_xTaskGenericNotify>:
;         {
 805dcec: f848 eb08    	str	lr, [r8], #8
 805dcf0: eb08 0809    	add.w	r8, r8, r9
 805dcf4: b480         	push	{r7}
 805dcf6: 466f         	mov	r7, sp
 805dcf8: b086         	sub	sp, #0x18
 805dcfa: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805dcfe: 9005         	str	r0, [sp, #0x14]
 805dd00: 9104         	str	r1, [sp, #0x10]
 805dd02: 9203         	str	r2, [sp, #0xc]
 805dd04: f807 3c0d    	strb	r3, [r7, #-13]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805dd08: 4815         	ldr	r0, [pc, #0x54]         @ 0x805dd60 <MPU_xTaskGenericNotify+0x74>
 805dd0a: 4780         	blx	r0
 805dd0c: b990         	cbnz	r0, 0x805dd34 <MPU_xTaskGenericNotify+0x48> @ imm = #0x24
 805dd0e: e7ff         	b	0x805dd10 <MPU_xTaskGenericNotify+0x24> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805dd10: df03         	svc	#0x3
;                 xReturn = xTaskGenericNotify( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue );
 805dd12: 9805         	ldr	r0, [sp, #0x14]
 805dd14: 9904         	ldr	r1, [sp, #0x10]
 805dd16: 9a03         	ldr	r2, [sp, #0xc]
 805dd18: f817 3c0d    	ldrb	r3, [r7, #-13]
 805dd1c: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805dd20: 46ee         	mov	lr, sp
 805dd22: f8ce c000    	str.w	r12, [lr]
 805dd26: f8df c040    	ldr.w	r12, [pc, #0x40]        @ 0x805dd68 <MPU_xTaskGenericNotify+0x7c>
 805dd2a: 47e0         	blx	r12
 805dd2c: 9001         	str	r0, [sp, #0x4]
;                 portRESET_PRIVILEGE();
 805dd2e: 480f         	ldr	r0, [pc, #0x3c]         @ 0x805dd6c <MPU_xTaskGenericNotify+0x80>
 805dd30: 4780         	blx	r0
;             }
 805dd32: e00e         	b	0x805dd52 <MPU_xTaskGenericNotify+0x66> @ imm = #0x1c
;                 xReturn = xTaskGenericNotify( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue );
 805dd34: 9805         	ldr	r0, [sp, #0x14]
 805dd36: 9904         	ldr	r1, [sp, #0x10]
 805dd38: 9a03         	ldr	r2, [sp, #0xc]
 805dd3a: f817 3c0d    	ldrb	r3, [r7, #-13]
 805dd3e: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805dd42: 46ee         	mov	lr, sp
 805dd44: f8ce c000    	str.w	r12, [lr]
 805dd48: f8df c018    	ldr.w	r12, [pc, #0x18]        @ 0x805dd64 <MPU_xTaskGenericNotify+0x78>
 805dd4c: 47e0         	blx	r12
 805dd4e: 9001         	str	r0, [sp, #0x4]
 805dd50: e7ff         	b	0x805dd52 <MPU_xTaskGenericNotify+0x66> @ imm = #-0x2
;             return xReturn;
 805dd52: 9801         	ldr	r0, [sp, #0x4]
 805dd54: b006         	add	sp, #0x18
 805dd56: bc80         	pop	{r7}
 805dd58: eba8 0809    	sub.w	r8, r8, r9
 805dd5c: f858 fd08    	ldr	pc, [r8, #-8]!

0805dd60 <$d.43>:
 805dd60: a1 f8 05 08  	.word	0x0805f8a1
 805dd64: d1 7e 05 08  	.word	0x08057ed1
 805dd68: d1 7e 05 08  	.word	0x08057ed1
 805dd6c: b1 f8 05 08  	.word	0x0805f8b1

0805dd70 <MPU_xTaskGenericNotifyWait>:
;         {
 805dd70: f848 eb10    	str	lr, [r8], #16
 805dd74: eb08 0809    	add.w	r8, r8, r9
 805dd78: b480         	push	{r7}
 805dd7a: 466f         	mov	r7, sp
 805dd7c: b086         	sub	sp, #0x18
 805dd7e: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805dd82: 9005         	str	r0, [sp, #0x14]
 805dd84: 9104         	str	r1, [sp, #0x10]
 805dd86: 9203         	str	r2, [sp, #0xc]
 805dd88: 9302         	str	r3, [sp, #0x8]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805dd8a: 4815         	ldr	r0, [pc, #0x54]         @ 0x805dde0 <MPU_xTaskGenericNotifyWait+0x70>
 805dd8c: 4780         	blx	r0
 805dd8e: b988         	cbnz	r0, 0x805ddb4 <MPU_xTaskGenericNotifyWait+0x44> @ imm = #0x22
 805dd90: e7ff         	b	0x805dd92 <MPU_xTaskGenericNotifyWait+0x22> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805dd92: df03         	svc	#0x3
;                 xReturn = xTaskGenericNotifyWait( uxIndexToWaitOn, ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait );
 805dd94: 9805         	ldr	r0, [sp, #0x14]
 805dd96: 9904         	ldr	r1, [sp, #0x10]
 805dd98: 9a03         	ldr	r2, [sp, #0xc]
 805dd9a: 9b02         	ldr	r3, [sp, #0x8]
 805dd9c: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805dda0: 46ee         	mov	lr, sp
 805dda2: f8ce c000    	str.w	r12, [lr]
 805dda6: f8df c040    	ldr.w	r12, [pc, #0x40]        @ 0x805dde8 <MPU_xTaskGenericNotifyWait+0x78>
 805ddaa: 47e0         	blx	r12
 805ddac: 9001         	str	r0, [sp, #0x4]
;                 portRESET_PRIVILEGE();
 805ddae: 480f         	ldr	r0, [pc, #0x3c]         @ 0x805ddec <MPU_xTaskGenericNotifyWait+0x7c>
 805ddb0: 4780         	blx	r0
;             }
 805ddb2: e00d         	b	0x805ddd0 <MPU_xTaskGenericNotifyWait+0x60> @ imm = #0x1a
;                 xReturn = xTaskGenericNotifyWait( uxIndexToWaitOn, ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait );
 805ddb4: 9805         	ldr	r0, [sp, #0x14]
 805ddb6: 9904         	ldr	r1, [sp, #0x10]
 805ddb8: 9a03         	ldr	r2, [sp, #0xc]
 805ddba: 9b02         	ldr	r3, [sp, #0x8]
 805ddbc: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805ddc0: 46ee         	mov	lr, sp
 805ddc2: f8ce c000    	str.w	r12, [lr]
 805ddc6: f8df c01c    	ldr.w	r12, [pc, #0x1c]        @ 0x805dde4 <MPU_xTaskGenericNotifyWait+0x74>
 805ddca: 47e0         	blx	r12
 805ddcc: 9001         	str	r0, [sp, #0x4]
 805ddce: e7ff         	b	0x805ddd0 <MPU_xTaskGenericNotifyWait+0x60> @ imm = #-0x2
;             return xReturn;
 805ddd0: 9801         	ldr	r0, [sp, #0x4]
 805ddd2: b006         	add	sp, #0x18
 805ddd4: bc80         	pop	{r7}
 805ddd6: eba8 0809    	sub.w	r8, r8, r9
 805ddda: f858 fd10    	ldr	pc, [r8, #-16]!
 805ddde: bf00         	nop

0805dde0 <$d.45>:
 805dde0: a1 f8 05 08  	.word	0x0805f8a1
 805dde4: 75 7d 05 08  	.word	0x08057d75
 805dde8: 75 7d 05 08  	.word	0x08057d75
 805ddec: b1 f8 05 08  	.word	0x0805f8b1

0805ddf0 <MPU_ulTaskGenericNotifyTake>:
;         {
 805ddf0: f848 eb10    	str	lr, [r8], #16
 805ddf4: eb08 0809    	add.w	r8, r8, r9
 805ddf8: b480         	push	{r7}
 805ddfa: 466f         	mov	r7, sp
 805ddfc: b084         	sub	sp, #0x10
 805ddfe: 9003         	str	r0, [sp, #0xc]
 805de00: 9102         	str	r1, [sp, #0x8]
 805de02: 9201         	str	r2, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805de04: 480d         	ldr	r0, [pc, #0x34]         @ 0x805de3c <MPU_ulTaskGenericNotifyTake+0x4c>
 805de06: 4780         	blx	r0
 805de08: b950         	cbnz	r0, 0x805de20 <MPU_ulTaskGenericNotifyTake+0x30> @ imm = #0x14
 805de0a: e7ff         	b	0x805de0c <MPU_ulTaskGenericNotifyTake+0x1c> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805de0c: df03         	svc	#0x3
;                 ulReturn = ulTaskGenericNotifyTake( uxIndexToWaitOn, xClearCountOnExit, xTicksToWait );
 805de0e: 9803         	ldr	r0, [sp, #0xc]
 805de10: 9902         	ldr	r1, [sp, #0x8]
 805de12: 9a01         	ldr	r2, [sp, #0x4]
 805de14: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x805de44 <MPU_ulTaskGenericNotifyTake+0x54>
 805de16: 4798         	blx	r3
 805de18: 9000         	str	r0, [sp]
;                 portRESET_PRIVILEGE();
 805de1a: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805de48 <MPU_ulTaskGenericNotifyTake+0x58>
 805de1c: 4780         	blx	r0
;             }
 805de1e: e006         	b	0x805de2e <MPU_ulTaskGenericNotifyTake+0x3e> @ imm = #0xc
;                 ulReturn = ulTaskGenericNotifyTake( uxIndexToWaitOn, xClearCountOnExit, xTicksToWait );
 805de20: 9803         	ldr	r0, [sp, #0xc]
 805de22: 9902         	ldr	r1, [sp, #0x8]
 805de24: 9a01         	ldr	r2, [sp, #0x4]
 805de26: 4b06         	ldr	r3, [pc, #0x18]         @ 0x805de40 <MPU_ulTaskGenericNotifyTake+0x50>
 805de28: 4798         	blx	r3
 805de2a: 9000         	str	r0, [sp]
 805de2c: e7ff         	b	0x805de2e <MPU_ulTaskGenericNotifyTake+0x3e> @ imm = #-0x2
;             return ulReturn;
 805de2e: 9800         	ldr	r0, [sp]
 805de30: b004         	add	sp, #0x10
 805de32: bc80         	pop	{r7}
 805de34: eba8 0809    	sub.w	r8, r8, r9
 805de38: f858 fd10    	ldr	pc, [r8, #-16]!

0805de3c <$d.47>:
 805de3c: a1 f8 05 08  	.word	0x0805f8a1
 805de40: 39 7c 05 08  	.word	0x08057c39
 805de44: 39 7c 05 08  	.word	0x08057c39
 805de48: b1 f8 05 08  	.word	0x0805f8b1

0805de4c <MPU_xTaskGenericNotifyStateClear>:
;         {
 805de4c: f848 eb08    	str	lr, [r8], #8
 805de50: eb08 0809    	add.w	r8, r8, r9
 805de54: b480         	push	{r7}
 805de56: 466f         	mov	r7, sp
 805de58: b084         	sub	sp, #0x10
 805de5a: 9003         	str	r0, [sp, #0xc]
 805de5c: 9102         	str	r1, [sp, #0x8]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805de5e: 480d         	ldr	r0, [pc, #0x34]         @ 0x805de94 <MPU_xTaskGenericNotifyStateClear+0x48>
 805de60: 4780         	blx	r0
 805de62: b948         	cbnz	r0, 0x805de78 <MPU_xTaskGenericNotifyStateClear+0x2c> @ imm = #0x12
 805de64: e7ff         	b	0x805de66 <MPU_xTaskGenericNotifyStateClear+0x1a> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805de66: df03         	svc	#0x3
;                 xReturn = xTaskGenericNotifyStateClear( xTask, uxIndexToClear );
 805de68: 9803         	ldr	r0, [sp, #0xc]
 805de6a: 9902         	ldr	r1, [sp, #0x8]
 805de6c: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x805de9c <MPU_xTaskGenericNotifyStateClear+0x50>
 805de6e: 4790         	blx	r2
 805de70: 9001         	str	r0, [sp, #0x4]
;                 portRESET_PRIVILEGE();
 805de72: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805dea0 <MPU_xTaskGenericNotifyStateClear+0x54>
 805de74: 4780         	blx	r0
;             }
 805de76: e005         	b	0x805de84 <MPU_xTaskGenericNotifyStateClear+0x38> @ imm = #0xa
;                 xReturn = xTaskGenericNotifyStateClear( xTask, uxIndexToClear );
 805de78: 9803         	ldr	r0, [sp, #0xc]
 805de7a: 9902         	ldr	r1, [sp, #0x8]
 805de7c: 4a06         	ldr	r2, [pc, #0x18]         @ 0x805de98 <MPU_xTaskGenericNotifyStateClear+0x4c>
 805de7e: 4790         	blx	r2
 805de80: 9001         	str	r0, [sp, #0x4]
 805de82: e7ff         	b	0x805de84 <MPU_xTaskGenericNotifyStateClear+0x38> @ imm = #-0x2
;             return xReturn;
 805de84: 9801         	ldr	r0, [sp, #0x4]
 805de86: b004         	add	sp, #0x10
 805de88: bc80         	pop	{r7}
 805de8a: eba8 0809    	sub.w	r8, r8, r9
 805de8e: f858 fd08    	ldr	pc, [r8, #-8]!
 805de92: bf00         	nop

0805de94 <$d.49>:
 805de94: a1 f8 05 08  	.word	0x0805f8a1
 805de98: 59 86 05 08  	.word	0x08058659
 805de9c: 59 86 05 08  	.word	0x08058659
 805dea0: b1 f8 05 08  	.word	0x0805f8b1

0805dea4 <MPU_ulTaskGenericNotifyValueClear>:
;         {
 805dea4: f848 eb64    	str	lr, [r8], #100
 805dea8: eb08 0809    	add.w	r8, r8, r9
 805deac: b480         	push	{r7}
 805deae: 466f         	mov	r7, sp
 805deb0: b084         	sub	sp, #0x10
 805deb2: 9003         	str	r0, [sp, #0xc]
 805deb4: 9102         	str	r1, [sp, #0x8]
 805deb6: 9201         	str	r2, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805deb8: 480d         	ldr	r0, [pc, #0x34]         @ 0x805def0 <MPU_ulTaskGenericNotifyValueClear+0x4c>
 805deba: 4780         	blx	r0
 805debc: b950         	cbnz	r0, 0x805ded4 <MPU_ulTaskGenericNotifyValueClear+0x30> @ imm = #0x14
 805debe: e7ff         	b	0x805dec0 <MPU_ulTaskGenericNotifyValueClear+0x1c> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805dec0: df03         	svc	#0x3
;                 ulReturn = ulTaskGenericNotifyValueClear( xTask, uxIndexToClear, ulBitsToClear );
 805dec2: 9803         	ldr	r0, [sp, #0xc]
 805dec4: 9902         	ldr	r1, [sp, #0x8]
 805dec6: 9a01         	ldr	r2, [sp, #0x4]
 805dec8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x805def8 <MPU_ulTaskGenericNotifyValueClear+0x54>
 805deca: 4798         	blx	r3
 805decc: 9000         	str	r0, [sp]
;                 portRESET_PRIVILEGE();
 805dece: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805defc <MPU_ulTaskGenericNotifyValueClear+0x58>
 805ded0: 4780         	blx	r0
;             }
 805ded2: e006         	b	0x805dee2 <MPU_ulTaskGenericNotifyValueClear+0x3e> @ imm = #0xc
;                 ulReturn = ulTaskGenericNotifyValueClear( xTask, uxIndexToClear, ulBitsToClear );
 805ded4: 9803         	ldr	r0, [sp, #0xc]
 805ded6: 9902         	ldr	r1, [sp, #0x8]
 805ded8: 9a01         	ldr	r2, [sp, #0x4]
 805deda: 4b06         	ldr	r3, [pc, #0x18]         @ 0x805def4 <MPU_ulTaskGenericNotifyValueClear+0x50>
 805dedc: 4798         	blx	r3
 805dede: 9000         	str	r0, [sp]
 805dee0: e7ff         	b	0x805dee2 <MPU_ulTaskGenericNotifyValueClear+0x3e> @ imm = #-0x2
;             return ulReturn;
 805dee2: 9800         	ldr	r0, [sp]
 805dee4: b004         	add	sp, #0x10
 805dee6: bc80         	pop	{r7}
 805dee8: eba8 0809    	sub.w	r8, r8, r9
 805deec: f858 fd64    	ldr	pc, [r8, #-100]!

0805def0 <$d.51>:
 805def0: a1 f8 05 08  	.word	0x0805f8a1
 805def4: e1 86 05 08  	.word	0x080586e1
 805def8: e1 86 05 08  	.word	0x080586e1
 805defc: b1 f8 05 08  	.word	0x0805f8b1

0805df00 <MPU_xQueueGenericSend>:
;     {
 805df00: f848 eb48    	str	lr, [r8], #72
 805df04: eb08 0809    	add.w	r8, r8, r9
 805df08: b480         	push	{r7}
 805df0a: 466f         	mov	r7, sp
 805df0c: b086         	sub	sp, #0x18
 805df0e: 9005         	str	r0, [sp, #0x14]
 805df10: 9104         	str	r1, [sp, #0x10]
 805df12: 9203         	str	r2, [sp, #0xc]
 805df14: 9302         	str	r3, [sp, #0x8]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805df16: 4810         	ldr	r0, [pc, #0x40]         @ 0x805df58 <MPU_xQueueGenericSend+0x58>
 805df18: 4780         	blx	r0
 805df1a: b960         	cbnz	r0, 0x805df36 <MPU_xQueueGenericSend+0x36> @ imm = #0x18
 805df1c: e7ff         	b	0x805df1e <MPU_xQueueGenericSend+0x1e> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805df1e: df03         	svc	#0x3
;             xReturn = xQueueGenericSend( xQueue, pvItemToQueue, xTicksToWait, xCopyPosition );
 805df20: 9805         	ldr	r0, [sp, #0x14]
 805df22: 9904         	ldr	r1, [sp, #0x10]
 805df24: 9a03         	ldr	r2, [sp, #0xc]
 805df26: 9b02         	ldr	r3, [sp, #0x8]
 805df28: f8df c034    	ldr.w	r12, [pc, #0x34]        @ 0x805df60 <MPU_xQueueGenericSend+0x60>
 805df2c: 47e0         	blx	r12
 805df2e: 9001         	str	r0, [sp, #0x4]
;             portRESET_PRIVILEGE();
 805df30: 480c         	ldr	r0, [pc, #0x30]         @ 0x805df64 <MPU_xQueueGenericSend+0x64>
 805df32: 4780         	blx	r0
;         }
 805df34: e008         	b	0x805df48 <MPU_xQueueGenericSend+0x48> @ imm = #0x10
;             xReturn = xQueueGenericSend( xQueue, pvItemToQueue, xTicksToWait, xCopyPosition );
 805df36: 9805         	ldr	r0, [sp, #0x14]
 805df38: 9904         	ldr	r1, [sp, #0x10]
 805df3a: 9a03         	ldr	r2, [sp, #0xc]
 805df3c: 9b02         	ldr	r3, [sp, #0x8]
 805df3e: f8df c01c    	ldr.w	r12, [pc, #0x1c]        @ 0x805df5c <MPU_xQueueGenericSend+0x5c>
 805df42: 47e0         	blx	r12
 805df44: 9001         	str	r0, [sp, #0x4]
 805df46: e7ff         	b	0x805df48 <MPU_xQueueGenericSend+0x48> @ imm = #-0x2
;         return xReturn;
 805df48: 9801         	ldr	r0, [sp, #0x4]
 805df4a: b006         	add	sp, #0x18
 805df4c: bc80         	pop	{r7}
 805df4e: eba8 0809    	sub.w	r8, r8, r9
 805df52: f858 fd48    	ldr	pc, [r8, #-72]!
 805df56: bf00         	nop

0805df58 <$d.57>:
 805df58: a1 f8 05 08  	.word	0x0805f8a1
 805df5c: 1d a9 05 08  	.word	0x0805a91d
 805df60: 1d a9 05 08  	.word	0x0805a91d
 805df64: b1 f8 05 08  	.word	0x0805f8b1

0805df68 <MPU_uxQueueMessagesWaiting>:
;     {
 805df68: f848 eb30    	str	lr, [r8], #48
 805df6c: eb08 0809    	add.w	r8, r8, r9
 805df70: b480         	push	{r7}
 805df72: 466f         	mov	r7, sp
 805df74: b082         	sub	sp, #0x8
 805df76: 9001         	str	r0, [sp, #0x4]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805df78: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805dfa8 <MPU_uxQueueMessagesWaiting+0x40>
 805df7a: 4780         	blx	r0
 805df7c: b940         	cbnz	r0, 0x805df90 <MPU_uxQueueMessagesWaiting+0x28> @ imm = #0x10
 805df7e: e7ff         	b	0x805df80 <MPU_uxQueueMessagesWaiting+0x18> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805df80: df03         	svc	#0x3
;             uxReturn = uxQueueMessagesWaiting( pxQueue );
 805df82: 9801         	ldr	r0, [sp, #0x4]
 805df84: 490a         	ldr	r1, [pc, #0x28]         @ 0x805dfb0 <MPU_uxQueueMessagesWaiting+0x48>
 805df86: 4788         	blx	r1
 805df88: 9000         	str	r0, [sp]
;             portRESET_PRIVILEGE();
 805df8a: 480a         	ldr	r0, [pc, #0x28]         @ 0x805dfb4 <MPU_uxQueueMessagesWaiting+0x4c>
 805df8c: 4780         	blx	r0
;         }
 805df8e: e004         	b	0x805df9a <MPU_uxQueueMessagesWaiting+0x32> @ imm = #0x8
;             uxReturn = uxQueueMessagesWaiting( pxQueue );
 805df90: 9801         	ldr	r0, [sp, #0x4]
 805df92: 4906         	ldr	r1, [pc, #0x18]         @ 0x805dfac <MPU_uxQueueMessagesWaiting+0x44>
 805df94: 4788         	blx	r1
 805df96: 9000         	str	r0, [sp]
 805df98: e7ff         	b	0x805df9a <MPU_uxQueueMessagesWaiting+0x32> @ imm = #-0x2
;         return uxReturn;
 805df9a: 9800         	ldr	r0, [sp]
 805df9c: b002         	add	sp, #0x8
 805df9e: bc80         	pop	{r7}
 805dfa0: eba8 0809    	sub.w	r8, r8, r9
 805dfa4: f858 fd30    	ldr	pc, [r8, #-48]!

0805dfa8 <$d.59>:
 805dfa8: a1 f8 05 08  	.word	0x0805f8a1
 805dfac: 29 ba 05 08  	.word	0x0805ba29
 805dfb0: 29 ba 05 08  	.word	0x0805ba29
 805dfb4: b1 f8 05 08  	.word	0x0805f8b1

0805dfb8 <MPU_uxQueueSpacesAvailable>:
;     {
 805dfb8: f848 eb68    	str	lr, [r8], #104
 805dfbc: eb08 0809    	add.w	r8, r8, r9
 805dfc0: b480         	push	{r7}
 805dfc2: 466f         	mov	r7, sp
 805dfc4: b082         	sub	sp, #0x8
 805dfc6: 9001         	str	r0, [sp, #0x4]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805dfc8: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805dff8 <MPU_uxQueueSpacesAvailable+0x40>
 805dfca: 4780         	blx	r0
 805dfcc: b940         	cbnz	r0, 0x805dfe0 <MPU_uxQueueSpacesAvailable+0x28> @ imm = #0x10
 805dfce: e7ff         	b	0x805dfd0 <MPU_uxQueueSpacesAvailable+0x18> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805dfd0: df03         	svc	#0x3
;             uxReturn = uxQueueSpacesAvailable( xQueue );
 805dfd2: 9801         	ldr	r0, [sp, #0x4]
 805dfd4: 490a         	ldr	r1, [pc, #0x28]         @ 0x805e000 <MPU_uxQueueSpacesAvailable+0x48>
 805dfd6: 4788         	blx	r1
 805dfd8: 9000         	str	r0, [sp]
;             portRESET_PRIVILEGE();
 805dfda: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e004 <MPU_uxQueueSpacesAvailable+0x4c>
 805dfdc: 4780         	blx	r0
;         }
 805dfde: e004         	b	0x805dfea <MPU_uxQueueSpacesAvailable+0x32> @ imm = #0x8
;             uxReturn = uxQueueSpacesAvailable( xQueue );
 805dfe0: 9801         	ldr	r0, [sp, #0x4]
 805dfe2: 4906         	ldr	r1, [pc, #0x18]         @ 0x805dffc <MPU_uxQueueSpacesAvailable+0x44>
 805dfe4: 4788         	blx	r1
 805dfe6: 9000         	str	r0, [sp]
 805dfe8: e7ff         	b	0x805dfea <MPU_uxQueueSpacesAvailable+0x32> @ imm = #-0x2
;         return uxReturn;
 805dfea: 9800         	ldr	r0, [sp]
 805dfec: b002         	add	sp, #0x8
 805dfee: bc80         	pop	{r7}
 805dff0: eba8 0809    	sub.w	r8, r8, r9
 805dff4: f858 fd68    	ldr	pc, [r8, #-104]!

0805dff8 <$d.61>:
 805dff8: a1 f8 05 08  	.word	0x0805f8a1
 805dffc: 71 ba 05 08  	.word	0x0805ba71
 805e000: 71 ba 05 08  	.word	0x0805ba71
 805e004: b1 f8 05 08  	.word	0x0805f8b1

0805e008 <MPU_xQueueReceive>:
;     {
 805e008: f848 eb78    	str	lr, [r8], #120
 805e00c: eb08 0809    	add.w	r8, r8, r9
 805e010: b480         	push	{r7}
 805e012: 466f         	mov	r7, sp
 805e014: b084         	sub	sp, #0x10
 805e016: 9003         	str	r0, [sp, #0xc]
 805e018: 9102         	str	r1, [sp, #0x8]
 805e01a: 9201         	str	r2, [sp, #0x4]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805e01c: 480d         	ldr	r0, [pc, #0x34]         @ 0x805e054 <MPU_xQueueReceive+0x4c>
 805e01e: 4780         	blx	r0
 805e020: b950         	cbnz	r0, 0x805e038 <MPU_xQueueReceive+0x30> @ imm = #0x14
 805e022: e7ff         	b	0x805e024 <MPU_xQueueReceive+0x1c> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805e024: df03         	svc	#0x3
;             xReturn = xQueueReceive( pxQueue, pvBuffer, xTicksToWait );
 805e026: 9803         	ldr	r0, [sp, #0xc]
 805e028: 9902         	ldr	r1, [sp, #0x8]
 805e02a: 9a01         	ldr	r2, [sp, #0x4]
 805e02c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x805e05c <MPU_xQueueReceive+0x54>
 805e02e: 4798         	blx	r3
 805e030: 9000         	str	r0, [sp]
;             portRESET_PRIVILEGE();
 805e032: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e060 <MPU_xQueueReceive+0x58>
 805e034: 4780         	blx	r0
;         }
 805e036: e006         	b	0x805e046 <MPU_xQueueReceive+0x3e> @ imm = #0xc
;             xReturn = xQueueReceive( pxQueue, pvBuffer, xTicksToWait );
 805e038: 9803         	ldr	r0, [sp, #0xc]
 805e03a: 9902         	ldr	r1, [sp, #0x8]
 805e03c: 9a01         	ldr	r2, [sp, #0x4]
 805e03e: 4b06         	ldr	r3, [pc, #0x18]         @ 0x805e058 <MPU_xQueueReceive+0x50>
 805e040: 4798         	blx	r3
 805e042: 9000         	str	r0, [sp]
 805e044: e7ff         	b	0x805e046 <MPU_xQueueReceive+0x3e> @ imm = #-0x2
;         return xReturn;
 805e046: 9800         	ldr	r0, [sp]
 805e048: b004         	add	sp, #0x10
 805e04a: bc80         	pop	{r7}
 805e04c: eba8 0809    	sub.w	r8, r8, r9
 805e050: f858 fd78    	ldr	pc, [r8, #-120]!

0805e054 <$d.63>:
 805e054: a1 f8 05 08  	.word	0x0805f8a1
 805e058: 5d b3 05 08  	.word	0x0805b35d
 805e05c: 5d b3 05 08  	.word	0x0805b35d
 805e060: b1 f8 05 08  	.word	0x0805f8b1

0805e064 <MPU_xQueuePeek>:
;     {
 805e064: f848 eb68    	str	lr, [r8], #104
 805e068: eb08 0809    	add.w	r8, r8, r9
 805e06c: b480         	push	{r7}
 805e06e: 466f         	mov	r7, sp
 805e070: b084         	sub	sp, #0x10
 805e072: 9003         	str	r0, [sp, #0xc]
 805e074: 9102         	str	r1, [sp, #0x8]
 805e076: 9201         	str	r2, [sp, #0x4]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805e078: 480d         	ldr	r0, [pc, #0x34]         @ 0x805e0b0 <MPU_xQueuePeek+0x4c>
 805e07a: 4780         	blx	r0
 805e07c: b950         	cbnz	r0, 0x805e094 <MPU_xQueuePeek+0x30> @ imm = #0x14
 805e07e: e7ff         	b	0x805e080 <MPU_xQueuePeek+0x1c> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805e080: df03         	svc	#0x3
;             xReturn = xQueuePeek( xQueue, pvBuffer, xTicksToWait );
 805e082: 9803         	ldr	r0, [sp, #0xc]
 805e084: 9902         	ldr	r1, [sp, #0x8]
 805e086: 9a01         	ldr	r2, [sp, #0x4]
 805e088: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x805e0b8 <MPU_xQueuePeek+0x54>
 805e08a: 4798         	blx	r3
 805e08c: 9000         	str	r0, [sp]
;             portRESET_PRIVILEGE();
 805e08e: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e0bc <MPU_xQueuePeek+0x58>
 805e090: 4780         	blx	r0
;         }
 805e092: e006         	b	0x805e0a2 <MPU_xQueuePeek+0x3e> @ imm = #0xc
;             xReturn = xQueuePeek( xQueue, pvBuffer, xTicksToWait );
 805e094: 9803         	ldr	r0, [sp, #0xc]
 805e096: 9902         	ldr	r1, [sp, #0x8]
 805e098: 9a01         	ldr	r2, [sp, #0x4]
 805e09a: 4b06         	ldr	r3, [pc, #0x18]         @ 0x805e0b4 <MPU_xQueuePeek+0x50>
 805e09c: 4798         	blx	r3
 805e09e: 9000         	str	r0, [sp]
 805e0a0: e7ff         	b	0x805e0a2 <MPU_xQueuePeek+0x3e> @ imm = #-0x2
;         return xReturn;
 805e0a2: 9800         	ldr	r0, [sp]
 805e0a4: b004         	add	sp, #0x10
 805e0a6: bc80         	pop	{r7}
 805e0a8: eba8 0809    	sub.w	r8, r8, r9
 805e0ac: f858 fd68    	ldr	pc, [r8, #-104]!

0805e0b0 <$d.65>:
 805e0b0: a1 f8 05 08  	.word	0x0805f8a1
 805e0b4: 29 b6 05 08  	.word	0x0805b629
 805e0b8: 29 b6 05 08  	.word	0x0805b629
 805e0bc: b1 f8 05 08  	.word	0x0805f8b1

0805e0c0 <MPU_xQueueSemaphoreTake>:
;     {
 805e0c0: f848 eb60    	str	lr, [r8], #96
 805e0c4: eb08 0809    	add.w	r8, r8, r9
 805e0c8: b480         	push	{r7}
 805e0ca: 466f         	mov	r7, sp
 805e0cc: b084         	sub	sp, #0x10
 805e0ce: 9003         	str	r0, [sp, #0xc]
 805e0d0: 9102         	str	r1, [sp, #0x8]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805e0d2: 480d         	ldr	r0, [pc, #0x34]         @ 0x805e108 <MPU_xQueueSemaphoreTake+0x48>
 805e0d4: 4780         	blx	r0
 805e0d6: b948         	cbnz	r0, 0x805e0ec <MPU_xQueueSemaphoreTake+0x2c> @ imm = #0x12
 805e0d8: e7ff         	b	0x805e0da <MPU_xQueueSemaphoreTake+0x1a> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805e0da: df03         	svc	#0x3
;             xReturn = xQueueSemaphoreTake( xQueue, xTicksToWait );
 805e0dc: 9803         	ldr	r0, [sp, #0xc]
 805e0de: 9902         	ldr	r1, [sp, #0x8]
 805e0e0: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x805e110 <MPU_xQueueSemaphoreTake+0x50>
 805e0e2: 4790         	blx	r2
 805e0e4: 9001         	str	r0, [sp, #0x4]
;             portRESET_PRIVILEGE();
 805e0e6: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e114 <MPU_xQueueSemaphoreTake+0x54>
 805e0e8: 4780         	blx	r0
;         }
 805e0ea: e005         	b	0x805e0f8 <MPU_xQueueSemaphoreTake+0x38> @ imm = #0xa
;             xReturn = xQueueSemaphoreTake( xQueue, xTicksToWait );
 805e0ec: 9803         	ldr	r0, [sp, #0xc]
 805e0ee: 9902         	ldr	r1, [sp, #0x8]
 805e0f0: 4a06         	ldr	r2, [pc, #0x18]         @ 0x805e10c <MPU_xQueueSemaphoreTake+0x4c>
 805e0f2: 4790         	blx	r2
 805e0f4: 9001         	str	r0, [sp, #0x4]
 805e0f6: e7ff         	b	0x805e0f8 <MPU_xQueueSemaphoreTake+0x38> @ imm = #-0x2
;         return xReturn;
 805e0f8: 9801         	ldr	r0, [sp, #0x4]
 805e0fa: b004         	add	sp, #0x10
 805e0fc: bc80         	pop	{r7}
 805e0fe: eba8 0809    	sub.w	r8, r8, r9
 805e102: f858 fd60    	ldr	pc, [r8, #-96]!
 805e106: bf00         	nop

0805e108 <$d.67>:
 805e108: a1 f8 05 08  	.word	0x0805f8a1
 805e10c: d9 ab 05 08  	.word	0x0805abd9
 805e110: d9 ab 05 08  	.word	0x0805abd9
 805e114: b1 f8 05 08  	.word	0x0805f8b1

0805e118 <MPU_xQueueGetMutexHolder>:
;         {
 805e118: f848 eb68    	str	lr, [r8], #104
 805e11c: eb08 0809    	add.w	r8, r8, r9
 805e120: b480         	push	{r7}
 805e122: 466f         	mov	r7, sp
 805e124: b082         	sub	sp, #0x8
 805e126: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e128: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e158 <MPU_xQueueGetMutexHolder+0x40>
 805e12a: 4780         	blx	r0
 805e12c: b940         	cbnz	r0, 0x805e140 <MPU_xQueueGetMutexHolder+0x28> @ imm = #0x10
 805e12e: e7ff         	b	0x805e130 <MPU_xQueueGetMutexHolder+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e130: df03         	svc	#0x3
;                 xReturn = xQueueGetMutexHolder( xSemaphore );
 805e132: 9801         	ldr	r0, [sp, #0x4]
 805e134: 490a         	ldr	r1, [pc, #0x28]         @ 0x805e160 <MPU_xQueueGetMutexHolder+0x48>
 805e136: 4788         	blx	r1
 805e138: 9000         	str	r0, [sp]
;                 portRESET_PRIVILEGE();
 805e13a: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e164 <MPU_xQueueGetMutexHolder+0x4c>
 805e13c: 4780         	blx	r0
;             }
 805e13e: e004         	b	0x805e14a <MPU_xQueueGetMutexHolder+0x32> @ imm = #0x8
;                 xReturn = xQueueGetMutexHolder( xSemaphore );
 805e140: 9801         	ldr	r0, [sp, #0x4]
 805e142: 4906         	ldr	r1, [pc, #0x18]         @ 0x805e15c <MPU_xQueueGetMutexHolder+0x44>
 805e144: 4788         	blx	r1
 805e146: 9000         	str	r0, [sp]
 805e148: e7ff         	b	0x805e14a <MPU_xQueueGetMutexHolder+0x32> @ imm = #-0x2
;             return xReturn;
 805e14a: 9800         	ldr	r0, [sp]
 805e14c: b002         	add	sp, #0x8
 805e14e: bc80         	pop	{r7}
 805e150: eba8 0809    	sub.w	r8, r8, r9
 805e154: f858 fd68    	ldr	pc, [r8, #-104]!

0805e158 <$d.69>:
 805e158: a1 f8 05 08  	.word	0x0805f8a1
 805e15c: f9 a7 05 08  	.word	0x0805a7f9
 805e160: f9 a7 05 08  	.word	0x0805a7f9
 805e164: b1 f8 05 08  	.word	0x0805f8b1

0805e168 <MPU_xQueueTakeMutexRecursive>:
;         {
 805e168: f848 eb74    	str	lr, [r8], #116
 805e16c: eb08 0809    	add.w	r8, r8, r9
 805e170: b480         	push	{r7}
 805e172: 466f         	mov	r7, sp
 805e174: b084         	sub	sp, #0x10
 805e176: 9003         	str	r0, [sp, #0xc]
 805e178: 9102         	str	r1, [sp, #0x8]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e17a: 480d         	ldr	r0, [pc, #0x34]         @ 0x805e1b0 <MPU_xQueueTakeMutexRecursive+0x48>
 805e17c: 4780         	blx	r0
 805e17e: b948         	cbnz	r0, 0x805e194 <MPU_xQueueTakeMutexRecursive+0x2c> @ imm = #0x12
 805e180: e7ff         	b	0x805e182 <MPU_xQueueTakeMutexRecursive+0x1a> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e182: df03         	svc	#0x3
;                 xReturn = xQueueTakeMutexRecursive( xMutex, xBlockTime );
 805e184: 9803         	ldr	r0, [sp, #0xc]
 805e186: 9902         	ldr	r1, [sp, #0x8]
 805e188: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x805e1b8 <MPU_xQueueTakeMutexRecursive+0x50>
 805e18a: 4790         	blx	r2
 805e18c: 9001         	str	r0, [sp, #0x4]
;                 portRESET_PRIVILEGE();
 805e18e: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e1bc <MPU_xQueueTakeMutexRecursive+0x54>
 805e190: 4780         	blx	r0
;             }
 805e192: e005         	b	0x805e1a0 <MPU_xQueueTakeMutexRecursive+0x38> @ imm = #0xa
;                 xReturn = xQueueTakeMutexRecursive( xMutex, xBlockTime );
 805e194: 9803         	ldr	r0, [sp, #0xc]
 805e196: 9902         	ldr	r1, [sp, #0x8]
 805e198: 4a06         	ldr	r2, [pc, #0x18]         @ 0x805e1b4 <MPU_xQueueTakeMutexRecursive+0x4c>
 805e19a: 4790         	blx	r2
 805e19c: 9001         	str	r0, [sp, #0x4]
 805e19e: e7ff         	b	0x805e1a0 <MPU_xQueueTakeMutexRecursive+0x38> @ imm = #-0x2
;             return xReturn;
 805e1a0: 9801         	ldr	r0, [sp, #0x4]
 805e1a2: b004         	add	sp, #0x10
 805e1a4: bc80         	pop	{r7}
 805e1a6: eba8 0809    	sub.w	r8, r8, r9
 805e1aa: f858 fd74    	ldr	pc, [r8, #-116]!
 805e1ae: bf00         	nop

0805e1b0 <$d.75>:
 805e1b0: a1 f8 05 08  	.word	0x0805f8a1
 805e1b4: 59 ab 05 08  	.word	0x0805ab59
 805e1b8: 59 ab 05 08  	.word	0x0805ab59
 805e1bc: b1 f8 05 08  	.word	0x0805f8b1

0805e1c0 <MPU_xQueueGiveMutexRecursive>:
;         {
 805e1c0: f848 eb6c    	str	lr, [r8], #108
 805e1c4: eb08 0809    	add.w	r8, r8, r9
 805e1c8: b480         	push	{r7}
 805e1ca: 466f         	mov	r7, sp
 805e1cc: b082         	sub	sp, #0x8
 805e1ce: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e1d0: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e200 <MPU_xQueueGiveMutexRecursive+0x40>
 805e1d2: 4780         	blx	r0
 805e1d4: b940         	cbnz	r0, 0x805e1e8 <MPU_xQueueGiveMutexRecursive+0x28> @ imm = #0x10
 805e1d6: e7ff         	b	0x805e1d8 <MPU_xQueueGiveMutexRecursive+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e1d8: df03         	svc	#0x3
;                 xReturn = xQueueGiveMutexRecursive( xMutex );
 805e1da: 9801         	ldr	r0, [sp, #0x4]
 805e1dc: 490a         	ldr	r1, [pc, #0x28]         @ 0x805e208 <MPU_xQueueGiveMutexRecursive+0x48>
 805e1de: 4788         	blx	r1
 805e1e0: 9000         	str	r0, [sp]
;                 portRESET_PRIVILEGE();
 805e1e2: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e20c <MPU_xQueueGiveMutexRecursive+0x4c>
 805e1e4: 4780         	blx	r0
;             }
 805e1e6: e004         	b	0x805e1f2 <MPU_xQueueGiveMutexRecursive+0x32> @ imm = #0x8
;                 xReturn = xQueueGiveMutexRecursive( xMutex );
 805e1e8: 9801         	ldr	r0, [sp, #0x4]
 805e1ea: 4906         	ldr	r1, [pc, #0x18]         @ 0x805e204 <MPU_xQueueGiveMutexRecursive+0x44>
 805e1ec: 4788         	blx	r1
 805e1ee: 9000         	str	r0, [sp]
 805e1f0: e7ff         	b	0x805e1f2 <MPU_xQueueGiveMutexRecursive+0x32> @ imm = #-0x2
;             return xReturn;
 805e1f2: 9800         	ldr	r0, [sp]
 805e1f4: b002         	add	sp, #0x8
 805e1f6: bc80         	pop	{r7}
 805e1f8: eba8 0809    	sub.w	r8, r8, r9
 805e1fc: f858 fd6c    	ldr	pc, [r8, #-108]!

0805e200 <$d.77>:
 805e200: a1 f8 05 08  	.word	0x0805f8a1
 805e204: 9d a8 05 08  	.word	0x0805a89d
 805e208: 9d a8 05 08  	.word	0x0805a89d
 805e20c: b1 f8 05 08  	.word	0x0805f8b1

0805e210 <MPU_vQueueAddToRegistry>:
;         {
 805e210: f848 eb3c    	str	lr, [r8], #60
 805e214: eb08 0809    	add.w	r8, r8, r9
 805e218: b480         	push	{r7}
 805e21a: 466f         	mov	r7, sp
 805e21c: b082         	sub	sp, #0x8
 805e21e: 9001         	str	r0, [sp, #0x4]
 805e220: 9100         	str	r1, [sp]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e222: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e250 <MPU_vQueueAddToRegistry+0x40>
 805e224: 4780         	blx	r0
 805e226: b940         	cbnz	r0, 0x805e23a <MPU_vQueueAddToRegistry+0x2a> @ imm = #0x10
 805e228: e7ff         	b	0x805e22a <MPU_vQueueAddToRegistry+0x1a> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e22a: df03         	svc	#0x3
;                 vQueueAddToRegistry( xQueue, pcName );
 805e22c: 9801         	ldr	r0, [sp, #0x4]
 805e22e: 9900         	ldr	r1, [sp]
 805e230: 4a09         	ldr	r2, [pc, #0x24]         @ 0x805e258 <MPU_vQueueAddToRegistry+0x48>
 805e232: 4790         	blx	r2
;                 portRESET_PRIVILEGE();
 805e234: 4809         	ldr	r0, [pc, #0x24]         @ 0x805e25c <MPU_vQueueAddToRegistry+0x4c>
 805e236: 4780         	blx	r0
;             }
 805e238: e004         	b	0x805e244 <MPU_vQueueAddToRegistry+0x34> @ imm = #0x8
;                 vQueueAddToRegistry( xQueue, pcName );
 805e23a: 9801         	ldr	r0, [sp, #0x4]
 805e23c: 9900         	ldr	r1, [sp]
 805e23e: 4a05         	ldr	r2, [pc, #0x14]         @ 0x805e254 <MPU_vQueueAddToRegistry+0x44>
 805e240: 4790         	blx	r2
 805e242: e7ff         	b	0x805e244 <MPU_vQueueAddToRegistry+0x34> @ imm = #-0x2
;         }
 805e244: b002         	add	sp, #0x8
 805e246: bc80         	pop	{r7}
 805e248: eba8 0809    	sub.w	r8, r8, r9
 805e24c: f858 fd3c    	ldr	pc, [r8, #-60]!

0805e250 <$d.79>:
 805e250: a1 f8 05 08  	.word	0x0805f8a1
 805e254: 9d bc 05 08  	.word	0x0805bc9d
 805e258: 9d bc 05 08  	.word	0x0805bc9d
 805e25c: b1 f8 05 08  	.word	0x0805f8b1

0805e260 <MPU_vQueueUnregisterQueue>:
;         {
 805e260: f848 eb44    	str	lr, [r8], #68
 805e264: eb08 0809    	add.w	r8, r8, r9
 805e268: b480         	push	{r7}
 805e26a: 466f         	mov	r7, sp
 805e26c: b082         	sub	sp, #0x8
 805e26e: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e270: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e29c <MPU_vQueueUnregisterQueue+0x3c>
 805e272: 4780         	blx	r0
 805e274: b938         	cbnz	r0, 0x805e286 <MPU_vQueueUnregisterQueue+0x26> @ imm = #0xe
 805e276: e7ff         	b	0x805e278 <MPU_vQueueUnregisterQueue+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e278: df03         	svc	#0x3
;                 vQueueUnregisterQueue( xQueue );
 805e27a: 9801         	ldr	r0, [sp, #0x4]
 805e27c: 4909         	ldr	r1, [pc, #0x24]         @ 0x805e2a4 <MPU_vQueueUnregisterQueue+0x44>
 805e27e: 4788         	blx	r1
;                 portRESET_PRIVILEGE();
 805e280: 4809         	ldr	r0, [pc, #0x24]         @ 0x805e2a8 <MPU_vQueueUnregisterQueue+0x48>
 805e282: 4780         	blx	r0
;             }
 805e284: e003         	b	0x805e28e <MPU_vQueueUnregisterQueue+0x2e> @ imm = #0x6
;                 vQueueUnregisterQueue( xQueue );
 805e286: 9801         	ldr	r0, [sp, #0x4]
 805e288: 4905         	ldr	r1, [pc, #0x14]         @ 0x805e2a0 <MPU_vQueueUnregisterQueue+0x40>
 805e28a: 4788         	blx	r1
 805e28c: e7ff         	b	0x805e28e <MPU_vQueueUnregisterQueue+0x2e> @ imm = #-0x2
;         }
 805e28e: b002         	add	sp, #0x8
 805e290: bc80         	pop	{r7}
 805e292: eba8 0809    	sub.w	r8, r8, r9
 805e296: f858 fd44    	ldr	pc, [r8, #-68]!
 805e29a: bf00         	nop

0805e29c <$d.81>:
 805e29c: a1 f8 05 08  	.word	0x0805f8a1
 805e2a0: 45 bb 05 08  	.word	0x0805bb45
 805e2a4: 45 bb 05 08  	.word	0x0805bb45
 805e2a8: b1 f8 05 08  	.word	0x0805f8b1

0805e2ac <MPU_pcQueueGetName>:
;         {
 805e2ac: f848 eb3c    	str	lr, [r8], #60
 805e2b0: eb08 0809    	add.w	r8, r8, r9
 805e2b4: b480         	push	{r7}
 805e2b6: 466f         	mov	r7, sp
 805e2b8: b082         	sub	sp, #0x8
 805e2ba: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e2bc: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e2ec <MPU_pcQueueGetName+0x40>
 805e2be: 4780         	blx	r0
 805e2c0: b940         	cbnz	r0, 0x805e2d4 <MPU_pcQueueGetName+0x28> @ imm = #0x10
 805e2c2: e7ff         	b	0x805e2c4 <MPU_pcQueueGetName+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e2c4: df03         	svc	#0x3
;                 pcReturn = pcQueueGetName( xQueue );
 805e2c6: 9801         	ldr	r0, [sp, #0x4]
 805e2c8: 490a         	ldr	r1, [pc, #0x28]         @ 0x805e2f4 <MPU_pcQueueGetName+0x48>
 805e2ca: 4788         	blx	r1
 805e2cc: 9000         	str	r0, [sp]
;                 portRESET_PRIVILEGE();
 805e2ce: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e2f8 <MPU_pcQueueGetName+0x4c>
 805e2d0: 4780         	blx	r0
;             }
 805e2d2: e004         	b	0x805e2de <MPU_pcQueueGetName+0x32> @ imm = #0x8
;                 pcReturn = pcQueueGetName( xQueue );
 805e2d4: 9801         	ldr	r0, [sp, #0x4]
 805e2d6: 4906         	ldr	r1, [pc, #0x18]         @ 0x805e2f0 <MPU_pcQueueGetName+0x44>
 805e2d8: 4788         	blx	r1
 805e2da: 9000         	str	r0, [sp]
 805e2dc: e7ff         	b	0x805e2de <MPU_pcQueueGetName+0x32> @ imm = #-0x2
;             return pcReturn;
 805e2de: 9800         	ldr	r0, [sp]
 805e2e0: b002         	add	sp, #0x8
 805e2e2: bc80         	pop	{r7}
 805e2e4: eba8 0809    	sub.w	r8, r8, r9
 805e2e8: f858 fd3c    	ldr	pc, [r8, #-60]!

0805e2ec <$d.83>:
 805e2ec: a1 f8 05 08  	.word	0x0805f8a1
 805e2f0: 5d bd 05 08  	.word	0x0805bd5d
 805e2f4: 5d bd 05 08  	.word	0x0805bd5d
 805e2f8: b1 f8 05 08  	.word	0x0805f8b1

0805e2fc <MPU_pvTimerGetTimerID>:
;         {
 805e2fc: f848 eb50    	str	lr, [r8], #80
 805e300: eb08 0809    	add.w	r8, r8, r9
 805e304: b480         	push	{r7}
 805e306: 466f         	mov	r7, sp
 805e308: b082         	sub	sp, #0x8
 805e30a: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e30c: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e33c <MPU_pvTimerGetTimerID+0x40>
 805e30e: 4780         	blx	r0
 805e310: b940         	cbnz	r0, 0x805e324 <MPU_pvTimerGetTimerID+0x28> @ imm = #0x10
 805e312: e7ff         	b	0x805e314 <MPU_pvTimerGetTimerID+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e314: df03         	svc	#0x3
;                 pvReturn = pvTimerGetTimerID( xTimer );
 805e316: 9801         	ldr	r0, [sp, #0x4]
 805e318: 490a         	ldr	r1, [pc, #0x28]         @ 0x805e344 <MPU_pvTimerGetTimerID+0x48>
 805e31a: 4788         	blx	r1
 805e31c: 9000         	str	r0, [sp]
;                 portRESET_PRIVILEGE();
 805e31e: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e348 <MPU_pvTimerGetTimerID+0x4c>
 805e320: 4780         	blx	r0
;             }
 805e322: e004         	b	0x805e32e <MPU_pvTimerGetTimerID+0x32> @ imm = #0x8
;                 pvReturn = pvTimerGetTimerID( xTimer );
 805e324: 9801         	ldr	r0, [sp, #0x4]
 805e326: 4906         	ldr	r1, [pc, #0x18]         @ 0x805e340 <MPU_pvTimerGetTimerID+0x44>
 805e328: 4788         	blx	r1
 805e32a: 9000         	str	r0, [sp]
 805e32c: e7ff         	b	0x805e32e <MPU_pvTimerGetTimerID+0x32> @ imm = #-0x2
;             return pvReturn;
 805e32e: 9800         	ldr	r0, [sp]
 805e330: b002         	add	sp, #0x8
 805e332: bc80         	pop	{r7}
 805e334: eba8 0809    	sub.w	r8, r8, r9
 805e338: f858 fd50    	ldr	pc, [r8, #-80]!

0805e33c <$d.87>:
 805e33c: a1 f8 05 08  	.word	0x0805f8a1
 805e340: 79 90 05 08  	.word	0x08059079
 805e344: 79 90 05 08  	.word	0x08059079
 805e348: b1 f8 05 08  	.word	0x0805f8b1

0805e34c <MPU_vTimerSetTimerID>:
;         {
 805e34c: f848 eb30    	str	lr, [r8], #48
 805e350: eb08 0809    	add.w	r8, r8, r9
 805e354: b480         	push	{r7}
 805e356: 466f         	mov	r7, sp
 805e358: b082         	sub	sp, #0x8
 805e35a: 9001         	str	r0, [sp, #0x4]
 805e35c: 9100         	str	r1, [sp]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e35e: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e38c <MPU_vTimerSetTimerID+0x40>
 805e360: 4780         	blx	r0
 805e362: b940         	cbnz	r0, 0x805e376 <MPU_vTimerSetTimerID+0x2a> @ imm = #0x10
 805e364: e7ff         	b	0x805e366 <MPU_vTimerSetTimerID+0x1a> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e366: df03         	svc	#0x3
;                 vTimerSetTimerID( xTimer, pvNewID );
 805e368: 9801         	ldr	r0, [sp, #0x4]
 805e36a: 9900         	ldr	r1, [sp]
 805e36c: 4a09         	ldr	r2, [pc, #0x24]         @ 0x805e394 <MPU_vTimerSetTimerID+0x48>
 805e36e: 4790         	blx	r2
;                 portRESET_PRIVILEGE();
 805e370: 4809         	ldr	r0, [pc, #0x24]         @ 0x805e398 <MPU_vTimerSetTimerID+0x4c>
 805e372: 4780         	blx	r0
;             }
 805e374: e004         	b	0x805e380 <MPU_vTimerSetTimerID+0x34> @ imm = #0x8
;                 vTimerSetTimerID( xTimer, pvNewID );
 805e376: 9801         	ldr	r0, [sp, #0x4]
 805e378: 9900         	ldr	r1, [sp]
 805e37a: 4a05         	ldr	r2, [pc, #0x14]         @ 0x805e390 <MPU_vTimerSetTimerID+0x44>
 805e37c: 4790         	blx	r2
 805e37e: e7ff         	b	0x805e380 <MPU_vTimerSetTimerID+0x34> @ imm = #-0x2
;         }
 805e380: b002         	add	sp, #0x8
 805e382: bc80         	pop	{r7}
 805e384: eba8 0809    	sub.w	r8, r8, r9
 805e388: f858 fd30    	ldr	pc, [r8, #-48]!

0805e38c <$d.89>:
 805e38c: a1 f8 05 08  	.word	0x0805f8a1
 805e390: c5 90 05 08  	.word	0x080590c5
 805e394: c5 90 05 08  	.word	0x080590c5
 805e398: b1 f8 05 08  	.word	0x0805f8b1

0805e39c <MPU_xTimerIsTimerActive>:
;         {
 805e39c: f848 eb34    	str	lr, [r8], #52
 805e3a0: eb08 0809    	add.w	r8, r8, r9
 805e3a4: b480         	push	{r7}
 805e3a6: 466f         	mov	r7, sp
 805e3a8: b082         	sub	sp, #0x8
 805e3aa: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e3ac: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e3dc <MPU_xTimerIsTimerActive+0x40>
 805e3ae: 4780         	blx	r0
 805e3b0: b940         	cbnz	r0, 0x805e3c4 <MPU_xTimerIsTimerActive+0x28> @ imm = #0x10
 805e3b2: e7ff         	b	0x805e3b4 <MPU_xTimerIsTimerActive+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e3b4: df03         	svc	#0x3
;                 xReturn = xTimerIsTimerActive( xTimer );
 805e3b6: 9801         	ldr	r0, [sp, #0x4]
 805e3b8: 490a         	ldr	r1, [pc, #0x28]         @ 0x805e3e4 <MPU_xTimerIsTimerActive+0x48>
 805e3ba: 4788         	blx	r1
 805e3bc: 9000         	str	r0, [sp]
;                 portRESET_PRIVILEGE();
 805e3be: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e3e8 <MPU_xTimerIsTimerActive+0x4c>
 805e3c0: 4780         	blx	r0
;             }
 805e3c2: e004         	b	0x805e3ce <MPU_xTimerIsTimerActive+0x32> @ imm = #0x8
;                 xReturn = xTimerIsTimerActive( xTimer );
 805e3c4: 9801         	ldr	r0, [sp, #0x4]
 805e3c6: 4906         	ldr	r1, [pc, #0x18]         @ 0x805e3e0 <MPU_xTimerIsTimerActive+0x44>
 805e3c8: 4788         	blx	r1
 805e3ca: 9000         	str	r0, [sp]
 805e3cc: e7ff         	b	0x805e3ce <MPU_xTimerIsTimerActive+0x32> @ imm = #-0x2
;             return xReturn;
 805e3ce: 9800         	ldr	r0, [sp]
 805e3d0: b002         	add	sp, #0x8
 805e3d2: bc80         	pop	{r7}
 805e3d4: eba8 0809    	sub.w	r8, r8, r9
 805e3d8: f858 fd34    	ldr	pc, [r8, #-52]!

0805e3dc <$d.91>:
 805e3dc: a1 f8 05 08  	.word	0x0805f8a1
 805e3e0: 1d 90 05 08  	.word	0x0805901d
 805e3e4: 1d 90 05 08  	.word	0x0805901d
 805e3e8: b1 f8 05 08  	.word	0x0805f8b1

0805e3ec <MPU_xTimerGetTimerDaemonTaskHandle>:
;         {
 805e3ec: f848 eb20    	str	lr, [r8], #32
 805e3f0: eb08 0809    	add.w	r8, r8, r9
 805e3f4: b480         	push	{r7}
 805e3f6: 466f         	mov	r7, sp
 805e3f8: b082         	sub	sp, #0x8
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e3fa: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e428 <MPU_xTimerGetTimerDaemonTaskHandle+0x3c>
 805e3fc: 4780         	blx	r0
 805e3fe: b938         	cbnz	r0, 0x805e410 <MPU_xTimerGetTimerDaemonTaskHandle+0x24> @ imm = #0xe
 805e400: e7ff         	b	0x805e402 <MPU_xTimerGetTimerDaemonTaskHandle+0x16> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e402: df03         	svc	#0x3
;                 xReturn = xTimerGetTimerDaemonTaskHandle();
 805e404: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e430 <MPU_xTimerGetTimerDaemonTaskHandle+0x44>
 805e406: 4780         	blx	r0
 805e408: 9001         	str	r0, [sp, #0x4]
;                 portRESET_PRIVILEGE();
 805e40a: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e434 <MPU_xTimerGetTimerDaemonTaskHandle+0x48>
 805e40c: 4780         	blx	r0
;             }
 805e40e: e003         	b	0x805e418 <MPU_xTimerGetTimerDaemonTaskHandle+0x2c> @ imm = #0x6
;                 xReturn = xTimerGetTimerDaemonTaskHandle();
 805e410: 4806         	ldr	r0, [pc, #0x18]         @ 0x805e42c <MPU_xTimerGetTimerDaemonTaskHandle+0x40>
 805e412: 4780         	blx	r0
 805e414: 9001         	str	r0, [sp, #0x4]
 805e416: e7ff         	b	0x805e418 <MPU_xTimerGetTimerDaemonTaskHandle+0x2c> @ imm = #-0x2
;             return xReturn;
 805e418: 9801         	ldr	r0, [sp, #0x4]
 805e41a: b002         	add	sp, #0x8
 805e41c: bc80         	pop	{r7}
 805e41e: eba8 0809    	sub.w	r8, r8, r9
 805e422: f858 fd20    	ldr	pc, [r8, #-32]!
 805e426: bf00         	nop

0805e428 <$d.93>:
 805e428: a1 f8 05 08  	.word	0x0805f8a1
 805e42c: 3d 8e 05 08  	.word	0x08058e3d
 805e430: 3d 8e 05 08  	.word	0x08058e3d
 805e434: b1 f8 05 08  	.word	0x0805f8b1

0805e438 <MPU_vTimerSetReloadMode>:
;         {
 805e438: f848 eb18    	str	lr, [r8], #24
 805e43c: eb08 0809    	add.w	r8, r8, r9
 805e440: b480         	push	{r7}
 805e442: 466f         	mov	r7, sp
 805e444: b082         	sub	sp, #0x8
 805e446: 9001         	str	r0, [sp, #0x4]
 805e448: 9100         	str	r1, [sp]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e44a: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e478 <MPU_vTimerSetReloadMode+0x40>
 805e44c: 4780         	blx	r0
 805e44e: b940         	cbnz	r0, 0x805e462 <MPU_vTimerSetReloadMode+0x2a> @ imm = #0x10
 805e450: e7ff         	b	0x805e452 <MPU_vTimerSetReloadMode+0x1a> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e452: df03         	svc	#0x3
;                 vTimerSetReloadMode( xTimer, uxAutoReload );
 805e454: 9801         	ldr	r0, [sp, #0x4]
 805e456: 9900         	ldr	r1, [sp]
 805e458: 4a09         	ldr	r2, [pc, #0x24]         @ 0x805e480 <MPU_vTimerSetReloadMode+0x48>
 805e45a: 4790         	blx	r2
;                 portRESET_PRIVILEGE();
 805e45c: 4809         	ldr	r0, [pc, #0x24]         @ 0x805e484 <MPU_vTimerSetReloadMode+0x4c>
 805e45e: 4780         	blx	r0
;             }
 805e460: e004         	b	0x805e46c <MPU_vTimerSetReloadMode+0x34> @ imm = #0x8
;                 vTimerSetReloadMode( xTimer, uxAutoReload );
 805e462: 9801         	ldr	r0, [sp, #0x4]
 805e464: 9900         	ldr	r1, [sp]
 805e466: 4a05         	ldr	r2, [pc, #0x14]         @ 0x805e47c <MPU_vTimerSetReloadMode+0x44>
 805e468: 4790         	blx	r2
 805e46a: e7ff         	b	0x805e46c <MPU_vTimerSetReloadMode+0x34> @ imm = #-0x2
;         }
 805e46c: b002         	add	sp, #0x8
 805e46e: bc80         	pop	{r7}
 805e470: eba8 0809    	sub.w	r8, r8, r9
 805e474: f858 fd18    	ldr	pc, [r8, #-24]!

0805e478 <$d.95>:
 805e478: a1 f8 05 08  	.word	0x0805f8a1
 805e47c: b1 8e 05 08  	.word	0x08058eb1
 805e480: b1 8e 05 08  	.word	0x08058eb1
 805e484: b1 f8 05 08  	.word	0x0805f8b1

0805e488 <MPU_uxTimerGetReloadMode>:
;         {
 805e488: f848 eb5c    	str	lr, [r8], #92
 805e48c: eb08 0809    	add.w	r8, r8, r9
 805e490: b480         	push	{r7}
 805e492: 466f         	mov	r7, sp
 805e494: b082         	sub	sp, #0x8
 805e496: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e498: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e4c8 <MPU_uxTimerGetReloadMode+0x40>
 805e49a: 4780         	blx	r0
 805e49c: b940         	cbnz	r0, 0x805e4b0 <MPU_uxTimerGetReloadMode+0x28> @ imm = #0x10
 805e49e: e7ff         	b	0x805e4a0 <MPU_uxTimerGetReloadMode+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e4a0: df03         	svc	#0x3
;                 uxReturn = uxTimerGetReloadMode( xTimer );
 805e4a2: 9801         	ldr	r0, [sp, #0x4]
 805e4a4: 490a         	ldr	r1, [pc, #0x28]         @ 0x805e4d0 <MPU_uxTimerGetReloadMode+0x48>
 805e4a6: 4788         	blx	r1
 805e4a8: 9000         	str	r0, [sp]
;                 portRESET_PRIVILEGE();
 805e4aa: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e4d4 <MPU_uxTimerGetReloadMode+0x4c>
 805e4ac: 4780         	blx	r0
;             }
 805e4ae: e004         	b	0x805e4ba <MPU_uxTimerGetReloadMode+0x32> @ imm = #0x8
;                 uxReturn = uxTimerGetReloadMode( xTimer );
 805e4b0: 9801         	ldr	r0, [sp, #0x4]
 805e4b2: 4906         	ldr	r1, [pc, #0x18]         @ 0x805e4cc <MPU_uxTimerGetReloadMode+0x44>
 805e4b4: 4788         	blx	r1
 805e4b6: 9000         	str	r0, [sp]
 805e4b8: e7ff         	b	0x805e4ba <MPU_uxTimerGetReloadMode+0x32> @ imm = #-0x2
;             return uxReturn;
 805e4ba: 9800         	ldr	r0, [sp]
 805e4bc: b002         	add	sp, #0x8
 805e4be: bc80         	pop	{r7}
 805e4c0: eba8 0809    	sub.w	r8, r8, r9
 805e4c4: f858 fd5c    	ldr	pc, [r8, #-92]!

0805e4c8 <$d.97>:
 805e4c8: a1 f8 05 08  	.word	0x0805f8a1
 805e4cc: 7d 8f 05 08  	.word	0x08058f7d
 805e4d0: 7d 8f 05 08  	.word	0x08058f7d
 805e4d4: b1 f8 05 08  	.word	0x0805f8b1

0805e4d8 <MPU_pcTimerGetName>:
;         {
 805e4d8: f848 eb0c    	str	lr, [r8], #12
 805e4dc: eb08 0809    	add.w	r8, r8, r9
 805e4e0: b480         	push	{r7}
 805e4e2: 466f         	mov	r7, sp
 805e4e4: b082         	sub	sp, #0x8
 805e4e6: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e4e8: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e518 <MPU_pcTimerGetName+0x40>
 805e4ea: 4780         	blx	r0
 805e4ec: b940         	cbnz	r0, 0x805e500 <MPU_pcTimerGetName+0x28> @ imm = #0x10
 805e4ee: e7ff         	b	0x805e4f0 <MPU_pcTimerGetName+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e4f0: df03         	svc	#0x3
;                 pcReturn = pcTimerGetName( xTimer );
 805e4f2: 9801         	ldr	r0, [sp, #0x4]
 805e4f4: 490a         	ldr	r1, [pc, #0x28]         @ 0x805e520 <MPU_pcTimerGetName+0x48>
 805e4f6: 4788         	blx	r1
 805e4f8: 9000         	str	r0, [sp]
;                 portRESET_PRIVILEGE();
 805e4fa: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e524 <MPU_pcTimerGetName+0x4c>
 805e4fc: 4780         	blx	r0
;             }
 805e4fe: e004         	b	0x805e50a <MPU_pcTimerGetName+0x32> @ imm = #0x8
;                 pcReturn = pcTimerGetName( xTimer );
 805e500: 9801         	ldr	r0, [sp, #0x4]
 805e502: 4906         	ldr	r1, [pc, #0x18]         @ 0x805e51c <MPU_pcTimerGetName+0x44>
 805e504: 4788         	blx	r1
 805e506: 9000         	str	r0, [sp]
 805e508: e7ff         	b	0x805e50a <MPU_pcTimerGetName+0x32> @ imm = #-0x2
;             return pcReturn;
 805e50a: 9800         	ldr	r0, [sp]
 805e50c: b002         	add	sp, #0x8
 805e50e: bc80         	pop	{r7}
 805e510: eba8 0809    	sub.w	r8, r8, r9
 805e514: f858 fd0c    	ldr	pc, [r8, #-12]!

0805e518 <$d.99>:
 805e518: a1 f8 05 08  	.word	0x0805f8a1
 805e51c: e5 8f 05 08  	.word	0x08058fe5
 805e520: e5 8f 05 08  	.word	0x08058fe5
 805e524: b1 f8 05 08  	.word	0x0805f8b1

0805e528 <MPU_xTimerGetPeriod>:
;         {
 805e528: f848 eb14    	str	lr, [r8], #20
 805e52c: eb08 0809    	add.w	r8, r8, r9
 805e530: b480         	push	{r7}
 805e532: 466f         	mov	r7, sp
 805e534: b082         	sub	sp, #0x8
 805e536: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e538: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e568 <MPU_xTimerGetPeriod+0x40>
 805e53a: 4780         	blx	r0
 805e53c: b940         	cbnz	r0, 0x805e550 <MPU_xTimerGetPeriod+0x28> @ imm = #0x10
 805e53e: e7ff         	b	0x805e540 <MPU_xTimerGetPeriod+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e540: df03         	svc	#0x3
;                 xReturn = xTimerGetPeriod( xTimer );
 805e542: 9801         	ldr	r0, [sp, #0x4]
 805e544: 490a         	ldr	r1, [pc, #0x28]         @ 0x805e570 <MPU_xTimerGetPeriod+0x48>
 805e546: 4788         	blx	r1
 805e548: 9000         	str	r0, [sp]
;                 portRESET_PRIVILEGE();
 805e54a: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e574 <MPU_xTimerGetPeriod+0x4c>
 805e54c: 4780         	blx	r0
;             }
 805e54e: e004         	b	0x805e55a <MPU_xTimerGetPeriod+0x32> @ imm = #0x8
;                 xReturn = xTimerGetPeriod( xTimer );
 805e550: 9801         	ldr	r0, [sp, #0x4]
 805e552: 4906         	ldr	r1, [pc, #0x18]         @ 0x805e56c <MPU_xTimerGetPeriod+0x44>
 805e554: 4788         	blx	r1
 805e556: 9000         	str	r0, [sp]
 805e558: e7ff         	b	0x805e55a <MPU_xTimerGetPeriod+0x32> @ imm = #-0x2
;             return xReturn;
 805e55a: 9800         	ldr	r0, [sp]
 805e55c: b002         	add	sp, #0x8
 805e55e: bc80         	pop	{r7}
 805e560: eba8 0809    	sub.w	r8, r8, r9
 805e564: f858 fd14    	ldr	pc, [r8, #-20]!

0805e568 <$d.101>:
 805e568: a1 f8 05 08  	.word	0x0805f8a1
 805e56c: 79 8e 05 08  	.word	0x08058e79
 805e570: 79 8e 05 08  	.word	0x08058e79
 805e574: b1 f8 05 08  	.word	0x0805f8b1

0805e578 <MPU_xTimerGetExpiryTime>:
;         {
 805e578: f848 eb04    	str	lr, [r8], #4
 805e57c: eb08 0809    	add.w	r8, r8, r9
 805e580: b480         	push	{r7}
 805e582: 466f         	mov	r7, sp
 805e584: b082         	sub	sp, #0x8
 805e586: 9001         	str	r0, [sp, #0x4]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e588: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e5b8 <MPU_xTimerGetExpiryTime+0x40>
 805e58a: 4780         	blx	r0
 805e58c: b940         	cbnz	r0, 0x805e5a0 <MPU_xTimerGetExpiryTime+0x28> @ imm = #0x10
 805e58e: e7ff         	b	0x805e590 <MPU_xTimerGetExpiryTime+0x18> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e590: df03         	svc	#0x3
;                 xReturn = xTimerGetExpiryTime( xTimer );
 805e592: 9801         	ldr	r0, [sp, #0x4]
 805e594: 490a         	ldr	r1, [pc, #0x28]         @ 0x805e5c0 <MPU_xTimerGetExpiryTime+0x48>
 805e596: 4788         	blx	r1
 805e598: 9000         	str	r0, [sp]
;                 portRESET_PRIVILEGE();
 805e59a: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e5c4 <MPU_xTimerGetExpiryTime+0x4c>
 805e59c: 4780         	blx	r0
;             }
 805e59e: e004         	b	0x805e5aa <MPU_xTimerGetExpiryTime+0x32> @ imm = #0x8
;                 xReturn = xTimerGetExpiryTime( xTimer );
 805e5a0: 9801         	ldr	r0, [sp, #0x4]
 805e5a2: 4906         	ldr	r1, [pc, #0x18]         @ 0x805e5bc <MPU_xTimerGetExpiryTime+0x44>
 805e5a4: 4788         	blx	r1
 805e5a6: 9000         	str	r0, [sp]
 805e5a8: e7ff         	b	0x805e5aa <MPU_xTimerGetExpiryTime+0x32> @ imm = #-0x2
;             return xReturn;
 805e5aa: 9800         	ldr	r0, [sp]
 805e5ac: b002         	add	sp, #0x8
 805e5ae: bc80         	pop	{r7}
 805e5b0: eba8 0809    	sub.w	r8, r8, r9
 805e5b4: f858 fd04    	ldr	pc, [r8, #-4]!

0805e5b8 <$d.103>:
 805e5b8: a1 f8 05 08  	.word	0x0805f8a1
 805e5bc: a9 8f 05 08  	.word	0x08058fa9
 805e5c0: a9 8f 05 08  	.word	0x08058fa9
 805e5c4: b1 f8 05 08  	.word	0x0805f8b1

0805e5c8 <MPU_xTimerGenericCommandFromTask>:
;         {
 805e5c8: f848 eb14    	str	lr, [r8], #20
 805e5cc: eb08 0809    	add.w	r8, r8, r9
 805e5d0: b480         	push	{r7}
 805e5d2: 466f         	mov	r7, sp
 805e5d4: b086         	sub	sp, #0x18
 805e5d6: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805e5da: 9005         	str	r0, [sp, #0x14]
 805e5dc: 9104         	str	r1, [sp, #0x10]
 805e5de: 9203         	str	r2, [sp, #0xc]
 805e5e0: 9302         	str	r3, [sp, #0x8]
;             if( portIS_PRIVILEGED() == pdFALSE )
 805e5e2: 4815         	ldr	r0, [pc, #0x54]         @ 0x805e638 <MPU_xTimerGenericCommandFromTask+0x70>
 805e5e4: 4780         	blx	r0
 805e5e6: b988         	cbnz	r0, 0x805e60c <MPU_xTimerGenericCommandFromTask+0x44> @ imm = #0x22
 805e5e8: e7ff         	b	0x805e5ea <MPU_xTimerGenericCommandFromTask+0x22> @ imm = #-0x2
;                 portRAISE_PRIVILEGE();
 805e5ea: df03         	svc	#0x3
;                 xReturn = xTimerGenericCommandFromTask( xTimer, xCommandID, xOptionalValue, pxHigherPriorityTaskWoken, xTicksToWait );
 805e5ec: 9805         	ldr	r0, [sp, #0x14]
 805e5ee: 9904         	ldr	r1, [sp, #0x10]
 805e5f0: 9a03         	ldr	r2, [sp, #0xc]
 805e5f2: 9b02         	ldr	r3, [sp, #0x8]
 805e5f4: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805e5f8: 46ee         	mov	lr, sp
 805e5fa: f8ce c000    	str.w	r12, [lr]
 805e5fe: f8df c040    	ldr.w	r12, [pc, #0x40]        @ 0x805e640 <MPU_xTimerGenericCommandFromTask+0x78>
 805e602: 47e0         	blx	r12
 805e604: 9001         	str	r0, [sp, #0x4]
;                 portRESET_PRIVILEGE();
 805e606: 480f         	ldr	r0, [pc, #0x3c]         @ 0x805e644 <MPU_xTimerGenericCommandFromTask+0x7c>
 805e608: 4780         	blx	r0
;             }
 805e60a: e00d         	b	0x805e628 <MPU_xTimerGenericCommandFromTask+0x60> @ imm = #0x1a
;                 xReturn = xTimerGenericCommandFromTask( xTimer, xCommandID, xOptionalValue, pxHigherPriorityTaskWoken, xTicksToWait );
 805e60c: 9805         	ldr	r0, [sp, #0x14]
 805e60e: 9904         	ldr	r1, [sp, #0x10]
 805e610: 9a03         	ldr	r2, [sp, #0xc]
 805e612: 9b02         	ldr	r3, [sp, #0x8]
 805e614: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805e618: 46ee         	mov	lr, sp
 805e61a: f8ce c000    	str.w	r12, [lr]
 805e61e: f8df c01c    	ldr.w	r12, [pc, #0x1c]        @ 0x805e63c <MPU_xTimerGenericCommandFromTask+0x74>
 805e622: 47e0         	blx	r12
 805e624: 9001         	str	r0, [sp, #0x4]
 805e626: e7ff         	b	0x805e628 <MPU_xTimerGenericCommandFromTask+0x60> @ imm = #-0x2
;             return xReturn;
 805e628: 9801         	ldr	r0, [sp, #0x4]
 805e62a: b006         	add	sp, #0x18
 805e62c: bc80         	pop	{r7}
 805e62e: eba8 0809    	sub.w	r8, r8, r9
 805e632: f858 fd14    	ldr	pc, [r8, #-20]!
 805e636: bf00         	nop

0805e638 <$d.105>:
 805e638: a1 f8 05 08  	.word	0x0805f8a1
 805e63c: e1 8c 05 08  	.word	0x08058ce1
 805e640: e1 8c 05 08  	.word	0x08058ce1
 805e644: b1 f8 05 08  	.word	0x0805f8b1

0805e648 <MPU_xEventGroupWaitBits>:
;     {
 805e648: f848 eb78    	str	lr, [r8], #120
 805e64c: eb08 0809    	add.w	r8, r8, r9
 805e650: b480         	push	{r7}
 805e652: 466f         	mov	r7, sp
 805e654: b086         	sub	sp, #0x18
 805e656: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805e65a: 9005         	str	r0, [sp, #0x14]
 805e65c: 9104         	str	r1, [sp, #0x10]
 805e65e: 9203         	str	r2, [sp, #0xc]
 805e660: 9302         	str	r3, [sp, #0x8]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805e662: 4815         	ldr	r0, [pc, #0x54]         @ 0x805e6b8 <MPU_xEventGroupWaitBits+0x70>
 805e664: 4780         	blx	r0
 805e666: b988         	cbnz	r0, 0x805e68c <MPU_xEventGroupWaitBits+0x44> @ imm = #0x22
 805e668: e7ff         	b	0x805e66a <MPU_xEventGroupWaitBits+0x22> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805e66a: df03         	svc	#0x3
;             xReturn = xEventGroupWaitBits( xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait );
 805e66c: 9805         	ldr	r0, [sp, #0x14]
 805e66e: 9904         	ldr	r1, [sp, #0x10]
 805e670: 9a03         	ldr	r2, [sp, #0xc]
 805e672: 9b02         	ldr	r3, [sp, #0x8]
 805e674: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805e678: 46ee         	mov	lr, sp
 805e67a: f8ce c000    	str.w	r12, [lr]
 805e67e: f8df c040    	ldr.w	r12, [pc, #0x40]        @ 0x805e6c0 <MPU_xEventGroupWaitBits+0x78>
 805e682: 47e0         	blx	r12
 805e684: 9001         	str	r0, [sp, #0x4]
;             portRESET_PRIVILEGE();
 805e686: 480f         	ldr	r0, [pc, #0x3c]         @ 0x805e6c4 <MPU_xEventGroupWaitBits+0x7c>
 805e688: 4780         	blx	r0
;         }
 805e68a: e00d         	b	0x805e6a8 <MPU_xEventGroupWaitBits+0x60> @ imm = #0x1a
;             xReturn = xEventGroupWaitBits( xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait );
 805e68c: 9805         	ldr	r0, [sp, #0x14]
 805e68e: 9904         	ldr	r1, [sp, #0x10]
 805e690: 9a03         	ldr	r2, [sp, #0xc]
 805e692: 9b02         	ldr	r3, [sp, #0x8]
 805e694: f8d7 c008    	ldr.w	r12, [r7, #0x8]
 805e698: 46ee         	mov	lr, sp
 805e69a: f8ce c000    	str.w	r12, [lr]
 805e69e: f8df c01c    	ldr.w	r12, [pc, #0x1c]        @ 0x805e6bc <MPU_xEventGroupWaitBits+0x74>
 805e6a2: 47e0         	blx	r12
 805e6a4: 9001         	str	r0, [sp, #0x4]
 805e6a6: e7ff         	b	0x805e6a8 <MPU_xEventGroupWaitBits+0x60> @ imm = #-0x2
;         return xReturn;
 805e6a8: 9801         	ldr	r0, [sp, #0x4]
 805e6aa: b006         	add	sp, #0x18
 805e6ac: bc80         	pop	{r7}
 805e6ae: eba8 0809    	sub.w	r8, r8, r9
 805e6b2: f858 fd78    	ldr	pc, [r8, #-120]!
 805e6b6: bf00         	nop

0805e6b8 <$d.109>:
 805e6b8: a1 f8 05 08  	.word	0x0805f8a1
 805e6bc: 05 a0 05 08  	.word	0x0805a005
 805e6c0: 05 a0 05 08  	.word	0x0805a005
 805e6c4: b1 f8 05 08  	.word	0x0805f8b1

0805e6c8 <MPU_xEventGroupClearBits>:
;     {
 805e6c8: f848 eb5c    	str	lr, [r8], #92
 805e6cc: eb08 0809    	add.w	r8, r8, r9
 805e6d0: b480         	push	{r7}
 805e6d2: 466f         	mov	r7, sp
 805e6d4: b084         	sub	sp, #0x10
 805e6d6: 9003         	str	r0, [sp, #0xc]
 805e6d8: 9102         	str	r1, [sp, #0x8]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805e6da: 480d         	ldr	r0, [pc, #0x34]         @ 0x805e710 <MPU_xEventGroupClearBits+0x48>
 805e6dc: 4780         	blx	r0
 805e6de: b948         	cbnz	r0, 0x805e6f4 <MPU_xEventGroupClearBits+0x2c> @ imm = #0x12
 805e6e0: e7ff         	b	0x805e6e2 <MPU_xEventGroupClearBits+0x1a> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805e6e2: df03         	svc	#0x3
;             xReturn = xEventGroupClearBits( xEventGroup, uxBitsToClear );
 805e6e4: 9803         	ldr	r0, [sp, #0xc]
 805e6e6: 9902         	ldr	r1, [sp, #0x8]
 805e6e8: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x805e718 <MPU_xEventGroupClearBits+0x50>
 805e6ea: 4790         	blx	r2
 805e6ec: 9001         	str	r0, [sp, #0x4]
;             portRESET_PRIVILEGE();
 805e6ee: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e71c <MPU_xEventGroupClearBits+0x54>
 805e6f0: 4780         	blx	r0
;         }
 805e6f2: e005         	b	0x805e700 <MPU_xEventGroupClearBits+0x38> @ imm = #0xa
;             xReturn = xEventGroupClearBits( xEventGroup, uxBitsToClear );
 805e6f4: 9803         	ldr	r0, [sp, #0xc]
 805e6f6: 9902         	ldr	r1, [sp, #0x8]
 805e6f8: 4a06         	ldr	r2, [pc, #0x18]         @ 0x805e714 <MPU_xEventGroupClearBits+0x4c>
 805e6fa: 4790         	blx	r2
 805e6fc: 9001         	str	r0, [sp, #0x4]
 805e6fe: e7ff         	b	0x805e700 <MPU_xEventGroupClearBits+0x38> @ imm = #-0x2
;         return xReturn;
 805e700: 9801         	ldr	r0, [sp, #0x4]
 805e702: b004         	add	sp, #0x10
 805e704: bc80         	pop	{r7}
 805e706: eba8 0809    	sub.w	r8, r8, r9
 805e70a: f858 fd5c    	ldr	pc, [r8, #-92]!
 805e70e: bf00         	nop

0805e710 <$d.111>:
 805e710: a1 f8 05 08  	.word	0x0805f8a1
 805e714: 01 a2 05 08  	.word	0x0805a201
 805e718: 01 a2 05 08  	.word	0x0805a201
 805e71c: b1 f8 05 08  	.word	0x0805f8b1

0805e720 <MPU_xEventGroupSetBits>:
;     {
 805e720: f848 eb20    	str	lr, [r8], #32
 805e724: eb08 0809    	add.w	r8, r8, r9
 805e728: b480         	push	{r7}
 805e72a: 466f         	mov	r7, sp
 805e72c: b084         	sub	sp, #0x10
 805e72e: 9003         	str	r0, [sp, #0xc]
 805e730: 9102         	str	r1, [sp, #0x8]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805e732: 480d         	ldr	r0, [pc, #0x34]         @ 0x805e768 <MPU_xEventGroupSetBits+0x48>
 805e734: 4780         	blx	r0
 805e736: b948         	cbnz	r0, 0x805e74c <MPU_xEventGroupSetBits+0x2c> @ imm = #0x12
 805e738: e7ff         	b	0x805e73a <MPU_xEventGroupSetBits+0x1a> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805e73a: df03         	svc	#0x3
;             xReturn = xEventGroupSetBits( xEventGroup, uxBitsToSet );
 805e73c: 9803         	ldr	r0, [sp, #0xc]
 805e73e: 9902         	ldr	r1, [sp, #0x8]
 805e740: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x805e770 <MPU_xEventGroupSetBits+0x50>
 805e742: 4790         	blx	r2
 805e744: 9001         	str	r0, [sp, #0x4]
;             portRESET_PRIVILEGE();
 805e746: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e774 <MPU_xEventGroupSetBits+0x54>
 805e748: 4780         	blx	r0
;         }
 805e74a: e005         	b	0x805e758 <MPU_xEventGroupSetBits+0x38> @ imm = #0xa
;             xReturn = xEventGroupSetBits( xEventGroup, uxBitsToSet );
 805e74c: 9803         	ldr	r0, [sp, #0xc]
 805e74e: 9902         	ldr	r1, [sp, #0x8]
 805e750: 4a06         	ldr	r2, [pc, #0x18]         @ 0x805e76c <MPU_xEventGroupSetBits+0x4c>
 805e752: 4790         	blx	r2
 805e754: 9001         	str	r0, [sp, #0x4]
 805e756: e7ff         	b	0x805e758 <MPU_xEventGroupSetBits+0x38> @ imm = #-0x2
;         return xReturn;
 805e758: 9801         	ldr	r0, [sp, #0x4]
 805e75a: b004         	add	sp, #0x10
 805e75c: bc80         	pop	{r7}
 805e75e: eba8 0809    	sub.w	r8, r8, r9
 805e762: f858 fd20    	ldr	pc, [r8, #-32]!
 805e766: bf00         	nop

0805e768 <$d.113>:
 805e768: a1 f8 05 08  	.word	0x0805f8a1
 805e76c: e1 9e 05 08  	.word	0x08059ee1
 805e770: e1 9e 05 08  	.word	0x08059ee1
 805e774: b1 f8 05 08  	.word	0x0805f8b1

0805e778 <MPU_xEventGroupSync>:
;     {
 805e778: f848 eb34    	str	lr, [r8], #52
 805e77c: eb08 0809    	add.w	r8, r8, r9
 805e780: b480         	push	{r7}
 805e782: 466f         	mov	r7, sp
 805e784: b086         	sub	sp, #0x18
 805e786: 9005         	str	r0, [sp, #0x14]
 805e788: 9104         	str	r1, [sp, #0x10]
 805e78a: 9203         	str	r2, [sp, #0xc]
 805e78c: 9302         	str	r3, [sp, #0x8]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805e78e: 4810         	ldr	r0, [pc, #0x40]         @ 0x805e7d0 <MPU_xEventGroupSync+0x58>
 805e790: 4780         	blx	r0
 805e792: b960         	cbnz	r0, 0x805e7ae <MPU_xEventGroupSync+0x36> @ imm = #0x18
 805e794: e7ff         	b	0x805e796 <MPU_xEventGroupSync+0x1e> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805e796: df03         	svc	#0x3
;             xReturn = xEventGroupSync( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait );
 805e798: 9805         	ldr	r0, [sp, #0x14]
 805e79a: 9904         	ldr	r1, [sp, #0x10]
 805e79c: 9a03         	ldr	r2, [sp, #0xc]
 805e79e: 9b02         	ldr	r3, [sp, #0x8]
 805e7a0: f8df c034    	ldr.w	r12, [pc, #0x34]        @ 0x805e7d8 <MPU_xEventGroupSync+0x60>
 805e7a4: 47e0         	blx	r12
 805e7a6: 9001         	str	r0, [sp, #0x4]
;             portRESET_PRIVILEGE();
 805e7a8: 480c         	ldr	r0, [pc, #0x30]         @ 0x805e7dc <MPU_xEventGroupSync+0x64>
 805e7aa: 4780         	blx	r0
;         }
 805e7ac: e008         	b	0x805e7c0 <MPU_xEventGroupSync+0x48> @ imm = #0x10
;             xReturn = xEventGroupSync( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait );
 805e7ae: 9805         	ldr	r0, [sp, #0x14]
 805e7b0: 9904         	ldr	r1, [sp, #0x10]
 805e7b2: 9a03         	ldr	r2, [sp, #0xc]
 805e7b4: 9b02         	ldr	r3, [sp, #0x8]
 805e7b6: f8df c01c    	ldr.w	r12, [pc, #0x1c]        @ 0x805e7d4 <MPU_xEventGroupSync+0x5c>
 805e7ba: 47e0         	blx	r12
 805e7bc: 9001         	str	r0, [sp, #0x4]
 805e7be: e7ff         	b	0x805e7c0 <MPU_xEventGroupSync+0x48> @ imm = #-0x2
;         return xReturn;
 805e7c0: 9801         	ldr	r0, [sp, #0x4]
 805e7c2: b006         	add	sp, #0x18
 805e7c4: bc80         	pop	{r7}
 805e7c6: eba8 0809    	sub.w	r8, r8, r9
 805e7ca: f858 fd34    	ldr	pc, [r8, #-52]!
 805e7ce: bf00         	nop

0805e7d0 <$d.115>:
 805e7d0: a1 f8 05 08  	.word	0x0805f8a1
 805e7d4: 71 9d 05 08  	.word	0x08059d71
 805e7d8: 71 9d 05 08  	.word	0x08059d71
 805e7dc: b1 f8 05 08  	.word	0x0805f8b1

0805e7e0 <MPU_xStreamBufferSend>:
;     {
 805e7e0: f848 eb74    	str	lr, [r8], #116
 805e7e4: eb08 0809    	add.w	r8, r8, r9
 805e7e8: b480         	push	{r7}
 805e7ea: 466f         	mov	r7, sp
 805e7ec: b086         	sub	sp, #0x18
 805e7ee: 9005         	str	r0, [sp, #0x14]
 805e7f0: 9104         	str	r1, [sp, #0x10]
 805e7f2: 9203         	str	r2, [sp, #0xc]
 805e7f4: 9302         	str	r3, [sp, #0x8]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805e7f6: 4810         	ldr	r0, [pc, #0x40]         @ 0x805e838 <MPU_xStreamBufferSend+0x58>
 805e7f8: 4780         	blx	r0
 805e7fa: b960         	cbnz	r0, 0x805e816 <MPU_xStreamBufferSend+0x36> @ imm = #0x18
 805e7fc: e7ff         	b	0x805e7fe <MPU_xStreamBufferSend+0x1e> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805e7fe: df03         	svc	#0x3
;             xReturn = xStreamBufferSend( xStreamBuffer, pvTxData, xDataLengthBytes, xTicksToWait );
 805e800: 9805         	ldr	r0, [sp, #0x14]
 805e802: 9904         	ldr	r1, [sp, #0x10]
 805e804: 9a03         	ldr	r2, [sp, #0xc]
 805e806: 9b02         	ldr	r3, [sp, #0x8]
 805e808: f8df c034    	ldr.w	r12, [pc, #0x34]        @ 0x805e840 <MPU_xStreamBufferSend+0x60>
 805e80c: 47e0         	blx	r12
 805e80e: 9001         	str	r0, [sp, #0x4]
;             portRESET_PRIVILEGE();
 805e810: 480c         	ldr	r0, [pc, #0x30]         @ 0x805e844 <MPU_xStreamBufferSend+0x64>
 805e812: 4780         	blx	r0
;         }
 805e814: e008         	b	0x805e828 <MPU_xStreamBufferSend+0x48> @ imm = #0x10
;             xReturn = xStreamBufferSend( xStreamBuffer, pvTxData, xDataLengthBytes, xTicksToWait );
 805e816: 9805         	ldr	r0, [sp, #0x14]
 805e818: 9904         	ldr	r1, [sp, #0x10]
 805e81a: 9a03         	ldr	r2, [sp, #0xc]
 805e81c: 9b02         	ldr	r3, [sp, #0x8]
 805e81e: f8df c01c    	ldr.w	r12, [pc, #0x1c]        @ 0x805e83c <MPU_xStreamBufferSend+0x5c>
 805e822: 47e0         	blx	r12
 805e824: 9001         	str	r0, [sp, #0x4]
 805e826: e7ff         	b	0x805e828 <MPU_xStreamBufferSend+0x48> @ imm = #-0x2
;         return xReturn;
 805e828: 9801         	ldr	r0, [sp, #0x4]
 805e82a: b006         	add	sp, #0x18
 805e82c: bc80         	pop	{r7}
 805e82e: eba8 0809    	sub.w	r8, r8, r9
 805e832: f858 fd74    	ldr	pc, [r8, #-116]!
 805e836: bf00         	nop

0805e838 <$d.119>:
 805e838: a1 f8 05 08  	.word	0x0805f8a1
 805e83c: 09 c2 05 08  	.word	0x0805c209
 805e840: 09 c2 05 08  	.word	0x0805c209
 805e844: b1 f8 05 08  	.word	0x0805f8b1

0805e848 <MPU_xStreamBufferNextMessageLengthBytes>:
;     {
 805e848: f848 eb04    	str	lr, [r8], #4
 805e84c: eb08 0809    	add.w	r8, r8, r9
 805e850: b480         	push	{r7}
 805e852: 466f         	mov	r7, sp
 805e854: b082         	sub	sp, #0x8
 805e856: 9001         	str	r0, [sp, #0x4]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805e858: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e888 <MPU_xStreamBufferNextMessageLengthBytes+0x40>
 805e85a: 4780         	blx	r0
 805e85c: b940         	cbnz	r0, 0x805e870 <MPU_xStreamBufferNextMessageLengthBytes+0x28> @ imm = #0x10
 805e85e: e7ff         	b	0x805e860 <MPU_xStreamBufferNextMessageLengthBytes+0x18> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805e860: df03         	svc	#0x3
;             xReturn = xStreamBufferNextMessageLengthBytes( xStreamBuffer );
 805e862: 9801         	ldr	r0, [sp, #0x4]
 805e864: 490a         	ldr	r1, [pc, #0x28]         @ 0x805e890 <MPU_xStreamBufferNextMessageLengthBytes+0x48>
 805e866: 4788         	blx	r1
 805e868: 9000         	str	r0, [sp]
;             portRESET_PRIVILEGE();
 805e86a: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e894 <MPU_xStreamBufferNextMessageLengthBytes+0x4c>
 805e86c: 4780         	blx	r0
;         }
 805e86e: e004         	b	0x805e87a <MPU_xStreamBufferNextMessageLengthBytes+0x32> @ imm = #0x8
;             xReturn = xStreamBufferNextMessageLengthBytes( xStreamBuffer );
 805e870: 9801         	ldr	r0, [sp, #0x4]
 805e872: 4906         	ldr	r1, [pc, #0x18]         @ 0x805e88c <MPU_xStreamBufferNextMessageLengthBytes+0x44>
 805e874: 4788         	blx	r1
 805e876: 9000         	str	r0, [sp]
 805e878: e7ff         	b	0x805e87a <MPU_xStreamBufferNextMessageLengthBytes+0x32> @ imm = #-0x2
;         return xReturn;
 805e87a: 9800         	ldr	r0, [sp]
 805e87c: b002         	add	sp, #0x8
 805e87e: bc80         	pop	{r7}
 805e880: eba8 0809    	sub.w	r8, r8, r9
 805e884: f858 fd04    	ldr	pc, [r8, #-4]!

0805e888 <$d.121>:
 805e888: a1 f8 05 08  	.word	0x0805f8a1
 805e88c: b1 c7 05 08  	.word	0x0805c7b1
 805e890: b1 c7 05 08  	.word	0x0805c7b1
 805e894: b1 f8 05 08  	.word	0x0805f8b1

0805e898 <MPU_xStreamBufferReceive>:
;     {
 805e898: f848 eb30    	str	lr, [r8], #48
 805e89c: eb08 0809    	add.w	r8, r8, r9
 805e8a0: b480         	push	{r7}
 805e8a2: 466f         	mov	r7, sp
 805e8a4: b086         	sub	sp, #0x18
 805e8a6: 9005         	str	r0, [sp, #0x14]
 805e8a8: 9104         	str	r1, [sp, #0x10]
 805e8aa: 9203         	str	r2, [sp, #0xc]
 805e8ac: 9302         	str	r3, [sp, #0x8]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805e8ae: 4810         	ldr	r0, [pc, #0x40]         @ 0x805e8f0 <MPU_xStreamBufferReceive+0x58>
 805e8b0: 4780         	blx	r0
 805e8b2: b960         	cbnz	r0, 0x805e8ce <MPU_xStreamBufferReceive+0x36> @ imm = #0x18
 805e8b4: e7ff         	b	0x805e8b6 <MPU_xStreamBufferReceive+0x1e> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805e8b6: df03         	svc	#0x3
;             xReturn = xStreamBufferReceive( xStreamBuffer, pvRxData, xBufferLengthBytes, xTicksToWait );
 805e8b8: 9805         	ldr	r0, [sp, #0x14]
 805e8ba: 9904         	ldr	r1, [sp, #0x10]
 805e8bc: 9a03         	ldr	r2, [sp, #0xc]
 805e8be: 9b02         	ldr	r3, [sp, #0x8]
 805e8c0: f8df c034    	ldr.w	r12, [pc, #0x34]        @ 0x805e8f8 <MPU_xStreamBufferReceive+0x60>
 805e8c4: 47e0         	blx	r12
 805e8c6: 9001         	str	r0, [sp, #0x4]
;             portRESET_PRIVILEGE();
 805e8c8: 480c         	ldr	r0, [pc, #0x30]         @ 0x805e8fc <MPU_xStreamBufferReceive+0x64>
 805e8ca: 4780         	blx	r0
;         }
 805e8cc: e008         	b	0x805e8e0 <MPU_xStreamBufferReceive+0x48> @ imm = #0x10
;             xReturn = xStreamBufferReceive( xStreamBuffer, pvRxData, xBufferLengthBytes, xTicksToWait );
 805e8ce: 9805         	ldr	r0, [sp, #0x14]
 805e8d0: 9904         	ldr	r1, [sp, #0x10]
 805e8d2: 9a03         	ldr	r2, [sp, #0xc]
 805e8d4: 9b02         	ldr	r3, [sp, #0x8]
 805e8d6: f8df c01c    	ldr.w	r12, [pc, #0x1c]        @ 0x805e8f4 <MPU_xStreamBufferReceive+0x5c>
 805e8da: 47e0         	blx	r12
 805e8dc: 9001         	str	r0, [sp, #0x4]
 805e8de: e7ff         	b	0x805e8e0 <MPU_xStreamBufferReceive+0x48> @ imm = #-0x2
;         return xReturn;
 805e8e0: 9801         	ldr	r0, [sp, #0x4]
 805e8e2: b006         	add	sp, #0x18
 805e8e4: bc80         	pop	{r7}
 805e8e6: eba8 0809    	sub.w	r8, r8, r9
 805e8ea: f858 fd30    	ldr	pc, [r8, #-48]!
 805e8ee: bf00         	nop

0805e8f0 <$d.123>:
 805e8f0: a1 f8 05 08  	.word	0x0805f8a1
 805e8f4: 99 c5 05 08  	.word	0x0805c599
 805e8f8: 99 c5 05 08  	.word	0x0805c599
 805e8fc: b1 f8 05 08  	.word	0x0805f8b1

0805e900 <MPU_xStreamBufferIsFull>:
;     {
 805e900: f848 eb28    	str	lr, [r8], #40
 805e904: eb08 0809    	add.w	r8, r8, r9
 805e908: b480         	push	{r7}
 805e90a: 466f         	mov	r7, sp
 805e90c: b082         	sub	sp, #0x8
 805e90e: 9001         	str	r0, [sp, #0x4]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805e910: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e940 <MPU_xStreamBufferIsFull+0x40>
 805e912: 4780         	blx	r0
 805e914: b940         	cbnz	r0, 0x805e928 <MPU_xStreamBufferIsFull+0x28> @ imm = #0x10
 805e916: e7ff         	b	0x805e918 <MPU_xStreamBufferIsFull+0x18> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805e918: df03         	svc	#0x3
;             xReturn = xStreamBufferIsFull( xStreamBuffer );
 805e91a: 9801         	ldr	r0, [sp, #0x4]
 805e91c: 490a         	ldr	r1, [pc, #0x28]         @ 0x805e948 <MPU_xStreamBufferIsFull+0x48>
 805e91e: 4788         	blx	r1
 805e920: 9000         	str	r0, [sp]
;             portRESET_PRIVILEGE();
 805e922: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e94c <MPU_xStreamBufferIsFull+0x4c>
 805e924: 4780         	blx	r0
;         }
 805e926: e004         	b	0x805e932 <MPU_xStreamBufferIsFull+0x32> @ imm = #0x8
;             xReturn = xStreamBufferIsFull( xStreamBuffer );
 805e928: 9801         	ldr	r0, [sp, #0x4]
 805e92a: 4906         	ldr	r1, [pc, #0x18]         @ 0x805e944 <MPU_xStreamBufferIsFull+0x44>
 805e92c: 4788         	blx	r1
 805e92e: 9000         	str	r0, [sp]
 805e930: e7ff         	b	0x805e932 <MPU_xStreamBufferIsFull+0x32> @ imm = #-0x2
;         return xReturn;
 805e932: 9800         	ldr	r0, [sp]
 805e934: b002         	add	sp, #0x8
 805e936: bc80         	pop	{r7}
 805e938: eba8 0809    	sub.w	r8, r8, r9
 805e93c: f858 fd28    	ldr	pc, [r8, #-40]!

0805e940 <$d.127>:
 805e940: a1 f8 05 08  	.word	0x0805f8a1
 805e944: 5d ca 05 08  	.word	0x0805ca5d
 805e948: 5d ca 05 08  	.word	0x0805ca5d
 805e94c: b1 f8 05 08  	.word	0x0805f8b1

0805e950 <MPU_xStreamBufferIsEmpty>:
;     {
 805e950: f848 eb58    	str	lr, [r8], #88
 805e954: eb08 0809    	add.w	r8, r8, r9
 805e958: b480         	push	{r7}
 805e95a: 466f         	mov	r7, sp
 805e95c: b082         	sub	sp, #0x8
 805e95e: 9001         	str	r0, [sp, #0x4]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805e960: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e990 <MPU_xStreamBufferIsEmpty+0x40>
 805e962: 4780         	blx	r0
 805e964: b940         	cbnz	r0, 0x805e978 <MPU_xStreamBufferIsEmpty+0x28> @ imm = #0x10
 805e966: e7ff         	b	0x805e968 <MPU_xStreamBufferIsEmpty+0x18> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805e968: df03         	svc	#0x3
;             xReturn = xStreamBufferIsEmpty( xStreamBuffer );
 805e96a: 9801         	ldr	r0, [sp, #0x4]
 805e96c: 490a         	ldr	r1, [pc, #0x28]         @ 0x805e998 <MPU_xStreamBufferIsEmpty+0x48>
 805e96e: 4788         	blx	r1
 805e970: 9000         	str	r0, [sp]
;             portRESET_PRIVILEGE();
 805e972: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e99c <MPU_xStreamBufferIsEmpty+0x4c>
 805e974: 4780         	blx	r0
;         }
 805e976: e004         	b	0x805e982 <MPU_xStreamBufferIsEmpty+0x32> @ imm = #0x8
;             xReturn = xStreamBufferIsEmpty( xStreamBuffer );
 805e978: 9801         	ldr	r0, [sp, #0x4]
 805e97a: 4906         	ldr	r1, [pc, #0x18]         @ 0x805e994 <MPU_xStreamBufferIsEmpty+0x44>
 805e97c: 4788         	blx	r1
 805e97e: 9000         	str	r0, [sp]
 805e980: e7ff         	b	0x805e982 <MPU_xStreamBufferIsEmpty+0x32> @ imm = #-0x2
;         return xReturn;
 805e982: 9800         	ldr	r0, [sp]
 805e984: b002         	add	sp, #0x8
 805e986: bc80         	pop	{r7}
 805e988: eba8 0809    	sub.w	r8, r8, r9
 805e98c: f858 fd58    	ldr	pc, [r8, #-88]!

0805e990 <$d.129>:
 805e990: a1 f8 05 08  	.word	0x0805f8a1
 805e994: 09 ca 05 08  	.word	0x0805ca09
 805e998: 09 ca 05 08  	.word	0x0805ca09
 805e99c: b1 f8 05 08  	.word	0x0805f8b1

0805e9a0 <MPU_xStreamBufferSpacesAvailable>:
;     {
 805e9a0: f848 eb48    	str	lr, [r8], #72
 805e9a4: eb08 0809    	add.w	r8, r8, r9
 805e9a8: b480         	push	{r7}
 805e9aa: 466f         	mov	r7, sp
 805e9ac: b082         	sub	sp, #0x8
 805e9ae: 9001         	str	r0, [sp, #0x4]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805e9b0: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805e9e0 <MPU_xStreamBufferSpacesAvailable+0x40>
 805e9b2: 4780         	blx	r0
 805e9b4: b940         	cbnz	r0, 0x805e9c8 <MPU_xStreamBufferSpacesAvailable+0x28> @ imm = #0x10
 805e9b6: e7ff         	b	0x805e9b8 <MPU_xStreamBufferSpacesAvailable+0x18> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805e9b8: df03         	svc	#0x3
;             xReturn = xStreamBufferSpacesAvailable( xStreamBuffer );
 805e9ba: 9801         	ldr	r0, [sp, #0x4]
 805e9bc: 490a         	ldr	r1, [pc, #0x28]         @ 0x805e9e8 <MPU_xStreamBufferSpacesAvailable+0x48>
 805e9be: 4788         	blx	r1
 805e9c0: 9000         	str	r0, [sp]
;             portRESET_PRIVILEGE();
 805e9c2: 480a         	ldr	r0, [pc, #0x28]         @ 0x805e9ec <MPU_xStreamBufferSpacesAvailable+0x4c>
 805e9c4: 4780         	blx	r0
;         }
 805e9c6: e004         	b	0x805e9d2 <MPU_xStreamBufferSpacesAvailable+0x32> @ imm = #0x8
;             xReturn = xStreamBufferSpacesAvailable( xStreamBuffer );
 805e9c8: 9801         	ldr	r0, [sp, #0x4]
 805e9ca: 4906         	ldr	r1, [pc, #0x18]         @ 0x805e9e4 <MPU_xStreamBufferSpacesAvailable+0x44>
 805e9cc: 4788         	blx	r1
 805e9ce: 9000         	str	r0, [sp]
 805e9d0: e7ff         	b	0x805e9d2 <MPU_xStreamBufferSpacesAvailable+0x32> @ imm = #-0x2
;         return xReturn;
 805e9d2: 9800         	ldr	r0, [sp]
 805e9d4: b002         	add	sp, #0x8
 805e9d6: bc80         	pop	{r7}
 805e9d8: eba8 0809    	sub.w	r8, r8, r9
 805e9dc: f858 fd48    	ldr	pc, [r8, #-72]!

0805e9e0 <$d.133>:
 805e9e0: a1 f8 05 08  	.word	0x0805f8a1
 805e9e4: 11 c1 05 08  	.word	0x0805c111
 805e9e8: 11 c1 05 08  	.word	0x0805c111
 805e9ec: b1 f8 05 08  	.word	0x0805f8b1

0805e9f0 <MPU_xStreamBufferBytesAvailable>:
;     {
 805e9f0: f848 eb78    	str	lr, [r8], #120
 805e9f4: eb08 0809    	add.w	r8, r8, r9
 805e9f8: b480         	push	{r7}
 805e9fa: 466f         	mov	r7, sp
 805e9fc: b082         	sub	sp, #0x8
 805e9fe: 9001         	str	r0, [sp, #0x4]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805ea00: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805ea30 <MPU_xStreamBufferBytesAvailable+0x40>
 805ea02: 4780         	blx	r0
 805ea04: b940         	cbnz	r0, 0x805ea18 <MPU_xStreamBufferBytesAvailable+0x28> @ imm = #0x10
 805ea06: e7ff         	b	0x805ea08 <MPU_xStreamBufferBytesAvailable+0x18> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805ea08: df03         	svc	#0x3
;             xReturn = xStreamBufferBytesAvailable( xStreamBuffer );
 805ea0a: 9801         	ldr	r0, [sp, #0x4]
 805ea0c: 490a         	ldr	r1, [pc, #0x28]         @ 0x805ea38 <MPU_xStreamBufferBytesAvailable+0x48>
 805ea0e: 4788         	blx	r1
 805ea10: 9000         	str	r0, [sp]
;             portRESET_PRIVILEGE();
 805ea12: 480a         	ldr	r0, [pc, #0x28]         @ 0x805ea3c <MPU_xStreamBufferBytesAvailable+0x4c>
 805ea14: 4780         	blx	r0
;         }
 805ea16: e004         	b	0x805ea22 <MPU_xStreamBufferBytesAvailable+0x32> @ imm = #0x8
;             xReturn = xStreamBufferBytesAvailable( xStreamBuffer );
 805ea18: 9801         	ldr	r0, [sp, #0x4]
 805ea1a: 4906         	ldr	r1, [pc, #0x18]         @ 0x805ea34 <MPU_xStreamBufferBytesAvailable+0x44>
 805ea1c: 4788         	blx	r1
 805ea1e: 9000         	str	r0, [sp]
 805ea20: e7ff         	b	0x805ea22 <MPU_xStreamBufferBytesAvailable+0x32> @ imm = #-0x2
;         return xReturn;
 805ea22: 9800         	ldr	r0, [sp]
 805ea24: b002         	add	sp, #0x8
 805ea26: bc80         	pop	{r7}
 805ea28: eba8 0809    	sub.w	r8, r8, r9
 805ea2c: f858 fd78    	ldr	pc, [r8, #-120]!

0805ea30 <$d.135>:
 805ea30: a1 f8 05 08  	.word	0x0805f8a1
 805ea34: 91 c1 05 08  	.word	0x0805c191
 805ea38: 91 c1 05 08  	.word	0x0805c191
 805ea3c: b1 f8 05 08  	.word	0x0805f8b1

0805ea40 <MPU_xStreamBufferSetTriggerLevel>:
;     {
 805ea40: f848 eb48    	str	lr, [r8], #72
 805ea44: eb08 0809    	add.w	r8, r8, r9
 805ea48: b480         	push	{r7}
 805ea4a: 466f         	mov	r7, sp
 805ea4c: b084         	sub	sp, #0x10
 805ea4e: 9003         	str	r0, [sp, #0xc]
 805ea50: 9102         	str	r1, [sp, #0x8]
;         if( portIS_PRIVILEGED() == pdFALSE )
 805ea52: 480d         	ldr	r0, [pc, #0x34]         @ 0x805ea88 <MPU_xStreamBufferSetTriggerLevel+0x48>
 805ea54: 4780         	blx	r0
 805ea56: b948         	cbnz	r0, 0x805ea6c <MPU_xStreamBufferSetTriggerLevel+0x2c> @ imm = #0x12
 805ea58: e7ff         	b	0x805ea5a <MPU_xStreamBufferSetTriggerLevel+0x1a> @ imm = #-0x2
;             portRAISE_PRIVILEGE();
 805ea5a: df03         	svc	#0x3
;             xReturn = xStreamBufferSetTriggerLevel( xStreamBuffer, xTriggerLevel );
 805ea5c: 9803         	ldr	r0, [sp, #0xc]
 805ea5e: 9902         	ldr	r1, [sp, #0x8]
 805ea60: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x805ea90 <MPU_xStreamBufferSetTriggerLevel+0x50>
 805ea62: 4790         	blx	r2
 805ea64: 9001         	str	r0, [sp, #0x4]
;             portRESET_PRIVILEGE();
 805ea66: 480b         	ldr	r0, [pc, #0x2c]         @ 0x805ea94 <MPU_xStreamBufferSetTriggerLevel+0x54>
 805ea68: 4780         	blx	r0
;         }
 805ea6a: e005         	b	0x805ea78 <MPU_xStreamBufferSetTriggerLevel+0x38> @ imm = #0xa
;             xReturn = xStreamBufferSetTriggerLevel( xStreamBuffer, xTriggerLevel );
 805ea6c: 9803         	ldr	r0, [sp, #0xc]
 805ea6e: 9902         	ldr	r1, [sp, #0x8]
 805ea70: 4a06         	ldr	r2, [pc, #0x18]         @ 0x805ea8c <MPU_xStreamBufferSetTriggerLevel+0x4c>
 805ea72: 4790         	blx	r2
 805ea74: 9001         	str	r0, [sp, #0x4]
 805ea76: e7ff         	b	0x805ea78 <MPU_xStreamBufferSetTriggerLevel+0x38> @ imm = #-0x2
;         return xReturn;
 805ea78: 9801         	ldr	r0, [sp, #0x4]
 805ea7a: b004         	add	sp, #0x10
 805ea7c: bc80         	pop	{r7}
 805ea7e: eba8 0809    	sub.w	r8, r8, r9
 805ea82: f858 fd48    	ldr	pc, [r8, #-72]!
 805ea86: bf00         	nop

0805ea88 <$d.137>:
 805ea88: a1 f8 05 08  	.word	0x0805f8a1
 805ea8c: b1 c0 05 08  	.word	0x0805c0b1
 805ea90: b1 c0 05 08  	.word	0x0805c0b1
 805ea94: b1 f8 05 08  	.word	0x0805f8b1
 805ea98: 00 00 00 00  	.word	0x00000000
 805ea9c: 00 00        	.short	0x0000
 805ea9e: 00           	.byte	0x00

0805ea9f <__syscalls_flash_end__>:
 805ea9f: 00           	.byte	0x00

Disassembly of section .text:

0805eaa0 <__unprivileged_flash_start__>:
; {
 805eaa0: f848 eb18    	str	lr, [r8], #24
 805eaa4: eb08 0809    	add.w	r8, r8, r9
 805eaa8: b480         	push	{r7}
 805eaaa: 466f         	mov	r7, sp
 805eaac: b082         	sub	sp, #0x8
 805eaae: 2000         	movs	r0, #0x0
;   HAL_StatusTypeDef  status = HAL_OK;
 805eab0: f807 0c01    	strb	r0, [r7, #-1]
;   HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 805eab4: 490c         	ldr	r1, [pc, #0x30]         @ 0x805eae8 <__unprivileged_flash_start__+0x48>
 805eab6: 2004         	movs	r0, #0x4
 805eab8: 4788         	blx	r1
;   SystemCoreClockUpdate();
 805eaba: 480c         	ldr	r0, [pc, #0x30]         @ 0x805eaec <__unprivileged_flash_start__+0x4c>
 805eabc: 4780         	blx	r0
;   if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 805eabe: 490c         	ldr	r1, [pc, #0x30]         @ 0x805eaf0 <__unprivileged_flash_start__+0x50>
 805eac0: 2007         	movs	r0, #0x7
 805eac2: 4788         	blx	r1
 805eac4: b120         	cbz	r0, 0x805ead0 <__unprivileged_flash_start__+0x30> @ imm = #0x8
 805eac6: e7ff         	b	0x805eac8 <__unprivileged_flash_start__+0x28> @ imm = #-0x2
 805eac8: 2001         	movs	r0, #0x1
;     status = HAL_ERROR;
 805eaca: f807 0c01    	strb	r0, [r7, #-1]
;   }
 805eace: e002         	b	0x805ead6 <__unprivileged_flash_start__+0x36> @ imm = #0x4
;     HAL_MspInit();
 805ead0: 4808         	ldr	r0, [pc, #0x20]         @ 0x805eaf4 <__unprivileged_flash_start__+0x54>
 805ead2: 4780         	blx	r0
 805ead4: e7ff         	b	0x805ead6 <__unprivileged_flash_start__+0x36> @ imm = #-0x2
;   return status;
 805ead6: f817 0c01    	ldrb	r0, [r7, #-1]
 805eada: b002         	add	sp, #0x8
 805eadc: bc80         	pop	{r7}
 805eade: eba8 0809    	sub.w	r8, r8, r9
 805eae2: f858 fd18    	ldr	pc, [r8, #-24]!
 805eae6: bf00         	nop

0805eae8 <$d.1>:
 805eae8: e1 f0 05 08  	.word	0x0805f0e1
 805eaec: a1 eb 05 08  	.word	0x0805eba1
 805eaf0: f9 ea 05 08  	.word	0x0805eaf9
 805eaf4: 9d eb 05 08  	.word	0x0805eb9d

0805eaf8 <HAL_InitTick>:
; {
 805eaf8: f848 eb24    	str	lr, [r8], #36
 805eafc: eb08 0809    	add.w	r8, r8, r9
 805eb00: b480         	push	{r7}
 805eb02: 466f         	mov	r7, sp
 805eb04: b082         	sub	sp, #0x8
 805eb06: 9001         	str	r0, [sp, #0x4]
 805eb08: 2000         	movs	r0, #0x0
;   HAL_StatusTypeDef  status = HAL_OK;
 805eb0a: f807 0c05    	strb	r0, [r7, #-5]
;   if ((uint32_t)uwTickFreq != 0U)
 805eb0e: f242 3084    	movw	r0, #0x2384
 805eb12: f2c2 0000    	movt	r0, #0x2000
 805eb16: 7800         	ldrb	r0, [r0]
 805eb18: b378         	cbz	r0, 0x805eb7a <HAL_InitTick+0x82> @ imm = #0x5e
 805eb1a: e7ff         	b	0x805eb1c <HAL_InitTick+0x24> @ imm = #-0x2
;     if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / (uint32_t)uwTickFreq)) == 0U)
 805eb1c: f242 3088    	movw	r0, #0x2388
 805eb20: f2c2 0000    	movt	r0, #0x2000
 805eb24: 6800         	ldr	r0, [r0]
 805eb26: f242 3184    	movw	r1, #0x2384
 805eb2a: f2c2 0100    	movt	r1, #0x2000
 805eb2e: 780a         	ldrb	r2, [r1]
 805eb30: f44f 717a    	mov.w	r1, #0x3e8
 805eb34: fbb1 f1f2    	udiv	r1, r1, r2
 805eb38: fbb0 f0f1    	udiv	r0, r0, r1
 805eb3c: 4915         	ldr	r1, [pc, #0x54]         @ 0x805eb94 <HAL_InitTick+0x9c>
 805eb3e: 4788         	blx	r1
 805eb40: b9b0         	cbnz	r0, 0x805eb70 <HAL_InitTick+0x78> @ imm = #0x2c
 805eb42: e7ff         	b	0x805eb44 <HAL_InitTick+0x4c> @ imm = #-0x2
;       if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 805eb44: 9801         	ldr	r0, [sp, #0x4]
 805eb46: 2807         	cmp	r0, #0x7
 805eb48: d80d         	bhi	0x805eb66 <HAL_InitTick+0x6e> @ imm = #0x1a
 805eb4a: e7ff         	b	0x805eb4c <HAL_InitTick+0x54> @ imm = #-0x2
;         HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 805eb4c: 9901         	ldr	r1, [sp, #0x4]
 805eb4e: 4b12         	ldr	r3, [pc, #0x48]         @ 0x805eb98 <HAL_InitTick+0xa0>
 805eb50: f04f 30ff    	mov.w	r0, #0xffffffff
 805eb54: 2200         	movs	r2, #0x0
 805eb56: 4798         	blx	r3
;         uwTickPrio = TickPriority;
 805eb58: 9801         	ldr	r0, [sp, #0x4]
 805eb5a: f242 3180    	movw	r1, #0x2380
 805eb5e: f2c2 0100    	movt	r1, #0x2000
 805eb62: 6008         	str	r0, [r1]
;       }
 805eb64: e003         	b	0x805eb6e <HAL_InitTick+0x76> @ imm = #0x6
 805eb66: 2001         	movs	r0, #0x1
;         status = HAL_ERROR;
 805eb68: f807 0c05    	strb	r0, [r7, #-5]
 805eb6c: e7ff         	b	0x805eb6e <HAL_InitTick+0x76> @ imm = #-0x2
;     }
 805eb6e: e003         	b	0x805eb78 <HAL_InitTick+0x80> @ imm = #0x6
 805eb70: 2001         	movs	r0, #0x1
;       status = HAL_ERROR;
 805eb72: f807 0c05    	strb	r0, [r7, #-5]
 805eb76: e7ff         	b	0x805eb78 <HAL_InitTick+0x80> @ imm = #-0x2
;   }
 805eb78: e003         	b	0x805eb82 <HAL_InitTick+0x8a> @ imm = #0x6
 805eb7a: 2001         	movs	r0, #0x1
;     status = HAL_ERROR;
 805eb7c: f807 0c05    	strb	r0, [r7, #-5]
 805eb80: e7ff         	b	0x805eb82 <HAL_InitTick+0x8a> @ imm = #-0x2
;   return status;
 805eb82: f817 0c05    	ldrb	r0, [r7, #-5]
 805eb86: b002         	add	sp, #0x8
 805eb88: bc80         	pop	{r7}
 805eb8a: eba8 0809    	sub.w	r8, r8, r9
 805eb8e: f858 fd24    	ldr	pc, [r8, #-36]!
 805eb92: bf00         	nop

0805eb94 <$d.3>:
 805eb94: 51 f2 05 08  	.word	0x0805f251
 805eb98: 45 f1 05 08  	.word	0x0805f145

0805eb9c <HAL_MspInit>:
; }
 805eb9c: 4770         	bx	lr

0805eb9e <SystemInit>:
; }
 805eb9e: 4770         	bx	lr

0805eba0 <SystemCoreClockUpdate>:
; {
 805eba0: b088         	sub	sp, #0x20
 805eba2: f241 0000    	movw	r0, #0x1000
 805eba6: f2c4 0002    	movt	r0, #0x4002
;   if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 805ebaa: 6800         	ldr	r0, [r0]
 805ebac: 0700         	lsls	r0, r0, #0x1c
 805ebae: 2800         	cmp	r0, #0x0
 805ebb0: d409         	bmi	0x805ebc6 <SystemCoreClockUpdate+0x26> @ imm = #0x12
 805ebb2: e7ff         	b	0x805ebb4 <SystemCoreClockUpdate+0x14> @ imm = #-0x2
 805ebb4: f241 0094    	movw	r0, #0x1094
 805ebb8: f2c4 0002    	movt	r0, #0x4002
;     msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 805ebbc: 6800         	ldr	r0, [r0]
 805ebbe: f3c0 2003    	ubfx	r0, r0, #0x8, #0x4
 805ebc2: 9006         	str	r0, [sp, #0x18]
;   }
 805ebc4: e008         	b	0x805ebd8 <SystemCoreClockUpdate+0x38> @ imm = #0x10
 805ebc6: f241 0000    	movw	r0, #0x1000
 805ebca: f2c4 0002    	movt	r0, #0x4002
;     msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 805ebce: 6800         	ldr	r0, [r0]
 805ebd0: b2c0         	uxtb	r0, r0
 805ebd2: 0900         	lsrs	r0, r0, #0x4
 805ebd4: 9006         	str	r0, [sp, #0x18]
 805ebd6: e7ff         	b	0x805ebd8 <SystemCoreClockUpdate+0x38> @ imm = #-0x2
;   msirange = MSIRangeTable[msirange];
 805ebd8: 9906         	ldr	r1, [sp, #0x18]
 805ebda: f64f 2060    	movw	r0, #0xfa60
 805ebde: f6c0 0005    	movt	r0, #0x805
 805ebe2: f850 0021    	ldr.w	r0, [r0, r1, lsl #2]
 805ebe6: 9006         	str	r0, [sp, #0x18]
 805ebe8: f241 0008    	movw	r0, #0x1008
 805ebec: f2c4 0002    	movt	r0, #0x4002
;   switch (RCC->CFGR & RCC_CFGR_SWS)
 805ebf0: 6800         	ldr	r0, [r0]
 805ebf2: f000 000c    	and	r0, r0, #0xc
 805ebf6: 4601         	mov	r1, r0
 805ebf8: 9101         	str	r1, [sp, #0x4]
 805ebfa: b160         	cbz	r0, 0x805ec16 <SystemCoreClockUpdate+0x76> @ imm = #0x18
 805ebfc: e7ff         	b	0x805ebfe <SystemCoreClockUpdate+0x5e> @ imm = #-0x2
 805ebfe: 9801         	ldr	r0, [sp, #0x4]
 805ec00: 2804         	cmp	r0, #0x4
 805ec02: d00f         	beq	0x805ec24 <SystemCoreClockUpdate+0x84> @ imm = #0x1e
 805ec04: e7ff         	b	0x805ec06 <SystemCoreClockUpdate+0x66> @ imm = #-0x2
 805ec06: 9801         	ldr	r0, [sp, #0x4]
 805ec08: 2808         	cmp	r0, #0x8
 805ec0a: d015         	beq	0x805ec38 <SystemCoreClockUpdate+0x98> @ imm = #0x2a
 805ec0c: e7ff         	b	0x805ec0e <SystemCoreClockUpdate+0x6e> @ imm = #-0x2
 805ec0e: 9801         	ldr	r0, [sp, #0x4]
 805ec10: 280c         	cmp	r0, #0xc
 805ec12: d01b         	beq	0x805ec4c <SystemCoreClockUpdate+0xac> @ imm = #0x36
 805ec14: e064         	b	0x805ece0 <SystemCoreClockUpdate+0x140> @ imm = #0xc8
;       SystemCoreClock = msirange;
 805ec16: 9806         	ldr	r0, [sp, #0x18]
 805ec18: f242 3188    	movw	r1, #0x2388
 805ec1c: f2c2 0100    	movt	r1, #0x2000
 805ec20: 6008         	str	r0, [r1]
;       break;
 805ec22: e064         	b	0x805ecee <SystemCoreClockUpdate+0x14e> @ imm = #0xc8
;       SystemCoreClock = HSI_VALUE;
 805ec24: f242 3188    	movw	r1, #0x2388
 805ec28: f2c2 0100    	movt	r1, #0x2000
 805ec2c: f242 4000    	movw	r0, #0x2400
 805ec30: f2c0 00f4    	movt	r0, #0xf4
 805ec34: 6008         	str	r0, [r1]
;       break;
 805ec36: e05a         	b	0x805ecee <SystemCoreClockUpdate+0x14e> @ imm = #0xb4
;       SystemCoreClock = HSE_VALUE;
 805ec38: f242 3188    	movw	r1, #0x2388
 805ec3c: f2c2 0100    	movt	r1, #0x2000
 805ec40: f242 4000    	movw	r0, #0x2400
 805ec44: f2c0 00f4    	movt	r0, #0xf4
 805ec48: 6008         	str	r0, [r1]
;       break;
 805ec4a: e050         	b	0x805ecee <SystemCoreClockUpdate+0x14e> @ imm = #0xa0
 805ec4c: f241 000c    	movw	r0, #0x100c
 805ec50: f2c4 0002    	movt	r0, #0x4002
;       pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 805ec54: 6801         	ldr	r1, [r0]
 805ec56: f001 0103    	and	r1, r1, #0x3
 805ec5a: 9104         	str	r1, [sp, #0x10]
;       pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 805ec5c: 6800         	ldr	r0, [r0]
 805ec5e: b2c1         	uxtb	r1, r0
 805ec60: 2001         	movs	r0, #0x1
 805ec62: eb00 1011    	add.w	r0, r0, r1, lsr #4
 805ec66: 9003         	str	r0, [sp, #0xc]
;       switch (pllsource)
 805ec68: 9804         	ldr	r0, [sp, #0x10]
 805ec6a: 9000         	str	r0, [sp]
 805ec6c: 2802         	cmp	r0, #0x2
 805ec6e: d004         	beq	0x805ec7a <SystemCoreClockUpdate+0xda> @ imm = #0x8
 805ec70: e7ff         	b	0x805ec72 <SystemCoreClockUpdate+0xd2> @ imm = #-0x2
 805ec72: 9800         	ldr	r0, [sp]
 805ec74: 2803         	cmp	r0, #0x3
 805ec76: d009         	beq	0x805ec8c <SystemCoreClockUpdate+0xec> @ imm = #0x12
 805ec78: e011         	b	0x805ec9e <SystemCoreClockUpdate+0xfe> @ imm = #0x22
;           pllvco = (HSI_VALUE / pllm);
 805ec7a: 9903         	ldr	r1, [sp, #0xc]
 805ec7c: f242 4000    	movw	r0, #0x2400
 805ec80: f2c0 00f4    	movt	r0, #0xf4
 805ec84: fbb0 f0f1    	udiv	r0, r0, r1
 805ec88: 9005         	str	r0, [sp, #0x14]
;           break;
 805ec8a: e00e         	b	0x805ecaa <SystemCoreClockUpdate+0x10a> @ imm = #0x1c
;           pllvco = (HSE_VALUE / pllm);
 805ec8c: 9903         	ldr	r1, [sp, #0xc]
 805ec8e: f242 4000    	movw	r0, #0x2400
 805ec92: f2c0 00f4    	movt	r0, #0xf4
 805ec96: fbb0 f0f1    	udiv	r0, r0, r1
 805ec9a: 9005         	str	r0, [sp, #0x14]
;           break;
 805ec9c: e005         	b	0x805ecaa <SystemCoreClockUpdate+0x10a> @ imm = #0xa
;           pllvco = (msirange / pllm);
 805ec9e: 9806         	ldr	r0, [sp, #0x18]
 805eca0: 9903         	ldr	r1, [sp, #0xc]
 805eca2: fbb0 f0f1    	udiv	r0, r0, r1
 805eca6: 9005         	str	r0, [sp, #0x14]
;           break;
 805eca8: e7ff         	b	0x805ecaa <SystemCoreClockUpdate+0x10a> @ imm = #-0x2
;       pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 805ecaa: 9905         	ldr	r1, [sp, #0x14]
 805ecac: f241 000c    	movw	r0, #0x100c
 805ecb0: f2c4 0002    	movt	r0, #0x4002
 805ecb4: 6802         	ldr	r2, [r0]
 805ecb6: f3c2 2206    	ubfx	r2, r2, #0x8, #0x7
 805ecba: 4351         	muls	r1, r2, r1
 805ecbc: 9105         	str	r1, [sp, #0x14]
;       pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 805ecbe: 6800         	ldr	r0, [r0]
 805ecc0: f000 61c0    	and	r1, r0, #0x6000000
 805ecc4: 2002         	movs	r0, #0x2
 805ecc6: eb00 6011    	add.w	r0, r0, r1, lsr #24
 805ecca: 9002         	str	r0, [sp, #0x8]
;       SystemCoreClock = pllvco/pllr;
 805eccc: 9805         	ldr	r0, [sp, #0x14]
 805ecce: 9902         	ldr	r1, [sp, #0x8]
 805ecd0: fbb0 f0f1    	udiv	r0, r0, r1
 805ecd4: f242 3188    	movw	r1, #0x2388
 805ecd8: f2c2 0100    	movt	r1, #0x2000
 805ecdc: 6008         	str	r0, [r1]
;       break;
 805ecde: e006         	b	0x805ecee <SystemCoreClockUpdate+0x14e> @ imm = #0xc
;       SystemCoreClock = msirange;
 805ece0: 9806         	ldr	r0, [sp, #0x18]
 805ece2: f242 3188    	movw	r1, #0x2388
 805ece6: f2c2 0100    	movt	r1, #0x2000
 805ecea: 6008         	str	r0, [r1]
;       break;
 805ecec: e7ff         	b	0x805ecee <SystemCoreClockUpdate+0x14e> @ imm = #-0x2
 805ecee: f241 0008    	movw	r0, #0x1008
 805ecf2: f2c4 0002    	movt	r0, #0x4002
;   tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];
 805ecf6: 6800         	ldr	r0, [r0]
 805ecf8: b2c0         	uxtb	r0, r0
 805ecfa: 0901         	lsrs	r1, r0, #0x4
 805ecfc: f64f 2050    	movw	r0, #0xfa50
 805ed00: f6c0 0005    	movt	r0, #0x805
 805ed04: 5c40         	ldrb	r0, [r0, r1]
 805ed06: 9007         	str	r0, [sp, #0x1c]
;   SystemCoreClock >>= tmp;
 805ed08: 9a07         	ldr	r2, [sp, #0x1c]
 805ed0a: f242 3188    	movw	r1, #0x2388
 805ed0e: f2c2 0100    	movt	r1, #0x2000
 805ed12: 6808         	ldr	r0, [r1]
 805ed14: 40d0         	lsrs	r0, r2
 805ed16: 6008         	str	r0, [r1]
; }
 805ed18: b008         	add	sp, #0x20
 805ed1a: 4770         	bx	lr

0805ed1c <HAL_GPIO_Init>:
; void HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init) {
 805ed1c: b08b         	sub	sp, #0x2c
 805ed1e: 900a         	str	r0, [sp, #0x28]
 805ed20: 9109         	str	r1, [sp, #0x24]
 805ed22: 2000         	movs	r0, #0x0
;   uint32_t position = 0U;
 805ed24: 9008         	str	r0, [sp, #0x20]
;   while (((GPIO_Init->Pin) >> position) != 0U) {
 805ed26: e7ff         	b	0x805ed28 <HAL_GPIO_Init+0xc> @ imm = #-0x2
 805ed28: 9809         	ldr	r0, [sp, #0x24]
 805ed2a: 6800         	ldr	r0, [r0]
 805ed2c: 9908         	ldr	r1, [sp, #0x20]
 805ed2e: 40c8         	lsrs	r0, r1
 805ed30: 2800         	cmp	r0, #0x0
 805ed32: f000 81a9    	beq.w	0x805f088 <HAL_GPIO_Init+0x36c> @ imm = #0x352
 805ed36: e7ff         	b	0x805ed38 <HAL_GPIO_Init+0x1c> @ imm = #-0x2
;     iocurrent = (GPIO_Init->Pin) & (1UL << position);
 805ed38: 9809         	ldr	r0, [sp, #0x24]
 805ed3a: 6800         	ldr	r0, [r0]
 805ed3c: 9a08         	ldr	r2, [sp, #0x20]
 805ed3e: 2101         	movs	r1, #0x1
 805ed40: 4091         	lsls	r1, r2
 805ed42: 4008         	ands	r0, r1
 805ed44: 9007         	str	r0, [sp, #0x1c]
;     if (iocurrent != 0U) {
 805ed46: 9807         	ldr	r0, [sp, #0x1c]
 805ed48: 2800         	cmp	r0, #0x0
 805ed4a: f000 8199    	beq.w	0x805f080 <HAL_GPIO_Init+0x364> @ imm = #0x332
 805ed4e: e7ff         	b	0x805ed50 <HAL_GPIO_Init+0x34> @ imm = #-0x2
;       if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) ||
 805ed50: 9809         	ldr	r0, [sp, #0x24]
 805ed52: 6840         	ldr	r0, [r0, #0x4]
 805ed54: 2801         	cmp	r0, #0x1
 805ed56: d00f         	beq	0x805ed78 <HAL_GPIO_Init+0x5c> @ imm = #0x1e
 805ed58: e7ff         	b	0x805ed5a <HAL_GPIO_Init+0x3e> @ imm = #-0x2
;           (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 805ed5a: 9809         	ldr	r0, [sp, #0x24]
 805ed5c: 6840         	ldr	r0, [r0, #0x4]
 805ed5e: 2802         	cmp	r0, #0x2
 805ed60: d00a         	beq	0x805ed78 <HAL_GPIO_Init+0x5c> @ imm = #0x14
 805ed62: e7ff         	b	0x805ed64 <HAL_GPIO_Init+0x48> @ imm = #-0x2
;           (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) ||
 805ed64: 9809         	ldr	r0, [sp, #0x24]
 805ed66: 6840         	ldr	r0, [r0, #0x4]
 805ed68: 2811         	cmp	r0, #0x11
 805ed6a: d005         	beq	0x805ed78 <HAL_GPIO_Init+0x5c> @ imm = #0xa
 805ed6c: e7ff         	b	0x805ed6e <HAL_GPIO_Init+0x52> @ imm = #-0x2
;           (GPIO_Init->Mode == GPIO_MODE_AF_OD)) {
 805ed6e: 9809         	ldr	r0, [sp, #0x24]
 805ed70: 6840         	ldr	r0, [r0, #0x4]
;       if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) ||
 805ed72: 2812         	cmp	r0, #0x12
 805ed74: d12f         	bne	0x805edd6 <HAL_GPIO_Init+0xba> @ imm = #0x5e
 805ed76: e7ff         	b	0x805ed78 <HAL_GPIO_Init+0x5c> @ imm = #-0x2
;         temp = GPIOx->OSPEEDR;
 805ed78: 980a         	ldr	r0, [sp, #0x28]
 805ed7a: 6880         	ldr	r0, [r0, #0x8]
 805ed7c: 9006         	str	r0, [sp, #0x18]
;         temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 805ed7e: 9808         	ldr	r0, [sp, #0x20]
 805ed80: 0041         	lsls	r1, r0, #0x1
 805ed82: 2003         	movs	r0, #0x3
 805ed84: fa00 f101    	lsl.w	r1, r0, r1
 805ed88: 9806         	ldr	r0, [sp, #0x18]
 805ed8a: 4388         	bics	r0, r1
 805ed8c: 9006         	str	r0, [sp, #0x18]
;         temp |= (GPIO_Init->Speed << (position * 2U));
 805ed8e: 9809         	ldr	r0, [sp, #0x24]
 805ed90: 68c0         	ldr	r0, [r0, #0xc]
 805ed92: 9908         	ldr	r1, [sp, #0x20]
 805ed94: 0049         	lsls	r1, r1, #0x1
 805ed96: fa00 f101    	lsl.w	r1, r0, r1
 805ed9a: 9806         	ldr	r0, [sp, #0x18]
 805ed9c: 4308         	orrs	r0, r1
 805ed9e: 9006         	str	r0, [sp, #0x18]
;         GPIOx->OSPEEDR = temp;
 805eda0: 9806         	ldr	r0, [sp, #0x18]
 805eda2: 990a         	ldr	r1, [sp, #0x28]
 805eda4: 6088         	str	r0, [r1, #0x8]
;         temp = GPIOx->OTYPER;
 805eda6: 980a         	ldr	r0, [sp, #0x28]
 805eda8: 6840         	ldr	r0, [r0, #0x4]
 805edaa: 9006         	str	r0, [sp, #0x18]
;         temp &= ~(GPIO_OTYPER_OT0 << position);
 805edac: 9908         	ldr	r1, [sp, #0x20]
 805edae: 2001         	movs	r0, #0x1
 805edb0: fa00 f101    	lsl.w	r1, r0, r1
 805edb4: 9806         	ldr	r0, [sp, #0x18]
 805edb6: 4388         	bics	r0, r1
 805edb8: 9006         	str	r0, [sp, #0x18]
;         temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 805edba: 9809         	ldr	r0, [sp, #0x24]
 805edbc: 6840         	ldr	r0, [r0, #0x4]
 805edbe: f3c0 1000    	ubfx	r0, r0, #0x4, #0x1
 805edc2: 9908         	ldr	r1, [sp, #0x20]
 805edc4: fa00 f101    	lsl.w	r1, r0, r1
 805edc8: 9806         	ldr	r0, [sp, #0x18]
 805edca: 4308         	orrs	r0, r1
 805edcc: 9006         	str	r0, [sp, #0x18]
;         GPIOx->OTYPER = temp;
 805edce: 9806         	ldr	r0, [sp, #0x18]
 805edd0: 990a         	ldr	r1, [sp, #0x28]
 805edd2: 6048         	str	r0, [r1, #0x4]
;       }
 805edd4: e7ff         	b	0x805edd6 <HAL_GPIO_Init+0xba> @ imm = #-0x2
;       temp = GPIOx->PUPDR;
 805edd6: 980a         	ldr	r0, [sp, #0x28]
 805edd8: 68c0         	ldr	r0, [r0, #0xc]
 805edda: 9006         	str	r0, [sp, #0x18]
;       temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 805eddc: 9808         	ldr	r0, [sp, #0x20]
 805edde: 0041         	lsls	r1, r0, #0x1
 805ede0: 2003         	movs	r0, #0x3
 805ede2: fa00 f101    	lsl.w	r1, r0, r1
 805ede6: 9806         	ldr	r0, [sp, #0x18]
 805ede8: 4388         	bics	r0, r1
 805edea: 9006         	str	r0, [sp, #0x18]
;       temp |= ((GPIO_Init->Pull) << (position * 2U));
 805edec: 9809         	ldr	r0, [sp, #0x24]
 805edee: 6880         	ldr	r0, [r0, #0x8]
 805edf0: 9908         	ldr	r1, [sp, #0x20]
 805edf2: 0049         	lsls	r1, r1, #0x1
 805edf4: fa00 f101    	lsl.w	r1, r0, r1
 805edf8: 9806         	ldr	r0, [sp, #0x18]
 805edfa: 4308         	orrs	r0, r1
 805edfc: 9006         	str	r0, [sp, #0x18]
;       GPIOx->PUPDR = temp;
 805edfe: 9806         	ldr	r0, [sp, #0x18]
 805ee00: 990a         	ldr	r1, [sp, #0x28]
 805ee02: 60c8         	str	r0, [r1, #0xc]
;       if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 805ee04: 9809         	ldr	r0, [sp, #0x24]
 805ee06: 6840         	ldr	r0, [r0, #0x4]
 805ee08: 2802         	cmp	r0, #0x2
 805ee0a: d005         	beq	0x805ee18 <HAL_GPIO_Init+0xfc> @ imm = #0xa
 805ee0c: e7ff         	b	0x805ee0e <HAL_GPIO_Init+0xf2> @ imm = #-0x2
;           (GPIO_Init->Mode == GPIO_MODE_AF_OD)) {
 805ee0e: 9809         	ldr	r0, [sp, #0x24]
 805ee10: 6840         	ldr	r0, [r0, #0x4]
;       if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 805ee12: 2812         	cmp	r0, #0x12
 805ee14: d126         	bne	0x805ee64 <HAL_GPIO_Init+0x148> @ imm = #0x4c
 805ee16: e7ff         	b	0x805ee18 <HAL_GPIO_Init+0xfc> @ imm = #-0x2
;         temp = GPIOx->AFR[position >> 3U];
 805ee18: 980a         	ldr	r0, [sp, #0x28]
 805ee1a: 9908         	ldr	r1, [sp, #0x20]
 805ee1c: f06f 0203    	mvn	r2, #0x3
 805ee20: ea02 0151    	and.w	r1, r2, r1, lsr #1
 805ee24: 4408         	add	r0, r1
 805ee26: 6a00         	ldr	r0, [r0, #0x20]
 805ee28: 9006         	str	r0, [sp, #0x18]
;         temp &= ~(0x0FUL << ((position & 0x07U) * 4U));
 805ee2a: 9808         	ldr	r0, [sp, #0x20]
 805ee2c: f000 0007    	and	r0, r0, #0x7
 805ee30: 0081         	lsls	r1, r0, #0x2
 805ee32: 200f         	movs	r0, #0xf
 805ee34: fa00 f101    	lsl.w	r1, r0, r1
 805ee38: 9806         	ldr	r0, [sp, #0x18]
 805ee3a: 4388         	bics	r0, r1
 805ee3c: 9006         	str	r0, [sp, #0x18]
;         temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 805ee3e: 9809         	ldr	r0, [sp, #0x24]
 805ee40: 6900         	ldr	r0, [r0, #0x10]
 805ee42: 9908         	ldr	r1, [sp, #0x20]
 805ee44: f001 0107    	and	r1, r1, #0x7
 805ee48: 0089         	lsls	r1, r1, #0x2
 805ee4a: fa00 f101    	lsl.w	r1, r0, r1
 805ee4e: 9806         	ldr	r0, [sp, #0x18]
 805ee50: 4308         	orrs	r0, r1
 805ee52: 9006         	str	r0, [sp, #0x18]
;         GPIOx->AFR[position >> 3U] = temp;
 805ee54: 9806         	ldr	r0, [sp, #0x18]
 805ee56: 990a         	ldr	r1, [sp, #0x28]
 805ee58: 9b08         	ldr	r3, [sp, #0x20]
 805ee5a: ea02 0253    	and.w	r2, r2, r3, lsr #1
 805ee5e: 4411         	add	r1, r2
 805ee60: 6208         	str	r0, [r1, #0x20]
;       }
 805ee62: e7ff         	b	0x805ee64 <HAL_GPIO_Init+0x148> @ imm = #-0x2
;       temp = GPIOx->MODER;
 805ee64: 980a         	ldr	r0, [sp, #0x28]
 805ee66: 6800         	ldr	r0, [r0]
 805ee68: 9006         	str	r0, [sp, #0x18]
;       temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 805ee6a: 9808         	ldr	r0, [sp, #0x20]
 805ee6c: 0041         	lsls	r1, r0, #0x1
 805ee6e: 2003         	movs	r0, #0x3
 805ee70: fa00 f101    	lsl.w	r1, r0, r1
 805ee74: 9806         	ldr	r0, [sp, #0x18]
 805ee76: 4388         	bics	r0, r1
 805ee78: 9006         	str	r0, [sp, #0x18]
;       temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 805ee7a: 9809         	ldr	r0, [sp, #0x24]
 805ee7c: 6840         	ldr	r0, [r0, #0x4]
 805ee7e: f000 0003    	and	r0, r0, #0x3
 805ee82: 9908         	ldr	r1, [sp, #0x20]
 805ee84: 0049         	lsls	r1, r1, #0x1
 805ee86: fa00 f101    	lsl.w	r1, r0, r1
 805ee8a: 9806         	ldr	r0, [sp, #0x18]
 805ee8c: 4308         	orrs	r0, r1
 805ee8e: 9006         	str	r0, [sp, #0x18]
;       GPIOx->MODER = temp;
 805ee90: 9806         	ldr	r0, [sp, #0x18]
 805ee92: 990a         	ldr	r1, [sp, #0x28]
 805ee94: 6008         	str	r0, [r1]
;       if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) {
 805ee96: 9809         	ldr	r0, [sp, #0x24]
 805ee98: 79c0         	ldrb	r0, [r0, #0x7]
 805ee9a: 06c0         	lsls	r0, r0, #0x1b
 805ee9c: 2800         	cmp	r0, #0x0
 805ee9e: f140 80ee    	bpl.w	0x805f07e <HAL_GPIO_Init+0x362> @ imm = #0x1dc
 805eea2: e7ff         	b	0x805eea4 <HAL_GPIO_Init+0x188> @ imm = #-0x2
;         temp = EXTI->EXTICR[position >> 2U];
 805eea4: 9808         	ldr	r0, [sp, #0x20]
 805eea6: f020 0003    	bic	r0, r0, #0x3
 805eeaa: f24f 4160    	movw	r1, #0xf460
 805eeae: f2c4 0102    	movt	r1, #0x4002
 805eeb2: 5840         	ldr	r0, [r0, r1]
 805eeb4: 9006         	str	r0, [sp, #0x18]
;         temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 805eeb6: 9808         	ldr	r0, [sp, #0x20]
 805eeb8: f000 0003    	and	r0, r0, #0x3
 805eebc: 00c1         	lsls	r1, r0, #0x3
 805eebe: 200f         	movs	r0, #0xf
 805eec0: fa00 f101    	lsl.w	r1, r0, r1
 805eec4: 9806         	ldr	r0, [sp, #0x18]
 805eec6: 4388         	bics	r0, r1
 805eec8: 9006         	str	r0, [sp, #0x18]
;         temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 805eeca: 980a         	ldr	r0, [sp, #0x28]
 805eecc: 2100         	movs	r1, #0x0
 805eece: f2c4 2102    	movt	r1, #0x4202
 805eed2: 4288         	cmp	r0, r1
 805eed4: d103         	bne	0x805eede <HAL_GPIO_Init+0x1c2> @ imm = #0x6
 805eed6: e7ff         	b	0x805eed8 <HAL_GPIO_Init+0x1bc> @ imm = #-0x2
 805eed8: 2000         	movs	r0, #0x0
;         temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 805eeda: 9005         	str	r0, [sp, #0x14]
 805eedc: e050         	b	0x805ef80 <HAL_GPIO_Init+0x264> @ imm = #0xa0
 805eede: 980a         	ldr	r0, [sp, #0x28]
 805eee0: f240 4100    	movw	r1, #0x400
 805eee4: f2c4 2102    	movt	r1, #0x4202
 805eee8: 4288         	cmp	r0, r1
 805eeea: d103         	bne	0x805eef4 <HAL_GPIO_Init+0x1d8> @ imm = #0x6
 805eeec: e7ff         	b	0x805eeee <HAL_GPIO_Init+0x1d2> @ imm = #-0x2
 805eeee: 2001         	movs	r0, #0x1
;         temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 805eef0: 9004         	str	r0, [sp, #0x10]
 805eef2: e042         	b	0x805ef7a <HAL_GPIO_Init+0x25e> @ imm = #0x84
 805eef4: 980a         	ldr	r0, [sp, #0x28]
 805eef6: f640 0100    	movw	r1, #0x800
 805eefa: f2c4 2102    	movt	r1, #0x4202
 805eefe: 4288         	cmp	r0, r1
 805ef00: d103         	bne	0x805ef0a <HAL_GPIO_Init+0x1ee> @ imm = #0x6
 805ef02: e7ff         	b	0x805ef04 <HAL_GPIO_Init+0x1e8> @ imm = #-0x2
 805ef04: 2002         	movs	r0, #0x2
;         temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 805ef06: 9003         	str	r0, [sp, #0xc]
 805ef08: e034         	b	0x805ef74 <HAL_GPIO_Init+0x258> @ imm = #0x68
 805ef0a: 980a         	ldr	r0, [sp, #0x28]
 805ef0c: f640 4100    	movw	r1, #0xc00
 805ef10: f2c4 2102    	movt	r1, #0x4202
 805ef14: 4288         	cmp	r0, r1
 805ef16: d103         	bne	0x805ef20 <HAL_GPIO_Init+0x204> @ imm = #0x6
 805ef18: e7ff         	b	0x805ef1a <HAL_GPIO_Init+0x1fe> @ imm = #-0x2
 805ef1a: 2003         	movs	r0, #0x3
;         temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 805ef1c: 9002         	str	r0, [sp, #0x8]
 805ef1e: e026         	b	0x805ef6e <HAL_GPIO_Init+0x252> @ imm = #0x4c
 805ef20: 980a         	ldr	r0, [sp, #0x28]
 805ef22: f241 0100    	movw	r1, #0x1000
 805ef26: f2c4 2102    	movt	r1, #0x4202
 805ef2a: 4288         	cmp	r0, r1
 805ef2c: d103         	bne	0x805ef36 <HAL_GPIO_Init+0x21a> @ imm = #0x6
 805ef2e: e7ff         	b	0x805ef30 <HAL_GPIO_Init+0x214> @ imm = #-0x2
 805ef30: 2004         	movs	r0, #0x4
;         temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 805ef32: 9001         	str	r0, [sp, #0x4]
 805ef34: e018         	b	0x805ef68 <HAL_GPIO_Init+0x24c> @ imm = #0x30
 805ef36: 980a         	ldr	r0, [sp, #0x28]
 805ef38: f241 4100    	movw	r1, #0x1400
 805ef3c: f2c4 2102    	movt	r1, #0x4202
 805ef40: 4288         	cmp	r0, r1
 805ef42: d103         	bne	0x805ef4c <HAL_GPIO_Init+0x230> @ imm = #0x6
 805ef44: e7ff         	b	0x805ef46 <HAL_GPIO_Init+0x22a> @ imm = #-0x2
 805ef46: 2005         	movs	r0, #0x5
;         temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 805ef48: 9000         	str	r0, [sp]
 805ef4a: e00a         	b	0x805ef62 <HAL_GPIO_Init+0x246> @ imm = #0x14
 805ef4c: 990a         	ldr	r1, [sp, #0x28]
 805ef4e: f641 0200    	movw	r2, #0x1800
 805ef52: f2c4 2202    	movt	r2, #0x4202
 805ef56: 2007         	movs	r0, #0x7
 805ef58: 4291         	cmp	r1, r2
 805ef5a: bf08         	it	eq
 805ef5c: 2006         	moveq	r0, #0x6
 805ef5e: 9000         	str	r0, [sp]
 805ef60: e7ff         	b	0x805ef62 <HAL_GPIO_Init+0x246> @ imm = #-0x2
 805ef62: 9800         	ldr	r0, [sp]
 805ef64: 9001         	str	r0, [sp, #0x4]
 805ef66: e7ff         	b	0x805ef68 <HAL_GPIO_Init+0x24c> @ imm = #-0x2
 805ef68: 9801         	ldr	r0, [sp, #0x4]
 805ef6a: 9002         	str	r0, [sp, #0x8]
 805ef6c: e7ff         	b	0x805ef6e <HAL_GPIO_Init+0x252> @ imm = #-0x2
 805ef6e: 9802         	ldr	r0, [sp, #0x8]
 805ef70: 9003         	str	r0, [sp, #0xc]
 805ef72: e7ff         	b	0x805ef74 <HAL_GPIO_Init+0x258> @ imm = #-0x2
 805ef74: 9803         	ldr	r0, [sp, #0xc]
 805ef76: 9004         	str	r0, [sp, #0x10]
 805ef78: e7ff         	b	0x805ef7a <HAL_GPIO_Init+0x25e> @ imm = #-0x2
 805ef7a: 9804         	ldr	r0, [sp, #0x10]
 805ef7c: 9005         	str	r0, [sp, #0x14]
 805ef7e: e7ff         	b	0x805ef80 <HAL_GPIO_Init+0x264> @ imm = #-0x2
 805ef80: 9805         	ldr	r0, [sp, #0x14]
 805ef82: 9908         	ldr	r1, [sp, #0x20]
 805ef84: f001 0103    	and	r1, r1, #0x3
 805ef88: 00c9         	lsls	r1, r1, #0x3
 805ef8a: fa00 f101    	lsl.w	r1, r0, r1
 805ef8e: 9806         	ldr	r0, [sp, #0x18]
 805ef90: 4308         	orrs	r0, r1
 805ef92: 9006         	str	r0, [sp, #0x18]
;         EXTI->EXTICR[position >> 2U] = temp;
 805ef94: 9806         	ldr	r0, [sp, #0x18]
 805ef96: 9908         	ldr	r1, [sp, #0x20]
 805ef98: f021 0103    	bic	r1, r1, #0x3
 805ef9c: f24f 4260    	movw	r2, #0xf460
 805efa0: f2c4 0202    	movt	r2, #0x4002
 805efa4: 5088         	str	r0, [r1, r2]
 805efa6: f24f 4080    	movw	r0, #0xf480
 805efaa: f2c4 0002    	movt	r0, #0x4002
;         temp = EXTI->IMR1;
 805efae: 6800         	ldr	r0, [r0]
 805efb0: 9006         	str	r0, [sp, #0x18]
;         temp &= ~(iocurrent);
 805efb2: 9907         	ldr	r1, [sp, #0x1c]
 805efb4: 9806         	ldr	r0, [sp, #0x18]
 805efb6: 4388         	bics	r0, r1
 805efb8: 9006         	str	r0, [sp, #0x18]
;         if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT) {
 805efba: 9809         	ldr	r0, [sp, #0x24]
 805efbc: 7980         	ldrb	r0, [r0, #0x6]
 805efbe: 07c0         	lsls	r0, r0, #0x1f
 805efc0: b128         	cbz	r0, 0x805efce <HAL_GPIO_Init+0x2b2> @ imm = #0xa
 805efc2: e7ff         	b	0x805efc4 <HAL_GPIO_Init+0x2a8> @ imm = #-0x2
;           temp |= iocurrent;
 805efc4: 9907         	ldr	r1, [sp, #0x1c]
 805efc6: 9806         	ldr	r0, [sp, #0x18]
 805efc8: 4308         	orrs	r0, r1
 805efca: 9006         	str	r0, [sp, #0x18]
;         }
 805efcc: e7ff         	b	0x805efce <HAL_GPIO_Init+0x2b2> @ imm = #-0x2
;         EXTI->IMR1 = temp;
 805efce: 9806         	ldr	r0, [sp, #0x18]
 805efd0: f24f 4180    	movw	r1, #0xf480
 805efd4: f2c4 0102    	movt	r1, #0x4002
 805efd8: 6008         	str	r0, [r1]
 805efda: f24f 4084    	movw	r0, #0xf484
 805efde: f2c4 0002    	movt	r0, #0x4002
;         temp = EXTI->EMR1;
 805efe2: 6800         	ldr	r0, [r0]
 805efe4: 9006         	str	r0, [sp, #0x18]
;         temp &= ~(iocurrent);
 805efe6: 9907         	ldr	r1, [sp, #0x1c]
 805efe8: 9806         	ldr	r0, [sp, #0x18]
 805efea: 4388         	bics	r0, r1
 805efec: 9006         	str	r0, [sp, #0x18]
;         if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT) {
 805efee: 9809         	ldr	r0, [sp, #0x24]
 805eff0: 7980         	ldrb	r0, [r0, #0x6]
 805eff2: 0780         	lsls	r0, r0, #0x1e
 805eff4: 2800         	cmp	r0, #0x0
 805eff6: d505         	bpl	0x805f004 <HAL_GPIO_Init+0x2e8> @ imm = #0xa
 805eff8: e7ff         	b	0x805effa <HAL_GPIO_Init+0x2de> @ imm = #-0x2
;           temp |= iocurrent;
 805effa: 9907         	ldr	r1, [sp, #0x1c]
 805effc: 9806         	ldr	r0, [sp, #0x18]
 805effe: 4308         	orrs	r0, r1
 805f000: 9006         	str	r0, [sp, #0x18]
;         }
 805f002: e7ff         	b	0x805f004 <HAL_GPIO_Init+0x2e8> @ imm = #-0x2
;         EXTI->EMR1 = temp;
 805f004: 9806         	ldr	r0, [sp, #0x18]
 805f006: f24f 4184    	movw	r1, #0xf484
 805f00a: f2c4 0102    	movt	r1, #0x4002
 805f00e: 6008         	str	r0, [r1]
 805f010: f24f 4000    	movw	r0, #0xf400
 805f014: f2c4 0002    	movt	r0, #0x4002
;         temp = EXTI->RTSR1;
 805f018: 6800         	ldr	r0, [r0]
 805f01a: 9006         	str	r0, [sp, #0x18]
;         temp &= ~(iocurrent);
 805f01c: 9907         	ldr	r1, [sp, #0x1c]
 805f01e: 9806         	ldr	r0, [sp, #0x18]
 805f020: 4388         	bics	r0, r1
 805f022: 9006         	str	r0, [sp, #0x18]
;         if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE) {
 805f024: 9809         	ldr	r0, [sp, #0x24]
 805f026: 7980         	ldrb	r0, [r0, #0x6]
 805f028: 06c0         	lsls	r0, r0, #0x1b
 805f02a: 2800         	cmp	r0, #0x0
 805f02c: d505         	bpl	0x805f03a <HAL_GPIO_Init+0x31e> @ imm = #0xa
 805f02e: e7ff         	b	0x805f030 <HAL_GPIO_Init+0x314> @ imm = #-0x2
;           temp |= iocurrent;
 805f030: 9907         	ldr	r1, [sp, #0x1c]
 805f032: 9806         	ldr	r0, [sp, #0x18]
 805f034: 4308         	orrs	r0, r1
 805f036: 9006         	str	r0, [sp, #0x18]
;         }
 805f038: e7ff         	b	0x805f03a <HAL_GPIO_Init+0x31e> @ imm = #-0x2
;         EXTI->RTSR1 = temp;
 805f03a: 9806         	ldr	r0, [sp, #0x18]
 805f03c: f24f 4100    	movw	r1, #0xf400
 805f040: f2c4 0102    	movt	r1, #0x4002
 805f044: 6008         	str	r0, [r1]
 805f046: f24f 4004    	movw	r0, #0xf404
 805f04a: f2c4 0002    	movt	r0, #0x4002
;         temp = EXTI->FTSR1;
 805f04e: 6800         	ldr	r0, [r0]
 805f050: 9006         	str	r0, [sp, #0x18]
;         temp &= ~(iocurrent);
 805f052: 9907         	ldr	r1, [sp, #0x1c]
 805f054: 9806         	ldr	r0, [sp, #0x18]
 805f056: 4388         	bics	r0, r1
 805f058: 9006         	str	r0, [sp, #0x18]
;         if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE) {
 805f05a: 9809         	ldr	r0, [sp, #0x24]
 805f05c: 7980         	ldrb	r0, [r0, #0x6]
 805f05e: 0680         	lsls	r0, r0, #0x1a
 805f060: 2800         	cmp	r0, #0x0
 805f062: d505         	bpl	0x805f070 <HAL_GPIO_Init+0x354> @ imm = #0xa
 805f064: e7ff         	b	0x805f066 <HAL_GPIO_Init+0x34a> @ imm = #-0x2
;           temp |= iocurrent;
 805f066: 9907         	ldr	r1, [sp, #0x1c]
 805f068: 9806         	ldr	r0, [sp, #0x18]
 805f06a: 4308         	orrs	r0, r1
 805f06c: 9006         	str	r0, [sp, #0x18]
;         }
 805f06e: e7ff         	b	0x805f070 <HAL_GPIO_Init+0x354> @ imm = #-0x2
;         EXTI->FTSR1 = temp;
 805f070: 9806         	ldr	r0, [sp, #0x18]
 805f072: f24f 4104    	movw	r1, #0xf404
 805f076: f2c4 0102    	movt	r1, #0x4002
 805f07a: 6008         	str	r0, [r1]
;       }
 805f07c: e7ff         	b	0x805f07e <HAL_GPIO_Init+0x362> @ imm = #-0x2
;     }
 805f07e: e7ff         	b	0x805f080 <HAL_GPIO_Init+0x364> @ imm = #-0x2
;     position++;
 805f080: 9808         	ldr	r0, [sp, #0x20]
 805f082: 3001         	adds	r0, #0x1
 805f084: 9008         	str	r0, [sp, #0x20]
;   while (((GPIO_Init->Pin) >> position) != 0U) {
 805f086: e64f         	b	0x805ed28 <HAL_GPIO_Init+0xc> @ imm = #-0x362
; }
 805f088: b00b         	add	sp, #0x2c
 805f08a: 4770         	bx	lr

0805f08c <HAL_GPIO_WritePin>:
;                        GPIO_PinState PinState) {
 805f08c: b082         	sub	sp, #0x8
 805f08e: 9001         	str	r0, [sp, #0x4]
 805f090: f8ad 1002    	strh.w	r1, [sp, #0x2]
 805f094: f88d 2001    	strb.w	r2, [sp, #0x1]
;   if (PinState != GPIO_PIN_RESET) {
 805f098: f89d 0001    	ldrb.w	r0, [sp, #0x1]
 805f09c: b128         	cbz	r0, 0x805f0aa <HAL_GPIO_WritePin+0x1e> @ imm = #0xa
 805f09e: e7ff         	b	0x805f0a0 <HAL_GPIO_WritePin+0x14> @ imm = #-0x2
;     GPIOx->BSRR = (uint32_t)GPIO_Pin;
 805f0a0: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
 805f0a4: 9901         	ldr	r1, [sp, #0x4]
 805f0a6: 6188         	str	r0, [r1, #0x18]
;   } else {
 805f0a8: e004         	b	0x805f0b4 <HAL_GPIO_WritePin+0x28> @ imm = #0x8
;     GPIOx->BRR = (uint32_t)GPIO_Pin;
 805f0aa: f8bd 0002    	ldrh.w	r0, [sp, #0x2]
 805f0ae: 9901         	ldr	r1, [sp, #0x4]
 805f0b0: 6288         	str	r0, [r1, #0x28]
 805f0b2: e7ff         	b	0x805f0b4 <HAL_GPIO_WritePin+0x28> @ imm = #-0x2
; }
 805f0b4: b002         	add	sp, #0x8
 805f0b6: 4770         	bx	lr

0805f0b8 <HAL_GPIO_TogglePin>:
; void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin) {
 805f0b8: b083         	sub	sp, #0xc
 805f0ba: 9002         	str	r0, [sp, #0x8]
 805f0bc: f8ad 1006    	strh.w	r1, [sp, #0x6]
;   odr = GPIOx->ODR;
 805f0c0: 9802         	ldr	r0, [sp, #0x8]
 805f0c2: 6940         	ldr	r0, [r0, #0x14]
 805f0c4: 9000         	str	r0, [sp]
;   GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 805f0c6: 9a00         	ldr	r2, [sp]
 805f0c8: f8bd 0006    	ldrh.w	r0, [sp, #0x6]
 805f0cc: ea02 0100    	and.w	r1, r2, r0
 805f0d0: 4390         	bics	r0, r2
 805f0d2: ea40 4001    	orr.w	r0, r0, r1, lsl #16
 805f0d6: 9902         	ldr	r1, [sp, #0x8]
 805f0d8: 6188         	str	r0, [r1, #0x18]
; }
 805f0da: b003         	add	sp, #0xc
 805f0dc: 4770         	bx	lr
 805f0de: 0000         	movs	r0, r0

0805f0e0 <HAL_NVIC_SetPriorityGrouping>:
; {
 805f0e0: f848 eb74    	str	lr, [r8], #116
 805f0e4: eb08 0809    	add.w	r8, r8, r9
 805f0e8: b480         	push	{r7}
 805f0ea: 466f         	mov	r7, sp
 805f0ec: b082         	sub	sp, #0x8
 805f0ee: 9001         	str	r0, [sp, #0x4]
;   NVIC_SetPriorityGrouping(PriorityGroup);
 805f0f0: 9801         	ldr	r0, [sp, #0x4]
 805f0f2: 4904         	ldr	r1, [pc, #0x10]         @ 0x805f104 <HAL_NVIC_SetPriorityGrouping+0x24>
 805f0f4: 4788         	blx	r1
; }
 805f0f6: b002         	add	sp, #0x8
 805f0f8: bc80         	pop	{r7}
 805f0fa: eba8 0809    	sub.w	r8, r8, r9
 805f0fe: f858 fd74    	ldr	pc, [r8, #-116]!
 805f102: bf00         	nop

0805f104 <$d.1>:
 805f104: 09 f1 05 08  	.word	0x0805f109

0805f108 <__NVIC_SetPriorityGrouping>:
; {
 805f108: b083         	sub	sp, #0xc
 805f10a: 9002         	str	r0, [sp, #0x8]
;   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 805f10c: 9802         	ldr	r0, [sp, #0x8]
 805f10e: f000 0007    	and	r0, r0, #0x7
 805f112: 9000         	str	r0, [sp]
 805f114: f64e 510c    	movw	r1, #0xed0c
 805f118: f2ce 0100    	movt	r1, #0xe000
;   reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 805f11c: 6808         	ldr	r0, [r1]
 805f11e: 9001         	str	r0, [sp, #0x4]
;   reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 805f120: 9801         	ldr	r0, [sp, #0x4]
 805f122: f64f 02ff    	movw	r2, #0xf8ff
 805f126: 4010         	ands	r0, r2
 805f128: 9001         	str	r0, [sp, #0x4]
;   reg_value  =  (reg_value                                   |
 805f12a: 9801         	ldr	r0, [sp, #0x4]
;                 (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 805f12c: 9a00         	ldr	r2, [sp]
;   reg_value  =  (reg_value                                   |
 805f12e: ea40 2002    	orr.w	r0, r0, r2, lsl #8
 805f132: 2200         	movs	r2, #0x0
 805f134: f2c0 52fa    	movt	r2, #0x5fa
;                 ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 805f138: 4310         	orrs	r0, r2
;   reg_value  =  (reg_value                                   |
 805f13a: 9001         	str	r0, [sp, #0x4]
;   SCB->AIRCR =  reg_value;
 805f13c: 9801         	ldr	r0, [sp, #0x4]
 805f13e: 6008         	str	r0, [r1]
; }
 805f140: b003         	add	sp, #0xc
 805f142: 4770         	bx	lr

0805f144 <HAL_NVIC_SetPriority>:
; {
 805f144: f848 eb1c    	str	lr, [r8], #28
 805f148: eb08 0809    	add.w	r8, r8, r9
 805f14c: b480         	push	{r7}
 805f14e: 466f         	mov	r7, sp
 805f150: b086         	sub	sp, #0x18
 805f152: f807 0c01    	strb	r0, [r7, #-1]
 805f156: 9104         	str	r1, [sp, #0x10]
 805f158: 9203         	str	r2, [sp, #0xc]
;   prioritygroup = NVIC_GetPriorityGrouping();
 805f15a: 480a         	ldr	r0, [pc, #0x28]         @ 0x805f184 <HAL_NVIC_SetPriority+0x40>
 805f15c: 4780         	blx	r0
 805f15e: 9002         	str	r0, [sp, #0x8]
;   NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 805f160: f917 0c01    	ldrsb	r0, [r7, #-1]
 805f164: 9001         	str	r0, [sp, #0x4]
 805f166: 9802         	ldr	r0, [sp, #0x8]
 805f168: 9904         	ldr	r1, [sp, #0x10]
 805f16a: 9a03         	ldr	r2, [sp, #0xc]
 805f16c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x805f188 <HAL_NVIC_SetPriority+0x44>
 805f16e: 4798         	blx	r3
 805f170: 4601         	mov	r1, r0
 805f172: 9801         	ldr	r0, [sp, #0x4]
 805f174: 4a05         	ldr	r2, [pc, #0x14]         @ 0x805f18c <HAL_NVIC_SetPriority+0x48>
 805f176: 4790         	blx	r2
; }
 805f178: b006         	add	sp, #0x18
 805f17a: bc80         	pop	{r7}
 805f17c: eba8 0809    	sub.w	r8, r8, r9
 805f180: f858 fd1c    	ldr	pc, [r8, #-28]!

0805f184 <$d.4>:
 805f184: 91 f1 05 08  	.word	0x0805f191
 805f188: e3 f1 05 08  	.word	0x0805f1e3
 805f18c: a1 f1 05 08  	.word	0x0805f1a1

0805f190 <__NVIC_GetPriorityGrouping>:
; {
 805f190: f64e 500c    	movw	r0, #0xed0c
 805f194: f2ce 0000    	movt	r0, #0xe000
;   return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 805f198: 6800         	ldr	r0, [r0]
 805f19a: f3c0 2002    	ubfx	r0, r0, #0x8, #0x3
 805f19e: 4770         	bx	lr

0805f1a0 <__NVIC_SetPriority>:
; {
 805f1a0: b082         	sub	sp, #0x8
 805f1a2: f88d 0007    	strb.w	r0, [sp, #0x7]
 805f1a6: 9100         	str	r1, [sp]
;   if ((int32_t)(IRQn) >= 0)
 805f1a8: f99d 0007    	ldrsb.w	r0, [sp, #0x7]
 805f1ac: 2800         	cmp	r0, #0x0
 805f1ae: d40a         	bmi	0x805f1c6 <__NVIC_SetPriority+0x26> @ imm = #0x14
 805f1b0: e7ff         	b	0x805f1b2 <__NVIC_SetPriority+0x12> @ imm = #-0x2
;     NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 805f1b2: 9800         	ldr	r0, [sp]
 805f1b4: 0140         	lsls	r0, r0, #0x5
 805f1b6: f99d 1007    	ldrsb.w	r1, [sp, #0x7]
 805f1ba: f24e 4200    	movw	r2, #0xe400
 805f1be: f2ce 0200    	movt	r2, #0xe000
 805f1c2: 5488         	strb	r0, [r1, r2]
;   }
 805f1c4: e00b         	b	0x805f1de <__NVIC_SetPriority+0x3e> @ imm = #0x16
;     SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 805f1c6: 9800         	ldr	r0, [sp]
 805f1c8: 0140         	lsls	r0, r0, #0x5
 805f1ca: f89d 1007    	ldrb.w	r1, [sp, #0x7]
 805f1ce: f001 010f    	and	r1, r1, #0xf
 805f1d2: f64e 5214    	movw	r2, #0xed14
 805f1d6: f2ce 0200    	movt	r2, #0xe000
 805f1da: 5488         	strb	r0, [r1, r2]
 805f1dc: e7ff         	b	0x805f1de <__NVIC_SetPriority+0x3e> @ imm = #-0x2
; }
 805f1de: b002         	add	sp, #0x8
 805f1e0: 4770         	bx	lr

0805f1e2 <NVIC_EncodePriority>:
; {
 805f1e2: b088         	sub	sp, #0x20
 805f1e4: 9007         	str	r0, [sp, #0x1c]
 805f1e6: 9106         	str	r1, [sp, #0x18]
 805f1e8: 9205         	str	r2, [sp, #0x14]
;   uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 805f1ea: 9807         	ldr	r0, [sp, #0x1c]
 805f1ec: f000 0007    	and	r0, r0, #0x7
 805f1f0: 9004         	str	r0, [sp, #0x10]
;   PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 805f1f2: 9804         	ldr	r0, [sp, #0x10]
 805f1f4: f1c0 0007    	rsb.w	r0, r0, #0x7
 805f1f8: 2804         	cmp	r0, #0x4
 805f1fa: d303         	blo	0x805f204 <NVIC_EncodePriority+0x22> @ imm = #0x6
 805f1fc: e7ff         	b	0x805f1fe <NVIC_EncodePriority+0x1c> @ imm = #-0x2
 805f1fe: 2003         	movs	r0, #0x3
;   PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 805f200: 9001         	str	r0, [sp, #0x4]
 805f202: e004         	b	0x805f20e <NVIC_EncodePriority+0x2c> @ imm = #0x8
 805f204: 9804         	ldr	r0, [sp, #0x10]
 805f206: f1c0 0007    	rsb.w	r0, r0, #0x7
 805f20a: 9001         	str	r0, [sp, #0x4]
 805f20c: e7ff         	b	0x805f20e <NVIC_EncodePriority+0x2c> @ imm = #-0x2
 805f20e: 9801         	ldr	r0, [sp, #0x4]
 805f210: 9003         	str	r0, [sp, #0xc]
;   SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 805f212: 9804         	ldr	r0, [sp, #0x10]
 805f214: 3003         	adds	r0, #0x3
 805f216: 2806         	cmp	r0, #0x6
 805f218: d803         	bhi	0x805f222 <NVIC_EncodePriority+0x40> @ imm = #0x6
 805f21a: e7ff         	b	0x805f21c <NVIC_EncodePriority+0x3a> @ imm = #-0x2
 805f21c: 2000         	movs	r0, #0x0
;   SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 805f21e: 9000         	str	r0, [sp]
 805f220: e003         	b	0x805f22a <NVIC_EncodePriority+0x48> @ imm = #0x6
 805f222: 9804         	ldr	r0, [sp, #0x10]
 805f224: 3804         	subs	r0, #0x4
 805f226: 9000         	str	r0, [sp]
 805f228: e7ff         	b	0x805f22a <NVIC_EncodePriority+0x48> @ imm = #-0x2
 805f22a: 9800         	ldr	r0, [sp]
 805f22c: 9002         	str	r0, [sp, #0x8]
;            ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 805f22e: 9806         	ldr	r0, [sp, #0x18]
 805f230: 9903         	ldr	r1, [sp, #0xc]
 805f232: 2201         	movs	r2, #0x1
 805f234: fa02 f101    	lsl.w	r1, r2, r1
 805f238: 3901         	subs	r1, #0x1
 805f23a: 4008         	ands	r0, r1
 805f23c: 9b02         	ldr	r3, [sp, #0x8]
 805f23e: 4098         	lsls	r0, r3
;            ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 805f240: 9905         	ldr	r1, [sp, #0x14]
 805f242: 409a         	lsls	r2, r3
 805f244: 3a01         	subs	r2, #0x1
 805f246: 4011         	ands	r1, r2
;            ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 805f248: 4308         	orrs	r0, r1
;   return (
 805f24a: b008         	add	sp, #0x20
 805f24c: 4770         	bx	lr
 805f24e: 0000         	movs	r0, r0

0805f250 <HAL_SYSTICK_Config>:
; {
 805f250: f848 eb48    	str	lr, [r8], #72
 805f254: eb08 0809    	add.w	r8, r8, r9
 805f258: b480         	push	{r7}
 805f25a: 466f         	mov	r7, sp
 805f25c: b082         	sub	sp, #0x8
 805f25e: 9001         	str	r0, [sp, #0x4]
;   return SysTick_Config(TicksNumb);
 805f260: 9801         	ldr	r0, [sp, #0x4]
 805f262: 4904         	ldr	r1, [pc, #0x10]         @ 0x805f274 <HAL_SYSTICK_Config+0x24>
 805f264: 4788         	blx	r1
 805f266: b002         	add	sp, #0x8
 805f268: bc80         	pop	{r7}
 805f26a: eba8 0809    	sub.w	r8, r8, r9
 805f26e: f858 fd48    	ldr	pc, [r8, #-72]!
 805f272: bf00         	nop

0805f274 <$d.18>:
 805f274: 79 f2 05 08  	.word	0x0805f279

0805f278 <SysTick_Config>:
; {
 805f278: f848 eb38    	str	lr, [r8], #56
 805f27c: eb08 0809    	add.w	r8, r8, r9
 805f280: b480         	push	{r7}
 805f282: 466f         	mov	r7, sp
 805f284: b084         	sub	sp, #0x10
 805f286: 9002         	str	r0, [sp, #0x8]
;   if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 805f288: 9802         	ldr	r0, [sp, #0x8]
 805f28a: 3801         	subs	r0, #0x1
 805f28c: f1b0 7f80    	cmp.w	r0, #0x1000000
 805f290: d303         	blo	0x805f29a <SysTick_Config+0x22> @ imm = #0x6
 805f292: e7ff         	b	0x805f294 <SysTick_Config+0x1c> @ imm = #-0x2
 805f294: 2001         	movs	r0, #0x1
;     return (1UL);                                                   /* Reload value impossible */
 805f296: 9003         	str	r0, [sp, #0xc]
 805f298: e01a         	b	0x805f2d0 <SysTick_Config+0x58> @ imm = #0x34
;   SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 805f29a: 9802         	ldr	r0, [sp, #0x8]
 805f29c: 3801         	subs	r0, #0x1
 805f29e: f24e 0114    	movw	r1, #0xe014
 805f2a2: f2ce 0100    	movt	r1, #0xe000
 805f2a6: 6008         	str	r0, [r1]
;   NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 805f2a8: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x805f2e0 <SysTick_Config+0x68>
 805f2aa: f04f 30ff    	mov.w	r0, #0xffffffff
 805f2ae: 2107         	movs	r1, #0x7
 805f2b0: 9101         	str	r1, [sp, #0x4]
 805f2b2: 4790         	blx	r2
 805f2b4: 9901         	ldr	r1, [sp, #0x4]
 805f2b6: f24e 0218    	movw	r2, #0xe018
 805f2ba: f2ce 0200    	movt	r2, #0xe000
 805f2be: 2000         	movs	r0, #0x0
;   SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 805f2c0: 6010         	str	r0, [r2]
 805f2c2: f24e 0210    	movw	r2, #0xe010
 805f2c6: f2ce 0200    	movt	r2, #0xe000
;   SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 805f2ca: 6011         	str	r1, [r2]
;   return (0UL);                                                     /* Function successful */
 805f2cc: 9003         	str	r0, [sp, #0xc]
 805f2ce: e7ff         	b	0x805f2d0 <SysTick_Config+0x58> @ imm = #-0x2
; }
 805f2d0: 9803         	ldr	r0, [sp, #0xc]
 805f2d2: b004         	add	sp, #0x10
 805f2d4: bc80         	pop	{r7}
 805f2d6: eba8 0809    	sub.w	r8, r8, r9
 805f2da: f858 fd38    	ldr	pc, [r8, #-56]!
 805f2de: bf00         	nop

0805f2e0 <$d.20>:
 805f2e0: a1 f1 05 08  	.word	0x0805f1a1

0805f2e4 <NMI_Handler>:
; DEFAULT_IRQ_HANDLER(NMI_Handler)
 805f2e4: e7ff         	b	0x805f2e6 <NMI_Handler+0x2> @ imm = #-0x2
 805f2e6: e7fe         	b	0x805f2e6 <NMI_Handler+0x2> @ imm = #-0x4

0805f2e8 <HardFault_Handler>:
; DEFAULT_IRQ_HANDLER(HardFault_Handler)
 805f2e8: e7ff         	b	0x805f2ea <HardFault_Handler+0x2> @ imm = #-0x2
 805f2ea: e7fe         	b	0x805f2ea <HardFault_Handler+0x2> @ imm = #-0x4

0805f2ec <MemManage_Handler>:
; DEFAULT_IRQ_HANDLER(MemManage_Handler)
 805f2ec: e7ff         	b	0x805f2ee <MemManage_Handler+0x2> @ imm = #-0x2
 805f2ee: e7fe         	b	0x805f2ee <MemManage_Handler+0x2> @ imm = #-0x4

0805f2f0 <BusFault_Handler>:
; DEFAULT_IRQ_HANDLER(BusFault_Handler)
 805f2f0: e7ff         	b	0x805f2f2 <BusFault_Handler+0x2> @ imm = #-0x2
 805f2f2: e7fe         	b	0x805f2f2 <BusFault_Handler+0x2> @ imm = #-0x4

0805f2f4 <UsageFault_Handler>:
; DEFAULT_IRQ_HANDLER(UsageFault_Handler)
 805f2f4: e7ff         	b	0x805f2f6 <UsageFault_Handler+0x2> @ imm = #-0x2
 805f2f6: e7fe         	b	0x805f2f6 <UsageFault_Handler+0x2> @ imm = #-0x4

0805f2f8 <SecureFault_Handler>:
; DEFAULT_IRQ_HANDLER(SecureFault_Handler)
 805f2f8: e7ff         	b	0x805f2fa <SecureFault_Handler+0x2> @ imm = #-0x2
 805f2fa: e7fe         	b	0x805f2fa <SecureFault_Handler+0x2> @ imm = #-0x4

0805f2fc <DebugMon_Handler>:
; DEFAULT_IRQ_HANDLER(DebugMon_Handler)
 805f2fc: e7ff         	b	0x805f2fe <DebugMon_Handler+0x2> @ imm = #-0x2
 805f2fe: e7fe         	b	0x805f2fe <DebugMon_Handler+0x2> @ imm = #-0x4

0805f300 <WWDG_IRQHandler>:
; DEFAULT_IRQ_HANDLER(WWDG_IRQHandler)
 805f300: e7ff         	b	0x805f302 <WWDG_IRQHandler+0x2> @ imm = #-0x2
 805f302: e7fe         	b	0x805f302 <WWDG_IRQHandler+0x2> @ imm = #-0x4

0805f304 <PVD_PVM_IRQHandler>:
; DEFAULT_IRQ_HANDLER(PVD_PVM_IRQHandler)
 805f304: e7ff         	b	0x805f306 <PVD_PVM_IRQHandler+0x2> @ imm = #-0x2
 805f306: e7fe         	b	0x805f306 <PVD_PVM_IRQHandler+0x2> @ imm = #-0x4

0805f308 <RTC_IRQHandler>:
; DEFAULT_IRQ_HANDLER(RTC_IRQHandler)
 805f308: e7ff         	b	0x805f30a <RTC_IRQHandler+0x2> @ imm = #-0x2
 805f30a: e7fe         	b	0x805f30a <RTC_IRQHandler+0x2> @ imm = #-0x4

0805f30c <RTC_IRQHandler_S>:
; DEFAULT_IRQ_HANDLER(RTC_IRQHandler_S)
 805f30c: e7ff         	b	0x805f30e <RTC_IRQHandler_S+0x2> @ imm = #-0x2
 805f30e: e7fe         	b	0x805f30e <RTC_IRQHandler_S+0x2> @ imm = #-0x4

0805f310 <TAMP_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TAMP_IRQHandler)
 805f310: e7ff         	b	0x805f312 <TAMP_IRQHandler+0x2> @ imm = #-0x2
 805f312: e7fe         	b	0x805f312 <TAMP_IRQHandler+0x2> @ imm = #-0x4

0805f314 <TAMP_IRQHandler_S>:
; DEFAULT_IRQ_HANDLER(TAMP_IRQHandler_S)
 805f314: e7ff         	b	0x805f316 <TAMP_IRQHandler_S+0x2> @ imm = #-0x2
 805f316: e7fe         	b	0x805f316 <TAMP_IRQHandler_S+0x2> @ imm = #-0x4

0805f318 <FLASH_IRQHandler>:
; DEFAULT_IRQ_HANDLER(FLASH_IRQHandler)
 805f318: e7ff         	b	0x805f31a <FLASH_IRQHandler+0x2> @ imm = #-0x2
 805f31a: e7fe         	b	0x805f31a <FLASH_IRQHandler+0x2> @ imm = #-0x4

0805f31c <FLASH_IRQHandler_S>:
; DEFAULT_IRQ_HANDLER(FLASH_IRQHandler_S)
 805f31c: e7ff         	b	0x805f31e <FLASH_IRQHandler_S+0x2> @ imm = #-0x2
 805f31e: e7fe         	b	0x805f31e <FLASH_IRQHandler_S+0x2> @ imm = #-0x4

0805f320 <SERR_IRQHandler>:
; DEFAULT_IRQ_HANDLER(SERR_IRQHandler)
 805f320: e7ff         	b	0x805f322 <SERR_IRQHandler+0x2> @ imm = #-0x2
 805f322: e7fe         	b	0x805f322 <SERR_IRQHandler+0x2> @ imm = #-0x4

0805f324 <RCC_IRQHandler>:
; DEFAULT_IRQ_HANDLER(RCC_IRQHandler)
 805f324: e7ff         	b	0x805f326 <RCC_IRQHandler+0x2> @ imm = #-0x2
 805f326: e7fe         	b	0x805f326 <RCC_IRQHandler+0x2> @ imm = #-0x4

0805f328 <RCC_IRQHandler_S>:
; DEFAULT_IRQ_HANDLER(RCC_IRQHandler_S)
 805f328: e7ff         	b	0x805f32a <RCC_IRQHandler_S+0x2> @ imm = #-0x2
 805f32a: e7fe         	b	0x805f32a <RCC_IRQHandler_S+0x2> @ imm = #-0x4

0805f32c <EXTI0_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI0_IRQHandler)
 805f32c: e7ff         	b	0x805f32e <EXTI0_IRQHandler+0x2> @ imm = #-0x2
 805f32e: e7fe         	b	0x805f32e <EXTI0_IRQHandler+0x2> @ imm = #-0x4

0805f330 <EXTI1_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI1_IRQHandler)
 805f330: e7ff         	b	0x805f332 <EXTI1_IRQHandler+0x2> @ imm = #-0x2
 805f332: e7fe         	b	0x805f332 <EXTI1_IRQHandler+0x2> @ imm = #-0x4

0805f334 <EXTI2_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI2_IRQHandler)
 805f334: e7ff         	b	0x805f336 <EXTI2_IRQHandler+0x2> @ imm = #-0x2
 805f336: e7fe         	b	0x805f336 <EXTI2_IRQHandler+0x2> @ imm = #-0x4

0805f338 <EXTI3_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI3_IRQHandler)
 805f338: e7ff         	b	0x805f33a <EXTI3_IRQHandler+0x2> @ imm = #-0x2
 805f33a: e7fe         	b	0x805f33a <EXTI3_IRQHandler+0x2> @ imm = #-0x4

0805f33c <EXTI4_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI4_IRQHandler)
 805f33c: e7ff         	b	0x805f33e <EXTI4_IRQHandler+0x2> @ imm = #-0x2
 805f33e: e7fe         	b	0x805f33e <EXTI4_IRQHandler+0x2> @ imm = #-0x4

0805f340 <EXTI5_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI5_IRQHandler)
 805f340: e7ff         	b	0x805f342 <EXTI5_IRQHandler+0x2> @ imm = #-0x2
 805f342: e7fe         	b	0x805f342 <EXTI5_IRQHandler+0x2> @ imm = #-0x4

0805f344 <EXTI6_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI6_IRQHandler)
 805f344: e7ff         	b	0x805f346 <EXTI6_IRQHandler+0x2> @ imm = #-0x2
 805f346: e7fe         	b	0x805f346 <EXTI6_IRQHandler+0x2> @ imm = #-0x4

0805f348 <EXTI7_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI7_IRQHandler)
 805f348: e7ff         	b	0x805f34a <EXTI7_IRQHandler+0x2> @ imm = #-0x2
 805f34a: e7fe         	b	0x805f34a <EXTI7_IRQHandler+0x2> @ imm = #-0x4

0805f34c <EXTI8_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI8_IRQHandler)
 805f34c: e7ff         	b	0x805f34e <EXTI8_IRQHandler+0x2> @ imm = #-0x2
 805f34e: e7fe         	b	0x805f34e <EXTI8_IRQHandler+0x2> @ imm = #-0x4

0805f350 <EXTI9_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI9_IRQHandler)
 805f350: e7ff         	b	0x805f352 <EXTI9_IRQHandler+0x2> @ imm = #-0x2
 805f352: e7fe         	b	0x805f352 <EXTI9_IRQHandler+0x2> @ imm = #-0x4

0805f354 <EXTI10_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI10_IRQHandler)
 805f354: e7ff         	b	0x805f356 <EXTI10_IRQHandler+0x2> @ imm = #-0x2
 805f356: e7fe         	b	0x805f356 <EXTI10_IRQHandler+0x2> @ imm = #-0x4

0805f358 <EXTI11_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI11_IRQHandler)
 805f358: e7ff         	b	0x805f35a <EXTI11_IRQHandler+0x2> @ imm = #-0x2
 805f35a: e7fe         	b	0x805f35a <EXTI11_IRQHandler+0x2> @ imm = #-0x4

0805f35c <EXTI12_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI12_IRQHandler)
 805f35c: e7ff         	b	0x805f35e <EXTI12_IRQHandler+0x2> @ imm = #-0x2
 805f35e: e7fe         	b	0x805f35e <EXTI12_IRQHandler+0x2> @ imm = #-0x4

0805f360 <EXTI13_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI13_IRQHandler)
 805f360: e7ff         	b	0x805f362 <EXTI13_IRQHandler+0x2> @ imm = #-0x2
 805f362: e7fe         	b	0x805f362 <EXTI13_IRQHandler+0x2> @ imm = #-0x4

0805f364 <EXTI14_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI14_IRQHandler)
 805f364: e7ff         	b	0x805f366 <EXTI14_IRQHandler+0x2> @ imm = #-0x2
 805f366: e7fe         	b	0x805f366 <EXTI14_IRQHandler+0x2> @ imm = #-0x4

0805f368 <EXTI15_IRQHandler>:
; DEFAULT_IRQ_HANDLER(EXTI15_IRQHandler)
 805f368: e7ff         	b	0x805f36a <EXTI15_IRQHandler+0x2> @ imm = #-0x2
 805f36a: e7fe         	b	0x805f36a <EXTI15_IRQHandler+0x2> @ imm = #-0x4

0805f36c <DMAMUX1_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMAMUX1_IRQHandler)
 805f36c: e7ff         	b	0x805f36e <DMAMUX1_IRQHandler+0x2> @ imm = #-0x2
 805f36e: e7fe         	b	0x805f36e <DMAMUX1_IRQHandler+0x2> @ imm = #-0x4

0805f370 <DMAMUX1_IRQHandler_S>:
; DEFAULT_IRQ_HANDLER(DMAMUX1_IRQHandler_S)
 805f370: e7ff         	b	0x805f372 <DMAMUX1_IRQHandler_S+0x2> @ imm = #-0x2
 805f372: e7fe         	b	0x805f372 <DMAMUX1_IRQHandler_S+0x2> @ imm = #-0x4

0805f374 <DMA1_Channel1_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA1_Channel1_IRQHandler)
 805f374: e7ff         	b	0x805f376 <DMA1_Channel1_IRQHandler+0x2> @ imm = #-0x2
 805f376: e7fe         	b	0x805f376 <DMA1_Channel1_IRQHandler+0x2> @ imm = #-0x4

0805f378 <DMA1_Channel2_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA1_Channel2_IRQHandler)
 805f378: e7ff         	b	0x805f37a <DMA1_Channel2_IRQHandler+0x2> @ imm = #-0x2
 805f37a: e7fe         	b	0x805f37a <DMA1_Channel2_IRQHandler+0x2> @ imm = #-0x4

0805f37c <DMA1_Channel3_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA1_Channel3_IRQHandler)
 805f37c: e7ff         	b	0x805f37e <DMA1_Channel3_IRQHandler+0x2> @ imm = #-0x2
 805f37e: e7fe         	b	0x805f37e <DMA1_Channel3_IRQHandler+0x2> @ imm = #-0x4

0805f380 <DMA1_Channel4_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA1_Channel4_IRQHandler)
 805f380: e7ff         	b	0x805f382 <DMA1_Channel4_IRQHandler+0x2> @ imm = #-0x2
 805f382: e7fe         	b	0x805f382 <DMA1_Channel4_IRQHandler+0x2> @ imm = #-0x4

0805f384 <DMA1_Channel5_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA1_Channel5_IRQHandler)
 805f384: e7ff         	b	0x805f386 <DMA1_Channel5_IRQHandler+0x2> @ imm = #-0x2
 805f386: e7fe         	b	0x805f386 <DMA1_Channel5_IRQHandler+0x2> @ imm = #-0x4

0805f388 <DMA1_Channel6_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA1_Channel6_IRQHandler)
 805f388: e7ff         	b	0x805f38a <DMA1_Channel6_IRQHandler+0x2> @ imm = #-0x2
 805f38a: e7fe         	b	0x805f38a <DMA1_Channel6_IRQHandler+0x2> @ imm = #-0x4

0805f38c <DMA1_Channel7_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA1_Channel7_IRQHandler)
 805f38c: e7ff         	b	0x805f38e <DMA1_Channel7_IRQHandler+0x2> @ imm = #-0x2
 805f38e: e7fe         	b	0x805f38e <DMA1_Channel7_IRQHandler+0x2> @ imm = #-0x4

0805f390 <DMA1_Channel8_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA1_Channel8_IRQHandler)
 805f390: e7ff         	b	0x805f392 <DMA1_Channel8_IRQHandler+0x2> @ imm = #-0x2
 805f392: e7fe         	b	0x805f392 <DMA1_Channel8_IRQHandler+0x2> @ imm = #-0x4

0805f394 <ADC1_2_IRQHandler>:
; DEFAULT_IRQ_HANDLER(ADC1_2_IRQHandler)
 805f394: e7ff         	b	0x805f396 <ADC1_2_IRQHandler+0x2> @ imm = #-0x2
 805f396: e7fe         	b	0x805f396 <ADC1_2_IRQHandler+0x2> @ imm = #-0x4

0805f398 <DAC_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DAC_IRQHandler)
 805f398: e7ff         	b	0x805f39a <DAC_IRQHandler+0x2> @ imm = #-0x2
 805f39a: e7fe         	b	0x805f39a <DAC_IRQHandler+0x2> @ imm = #-0x4

0805f39c <FDCAN1_IT0_IRQHandler>:
; DEFAULT_IRQ_HANDLER(FDCAN1_IT0_IRQHandler)
 805f39c: e7ff         	b	0x805f39e <FDCAN1_IT0_IRQHandler+0x2> @ imm = #-0x2
 805f39e: e7fe         	b	0x805f39e <FDCAN1_IT0_IRQHandler+0x2> @ imm = #-0x4

0805f3a0 <FDCAN1_IT1_IRQHandler>:
; DEFAULT_IRQ_HANDLER(FDCAN1_IT1_IRQHandler)
 805f3a0: e7ff         	b	0x805f3a2 <FDCAN1_IT1_IRQHandler+0x2> @ imm = #-0x2
 805f3a2: e7fe         	b	0x805f3a2 <FDCAN1_IT1_IRQHandler+0x2> @ imm = #-0x4

0805f3a4 <TIM1_BRK_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM1_BRK_IRQHandler)
 805f3a4: e7ff         	b	0x805f3a6 <TIM1_BRK_IRQHandler+0x2> @ imm = #-0x2
 805f3a6: e7fe         	b	0x805f3a6 <TIM1_BRK_IRQHandler+0x2> @ imm = #-0x4

0805f3a8 <TIM1_UP_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM1_UP_IRQHandler)
 805f3a8: e7ff         	b	0x805f3aa <TIM1_UP_IRQHandler+0x2> @ imm = #-0x2
 805f3aa: e7fe         	b	0x805f3aa <TIM1_UP_IRQHandler+0x2> @ imm = #-0x4

0805f3ac <TIM1_TRG_COM_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM1_TRG_COM_IRQHandler)
 805f3ac: e7ff         	b	0x805f3ae <TIM1_TRG_COM_IRQHandler+0x2> @ imm = #-0x2
 805f3ae: e7fe         	b	0x805f3ae <TIM1_TRG_COM_IRQHandler+0x2> @ imm = #-0x4

0805f3b0 <TIM1_CC_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM1_CC_IRQHandler)
 805f3b0: e7ff         	b	0x805f3b2 <TIM1_CC_IRQHandler+0x2> @ imm = #-0x2
 805f3b2: e7fe         	b	0x805f3b2 <TIM1_CC_IRQHandler+0x2> @ imm = #-0x4

0805f3b4 <TIM2_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM2_IRQHandler)
 805f3b4: e7ff         	b	0x805f3b6 <TIM2_IRQHandler+0x2> @ imm = #-0x2
 805f3b6: e7fe         	b	0x805f3b6 <TIM2_IRQHandler+0x2> @ imm = #-0x4

0805f3b8 <TIM3_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM3_IRQHandler)
 805f3b8: e7ff         	b	0x805f3ba <TIM3_IRQHandler+0x2> @ imm = #-0x2
 805f3ba: e7fe         	b	0x805f3ba <TIM3_IRQHandler+0x2> @ imm = #-0x4

0805f3bc <TIM4_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM4_IRQHandler)
 805f3bc: e7ff         	b	0x805f3be <TIM4_IRQHandler+0x2> @ imm = #-0x2
 805f3be: e7fe         	b	0x805f3be <TIM4_IRQHandler+0x2> @ imm = #-0x4

0805f3c0 <TIM5_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM5_IRQHandler)
 805f3c0: e7ff         	b	0x805f3c2 <TIM5_IRQHandler+0x2> @ imm = #-0x2
 805f3c2: e7fe         	b	0x805f3c2 <TIM5_IRQHandler+0x2> @ imm = #-0x4

0805f3c4 <TIM6_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM6_IRQHandler)
 805f3c4: e7ff         	b	0x805f3c6 <TIM6_IRQHandler+0x2> @ imm = #-0x2
 805f3c6: e7fe         	b	0x805f3c6 <TIM6_IRQHandler+0x2> @ imm = #-0x4

0805f3c8 <TIM7_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM7_IRQHandler)
 805f3c8: e7ff         	b	0x805f3ca <TIM7_IRQHandler+0x2> @ imm = #-0x2
 805f3ca: e7fe         	b	0x805f3ca <TIM7_IRQHandler+0x2> @ imm = #-0x4

0805f3cc <TIM8_BRK_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM8_BRK_IRQHandler)
 805f3cc: e7ff         	b	0x805f3ce <TIM8_BRK_IRQHandler+0x2> @ imm = #-0x2
 805f3ce: e7fe         	b	0x805f3ce <TIM8_BRK_IRQHandler+0x2> @ imm = #-0x4

0805f3d0 <TIM8_UP_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM8_UP_IRQHandler)
 805f3d0: e7ff         	b	0x805f3d2 <TIM8_UP_IRQHandler+0x2> @ imm = #-0x2
 805f3d2: e7fe         	b	0x805f3d2 <TIM8_UP_IRQHandler+0x2> @ imm = #-0x4

0805f3d4 <TIM8_TRG_COM_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM8_TRG_COM_IRQHandler)
 805f3d4: e7ff         	b	0x805f3d6 <TIM8_TRG_COM_IRQHandler+0x2> @ imm = #-0x2
 805f3d6: e7fe         	b	0x805f3d6 <TIM8_TRG_COM_IRQHandler+0x2> @ imm = #-0x4

0805f3d8 <TIM8_CC_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM8_CC_IRQHandler)
 805f3d8: e7ff         	b	0x805f3da <TIM8_CC_IRQHandler+0x2> @ imm = #-0x2
 805f3da: e7fe         	b	0x805f3da <TIM8_CC_IRQHandler+0x2> @ imm = #-0x4

0805f3dc <I2C1_EV_IRQHandler>:
; DEFAULT_IRQ_HANDLER(I2C1_EV_IRQHandler)
 805f3dc: e7ff         	b	0x805f3de <I2C1_EV_IRQHandler+0x2> @ imm = #-0x2
 805f3de: e7fe         	b	0x805f3de <I2C1_EV_IRQHandler+0x2> @ imm = #-0x4

0805f3e0 <I2C1_ER_IRQHandler>:
; DEFAULT_IRQ_HANDLER(I2C1_ER_IRQHandler)
 805f3e0: e7ff         	b	0x805f3e2 <I2C1_ER_IRQHandler+0x2> @ imm = #-0x2
 805f3e2: e7fe         	b	0x805f3e2 <I2C1_ER_IRQHandler+0x2> @ imm = #-0x4

0805f3e4 <I2C2_EV_IRQHandler>:
; DEFAULT_IRQ_HANDLER(I2C2_EV_IRQHandler)
 805f3e4: e7ff         	b	0x805f3e6 <I2C2_EV_IRQHandler+0x2> @ imm = #-0x2
 805f3e6: e7fe         	b	0x805f3e6 <I2C2_EV_IRQHandler+0x2> @ imm = #-0x4

0805f3e8 <I2C2_ER_IRQHandler>:
; DEFAULT_IRQ_HANDLER(I2C2_ER_IRQHandler)
 805f3e8: e7ff         	b	0x805f3ea <I2C2_ER_IRQHandler+0x2> @ imm = #-0x2
 805f3ea: e7fe         	b	0x805f3ea <I2C2_ER_IRQHandler+0x2> @ imm = #-0x4

0805f3ec <SPI1_IRQHandler>:
; DEFAULT_IRQ_HANDLER(SPI1_IRQHandler)
 805f3ec: e7ff         	b	0x805f3ee <SPI1_IRQHandler+0x2> @ imm = #-0x2
 805f3ee: e7fe         	b	0x805f3ee <SPI1_IRQHandler+0x2> @ imm = #-0x4

0805f3f0 <SPI2_IRQHandler>:
; DEFAULT_IRQ_HANDLER(SPI2_IRQHandler)
 805f3f0: e7ff         	b	0x805f3f2 <SPI2_IRQHandler+0x2> @ imm = #-0x2
 805f3f2: e7fe         	b	0x805f3f2 <SPI2_IRQHandler+0x2> @ imm = #-0x4

0805f3f4 <USART1_IRQHandler>:
; DEFAULT_IRQ_HANDLER(USART1_IRQHandler)
 805f3f4: e7ff         	b	0x805f3f6 <USART1_IRQHandler+0x2> @ imm = #-0x2
 805f3f6: e7fe         	b	0x805f3f6 <USART1_IRQHandler+0x2> @ imm = #-0x4

0805f3f8 <USART2_IRQHandler>:
; DEFAULT_IRQ_HANDLER(USART2_IRQHandler)
 805f3f8: e7ff         	b	0x805f3fa <USART2_IRQHandler+0x2> @ imm = #-0x2
 805f3fa: e7fe         	b	0x805f3fa <USART2_IRQHandler+0x2> @ imm = #-0x4

0805f3fc <USART3_IRQHandler>:
; DEFAULT_IRQ_HANDLER(USART3_IRQHandler)
 805f3fc: e7ff         	b	0x805f3fe <USART3_IRQHandler+0x2> @ imm = #-0x2
 805f3fe: e7fe         	b	0x805f3fe <USART3_IRQHandler+0x2> @ imm = #-0x4

0805f400 <UART4_IRQHandler>:
; DEFAULT_IRQ_HANDLER(UART4_IRQHandler)
 805f400: e7ff         	b	0x805f402 <UART4_IRQHandler+0x2> @ imm = #-0x2
 805f402: e7fe         	b	0x805f402 <UART4_IRQHandler+0x2> @ imm = #-0x4

0805f404 <UART5_IRQHandler>:
; DEFAULT_IRQ_HANDLER(UART5_IRQHandler)
 805f404: e7ff         	b	0x805f406 <UART5_IRQHandler+0x2> @ imm = #-0x2
 805f406: e7fe         	b	0x805f406 <UART5_IRQHandler+0x2> @ imm = #-0x4

0805f408 <LPUART1_IRQHandler>:
; DEFAULT_IRQ_HANDLER(LPUART1_IRQHandler)
 805f408: e7ff         	b	0x805f40a <LPUART1_IRQHandler+0x2> @ imm = #-0x2
 805f40a: e7fe         	b	0x805f40a <LPUART1_IRQHandler+0x2> @ imm = #-0x4

0805f40c <LPTIM1_IRQHandler>:
; DEFAULT_IRQ_HANDLER(LPTIM1_IRQHandler)
 805f40c: e7ff         	b	0x805f40e <LPTIM1_IRQHandler+0x2> @ imm = #-0x2
 805f40e: e7fe         	b	0x805f40e <LPTIM1_IRQHandler+0x2> @ imm = #-0x4

0805f410 <LPTIM2_IRQHandler>:
; DEFAULT_IRQ_HANDLER(LPTIM2_IRQHandler)
 805f410: e7ff         	b	0x805f412 <LPTIM2_IRQHandler+0x2> @ imm = #-0x2
 805f412: e7fe         	b	0x805f412 <LPTIM2_IRQHandler+0x2> @ imm = #-0x4

0805f414 <TIM15_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM15_IRQHandler)
 805f414: e7ff         	b	0x805f416 <TIM15_IRQHandler+0x2> @ imm = #-0x2
 805f416: e7fe         	b	0x805f416 <TIM15_IRQHandler+0x2> @ imm = #-0x4

0805f418 <TIM16_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM16_IRQHandler)
 805f418: e7ff         	b	0x805f41a <TIM16_IRQHandler+0x2> @ imm = #-0x2
 805f41a: e7fe         	b	0x805f41a <TIM16_IRQHandler+0x2> @ imm = #-0x4

0805f41c <TIM17_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TIM17_IRQHandler)
 805f41c: e7ff         	b	0x805f41e <TIM17_IRQHandler+0x2> @ imm = #-0x2
 805f41e: e7fe         	b	0x805f41e <TIM17_IRQHandler+0x2> @ imm = #-0x4

0805f420 <COMP_IRQHandler>:
; DEFAULT_IRQ_HANDLER(COMP_IRQHandler)
 805f420: e7ff         	b	0x805f422 <COMP_IRQHandler+0x2> @ imm = #-0x2
 805f422: e7fe         	b	0x805f422 <COMP_IRQHandler+0x2> @ imm = #-0x4

0805f424 <USB_FS_IRQHandler>:
; DEFAULT_IRQ_HANDLER(USB_FS_IRQHandler)
 805f424: e7ff         	b	0x805f426 <USB_FS_IRQHandler+0x2> @ imm = #-0x2
 805f426: e7fe         	b	0x805f426 <USB_FS_IRQHandler+0x2> @ imm = #-0x4

0805f428 <CRS_IRQHandler>:
; DEFAULT_IRQ_HANDLER(CRS_IRQHandler)
 805f428: e7ff         	b	0x805f42a <CRS_IRQHandler+0x2> @ imm = #-0x2
 805f42a: e7fe         	b	0x805f42a <CRS_IRQHandler+0x2> @ imm = #-0x4

0805f42c <FMC_IRQHandler>:
; DEFAULT_IRQ_HANDLER(FMC_IRQHandler)
 805f42c: e7ff         	b	0x805f42e <FMC_IRQHandler+0x2> @ imm = #-0x2
 805f42e: e7fe         	b	0x805f42e <FMC_IRQHandler+0x2> @ imm = #-0x4

0805f430 <OCTOSPI1_IRQHandler>:
; DEFAULT_IRQ_HANDLER(OCTOSPI1_IRQHandler)
 805f430: e7ff         	b	0x805f432 <OCTOSPI1_IRQHandler+0x2> @ imm = #-0x2
 805f432: e7fe         	b	0x805f432 <OCTOSPI1_IRQHandler+0x2> @ imm = #-0x4

0805f434 <SDMMC1_IRQHandler>:
; DEFAULT_IRQ_HANDLER(SDMMC1_IRQHandler)
 805f434: e7ff         	b	0x805f436 <SDMMC1_IRQHandler+0x2> @ imm = #-0x2
 805f436: e7fe         	b	0x805f436 <SDMMC1_IRQHandler+0x2> @ imm = #-0x4

0805f438 <DMA2_Channel1_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA2_Channel1_IRQHandler)
 805f438: e7ff         	b	0x805f43a <DMA2_Channel1_IRQHandler+0x2> @ imm = #-0x2
 805f43a: e7fe         	b	0x805f43a <DMA2_Channel1_IRQHandler+0x2> @ imm = #-0x4

0805f43c <DMA2_Channel2_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA2_Channel2_IRQHandler)
 805f43c: e7ff         	b	0x805f43e <DMA2_Channel2_IRQHandler+0x2> @ imm = #-0x2
 805f43e: e7fe         	b	0x805f43e <DMA2_Channel2_IRQHandler+0x2> @ imm = #-0x4

0805f440 <DMA2_Channel3_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA2_Channel3_IRQHandler)
 805f440: e7ff         	b	0x805f442 <DMA2_Channel3_IRQHandler+0x2> @ imm = #-0x2
 805f442: e7fe         	b	0x805f442 <DMA2_Channel3_IRQHandler+0x2> @ imm = #-0x4

0805f444 <DMA2_Channel4_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA2_Channel4_IRQHandler)
 805f444: e7ff         	b	0x805f446 <DMA2_Channel4_IRQHandler+0x2> @ imm = #-0x2
 805f446: e7fe         	b	0x805f446 <DMA2_Channel4_IRQHandler+0x2> @ imm = #-0x4

0805f448 <DMA2_Channel5_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA2_Channel5_IRQHandler)
 805f448: e7ff         	b	0x805f44a <DMA2_Channel5_IRQHandler+0x2> @ imm = #-0x2
 805f44a: e7fe         	b	0x805f44a <DMA2_Channel5_IRQHandler+0x2> @ imm = #-0x4

0805f44c <DMA2_Channel6_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA2_Channel6_IRQHandler)
 805f44c: e7ff         	b	0x805f44e <DMA2_Channel6_IRQHandler+0x2> @ imm = #-0x2
 805f44e: e7fe         	b	0x805f44e <DMA2_Channel6_IRQHandler+0x2> @ imm = #-0x4

0805f450 <DMA2_Channel7_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA2_Channel7_IRQHandler)
 805f450: e7ff         	b	0x805f452 <DMA2_Channel7_IRQHandler+0x2> @ imm = #-0x2
 805f452: e7fe         	b	0x805f452 <DMA2_Channel7_IRQHandler+0x2> @ imm = #-0x4

0805f454 <DMA2_Channel8_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DMA2_Channel8_IRQHandler)
 805f454: e7ff         	b	0x805f456 <DMA2_Channel8_IRQHandler+0x2> @ imm = #-0x2
 805f456: e7fe         	b	0x805f456 <DMA2_Channel8_IRQHandler+0x2> @ imm = #-0x4

0805f458 <I2C3_EV_IRQHandler>:
; DEFAULT_IRQ_HANDLER(I2C3_EV_IRQHandler)
 805f458: e7ff         	b	0x805f45a <I2C3_EV_IRQHandler+0x2> @ imm = #-0x2
 805f45a: e7fe         	b	0x805f45a <I2C3_EV_IRQHandler+0x2> @ imm = #-0x4

0805f45c <I2C3_ER_IRQHandler>:
; DEFAULT_IRQ_HANDLER(I2C3_ER_IRQHandler)
 805f45c: e7ff         	b	0x805f45e <I2C3_ER_IRQHandler+0x2> @ imm = #-0x2
 805f45e: e7fe         	b	0x805f45e <I2C3_ER_IRQHandler+0x2> @ imm = #-0x4

0805f460 <SAI1_IRQHandler>:
; DEFAULT_IRQ_HANDLER(SAI1_IRQHandler)
 805f460: e7ff         	b	0x805f462 <SAI1_IRQHandler+0x2> @ imm = #-0x2
 805f462: e7fe         	b	0x805f462 <SAI1_IRQHandler+0x2> @ imm = #-0x4

0805f464 <SAI2_IRQHandler>:
; DEFAULT_IRQ_HANDLER(SAI2_IRQHandler)
 805f464: e7ff         	b	0x805f466 <SAI2_IRQHandler+0x2> @ imm = #-0x2
 805f466: e7fe         	b	0x805f466 <SAI2_IRQHandler+0x2> @ imm = #-0x4

0805f468 <TSC_IRQHandler>:
; DEFAULT_IRQ_HANDLER(TSC_IRQHandler)
 805f468: e7ff         	b	0x805f46a <TSC_IRQHandler+0x2> @ imm = #-0x2
 805f46a: e7fe         	b	0x805f46a <TSC_IRQHandler+0x2> @ imm = #-0x4

0805f46c <AES_IRQHandler>:
; DEFAULT_IRQ_HANDLER(AES_IRQHandler)
 805f46c: e7ff         	b	0x805f46e <AES_IRQHandler+0x2> @ imm = #-0x2
 805f46e: e7fe         	b	0x805f46e <AES_IRQHandler+0x2> @ imm = #-0x4

0805f470 <RNG_IRQHandler>:
; DEFAULT_IRQ_HANDLER(RNG_IRQHandler)
 805f470: e7ff         	b	0x805f472 <RNG_IRQHandler+0x2> @ imm = #-0x2
 805f472: e7fe         	b	0x805f472 <RNG_IRQHandler+0x2> @ imm = #-0x4

0805f474 <FPU_IRQHandler>:
; DEFAULT_IRQ_HANDLER(FPU_IRQHandler)
 805f474: e7ff         	b	0x805f476 <FPU_IRQHandler+0x2> @ imm = #-0x2
 805f476: e7fe         	b	0x805f476 <FPU_IRQHandler+0x2> @ imm = #-0x4

0805f478 <HASH_IRQHandler>:
; DEFAULT_IRQ_HANDLER(HASH_IRQHandler)
 805f478: e7ff         	b	0x805f47a <HASH_IRQHandler+0x2> @ imm = #-0x2
 805f47a: e7fe         	b	0x805f47a <HASH_IRQHandler+0x2> @ imm = #-0x4

0805f47c <PKA_IRQHandler>:
; DEFAULT_IRQ_HANDLER(PKA_IRQHandler)
 805f47c: e7ff         	b	0x805f47e <PKA_IRQHandler+0x2> @ imm = #-0x2
 805f47e: e7fe         	b	0x805f47e <PKA_IRQHandler+0x2> @ imm = #-0x4

0805f480 <LPTIM3_IRQHandler>:
; DEFAULT_IRQ_HANDLER(LPTIM3_IRQHandler)
 805f480: e7ff         	b	0x805f482 <LPTIM3_IRQHandler+0x2> @ imm = #-0x2
 805f482: e7fe         	b	0x805f482 <LPTIM3_IRQHandler+0x2> @ imm = #-0x4

0805f484 <SPI3_IRQHandler>:
; DEFAULT_IRQ_HANDLER(SPI3_IRQHandler)
 805f484: e7ff         	b	0x805f486 <SPI3_IRQHandler+0x2> @ imm = #-0x2
 805f486: e7fe         	b	0x805f486 <SPI3_IRQHandler+0x2> @ imm = #-0x4

0805f488 <I2C4_ER_IRQHandler>:
; DEFAULT_IRQ_HANDLER(I2C4_ER_IRQHandler)
 805f488: e7ff         	b	0x805f48a <I2C4_ER_IRQHandler+0x2> @ imm = #-0x2
 805f48a: e7fe         	b	0x805f48a <I2C4_ER_IRQHandler+0x2> @ imm = #-0x4

0805f48c <I2C4_EV_IRQHandler>:
; DEFAULT_IRQ_HANDLER(I2C4_EV_IRQHandler)
 805f48c: e7ff         	b	0x805f48e <I2C4_EV_IRQHandler+0x2> @ imm = #-0x2
 805f48e: e7fe         	b	0x805f48e <I2C4_EV_IRQHandler+0x2> @ imm = #-0x4

0805f490 <DFSDM1_FLT0_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DFSDM1_FLT0_IRQHandler)
 805f490: e7ff         	b	0x805f492 <DFSDM1_FLT0_IRQHandler+0x2> @ imm = #-0x2
 805f492: e7fe         	b	0x805f492 <DFSDM1_FLT0_IRQHandler+0x2> @ imm = #-0x4

0805f494 <DFSDM1_FLT1_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DFSDM1_FLT1_IRQHandler)
 805f494: e7ff         	b	0x805f496 <DFSDM1_FLT1_IRQHandler+0x2> @ imm = #-0x2
 805f496: e7fe         	b	0x805f496 <DFSDM1_FLT1_IRQHandler+0x2> @ imm = #-0x4

0805f498 <DFSDM1_FLT2_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DFSDM1_FLT2_IRQHandler)
 805f498: e7ff         	b	0x805f49a <DFSDM1_FLT2_IRQHandler+0x2> @ imm = #-0x2
 805f49a: e7fe         	b	0x805f49a <DFSDM1_FLT2_IRQHandler+0x2> @ imm = #-0x4

0805f49c <DFSDM1_FLT3_IRQHandler>:
; DEFAULT_IRQ_HANDLER(DFSDM1_FLT3_IRQHandler)
 805f49c: e7ff         	b	0x805f49e <DFSDM1_FLT3_IRQHandler+0x2> @ imm = #-0x2
 805f49e: e7fe         	b	0x805f49e <DFSDM1_FLT3_IRQHandler+0x2> @ imm = #-0x4

0805f4a0 <UCPD1_IRQHandler>:
; DEFAULT_IRQ_HANDLER(UCPD1_IRQHandler)
 805f4a0: e7ff         	b	0x805f4a2 <UCPD1_IRQHandler+0x2> @ imm = #-0x2
 805f4a2: e7fe         	b	0x805f4a2 <UCPD1_IRQHandler+0x2> @ imm = #-0x4

0805f4a4 <ICACHE_IRQHandler>:
; DEFAULT_IRQ_HANDLER(ICACHE_IRQHandler)
 805f4a4: e7ff         	b	0x805f4a6 <ICACHE_IRQHandler+0x2> @ imm = #-0x2
 805f4a6: e7fe         	b	0x805f4a6 <ICACHE_IRQHandler+0x2> @ imm = #-0x4

0805f4a8 <OTFDEC1_IRQHandler>:
; DEFAULT_IRQ_HANDLER(OTFDEC1_IRQHandler)
 805f4a8: e7ff         	b	0x805f4aa <OTFDEC1_IRQHandler+0x2> @ imm = #-0x2
 805f4aa: e7fe         	b	0x805f4aa <OTFDEC1_IRQHandler+0x2> @ imm = #-0x4

0805f4ac <Reset_Handler>:
; void Reset_Handler(void) {
 805f4ac: f848 eb48    	str	lr, [r8], #72
 805f4b0: eb08 0809    	add.w	r8, r8, r9
 805f4b4: b480         	push	{r7}
 805f4b6: 466f         	mov	r7, sp
 805f4b8: b088         	sub	sp, #0x20
 805f4ba: f242 50e0    	movw	r0, #0x25e0
 805f4be: f2c2 0000    	movt	r0, #0x2000
 805f4c2: 9005         	str	r0, [sp, #0x14]
;   __ASM volatile("MSR msplim, %0" : : "r"(MainStackPtrLimit));
 805f4c4: 9905         	ldr	r1, [sp, #0x14]
 805f4c6: f381 880a    	msr	msplim, r1
 805f4ca: f243 51e0    	movw	r1, #0x35e0
 805f4ce: f2c2 0100    	movt	r1, #0x2000
 805f4d2: 9106         	str	r1, [sp, #0x18]
;   __ASM volatile("MSR psp, %0" : : "r"(topOfProcStack) :);
 805f4d4: 9906         	ldr	r1, [sp, #0x18]
 805f4d6: f381 8809    	msr	psp, r1
 805f4da: 9007         	str	r0, [sp, #0x1c]
;   __ASM volatile("MSR psplim, %0" : : "r"(ProcStackPtrLimit));
 805f4dc: 9807         	ldr	r0, [sp, #0x1c]
 805f4de: f380 880b    	msr	psplim, r0
;   SystemInit();      /* CMSIS System Initialization */
 805f4e2: 4828         	ldr	r0, [pc, #0xa0]         @ 0x805f584 <Reset_Handler+0xd8>
 805f4e4: 4780         	blx	r0
;   for (__copy_table_t const *pTable = &__copy_table_start__;
 805f4e6: f64f 3008    	movw	r0, #0xfb08
 805f4ea: f6c0 0005    	movt	r0, #0x805
 805f4ee: 9004         	str	r0, [sp, #0x10]
 805f4f0: e7ff         	b	0x805f4f2 <Reset_Handler+0x46> @ imm = #-0x2
;        pTable < &__copy_table_end__; ++pTable) {
 805f4f2: 9804         	ldr	r0, [sp, #0x10]
 805f4f4: f64f 3120    	movw	r1, #0xfb20
 805f4f8: f6c0 0105    	movt	r1, #0x805
;   for (__copy_table_t const *pTable = &__copy_table_start__;
 805f4fc: 4288         	cmp	r0, r1
 805f4fe: d219         	bhs	0x805f534 <Reset_Handler+0x88> @ imm = #0x32
 805f500: e7ff         	b	0x805f502 <Reset_Handler+0x56> @ imm = #-0x2
 805f502: 2000         	movs	r0, #0x0
;     for (uint32_t i = 0u; i < pTable->wlen; ++i) {
 805f504: 9003         	str	r0, [sp, #0xc]
 805f506: e7ff         	b	0x805f508 <Reset_Handler+0x5c> @ imm = #-0x2
 805f508: 9803         	ldr	r0, [sp, #0xc]
 805f50a: 9904         	ldr	r1, [sp, #0x10]
 805f50c: 6889         	ldr	r1, [r1, #0x8]
 805f50e: 4288         	cmp	r0, r1
 805f510: d20c         	bhs	0x805f52c <Reset_Handler+0x80> @ imm = #0x18
 805f512: e7ff         	b	0x805f514 <Reset_Handler+0x68> @ imm = #-0x2
;       pTable->dest[i] = pTable->src[i];
 805f514: 9904         	ldr	r1, [sp, #0x10]
 805f516: 9a03         	ldr	r2, [sp, #0xc]
 805f518: 6808         	ldr	r0, [r1]
 805f51a: 6849         	ldr	r1, [r1, #0x4]
 805f51c: f850 0022    	ldr.w	r0, [r0, r2, lsl #2]
 805f520: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     for (uint32_t i = 0u; i < pTable->wlen; ++i) {
 805f524: 9803         	ldr	r0, [sp, #0xc]
 805f526: 3001         	adds	r0, #0x1
 805f528: 9003         	str	r0, [sp, #0xc]
 805f52a: e7ed         	b	0x805f508 <Reset_Handler+0x5c> @ imm = #-0x26
;        pTable < &__copy_table_end__; ++pTable) {
 805f52c: 9804         	ldr	r0, [sp, #0x10]
 805f52e: 300c         	adds	r0, #0xc
 805f530: 9004         	str	r0, [sp, #0x10]
;   for (__copy_table_t const *pTable = &__copy_table_start__;
 805f532: e7de         	b	0x805f4f2 <Reset_Handler+0x46> @ imm = #-0x44
;   for (__zero_table_t const *pTable = &__zero_table_start__;
 805f534: f64f 3020    	movw	r0, #0xfb20
 805f538: f6c0 0005    	movt	r0, #0x805
 805f53c: 9002         	str	r0, [sp, #0x8]
 805f53e: e7ff         	b	0x805f540 <Reset_Handler+0x94> @ imm = #-0x2
;        pTable < &__zero_table_end__; ++pTable) {
 805f540: 9802         	ldr	r0, [sp, #0x8]
 805f542: f64f 3130    	movw	r1, #0xfb30
 805f546: f6c0 0105    	movt	r1, #0x805
;   for (__zero_table_t const *pTable = &__zero_table_start__;
 805f54a: 4288         	cmp	r0, r1
 805f54c: d217         	bhs	0x805f57e <Reset_Handler+0xd2> @ imm = #0x2e
 805f54e: e7ff         	b	0x805f550 <Reset_Handler+0xa4> @ imm = #-0x2
 805f550: 2000         	movs	r0, #0x0
;     for (uint32_t i = 0u; i < pTable->wlen; ++i) {
 805f552: 9001         	str	r0, [sp, #0x4]
 805f554: e7ff         	b	0x805f556 <Reset_Handler+0xaa> @ imm = #-0x2
 805f556: 9801         	ldr	r0, [sp, #0x4]
 805f558: 9902         	ldr	r1, [sp, #0x8]
 805f55a: 6849         	ldr	r1, [r1, #0x4]
 805f55c: 4288         	cmp	r0, r1
 805f55e: d20a         	bhs	0x805f576 <Reset_Handler+0xca> @ imm = #0x14
 805f560: e7ff         	b	0x805f562 <Reset_Handler+0xb6> @ imm = #-0x2
;       pTable->dest[i] = 0u;
 805f562: 9802         	ldr	r0, [sp, #0x8]
 805f564: 6801         	ldr	r1, [r0]
 805f566: 9a01         	ldr	r2, [sp, #0x4]
 805f568: 2000         	movs	r0, #0x0
 805f56a: f841 0022    	str.w	r0, [r1, r2, lsl #2]
;     for (uint32_t i = 0u; i < pTable->wlen; ++i) {
 805f56e: 9801         	ldr	r0, [sp, #0x4]
 805f570: 3001         	adds	r0, #0x1
 805f572: 9001         	str	r0, [sp, #0x4]
 805f574: e7ef         	b	0x805f556 <Reset_Handler+0xaa> @ imm = #-0x22
;        pTable < &__zero_table_end__; ++pTable) {
 805f576: 9802         	ldr	r0, [sp, #0x8]
 805f578: 3008         	adds	r0, #0x8
 805f57a: 9002         	str	r0, [sp, #0x8]
;   for (__zero_table_t const *pTable = &__zero_table_start__;
 805f57c: e7e0         	b	0x805f540 <Reset_Handler+0x94> @ imm = #-0x40
;   main();
 805f57e: 4802         	ldr	r0, [pc, #0x8]          @ 0x805f588 <Reset_Handler+0xdc>
 805f580: 4780         	blx	r0
 805f582: bf00         	nop

0805f584 <$d.118>:
 805f584: 9f eb 05 08  	.word	0x0805eb9f
 805f588: 3d f6 05 08  	.word	0x0805f63d

0805f58c <getAddr>:
; void getAddr() {
 805f58c: f848 eb44    	str	lr, [r8], #68
 805f590: eb08 0809    	add.w	r8, r8, r9
 805f594: b480         	push	{r7}
 805f596: 466f         	mov	r7, sp
;   ret_addr2 = __builtin_return_address(1);
 805f598: 4638         	mov	r0, r7
 805f59a: 6800         	ldr	r0, [r0]
 805f59c: 6840         	ldr	r0, [r0, #0x4]
 805f59e: f242 31a0    	movw	r1, #0x23a0
 805f5a2: f2c2 0100    	movt	r1, #0x2000
 805f5a6: 6008         	str	r0, [r1]
; }
 805f5a8: bc80         	pop	{r7}
 805f5aa: eba8 0809    	sub.w	r8, r8, r9
 805f5ae: f858 fd44    	ldr	pc, [r8, #-68]!
 805f5b2: 0000         	movs	r0, r0

0805f5b4 <foo>:
; int foo(int a, int b) {
 805f5b4: f848 eb64    	str	lr, [r8], #100
 805f5b8: eb08 0809    	add.w	r8, r8, r9
 805f5bc: b480         	push	{r7}
 805f5be: 466f         	mov	r7, sp
 805f5c0: b084         	sub	sp, #0x10
 805f5c2: 9003         	str	r0, [sp, #0xc]
 805f5c4: 9102         	str	r1, [sp, #0x8]
;   int c = a + b;
 805f5c6: 9803         	ldr	r0, [sp, #0xc]
 805f5c8: 9902         	ldr	r1, [sp, #0x8]
 805f5ca: 4408         	add	r0, r1
 805f5cc: 9001         	str	r0, [sp, #0x4]
;   getAddr();
 805f5ce: 4804         	ldr	r0, [pc, #0x10]         @ 0x805f5e0 <foo+0x2c>
 805f5d0: 4780         	blx	r0
;   return c;
 805f5d2: 9801         	ldr	r0, [sp, #0x4]
 805f5d4: b004         	add	sp, #0x10
 805f5d6: bc80         	pop	{r7}
 805f5d8: eba8 0809    	sub.w	r8, r8, r9
 805f5dc: f858 fd64    	ldr	pc, [r8, #-100]!

0805f5e0 <$d.2>:
 805f5e0: 8d f5 05 08  	.word	0x0805f58d

0805f5e4 <sum>:
; int sum(int a, int b) { return a + b; }
 805f5e4: b082         	sub	sp, #0x8
 805f5e6: 9001         	str	r0, [sp, #0x4]
 805f5e8: 9100         	str	r1, [sp]
 805f5ea: 9801         	ldr	r0, [sp, #0x4]
 805f5ec: 9900         	ldr	r1, [sp]
 805f5ee: 4408         	add	r0, r1
 805f5f0: b002         	add	sp, #0x8
 805f5f2: 4770         	bx	lr

0805f5f4 <testThread>:
; void testThread(void *pvParameters) {
 805f5f4: f848 eb04    	str	lr, [r8], #4
 805f5f8: eb08 0809    	add.w	r8, r8, r9
 805f5fc: b480         	push	{r7}
 805f5fe: 466f         	mov	r7, sp
 805f600: b084         	sub	sp, #0x10
 805f602: 9003         	str	r0, [sp, #0xc]
;   while (1) {
 805f604: e7ff         	b	0x805f606 <testThread+0x12> @ imm = #-0x2
;     HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_3);
 805f606: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x805f630 <testThread+0x3c>
 805f608: f640 4000    	movw	r0, #0xc00
 805f60c: f2c4 2002    	movt	r0, #0x4202
 805f610: 2108         	movs	r1, #0x8
 805f612: 4790         	blx	r2
 805f614: 2002         	movs	r0, #0x2
;     int a = 2;
 805f616: 9002         	str	r0, [sp, #0x8]
 805f618: 2003         	movs	r0, #0x3
;     int b = 3;
 805f61a: 9001         	str	r0, [sp, #0x4]
;     int c = sum(a, b);
 805f61c: 9802         	ldr	r0, [sp, #0x8]
 805f61e: 9901         	ldr	r1, [sp, #0x4]
 805f620: 4a04         	ldr	r2, [pc, #0x10]         @ 0x805f634 <testThread+0x40>
 805f622: 4790         	blx	r2
 805f624: 9000         	str	r0, [sp]
;     vTaskDelay(500);
 805f626: 4904         	ldr	r1, [pc, #0x10]         @ 0x805f638 <testThread+0x44>
 805f628: f44f 70fa    	mov.w	r0, #0x1f4
 805f62c: 4788         	blx	r1
;   while (1) {
 805f62e: e7ea         	b	0x805f606 <testThread+0x12> @ imm = #-0x2c

0805f630 <$d.5>:
 805f630: b9 f0 05 08  	.word	0x0805f0b9
 805f634: e5 f5 05 08  	.word	0x0805f5e5
 805f638: 79 d8 05 08  	.word	0x0805d879

0805f63c <main>:
; int main() {
 805f63c: f848 eb38    	str	lr, [r8], #56
 805f640: eb08 0809    	add.w	r8, r8, r9
 805f644: b480         	push	{r7}
 805f646: 466f         	mov	r7, sp
 805f648: b092         	sub	sp, #0x48
 805f64a: 2000         	movs	r0, #0x0
 805f64c: 9001         	str	r0, [sp, #0x4]
 805f64e: 9011         	str	r0, [sp, #0x44]
;   HAL_Init();
 805f650: 4810         	ldr	r0, [pc, #0x40]         @ 0x805f694 <main+0x58>
 805f652: 4780         	blx	r0
;   MX_GPIO_Init();
 805f654: 4810         	ldr	r0, [pc, #0x40]         @ 0x805f698 <main+0x5c>
 805f656: 4780         	blx	r0
;   foo(1, 2);
 805f658: 4a10         	ldr	r2, [pc, #0x40]         @ 0x805f69c <main+0x60>
 805f65a: 2001         	movs	r0, #0x1
 805f65c: 2102         	movs	r1, #0x2
 805f65e: 4790         	blx	r2
 805f660: 9901         	ldr	r1, [sp, #0x4]
;   TaskParameters_t taskParams = {
 805f662: f64f 23ac    	movw	r3, #0xfaac
 805f666: f6c0 0305    	movt	r3, #0x805
 805f66a: a802         	add	r0, sp, #0x8
 805f66c: 4602         	mov	r2, r0
 805f66e: e8b3 5070    	ldm.w	r3!, {r4, r5, r6, r12, lr}
 805f672: e8a2 5070    	stm.w	r2!, {r4, r5, r6, r12, lr}
 805f676: e8b3 5070    	ldm.w	r3!, {r4, r5, r6, r12, lr}
 805f67a: e8a2 5070    	stm.w	r2!, {r4, r5, r6, r12, lr}
 805f67e: e893 5070    	ldm.w	r3, {r4, r5, r6, r12, lr}
 805f682: e882 5070    	stm.w	r2, {r4, r5, r6, r12, lr}
;   xTaskCreateRestricted(&taskParams, NULL);
 805f686: 4a06         	ldr	r2, [pc, #0x18]         @ 0x805f6a0 <main+0x64>
 805f688: 4790         	blx	r2
;   vTaskStartScheduler();
 805f68a: 4806         	ldr	r0, [pc, #0x18]         @ 0x805f6a4 <main+0x68>
 805f68c: 4780         	blx	r0
;   for (;;)
 805f68e: e7ff         	b	0x805f690 <main+0x54>   @ imm = #-0x2
 805f690: e7fe         	b	0x805f690 <main+0x54>   @ imm = #-0x4
 805f692: bf00         	nop

0805f694 <$d.7>:
 805f694: a1 ea 05 08  	.word	0x0805eaa1
 805f698: a9 f6 05 08  	.word	0x0805f6a9
 805f69c: b5 f5 05 08  	.word	0x0805f5b5
 805f6a0: 01 52 05 08  	.word	0x08055201
 805f6a4: 5d 67 05 08  	.word	0x0805675d

0805f6a8 <MX_GPIO_Init>:
; static void MX_GPIO_Init(void) {
 805f6a8: f848 eb60    	str	lr, [r8], #96
 805f6ac: eb08 0809    	add.w	r8, r8, r9
 805f6b0: b480         	push	{r7}
 805f6b2: 466f         	mov	r7, sp
 805f6b4: b08a         	sub	sp, #0x28
 805f6b6: 2000         	movs	r0, #0x0
;   GPIO_InitTypeDef GPIO_InitStruct = {0};
 805f6b8: 9009         	str	r0, [sp, #0x24]
 805f6ba: 9008         	str	r0, [sp, #0x20]
 805f6bc: 9007         	str	r0, [sp, #0x1c]
 805f6be: 9006         	str	r0, [sp, #0x18]
 805f6c0: 9005         	str	r0, [sp, #0x14]
;   __HAL_RCC_GPIOD_CLK_ENABLE();
 805f6c2: e7ff         	b	0x805f6c4 <MX_GPIO_Init+0x1c> @ imm = #-0x2
 805f6c4: f241 004c    	movw	r0, #0x104c
 805f6c8: f2c4 0002    	movt	r0, #0x4002
;   __HAL_RCC_GPIOD_CLK_ENABLE();
 805f6cc: 6801         	ldr	r1, [r0]
 805f6ce: f041 0108    	orr	r1, r1, #0x8
 805f6d2: 6001         	str	r1, [r0]
 805f6d4: 6800         	ldr	r0, [r0]
 805f6d6: f000 0008    	and	r0, r0, #0x8
 805f6da: 9004         	str	r0, [sp, #0x10]
 805f6dc: 9804         	ldr	r0, [sp, #0x10]
 805f6de: e7ff         	b	0x805f6e0 <MX_GPIO_Init+0x38> @ imm = #-0x2
;   HAL_GPIO_WritePin(LED9_GPIO_Port, LED9_Pin, GPIO_PIN_SET);
 805f6e0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x805f718 <MX_GPIO_Init+0x70>
 805f6e2: f640 4000    	movw	r0, #0xc00
 805f6e6: f2c4 2002    	movt	r0, #0x4202
 805f6ea: 9003         	str	r0, [sp, #0xc]
 805f6ec: 2108         	movs	r1, #0x8
 805f6ee: 9101         	str	r1, [sp, #0x4]
 805f6f0: 2201         	movs	r2, #0x1
 805f6f2: 9202         	str	r2, [sp, #0x8]
 805f6f4: 4798         	blx	r3
 805f6f6: 9a01         	ldr	r2, [sp, #0x4]
 805f6f8: 9902         	ldr	r1, [sp, #0x8]
 805f6fa: 9803         	ldr	r0, [sp, #0xc]
;   GPIO_InitStruct.Pin = LED9_Pin;
 805f6fc: 9205         	str	r2, [sp, #0x14]
;   GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 805f6fe: 9106         	str	r1, [sp, #0x18]
;   GPIO_InitStruct.Pull = GPIO_PULLUP;
 805f700: 9107         	str	r1, [sp, #0x1c]
 805f702: 2103         	movs	r1, #0x3
;   GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 805f704: 9108         	str	r1, [sp, #0x20]
;   HAL_GPIO_Init(LED9_GPIO_Port, &GPIO_InitStruct);
 805f706: 4a05         	ldr	r2, [pc, #0x14]         @ 0x805f71c <MX_GPIO_Init+0x74>
 805f708: a905         	add	r1, sp, #0x14
 805f70a: 4790         	blx	r2
; }
 805f70c: b00a         	add	sp, #0x28
 805f70e: bc80         	pop	{r7}
 805f710: eba8 0809    	sub.w	r8, r8, r9
 805f714: f858 fd60    	ldr	pc, [r8, #-96]!

0805f718 <$d.9>:
 805f718: 8d f0 05 08  	.word	0x0805f08d
 805f71c: 1d ed 05 08  	.word	0x0805ed1d

0805f720 <prvCreateIdleTasks>:
; {
 805f720: f848 eb40    	str	lr, [r8], #64
 805f724: eb08 0809    	add.w	r8, r8, r9
 805f728: b480         	push	{r7}
 805f72a: 466f         	mov	r7, sp
 805f72c: b08a         	sub	sp, #0x28
 805f72e: 2001         	movs	r0, #0x1
;     BaseType_t xReturn = pdPASS;
 805f730: 9009         	str	r0, [sp, #0x24]
 805f732: 2000         	movs	r0, #0x0
;     TaskFunction_t pxIdleTaskFunction = NULL;
 805f734: 9003         	str	r0, [sp, #0xc]
;     for( xIdleTaskNameIndex = ( BaseType_t ) 0; xIdleTaskNameIndex < ( BaseType_t ) configMAX_TASK_NAME_LEN; xIdleTaskNameIndex++ )
 805f736: 9002         	str	r0, [sp, #0x8]
 805f738: e7ff         	b	0x805f73a <prvCreateIdleTasks+0x1a> @ imm = #-0x2
 805f73a: 9802         	ldr	r0, [sp, #0x8]
 805f73c: 280f         	cmp	r0, #0xf
 805f73e: dc13         	bgt	0x805f768 <prvCreateIdleTasks+0x48> @ imm = #0x26
 805f740: e7ff         	b	0x805f742 <prvCreateIdleTasks+0x22> @ imm = #-0x2
;         cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
 805f742: 9a02         	ldr	r2, [sp, #0x8]
 805f744: f64f 20ec    	movw	r0, #0xfaec
 805f748: f6c0 0005    	movt	r0, #0x805
 805f74c: 5c81         	ldrb	r1, [r0, r2]
 805f74e: a804         	add	r0, sp, #0x10
 805f750: 5481         	strb	r1, [r0, r2]
;         if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
 805f752: 9902         	ldr	r1, [sp, #0x8]
 805f754: 5c40         	ldrb	r0, [r0, r1]
 805f756: b908         	cbnz	r0, 0x805f75c <prvCreateIdleTasks+0x3c> @ imm = #0x2
 805f758: e7ff         	b	0x805f75a <prvCreateIdleTasks+0x3a> @ imm = #-0x2
;             break;
 805f75a: e005         	b	0x805f768 <prvCreateIdleTasks+0x48> @ imm = #0xa
 805f75c: e7ff         	b	0x805f75e <prvCreateIdleTasks+0x3e> @ imm = #-0x2
;     }
 805f75e: e7ff         	b	0x805f760 <prvCreateIdleTasks+0x40> @ imm = #-0x2
;     for( xIdleTaskNameIndex = ( BaseType_t ) 0; xIdleTaskNameIndex < ( BaseType_t ) configMAX_TASK_NAME_LEN; xIdleTaskNameIndex++ )
 805f760: 9802         	ldr	r0, [sp, #0x8]
 805f762: 3001         	adds	r0, #0x1
 805f764: 9002         	str	r0, [sp, #0x8]
 805f766: e7e8         	b	0x805f73a <prvCreateIdleTasks+0x1a> @ imm = #-0x30
 805f768: 2000         	movs	r0, #0x0
;     for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
 805f76a: 9008         	str	r0, [sp, #0x20]
 805f76c: e7ff         	b	0x805f76e <prvCreateIdleTasks+0x4e> @ imm = #-0x2
 805f76e: 9808         	ldr	r0, [sp, #0x20]
 805f770: 2800         	cmp	r0, #0x0
 805f772: dc23         	bgt	0x805f7bc <prvCreateIdleTasks+0x9c> @ imm = #0x46
 805f774: e7ff         	b	0x805f776 <prvCreateIdleTasks+0x56> @ imm = #-0x2
;             pxIdleTaskFunction = prvIdleTask;
 805f776: f648 10d9    	movw	r0, #0x89d9
 805f77a: f6c0 0005    	movt	r0, #0x805
 805f77e: 9003         	str	r0, [sp, #0xc]
;             xReturn = xTaskCreate( pxIdleTaskFunction,
 805f780: 9803         	ldr	r0, [sp, #0xc]
;                                    &xIdleTaskHandles[ xCoreID ] ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 805f782: 9a08         	ldr	r2, [sp, #0x20]
 805f784: f240 21ac    	movw	r1, #0x2ac
 805f788: f2c2 0100    	movt	r1, #0x2000
 805f78c: eb01 0182    	add.w	r1, r1, r2, lsl #2
;             xReturn = xTaskCreate( pxIdleTaskFunction,
 805f790: 466a         	mov	r2, sp
 805f792: 6051         	str	r1, [r2, #0x4]
 805f794: f04f 4100    	mov.w	r1, #0x80000000
 805f798: 6011         	str	r1, [r2]
 805f79a: f8df c030    	ldr.w	r12, [pc, #0x30]        @ 0x805f7cc <prvCreateIdleTasks+0xac>
 805f79e: a904         	add	r1, sp, #0x10
 805f7a0: 2280         	movs	r2, #0x80
 805f7a2: 2300         	movs	r3, #0x0
 805f7a4: 47e0         	blx	r12
 805f7a6: 9009         	str	r0, [sp, #0x24]
;         if( xReturn == pdFAIL )
 805f7a8: 9809         	ldr	r0, [sp, #0x24]
 805f7aa: b908         	cbnz	r0, 0x805f7b0 <prvCreateIdleTasks+0x90> @ imm = #0x2
 805f7ac: e7ff         	b	0x805f7ae <prvCreateIdleTasks+0x8e> @ imm = #-0x2
;             break;
 805f7ae: e005         	b	0x805f7bc <prvCreateIdleTasks+0x9c> @ imm = #0xa
 805f7b0: e7ff         	b	0x805f7b2 <prvCreateIdleTasks+0x92> @ imm = #-0x2
;     }
 805f7b2: e7ff         	b	0x805f7b4 <prvCreateIdleTasks+0x94> @ imm = #-0x2
;     for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
 805f7b4: 9808         	ldr	r0, [sp, #0x20]
 805f7b6: 3001         	adds	r0, #0x1
 805f7b8: 9008         	str	r0, [sp, #0x20]
 805f7ba: e7d8         	b	0x805f76e <prvCreateIdleTasks+0x4e> @ imm = #-0x50
;     return xReturn;
 805f7bc: 9809         	ldr	r0, [sp, #0x24]
 805f7be: b00a         	add	sp, #0x28
 805f7c0: bc80         	pop	{r7}
 805f7c2: eba8 0809    	sub.w	r8, r8, r9
 805f7c6: f858 fd40    	ldr	pc, [r8, #-64]!
 805f7ca: bf00         	nop

0805f7cc <$d.47>:
 805f7cc: a5 54 05 08  	.word	0x080554a5

0805f7d0 <prvTaskExitError>:
; {
 805f7d0: f848 eb0c    	str	lr, [r8], #12
 805f7d4: eb08 0809    	add.w	r8, r8, r9
 805f7d8: b480         	push	{r7}
 805f7da: 466f         	mov	r7, sp
 805f7dc: b082         	sub	sp, #0x8
 805f7de: 2000         	movs	r0, #0x0
;     volatile uint32_t ulDummy = 0UL;
 805f7e0: 9001         	str	r0, [sp, #0x4]
;     configASSERT( ulCriticalNesting == ~0UL );
 805f7e2: f242 3078    	movw	r0, #0x2378
 805f7e6: f2c2 0000    	movt	r0, #0x2000
 805f7ea: 6800         	ldr	r0, [r0]
 805f7ec: 3001         	adds	r0, #0x1
 805f7ee: b120         	cbz	r0, 0x805f7fa <prvTaskExitError+0x2a> @ imm = #0x8
 805f7f0: e7ff         	b	0x805f7f2 <prvTaskExitError+0x22> @ imm = #-0x2
 805f7f2: 4809         	ldr	r0, [pc, #0x24]         @ 0x805f818 <prvTaskExitError+0x48>
 805f7f4: 4780         	blx	r0
 805f7f6: e7ff         	b	0x805f7f8 <prvTaskExitError+0x28> @ imm = #-0x2
 805f7f8: e7fe         	b	0x805f7f8 <prvTaskExitError+0x28> @ imm = #-0x4
;     portDISABLE_INTERRUPTS();
 805f7fa: 4806         	ldr	r0, [pc, #0x18]         @ 0x805f814 <prvTaskExitError+0x44>
 805f7fc: 4780         	blx	r0
;     while( ulDummy == 0 )
 805f7fe: e7ff         	b	0x805f800 <prvTaskExitError+0x30> @ imm = #-0x2
 805f800: 9801         	ldr	r0, [sp, #0x4]
 805f802: b908         	cbnz	r0, 0x805f808 <prvTaskExitError+0x38> @ imm = #0x2
 805f804: e7ff         	b	0x805f806 <prvTaskExitError+0x36> @ imm = #-0x2
 805f806: e7fb         	b	0x805f800 <prvTaskExitError+0x30> @ imm = #-0xa
; }
 805f808: b002         	add	sp, #0x8
 805f80a: bc80         	pop	{r7}
 805f80c: eba8 0809    	sub.w	r8, r8, r9
 805f810: f858 fd0c    	ldr	pc, [r8, #-12]!

0805f814 <$d.12>:
 805f814: 15 d7 05 08  	.word	0x0805d715
 805f818: 15 d7 05 08  	.word	0x0805d715

0805f81c <vPortValidateInterruptPriority>:
;     {
 805f81c: f848 eb18    	str	lr, [r8], #24
 805f820: eb08 0809    	add.w	r8, r8, r9
 805f824: b480         	push	{r7}
 805f826: 466f         	mov	r7, sp
 805f828: b082         	sub	sp, #0x8
;         __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 805f82a: f3ef 8005    	mrs	r0, ipsr
 805f82e: 9001         	str	r0, [sp, #0x4]
;         if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 805f830: 9801         	ldr	r0, [sp, #0x4]
 805f832: 2810         	cmp	r0, #0x10
 805f834: d317         	blo	0x805f866 <vPortValidateInterruptPriority+0x4a> @ imm = #0x2e
 805f836: e7ff         	b	0x805f838 <vPortValidateInterruptPriority+0x1c> @ imm = #-0x2
;             ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 805f838: 9801         	ldr	r0, [sp, #0x4]
 805f83a: f24e 31f0    	movw	r1, #0xe3f0
 805f83e: f2ce 0100    	movt	r1, #0xe000
 805f842: 5c40         	ldrb	r0, [r0, r1]
 805f844: f807 0c05    	strb	r0, [r7, #-5]
;             configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 805f848: f817 0c05    	ldrb	r0, [r7, #-5]
 805f84c: f242 51c0    	movw	r1, #0x25c0
 805f850: f2c2 0100    	movt	r1, #0x2000
 805f854: 7809         	ldrb	r1, [r1]
 805f856: 4288         	cmp	r0, r1
 805f858: da04         	bge	0x805f864 <vPortValidateInterruptPriority+0x48> @ imm = #0x8
 805f85a: e7ff         	b	0x805f85c <vPortValidateInterruptPriority+0x40> @ imm = #-0x2
 805f85c: 480f         	ldr	r0, [pc, #0x3c]         @ 0x805f89c <vPortValidateInterruptPriority+0x80>
 805f85e: 4780         	blx	r0
 805f860: e7ff         	b	0x805f862 <vPortValidateInterruptPriority+0x46> @ imm = #-0x2
 805f862: e7fe         	b	0x805f862 <vPortValidateInterruptPriority+0x46> @ imm = #-0x4
;         }
 805f864: e7ff         	b	0x805f866 <vPortValidateInterruptPriority+0x4a> @ imm = #-0x2
 805f866: f64e 500c    	movw	r0, #0xed0c
 805f86a: f2ce 0000    	movt	r0, #0xe000
;         configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 805f86e: 6800         	ldr	r0, [r0]
 805f870: f400 60e0    	and	r0, r0, #0x700
 805f874: f242 51c4    	movw	r1, #0x25c4
 805f878: f2c2 0100    	movt	r1, #0x2000
 805f87c: 6809         	ldr	r1, [r1]
 805f87e: 4288         	cmp	r0, r1
 805f880: d904         	bls	0x805f88c <vPortValidateInterruptPriority+0x70> @ imm = #0x8
 805f882: e7ff         	b	0x805f884 <vPortValidateInterruptPriority+0x68> @ imm = #-0x2
 805f884: 4804         	ldr	r0, [pc, #0x10]         @ 0x805f898 <vPortValidateInterruptPriority+0x7c>
 805f886: 4780         	blx	r0
 805f888: e7ff         	b	0x805f88a <vPortValidateInterruptPriority+0x6e> @ imm = #-0x2
 805f88a: e7fe         	b	0x805f88a <vPortValidateInterruptPriority+0x6e> @ imm = #-0x4
;     }
 805f88c: b002         	add	sp, #0x8
 805f88e: bc80         	pop	{r7}
 805f890: eba8 0809    	sub.w	r8, r8, r9
 805f894: f858 fd18    	ldr	pc, [r8, #-24]!

0805f898 <$d.23>:
 805f898: 15 d7 05 08  	.word	0x0805d715
 805f89c: 15 d7 05 08  	.word	0x0805d715

0805f8a0 <xIsPrivileged>:
;     __asm volatile
 805f8a0: f3ef 8014    	mrs	r0, control
 805f8a4: f010 0f01    	tst.w	r0, #0x1
 805f8a8: bf14         	ite	ne
 805f8aa: 2000         	movne	r0, #0x0
 805f8ac: 2001         	moveq	r0, #0x1
 805f8ae: 4770         	bx	lr

0805f8b0 <vResetPrivilege>:
;     __asm volatile
 805f8b0: f3ef 8014    	mrs	r0, control
 805f8b4: f040 0001    	orr	r0, r0, #0x1
 805f8b8: f380 8814    	msr	control, r0
 805f8bc: 4770         	bx	lr
 805f8be: 0000         	movs	r0, r0

0805f8c0 <memcpy>:
 805f8c0: 4684         	mov	r12, r0
 805f8c2: ea41 0300    	orr.w	r3, r1, r0
 805f8c6: f013 0303    	ands	r3, r3, #0x3
 805f8ca: d149         	bne	0x805f960 <memcpy+0xa0> @ imm = #0x92
 805f8cc: 3a40         	subs	r2, #0x40
 805f8ce: d323         	blo	0x805f918 <memcpy+0x58> @ imm = #0x46
 805f8d0: 680b         	ldr	r3, [r1]
 805f8d2: 6003         	str	r3, [r0]
 805f8d4: 684b         	ldr	r3, [r1, #0x4]
 805f8d6: 6043         	str	r3, [r0, #0x4]
 805f8d8: 688b         	ldr	r3, [r1, #0x8]
 805f8da: 6083         	str	r3, [r0, #0x8]
 805f8dc: 68cb         	ldr	r3, [r1, #0xc]
 805f8de: 60c3         	str	r3, [r0, #0xc]
 805f8e0: 690b         	ldr	r3, [r1, #0x10]
 805f8e2: 6103         	str	r3, [r0, #0x10]
 805f8e4: 694b         	ldr	r3, [r1, #0x14]
 805f8e6: 6143         	str	r3, [r0, #0x14]
 805f8e8: 698b         	ldr	r3, [r1, #0x18]
 805f8ea: 6183         	str	r3, [r0, #0x18]
 805f8ec: 69cb         	ldr	r3, [r1, #0x1c]
 805f8ee: 61c3         	str	r3, [r0, #0x1c]
 805f8f0: 6a0b         	ldr	r3, [r1, #0x20]
 805f8f2: 6203         	str	r3, [r0, #0x20]
 805f8f4: 6a4b         	ldr	r3, [r1, #0x24]
 805f8f6: 6243         	str	r3, [r0, #0x24]
 805f8f8: 6a8b         	ldr	r3, [r1, #0x28]
 805f8fa: 6283         	str	r3, [r0, #0x28]
 805f8fc: 6acb         	ldr	r3, [r1, #0x2c]
 805f8fe: 62c3         	str	r3, [r0, #0x2c]
 805f900: 6b0b         	ldr	r3, [r1, #0x30]
 805f902: 6303         	str	r3, [r0, #0x30]
 805f904: 6b4b         	ldr	r3, [r1, #0x34]
 805f906: 6343         	str	r3, [r0, #0x34]
 805f908: 6b8b         	ldr	r3, [r1, #0x38]
 805f90a: 6383         	str	r3, [r0, #0x38]
 805f90c: 6bcb         	ldr	r3, [r1, #0x3c]
 805f90e: 63c3         	str	r3, [r0, #0x3c]
 805f910: 3040         	adds	r0, #0x40
 805f912: 3140         	adds	r1, #0x40
 805f914: 3a40         	subs	r2, #0x40
 805f916: d2db         	bhs	0x805f8d0 <memcpy+0x10> @ imm = #-0x4a
 805f918: 3230         	adds	r2, #0x30
 805f91a: d30b         	blo	0x805f934 <memcpy+0x74> @ imm = #0x16
 805f91c: 680b         	ldr	r3, [r1]
 805f91e: 6003         	str	r3, [r0]
 805f920: 684b         	ldr	r3, [r1, #0x4]
 805f922: 6043         	str	r3, [r0, #0x4]
 805f924: 688b         	ldr	r3, [r1, #0x8]
 805f926: 6083         	str	r3, [r0, #0x8]
 805f928: 68cb         	ldr	r3, [r1, #0xc]
 805f92a: 60c3         	str	r3, [r0, #0xc]
 805f92c: 3010         	adds	r0, #0x10
 805f92e: 3110         	adds	r1, #0x10
 805f930: 3a10         	subs	r2, #0x10
 805f932: d2f3         	bhs	0x805f91c <memcpy+0x5c> @ imm = #-0x1a
 805f934: 320c         	adds	r2, #0xc
 805f936: d305         	blo	0x805f944 <memcpy+0x84> @ imm = #0xa
 805f938: f851 3b04    	ldr	r3, [r1], #4
 805f93c: f840 3b04    	str	r3, [r0], #4
 805f940: 3a04         	subs	r2, #0x4
 805f942: d2f9         	bhs	0x805f938 <memcpy+0x78> @ imm = #-0xe
 805f944: 3204         	adds	r2, #0x4
 805f946: d008         	beq	0x805f95a <memcpy+0x9a> @ imm = #0x10
 805f948: 07d2         	lsls	r2, r2, #0x1f
 805f94a: bf1c         	itt	ne
 805f94c: f811 3b01    	ldrbne	r3, [r1], #1
 805f950: f800 3b01    	strbne	r3, [r0], #1
 805f954: d301         	blo	0x805f95a <memcpy+0x9a> @ imm = #0x2
 805f956: 880b         	ldrh	r3, [r1]
 805f958: 8003         	strh	r3, [r0]
 805f95a: 4660         	mov	r0, r12
 805f95c: 4770         	bx	lr
 805f95e: bf00         	nop
 805f960: 2a08         	cmp	r2, #0x8
 805f962: d313         	blo	0x805f98c <memcpy+0xcc> @ imm = #0x26
 805f964: 078b         	lsls	r3, r1, #0x1e
 805f966: d0b1         	beq	0x805f8cc <memcpy+0xc>  @ imm = #-0x9e
 805f968: f010 0303    	ands	r3, r0, #0x3
 805f96c: d0ae         	beq	0x805f8cc <memcpy+0xc>  @ imm = #-0xa4
 805f96e: f1c3 0304    	rsb.w	r3, r3, #0x4
 805f972: 1ad2         	subs	r2, r2, r3
 805f974: 07db         	lsls	r3, r3, #0x1f
 805f976: bf1c         	itt	ne
 805f978: f811 3b01    	ldrbne	r3, [r1], #1
 805f97c: f800 3b01    	strbne	r3, [r0], #1
 805f980: d3a4         	blo	0x805f8cc <memcpy+0xc>  @ imm = #-0xb8
 805f982: f831 3b02    	ldrh	r3, [r1], #2
 805f986: f820 3b02    	strh	r3, [r0], #2
 805f98a: e79f         	b	0x805f8cc <memcpy+0xc>  @ imm = #-0xc2
 805f98c: 3a04         	subs	r2, #0x4
 805f98e: d3d9         	blo	0x805f944 <memcpy+0x84> @ imm = #-0x4e
 805f990: 3a01         	subs	r2, #0x1
 805f992: f811 3b01    	ldrb	r3, [r1], #1
 805f996: f800 3b01    	strb	r3, [r0], #1
 805f99a: d2f9         	bhs	0x805f990 <memcpy+0xd0> @ imm = #-0xe
 805f99c: 780b         	ldrb	r3, [r1]
 805f99e: 7003         	strb	r3, [r0]
 805f9a0: 784b         	ldrb	r3, [r1, #0x1]
 805f9a2: 7043         	strb	r3, [r0, #0x1]
 805f9a4: 788b         	ldrb	r3, [r1, #0x2]
 805f9a6: 7083         	strb	r3, [r0, #0x2]
 805f9a8: 4660         	mov	r0, r12
 805f9aa: 4770         	bx	lr

0805f9ac <memset>:
 805f9ac: b570         	push	{r4, r5, r6, lr}
 805f9ae: 0786         	lsls	r6, r0, #0x1e
 805f9b0: d048         	beq	0x805fa44 <memset+0x98> @ imm = #0x90
 805f9b2: 1e54         	subs	r4, r2, #0x1
 805f9b4: 2a00         	cmp	r2, #0x0
 805f9b6: d03f         	beq	0x805fa38 <memset+0x8c> @ imm = #0x7e
 805f9b8: b2ca         	uxtb	r2, r1
 805f9ba: 4603         	mov	r3, r0
 805f9bc: e001         	b	0x805f9c2 <memset+0x16> @ imm = #0x2
 805f9be: 3c01         	subs	r4, #0x1
 805f9c0: d33a         	blo	0x805fa38 <memset+0x8c> @ imm = #0x74
 805f9c2: f803 2b01    	strb	r2, [r3], #1
 805f9c6: 079d         	lsls	r5, r3, #0x1e
 805f9c8: d1f9         	bne	0x805f9be <memset+0x12> @ imm = #-0xe
 805f9ca: 2c03         	cmp	r4, #0x3
 805f9cc: d92d         	bls	0x805fa2a <memset+0x7e> @ imm = #0x5a
 805f9ce: b2cd         	uxtb	r5, r1
 805f9d0: 2c0f         	cmp	r4, #0xf
 805f9d2: ea45 2505    	orr.w	r5, r5, r5, lsl #8
 805f9d6: ea45 4505    	orr.w	r5, r5, r5, lsl #16
 805f9da: d936         	bls	0x805fa4a <memset+0x9e> @ imm = #0x6c
 805f9dc: f1a4 0c10    	sub.w	r12, r4, #0x10
 805f9e0: f103 0e20    	add.w	lr, r3, #0x20
 805f9e4: f103 0210    	add.w	r2, r3, #0x10
 805f9e8: f02c 060f    	bic	r6, r12, #0xf
 805f9ec: ea4f 1c1c    	lsr.w	r12, r12, #0x4
 805f9f0: 44b6         	add	lr, r6
 805f9f2: e942 5504    	strd	r5, r5, [r2, #-16]
 805f9f6: e942 5502    	strd	r5, r5, [r2, #-8]
 805f9fa: 3210         	adds	r2, #0x10
 805f9fc: 4572         	cmp	r2, lr
 805f9fe: d1f8         	bne	0x805f9f2 <memset+0x46> @ imm = #-0x10
 805fa00: f10c 0201    	add.w	r2, r12, #0x1
 805fa04: f014 0f0c    	tst.w	r4, #0xc
 805fa08: f004 0c0f    	and	r12, r4, #0xf
 805fa0c: eb03 1202    	add.w	r2, r3, r2, lsl #4
 805fa10: d013         	beq	0x805fa3a <memset+0x8e> @ imm = #0x26
 805fa12: f1ac 0304    	sub.w	r3, r12, #0x4
 805fa16: f023 0303    	bic	r3, r3, #0x3
 805fa1a: 3304         	adds	r3, #0x4
 805fa1c: 4413         	add	r3, r2
 805fa1e: f842 5b04    	str	r5, [r2], #4
 805fa22: 4293         	cmp	r3, r2
 805fa24: d1fb         	bne	0x805fa1e <memset+0x72> @ imm = #-0xa
 805fa26: f00c 0403    	and	r4, r12, #0x3
 805fa2a: b12c         	cbz	r4, 0x805fa38 <memset+0x8c> @ imm = #0xa
 805fa2c: b2ca         	uxtb	r2, r1
 805fa2e: 441c         	add	r4, r3
 805fa30: f803 2b01    	strb	r2, [r3], #1
 805fa34: 429c         	cmp	r4, r3
 805fa36: d1fb         	bne	0x805fa30 <memset+0x84> @ imm = #-0xa
 805fa38: bd70         	pop	{r4, r5, r6, pc}
 805fa3a: 4664         	mov	r4, r12
 805fa3c: 4613         	mov	r3, r2
 805fa3e: 2c00         	cmp	r4, #0x0
 805fa40: d1f4         	bne	0x805fa2c <memset+0x80> @ imm = #-0x18
 805fa42: e7f9         	b	0x805fa38 <memset+0x8c> @ imm = #-0xe
 805fa44: 4603         	mov	r3, r0
 805fa46: 4614         	mov	r4, r2
 805fa48: e7bf         	b	0x805f9ca <memset+0x1e> @ imm = #-0x82
 805fa4a: 461a         	mov	r2, r3
 805fa4c: 46a4         	mov	r12, r4
 805fa4e: e7e0         	b	0x805fa12 <memset+0x66> @ imm = #-0x40

0805fa50 <$d>:
 805fa50: 00 00 00 00  	.word	0x00000000
 805fa54: 00 00 00 00  	.word	0x00000000
 805fa58: 01 02 03 04  	.word	0x04030201
 805fa5c: 06 07 08 09  	.word	0x09080706

0805fa60 <$d>:
 805fa60: a0 86 01 00  	.word	0x000186a0
 805fa64: 40 0d 03 00  	.word	0x00030d40
 805fa68: 80 1a 06 00  	.word	0x00061a80
 805fa6c: 00 35 0c 00  	.word	0x000c3500
 805fa70: 40 42 0f 00  	.word	0x000f4240
 805fa74: 80 84 1e 00  	.word	0x001e8480
 805fa78: 00 09 3d 00  	.word	0x003d0900
 805fa7c: 00 12 7a 00  	.word	0x007a1200
 805fa80: 00 24 f4 00  	.word	0x00f42400
 805fa84: 00 36 6e 01  	.word	0x016e3600
 805fa88: 00 48 e8 01  	.word	0x01e84800
 805fa8c: 00 6c dc 02  	.word	0x02dc6c00
 805fa90: 00 00 00 00  	.word	0x00000000
 805fa94: 00 00 00 00  	.word	0x00000000
 805fa98: 00 00 00 00  	.word	0x00000000
 805fa9c: 00 00 00 00  	.word	0x00000000

0805faa0 <$d>:
 805faa0: 74 65 73 74  	.word	0x74736574
 805faa4: 54 68 72 65  	.word	0x65726854
 805faa8: 61 64 00 00  	.word	0x00006461

0805faac <$d>:
 805faac: f5 f5 05 08  	.word	0x0805f5f5
 805fab0: a0 fa 05 08  	.word	0x0805faa0
 805fab4: 80 00 00 00  	.word	0x00000080
 805fab8: 00 00 00 00  	.word	0x00000000
 805fabc: 01 00 00 00  	.word	0x00000001
 805fac0: c0 23 00 20  	.word	0x200023c0
 805fac4: 00 00 02 42  	.word	0x42020000
 805fac8: 00 20 00 00  	.word	0x00002000
 805facc: 02 00 00 00  	.word	0x00000002
 805fad0: 00 00 00 00  	.word	0x00000000
 805fad4: 00 00 00 00  	.word	0x00000000
 805fad8: 00 00 00 00  	.word	0x00000000
 805fadc: 00 00 00 00  	.word	0x00000000
 805fae0: 00 00 00 00  	.word	0x00000000
 805fae4: 00 00 00 00  	.word	0x00000000

0805fae8 <$d>:
 805fae8: 0f 00 00 00  	.word	0x0000000f

0805faec <$d>:
 805faec: 49 44 4c 45  	.word	0x454c4449
 805faf0: 00           	.byte	0x00

0805faf1 <$d>:
 805faf1: 54 6d 72 20  	.word	0x20726d54
 805faf5: 53 76 63 00  	.word	0x00637653
 805faf9: 54 6d 72 51  	.word	0x51726d54
 805fafd: 00 00        	.short	0x0000

0805faff <__unprivileged_flash_end__>:
 805faff: 00           	.byte	0x00
